<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/rewrite/rewriteHandler.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * rewriteHandler.c
 *		Primary module of query rewriter.
 *
 * Portions Copyright (c) 2006-2008, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/rewrite/rewriteHandler.c
 *
 * NOTES
 *	  Some of the terms used in this file are of historic nature: "retrieve"
 *	  was the PostQUEL keyword for what today is SELECT. "RIR" stands for
 *	  "Retrieve-Instead-Retrieve", that is an ON SELECT DO INSTEAD SELECT rule
 *	  (which has to be unconditional and where only one rule can exist on each
 *	  relation).
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/fdwapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/analyze.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteDefine.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteManip.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rowsecurity.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/aocatalog.h"</cpp:file></cpp:include>


<comment type="block">/* We use a list of these to detect recursion in RewriteQuery */</comment>
<typedef>typedef <type><struct>struct <name>rewrite_event</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relation</name></decl>;</decl_stmt>		<comment type="block">/* OID of relation having rules */</comment>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>event</name></decl>;</decl_stmt>			<comment type="block">/* type of rule being fired */</comment>
}</block></struct></type> <name>rewrite_event</name>;</typedef>

<typedef>typedef <type><struct>struct <name>acquireLocksOnSubLinks_context</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>for_execute</name></decl>;</decl_stmt>	<comment type="block">/* AcquireRewriteLocks' forExecute param */</comment>
}</block></struct></type> <name>acquireLocksOnSubLinks_context</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>acquireLocksOnSubLinks</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
								   <parameter><decl><type><name>acquireLocksOnSubLinks_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>rewriteRuleAction</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
								<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>rule_action</name></decl></parameter>,
								<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rule_qual</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>rt_index</name></decl></parameter>,
								<parameter><decl><type><name>CmdType</name></type> <name>event</name></decl></parameter>,
								<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>returning_flag</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>adjustJoinTreeList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>removert</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rt_index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>rewriteTargetListIU</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
								 <parameter><decl><type><name>CmdType</name></type> <name>commandType</name></decl></parameter>,
								 <parameter><decl><type><name>OverridingKind</name></type> <name>override</name></decl></parameter>,
								 <parameter><decl><type><name>Relation</name></type> <name>target_relation</name></decl></parameter>,
								 <parameter><decl><type><name>int</name></type> <name>result_rti</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type><name>process_matched_tle</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>src_tle</name></decl></parameter>,
										<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>prior_tle</name></decl></parameter>,
										<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attrName</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>get_assignment_input</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>rewriteValuesRTE</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rti</name></decl></parameter>,
							 <parameter><decl><type><name>Relation</name></type> <name>target_relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_nulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>markQueryForLocking</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
								<parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>, <parameter><decl><type><name>LockWaitPolicy</name></type> <name>waitPolicy</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>pushedDown</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>matchLocks</name><parameter_list>(<parameter><decl><type><name>CmdType</name></type> <name>event</name></decl></parameter>, <parameter><decl><type><name>RuleLock</name> <modifier>*</modifier></type><name>rulelocks</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>, <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasUpdate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type><name>fireRIRrules</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeRIRs</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>view_has_instead_trigger</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>view</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>event</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>adjust_view_column_set</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>cols</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * AcquireRewriteLocks -
 *	  Acquire suitable locks on all the relations mentioned in the Query.
 *	  These locks will ensure that the relation schemas don't change under us
 *	  while we are rewriting, planning, and executing the query.
 *
 * Caution: this may modify the querytree, therefore caller should usually
 * have done a copyObject() to make a writable copy of the querytree in the
 * current memory context.
 *
 * forExecute indicates that the query is about to be executed.  If so,
 * we'll acquire the lock modes specified in the RTE rellockmode fields.
 * If forExecute is false, AccessShareLock is acquired on all relations.
 * This case is suitable for ruleutils.c, for example, where we only need
 * schema stability and we don't intend to actually modify any relations.
 *
 * forUpdatePushedDown indicates that a pushed-down FOR [KEY] UPDATE/SHARE
 * applies to the current subquery, requiring all rels to be opened with at
 * least RowShareLock.  This should always be false at the top of the
 * recursion.  When it is true, we adjust RTE rellockmode fields to reflect
 * the higher lock level.  This flag is ignored if forExecute is false.
 *
 * A secondary purpose of this routine is to fix up JOIN RTE references to
 * dropped columns (see details below).  Such RTEs are modified in-place.
 *
 * This processing can, and for efficiency's sake should, be skipped when the
 * querytree has just been built by the parser: parse analysis already got
 * all the same locks we'd get here, and the parser will have omitted dropped
 * columns from JOINs to begin with.  But we must do this whenever we are
 * dealing with a querytree produced earlier than the current command.
 *
 * About JOINs and dropped columns: although the parser never includes an
 * already-dropped column in a JOIN RTE's alias var list, it is possible for
 * such a list in a stored rule to include references to dropped columns.
 * (If the column is not explicitly referenced anywhere else in the query,
 * the dependency mechanism won't consider it used by the rule and so won't
 * prevent the column drop.)  To support get_rte_attribute_is_dropped(), we
 * replace join alias vars that reference dropped columns with null pointers.
 *
 * (In PostgreSQL 8.0, we did not do this processing but instead had
 * get_rte_attribute_is_dropped() recurse to detect dropped columns in joins.
 * That approach had horrible performance unfortunately; in particular
 * construction of a nested join was O(N^2) in the nesting depth.)
 */</comment>
<function><type><name>void</name></type>
<name>AcquireRewriteLocks</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>forExecute</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>forUpdatePushedDown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>      <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			   <name>rt_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>acquireLocksOnSubLinks_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>for_execute</name></name> <operator>=</operator> <name>forExecute</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, process RTEs of the current query level.
	 */</comment>
	<expr_stmt><expr><name>rt_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parsetree-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>        <name>needLockUpgrade</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newaliasvars</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Index</name></type>		<name>curinputvarno</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>curinputrte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ll</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>++</operator><name>rt_index</name></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RTE_RELATION</name></expr>:</case>

				<comment type="block">/*
				 * Grab the appropriate lock type for the relation, and do not
				 * release it until end of transaction.  This protects the
				 * rewriter, planner, and executor against schema changes
				 * mid-query.
				 *
				 * If forExecute is false, ignore rellockmode and just use
				 * AccessShareLock.
				 *
				 * CDB: The proper lock mode depends on whether the relation is
				 * local or distributed, which is discovered by heap_open().
				 * To handle this we make use of CdbOpenRelation().
				 * 
				 * For update should hold ExclusiveLock, see the discussion on
				 * https://groups.google.com/a/greenplum.org/d/msg/gpdb-dev/p-6_dNjnRMQ/OzTnb586AwAJ
				 *
				 * Update|DELETE may have to upgrade the locks to avoid global
				 * deadlock and CdbOpenRelation will do more check for AO table
				 * and GDD's status.
				 */</comment>
				<expr_stmt><expr><name>needLockUpgrade</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>forExecute</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>rt_index</name> <operator>==</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>needLockUpgrade</name> <operator>=</operator> <operator>(</operator><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
						<name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name><operator>)</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>forUpdatePushedDown</name> <operator>||</operator>
						 <call><name>get_parse_rowmark</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Greenplum specific behavior:
					 * The implementation of select statement with locking clause
					 * (for update | no key update | share | key share) in postgres
					 * is to hold RowShareLock on tables during parsing stage, and
					 * generate a LockRows plan node for executor to lock the tuples.
					 * It is not easy to lock tuples in Greenplum database, since
					 * tuples may be fetched through motion nodes.
					 *
					 * But when Global Deadlock Detector is enabled, and the select
					 * statement with locking clause contains only one table, we are
					 * sure that there are no motions. For such simple cases, we could
					 * make the behavior just the same as Postgres.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parsetree</name><operator>-&gt;</operator><name>canOptSelectLockingClause</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>=</operator> <name>ExclusiveLock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Upgrade RTE's lock mode to reflect pushed-down lock */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>==</operator> <name>AccessShareLock</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>=</operator> <name>RowShareLock</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>lockmode</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>


				<comment type="block">/* Take a lock either using CDB lock promotion or not */</comment>
				<if_stmt><if>if <condition>(<expr><name>needLockUpgrade</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>CdbOpenTable</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * While we have the relation open, update the RTE's relkind,
				 * just in case it changed since this rule was made.
				 */</comment>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>

				<comment type="block">/* Close the relcache entry without releasing the lock. */</comment>
				<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>RTE_JOIN</name></expr>:</case>

				<comment type="block">/*
				 * Scan the join's alias var list to see if any columns have
				 * been dropped, and if so replace those Vars with null
				 * pointers.
				 *
				 * Since a join has only two inputs, we can expect to see
				 * multiple references to the same input RTE; optimize away
				 * multiple fetches.
				 */</comment>
				<expr_stmt><expr><name>newaliasvars</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>curinputvarno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>curinputrte</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<macro><name>foreach</name><argument_list>(<argument>ll</argument>, <argument>rte-&gt;joinaliasvars</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aliasitem</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ll</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>aliasvar</name> <init>= <expr><name>aliasitem</name></expr></init></decl>;</decl_stmt>

					<comment type="block">/* Look through any implicit coercion */</comment>
					<expr_stmt><expr><name>aliasvar</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>strip_implicit_coercions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>aliasvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * If the list item isn't a simple Var, then it must
					 * represent a merged column, ie a USING column, and so it
					 * couldn't possibly be dropped, since it's referenced in
					 * the join clause.  (Conceivably it could also be a null
					 * pointer already?  But that's OK too.)
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>aliasvar</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>aliasvar</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * The elements of an alias list have to refer to
						 * earlier RTEs of the same rtable, because that's the
						 * order the planner builds things in.  So we already
						 * processed the referenced RTE, and so it's safe to
						 * use get_rte_attribute_is_dropped on it. (This might
						 * not hold after rewriting or planning, but it's OK
						 * to assume here.)
						 */</comment>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>aliasvar</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>aliasvar</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name>curinputvarno</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>curinputvarno</name> <operator>=</operator> <name><name>aliasvar</name><operator>-&gt;</operator><name>varno</name></name></expr>;</expr_stmt>
							<if_stmt><if>if <condition>(<expr><name>curinputvarno</name> <operator>&gt;=</operator> <name>rt_index</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected varno %d in JOIN RTE %d"</literal></expr></argument>,
									 <argument><expr><name>curinputvarno</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
							<expr_stmt><expr><name>curinputrte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>curinputvarno</name></expr></argument>,
												   <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><call><name>get_rte_attribute_is_dropped</name><argument_list>(<argument><expr><name>curinputrte</name></expr></argument>,
														 <argument><expr><name><name>aliasvar</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* Replace the join alias item with a NULL */</comment>
							<expr_stmt><expr><name>aliasitem</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>newaliasvars</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newaliasvars</name></expr></argument>, <argument><expr><name>aliasitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>joinaliasvars</name></name> <operator>=</operator> <name>newaliasvars</name></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>RTE_SUBQUERY</name></expr>:</case>
			<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>

				<comment type="block">/*
				 * The subquery RTE itself is all right, but we have to
				 * recurse to process the represented subquery.
				 */</comment>
				<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>,
									<argument><expr><name>forExecute</name></expr></argument>,
									<argument><expr><operator>(</operator><name>forUpdatePushedDown</name> <operator>||</operator>
									 <call><name>get_parse_rowmark</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<default>default:</default>
				<comment type="block">/* ignore other types of RTEs */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<comment type="block">/* Recurse into subqueries in WITH */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>parsetree-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name>forExecute</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Recurse into sublink subqueries, too.  But we already did the ones in
	 * the rtable and cteList.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>acquireLocksOnSubLinks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>,
						  <argument><expr><name>QTW_IGNORE_RC_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Walker to find sublink subqueries for AcquireRewriteLocks
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>acquireLocksOnSubLinks</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>acquireLocksOnSubLinks_context</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sub</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Do what we came for */</comment>
		<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sub</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>,
							<argument><expr><name><name>context</name><operator>-&gt;</operator><name>for_execute</name></name></expr></argument>,
							<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Fall through to process lefthand args of SubLink */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do NOT recurse into Query nodes, because AcquireRewriteLocks already
	 * processed subselects of subselects for us.
	 */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>acquireLocksOnSubLinks</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * rewriteRuleAction -
 *	  Rewrite the rule action with appropriate qualifiers (taken from
 *	  the triggering query).
 *
 * Input arguments:
 *	parsetree - original query
 *	rule_action - one action (query) of a rule
 *	rule_qual - WHERE condition of rule, or NULL if unconditional
 *	rt_index - RT index of result relation in original query
 *	event - type of rule event
 * Output arguments:
 *	*returning_flag - set true if we rewrite RETURNING clause in rule_action
 *					(must be initialized to false)
 * Return value:
 *	rewritten form of rule_action
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>rewriteRuleAction</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
				  <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>rule_action</name></decl></parameter>,
				  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rule_qual</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>rt_index</name></decl></parameter>,
				  <parameter><decl><type><name>CmdType</name></type> <name>event</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>returning_flag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>current_varno</name></decl>,
				<decl><type ref="prev"/><name>new_varno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rt_length</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>sub_action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>sub_action_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>acquireLocksOnSubLinks_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>for_execute</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make modifiable copies of rule action and qual (what we're passed are
	 * the stored versions in the relcache; don't touch 'em!).
	 */</comment>
	<expr_stmt><expr><name>rule_action</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rule_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rule_qual</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rule_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Acquire necessary locks and fix any deleted JOIN RTE entries.
	 */</comment>
	<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name>rule_action</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>acquireLocksOnSubLinks</name><argument_list>(<argument><expr><name>rule_qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>current_varno</name> <operator>=</operator> <name>rt_index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rt_length</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_varno</name> <operator>=</operator> <name>PRS2_NEW_VARNO</name> <operator>+</operator> <name>rt_length</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust rule action and qual to offset its varnos, so that we can merge
	 * its rtable with the main parsetree's rtable.
	 *
	 * If the rule action is an INSERT...SELECT, the OLD/NEW rtable entries
	 * will be in the SELECT part, and we have to modify that rather than the
	 * top-level INSERT (kluge!).
	 */</comment>
	<expr_stmt><expr><name>sub_action</name> <operator>=</operator> <call><name>getInsertSelectQuery</name><argument_list>(<argument><expr><name>rule_action</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sub_action_ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub_action</name></expr></argument>, <argument><expr><name>rt_length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>OffsetVarNodes</name><argument_list>(<argument><expr><name>rule_qual</name></expr></argument>, <argument><expr><name>rt_length</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* but references to OLD should point at original rt_index */</comment>
	<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub_action</name></expr></argument>,
				   <argument><expr><name>PRS2_OLD_VARNO</name> <operator>+</operator> <name>rt_length</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><name>rule_qual</name></expr></argument>,
				   <argument><expr><name>PRS2_OLD_VARNO</name> <operator>+</operator> <name>rt_length</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generate expanded rtable consisting of main parsetree's rtable plus
	 * rule action's rtable; this becomes the complete rtable for the rule
	 * action.  Some of the entries may be unused after we finish rewriting,
	 * but we leave them all in place for two reasons:
	 *
	 * We'd have a much harder job to adjust the query's varnos if we
	 * selectively removed RT entries.
	 *
	 * If the rule is INSTEAD, then the original query won't be executed at
	 * all, and so its rtable must be preserved so that the executor will do
	 * the correct permissions checks on it.
	 *
	 * RT entries that are not referenced in the completed jointree will be
	 * ignored by the planner, so they do not affect query semantics.  But any
	 * permissions checks specified in them will be applied during executor
	 * startup (see ExecCheckRTEPerms()).  This allows us to check that the
	 * caller has, say, insert-permission on a view, when the view is not
	 * semantically referenced at all in the resulting query.
	 *
	 * When a rule is not INSTEAD, the permissions checks done on its copied
	 * RT entries will be redundant with those done during execution of the
	 * original query, but we don't bother to treat that case differently.
	 *
	 * NOTE: because planner will destructively alter rtable, we must ensure
	 * that rule action's rtable is separate and shares no substructure with
	 * the main rtable.  Hence do a deep copy here.
	 */</comment>
	<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name><name>sub_action</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There could have been some SubLinks in parsetree's rtable, in which
	 * case we'd better mark the sub_action correctly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sub_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;rtable</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<switch>switch <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RTE_RELATION</name></expr>:</case>
					<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator>
						<call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>RTE_TABLEFUNCTION</name></expr>:</case>
					<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator>
						<call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>RTE_FUNCTION</name></expr>:</case>
					<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator>
						<call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>functions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>RTE_TABLEFUNC</name></expr>:</case>
					<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator>
						<call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>tablefunc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>RTE_VALUES</name></expr>:</case>
					<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator>
						<call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<comment type="block">/* other RTE types don't contain bare expressions */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
			<if_stmt><if>if <condition>(<expr><name><name>sub_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* no need to keep scanning rtable */</comment>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Also, we might have absorbed some RTEs with RLS conditions into the
	 * sub_action.  If so, mark it as hasRowSecurity, whether or not those
	 * RTEs will be referenced after we finish rewriting.  (Note: currently
	 * this is a no-op because RLS conditions aren't added till later, but it
	 * seems like good future-proofing to do this anyway.)
	 */</comment>
	<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>hasRowSecurity</name></name> <operator>|=</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>hasRowSecurity</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each rule action's jointree should be the main parsetree's jointree
	 * plus that rule's jointree, but usually *without* the original rtindex
	 * that we're replacing (if present, which it won't be for INSERT). Note
	 * that if the rule action refers to OLD, its jointree will add a
	 * reference to rt_index.  If the rule action doesn't refer to OLD, but
	 * either the rule_qual or the user query quals do, then we need to keep
	 * the original rtindex in the jointree to provide data for the quals.  We
	 * don't want the original rtindex to be joined twice, however, so avoid
	 * keeping it if the rule action mentions it.
	 *
	 * As above, the action's jointree must not share substructure with the
	 * main parsetree's.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sub_action</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>keeporig</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newjointree</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sub_action</name><operator>-&gt;</operator><name>jointree</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>keeporig</name> <operator>=</operator> <operator>(</operator><operator>!</operator><call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sub_action</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
										  <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><name>rule_qual</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator>
			 <call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>newjointree</name> <operator>=</operator> <call><name>adjustJoinTreeList</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><operator>!</operator><name>keeporig</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newjointree</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If sub_action is a setop, manipulating its jointree will do no
			 * good at all, because the jointree is dummy.  (Perhaps someday
			 * we could push the joining and quals down to the member
			 * statements of the setop?)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sub_action</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional UNION/INTERSECT/EXCEPT statements are not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><name>newjointree</name></expr></argument>, <argument><expr><name><name>sub_action</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * There could have been some SubLinks in newjointree, in which
			 * case we'd better mark the sub_action correctly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>sub_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator>
					<call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newjointree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the original query has any CTEs, copy them into the rule action. But
	 * we don't need them for a utility action.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>cteList</name></name> <operator>!=</operator> <name>NIL</name> <operator>&amp;&amp;</operator> <name><name>sub_action</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Annoying implementation restriction: because CTEs are identified by
		 * name within a cteList, we can't merge a CTE from the original query
		 * if it has the same name as any CTE in the rule action.
		 *
		 * This could possibly be fixed by using some sort of internally
		 * generated ID, instead of names, to link CTE RTEs to their CTEs.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;cteList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>sub_action-&gt;cteList</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte2</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>, <argument><expr><name><name>cte2</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH query name \"%s\" appears in both a rule action and the query being rewritten"</literal></expr></argument>,
									<argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctename</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block>

		<comment type="block">/* OK, it's safe to combine the CTE lists */</comment>
		<expr_stmt><expr><name><name>sub_action</name><operator>-&gt;</operator><name>cteList</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name><name>sub_action</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>,
										  <argument><expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>cteList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Event Qualification forces copying of parsetree and splitting into two
	 * queries one w/rule_qual, one w/NOT rule_qual. Also add user query qual
	 * onto rule action
	 */</comment>
	<expr_stmt><expr><call><name>AddQual</name><argument_list>(<argument><expr><name>sub_action</name></expr></argument>, <argument><expr><name>rule_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AddQual</name><argument_list>(<argument><expr><name>sub_action</name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Rewrite new.attribute with right hand side of target-list entry for
	 * appropriate field name in insert/update.
	 *
	 * KLUGE ALERT: since ReplaceVarsFromTargetList returns a mutated copy, we
	 * can't just apply it to sub_action; we have to remember to update the
	 * sublink inside rule_action, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>event</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>event</name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>sub_action</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sub_action</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator>
			<call><name>ReplaceVarsFromTargetList</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sub_action</name></expr></argument>,
									  <argument><expr><name>new_varno</name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>,
									  <argument><expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>new_varno</name></expr></argument>, <argument><expr><name><name>sub_action</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
									  <argument><expr><ternary><condition><expr><operator>(</operator><name>event</name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator></expr> ?</condition><then>
									  <expr><name>REPLACEVARS_CHANGE_VARNO</name></expr> </then><else>:
									  <expr><name>REPLACEVARS_SUBSTITUTE_NULL</name></expr></else></ternary></expr></argument>,
									  <argument><expr><name>current_varno</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sub_action_ptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>sub_action_ptr</name> <operator>=</operator> <name>sub_action</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>rule_action</name> <operator>=</operator> <name>sub_action</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If rule_action has a RETURNING clause, then either throw it away if the
	 * triggering query has no RETURNING clause, or rewrite it to emit what
	 * the triggering query's RETURNING clause asks for.  Throw an error if
	 * more than one rule has a RETURNING clause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parsetree</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>rule_action</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rule_action</name><operator>-&gt;</operator><name>returningList</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>returning_flag</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot have RETURNING lists in multiple rules"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>returning_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rule_action</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator>
			<call><name>ReplaceVarsFromTargetList</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>,
									  <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>,
									  <argument><expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
											   <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name><name>rule_action</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>,
									  <argument><expr><name>REPLACEVARS_REPORT_ERROR</name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>rule_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * There could have been some SubLinks in parsetree's returningList,
		 * in which case we'd better mark the rule_action correctly.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rule_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>rule_action</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator>
				<call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rule_action</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rule_action</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the query's jointree list, and optionally attempt to remove any
 * occurrence of the given rt_index as a top-level join item (we do not look
 * for it within join items; this is OK because we are only expecting to find
 * it as an UPDATE or DELETE target relation, which will be at the top level
 * of the join).  Returns modified jointree list --- this is a separate copy
 * sharing no nodes with the original.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>adjustJoinTreeList</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>removert</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rt_index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newjointree</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>removert</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>newjointree</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rtr</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>==</operator> <name>rt_index</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newjointree</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>newjointree</name></expr></argument>, <argument><expr><name>rtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * foreach is safe because we exit loop after list_delete...
				 */</comment>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>newjointree</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * rewriteTargetListIU - rewrite INSERT/UPDATE targetlist into standard form
 *
 * This has the following responsibilities:
 *
 * 1. For an INSERT, add tlist entries to compute default values for any
 * attributes that have defaults and are not assigned to in the given tlist.
 * (We do not insert anything for default-less attributes, however.  The
 * planner will later insert NULLs for them, but there's no reason to slow
 * down rewriter processing with extra tlist nodes.)  Also, for both INSERT
 * and UPDATE, replace explicit DEFAULT specifications with column default
 * expressions.
 *
 * 2. For an UPDATE on a trigger-updatable view, add tlist entries for any
 * unassigned-to attributes, assigning them their old values.  These will
 * later get expanded to the output values of the view.  (This is equivalent
 * to what the planner's expand_targetlist() will do for UPDATE on a regular
 * table, but it's more convenient to do it here while we still have easy
 * access to the view's original RT index.)  This is only necessary for
 * trigger-updatable views, for which the view remains the result relation of
 * the query.  For auto-updatable views we must not do this, since it might
 * add assignments to non-updatable view columns.  For rule-updatable views it
 * is unnecessary extra work, since the query will be rewritten with a
 * different result relation which will be processed when we recurse via
 * RewriteQuery.
 *
 * 3. Merge multiple entries for the same target attribute, or declare error
 * if we can't.  Multiple entries are only allowed for INSERT/UPDATE of
 * portions of an array or record field, for example
 *			UPDATE table SET foo[2] = 42, foo[4] = 43;
 * We can merge such operations into a single assignment op.  Essentially,
 * the expression we want to produce in this case is like
 *		foo = array_set_element(array_set_element(foo, 2, 42), 4, 43)
 *
 * 4. Sort the tlist into standard order: non-junk fields in order by resno,
 * then junk fields (these in no particular order).
 *
 * We must do items 1,2,3 before firing rewrite rules, else rewritten
 * references to NEW.foo will produce wrong or incomplete results.  Item 4
 * is not needed for rewriting, but will be needed by the planner, and we
 * can do it essentially for free while handling the other items.
 *
 * Note that for an inheritable UPDATE, this processing is only done once,
 * using the parent relation as reference.  It must not do anything that
 * will not be correct when transposed to the child relation(s).  (Step 4
 * is incorrect by this light, since child relations might have different
 * column ordering, but the planner will fix things by re-sorting the tlist
 * for each child.)
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>rewriteTargetListIU</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetList</name></decl></parameter>,
					<parameter><decl><type><name>CmdType</name></type> <name>commandType</name></decl></parameter>,
					<parameter><decl><type><name>OverridingKind</name></type> <name>override</name></decl></parameter>,
					<parameter><decl><type><name>Relation</name></type> <name>target_relation</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>result_rti</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier><modifier>*</modifier></type><name>new_tles</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>new_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>junk_tlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name></decl>,
				<decl><type ref="prev"/><name>next_junk_attrno</name></decl>,
				<decl><type ref="prev"/><name>numattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>temp</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We process the normal (non-junk) attributes by scanning the input tlist
	 * once and transferring TLEs into an array, then scanning the array to
	 * build an output tlist.  This avoids O(N^2) behavior for large numbers
	 * of attributes.
	 *
	 * Junk attributes are tossed into a separate list during the same tlist
	 * scan, then appended to the reconstructed tlist.
	 */</comment>
	<expr_stmt><expr><name>numattrs</name> <operator>=</operator> <call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_tles</name> <operator>=</operator> <operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TargetEntry</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_junk_attrno</name> <operator>=</operator> <name>numattrs</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>temp</argument>, <argument>targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>old_tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>temp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>old_tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Normal attr: stash it into new_tles[] */</comment>
			<expr_stmt><expr><name>attrno</name> <operator>=</operator> <name><name>old_tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>attrno</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>attrno</name></expr></argument> &gt;</argument_list></name> <name>numattrs</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bogus resno %d in targetlist"</literal></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>target_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* We can (and must) ignore deleted attributes */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Merge with any prior assignment to same attribute */</comment>
			<expr_stmt><expr><name><name>new_tles</name><index>[<expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
				<call><name>process_matched_tle</name><argument_list>(<argument><expr><name>old_tle</name></expr></argument>,
									<argument><expr><name><name>new_tles</name><index>[<expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Copy all resjunk tlist entries to junk_tlist, and assign them
			 * resnos above the last real resno.
			 *
			 * Typical junk entries include ORDER BY or GROUP BY expressions
			 * (are these actually possible in an INSERT or UPDATE?), system
			 * attribute references, etc.
			 */</comment>

			<comment type="block">/* Get the resno right, but don't copy unnecessarily */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>old_tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>!=</operator> <name>next_junk_attrno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>old_tle</name> <operator>=</operator> <call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>old_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>old_tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <name>next_junk_attrno</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>junk_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>junk_tlist</name></expr></argument>, <argument><expr><name>old_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>next_junk_attrno</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<for>for <control>(<init><expr><name>attrno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attrno</name> <operator>&lt;=</operator> <name>numattrs</name></expr>;</condition> <incr><expr><name>attrno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>new_tle</name> <init>= <expr><name><name>new_tles</name><index>[<expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>apply_default</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>target_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We can (and must) ignore deleted attributes */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Handle the two cases where we need to insert a default expression:
		 * it's an INSERT and there's no tlist entry for the column, or the
		 * tlist entry is a DEFAULT placeholder node.
		 */</comment>
		<expr_stmt><expr><name>apply_default</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>new_tle</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>commandType</name> <operator>==</operator> <name>CMD_INSERT</name><operator>)</operator> <operator>||</operator>
						 <operator>(</operator><name>new_tle</name> <operator>&amp;&amp;</operator> <name><name>new_tle</name><operator>-&gt;</operator><name>expr</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>new_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_ALWAYS</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>apply_default</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>override</name> <operator>!=</operator> <name>OVERRIDING_SYSTEM_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GENERATED_ALWAYS</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert into column \"%s\""</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" is an identity column defined as GENERATED ALWAYS."</literal></expr></argument>,
									   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use OVERRIDING SYSTEM VALUE to override."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_BY_DEFAULT</name> <operator>&amp;&amp;</operator> <name>override</name> <operator>==</operator> <name>OVERRIDING_USER_VALUE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>apply_default</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>apply_default</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert into column \"%s\""</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" is a generated column."</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attidentity</name></name> <operator>==</operator> <name>ATTRIBUTE_IDENTITY_ALWAYS</name> <operator>&amp;&amp;</operator> <name>new_tle</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>apply_default</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_GENERATED_ALWAYS</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" can only be updated to DEFAULT"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" is an identity column defined as GENERATED ALWAYS."</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>&amp;&amp;</operator> <name>new_tle</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>apply_default</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" can only be updated to DEFAULT"</literal></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Column \"%s\" is a generated column."</literal></expr></argument>,
								   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * stored generated column will be fixed in executor
			 */</comment>
			<expr_stmt><expr><name>new_tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>apply_default</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>new_expr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If there is no default (ie, default is effectively NULL), we
			 * can omit the tlist entry in the INSERT case, since the planner
			 * can insert a NULL for itself, and there's no point in spending
			 * any more rewriter cycles on the entry.  But in the UPDATE case
			 * we've got to explicitly set the column to NULL.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_expr</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>commandType</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>new_tle</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
												  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
												  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* isnull */</comment>
												  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* this is to catch a NOT NULL domain constraint */</comment>
					<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <call><name>coerce_to_domain</name><argument_list>(<argument><expr><name>new_expr</name></expr></argument>,
												<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
												<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
												<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>new_expr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>new_tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>new_expr</name></expr></argument>,
										  <argument><expr><name>attrno</name></expr></argument>,
										  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * For an UPDATE on a trigger-updatable view, provide a dummy entry
		 * whenever there is no explicit assignment.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>new_tle</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>commandType</name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
			<name><name>target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
			<call><name>view_has_instead_trigger</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>, <argument><expr><name>CMD_UPDATE</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>new_expr</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name>result_rti</name></expr></argument>,
										<argument><expr><name>attrno</name></expr></argument>,
										<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
										<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
										<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>new_tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>new_expr</name></expr></argument>,
									  <argument><expr><name>attrno</name></expr></argument>,
									  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_tle</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>new_tlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>new_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_tles</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>new_tlist</name></expr></argument>, <argument><expr><name>junk_tlist</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Convert a matched TLE from the original tlist into a correct new TLE.
 *
 * This routine detects and handles multiple assignments to the same target
 * attribute.  (The attribute name is needed only for error messages.)
 */</comment>
<function><type><specifier>static</specifier> <name>TargetEntry</name> <modifier>*</modifier></type>
<name>process_matched_tle</name><parameter_list>(<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>src_tle</name></decl></parameter>,
					<parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>prior_tle</name></decl></parameter>,
					<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attrName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>coerce_expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>src_expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prior_expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>src_input</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>prior_input</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>priorbottom</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newexpr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>prior_tle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Normal case where this is the first assignment to the attribute.
		 */</comment>
		<return>return <expr><name>src_tle</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*----------
	 * Multiple assignments to same attribute.  Allow only if all are
	 * FieldStore or SubscriptingRef assignment operations.  This is a bit
	 * tricky because what we may actually be looking at is a nest of
	 * such nodes; consider
	 *		UPDATE tab SET col.fld1.subfld1 = x, col.fld2.subfld2 = y
	 * The two expressions produced by the parser will look like
	 *		FieldStore(col, fld1, FieldStore(placeholder, subfld1, x))
	 *		FieldStore(col, fld2, FieldStore(placeholder, subfld2, y))
	 * However, we can ignore the substructure and just consider the top
	 * FieldStore or SubscriptingRef from each assignment, because it works to
	 * combine these as
	 *		FieldStore(FieldStore(col, fld1,
	 *							  FieldStore(placeholder, subfld1, x)),
	 *				   fld2, FieldStore(placeholder, subfld2, y))
	 * Note the leftmost expression goes on the inside so that the
	 * assignments appear to occur left-to-right.
	 *
	 * For FieldStore, instead of nesting we can generate a single
	 * FieldStore with multiple target fields.  We must nest when
	 * SubscriptingRefs are involved though.
	 *
	 * As a further complication, the destination column might be a domain,
	 * resulting in each assignment containing a CoerceToDomain node over a
	 * FieldStore or SubscriptingRef.  These should have matching target
	 * domains, so we strip them and reconstitute a single CoerceToDomain over
	 * the combined FieldStore/SubscriptingRef nodes.  (Notice that this has the
	 * result that the domain's checks are applied only after we do all the
	 * field or element updates, not after each one.  This is arguably desirable.)
	 *----------
	 */</comment>
	<expr_stmt><expr><name>src_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>src_tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>prior_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>prior_tle</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>src_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>src_expr</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>prior_expr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>prior_expr</name></expr></argument>, <argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>src_expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttype</name> <operator>==</operator>
		<operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>prior_expr</name><operator>)</operator><operator>-&gt;</operator><name>resulttype</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we assume without checking that resulttypmod/resultcollid match */</comment>
		<expr_stmt><expr><name>coerce_expr</name> <operator>=</operator> <operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>src_expr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>src_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>src_expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>prior_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>CoerceToDomain</name> <operator>*</operator><operator>)</operator> <name>prior_expr</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>src_input</name> <operator>=</operator> <call><name>get_assignment_input</name><argument_list>(<argument><expr><name>src_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prior_input</name> <operator>=</operator> <call><name>get_assignment_input</name><argument_list>(<argument><expr><name>prior_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>src_input</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name>prior_input</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<call><name>exprType</name><argument_list>(<argument><expr><name>src_expr</name></expr></argument>)</argument_list></call> <operator>!=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>prior_expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple assignments to same column \"%s\""</literal></expr></argument>,
						<argument><expr><name>attrName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Prior TLE could be a nest of assignments if we do this more than once.
	 */</comment>
	<expr_stmt><expr><name>priorbottom</name> <operator>=</operator> <name>prior_input</name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>newbottom</name> <init>= <expr><call><name>get_assignment_input</name><argument_list>(<argument><expr><name>priorbottom</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>newbottom</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* found the original Var reference */</comment>
		<expr_stmt><expr><name>priorbottom</name> <operator>=</operator> <name>newbottom</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>equal</name><argument_list>(<argument><expr><name>priorbottom</name></expr></argument>, <argument><expr><name>src_input</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple assignments to same column \"%s\""</literal></expr></argument>,
						<argument><expr><name>attrName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Looks OK to nest 'em.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>src_expr</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>prior_expr</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* combine the two */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fstore</name></expr></argument>, <argument><expr><name>prior_expr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FieldStore</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fstore</name><operator>-&gt;</operator><name>newvals</name></name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>prior_expr</name><operator>)</operator><operator>-&gt;</operator><name>newvals</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>src_expr</name><operator>)</operator><operator>-&gt;</operator><name>newvals</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fstore</name><operator>-&gt;</operator><name>fieldnums</name></name> <operator>=</operator>
				<call><name>list_concat</name><argument_list>(<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>prior_expr</name><operator>)</operator><operator>-&gt;</operator><name>fieldnums</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>list_copy</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>src_expr</name><operator>)</operator><operator>-&gt;</operator><name>fieldnums</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* general case, just nest 'em */</comment>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>fstore</name></expr></argument>, <argument><expr><name>src_expr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FieldStore</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>prior_expr</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>fstore</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>src_expr</name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>sbsref</name></expr></argument>, <argument><expr><name>src_expr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>prior_expr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>sbsref</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot happen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>coerce_expr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* put back the CoerceToDomain */</comment>
		<decl_stmt><decl><type><name>CoerceToDomain</name> <modifier>*</modifier></type><name>newcoerce</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newcoerce</name></expr></argument>, <argument><expr><name>coerce_expr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CoerceToDomain</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newcoerce</name><operator>-&gt;</operator><name>arg</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>newexpr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>newcoerce</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>flatCopyTargetEntry</name><argument_list>(<argument><expr><name>src_tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>newexpr</name></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If node is an assignment node, return its input; else return NULL
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>get_assignment_input</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>FieldStore</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FieldStore</name> <modifier>*</modifier></type><name>fstore</name> <init>= <expr><operator>(</operator><name>FieldStore</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>fstore</name><operator>-&gt;</operator><name>arg</name></name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubscriptingRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubscriptingRef</name> <modifier>*</modifier></type><name>sbsref</name> <init>= <expr><operator>(</operator><name>SubscriptingRef</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sbsref</name><operator>-&gt;</operator><name>refassgnexpr</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>sbsref</name><operator>-&gt;</operator><name>refexpr</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make an expression tree for the default value for a column.
 *
 * If there is no default, return a NULL instead.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>build_column_default</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attrno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>rd_att</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>rd_att</name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>atttype</name> <init>= <expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>atttypmod</name> <init>= <expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>exprtype</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>attidentity</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NextValueExpr</name> <modifier>*</modifier></type><name>nve</name> <init>= <expr><call><name>makeNode</name><argument_list>(<argument><expr><name>NextValueExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>nve</name><operator>-&gt;</operator><name>seqid</name></name> <operator>=</operator> <call><name>getOwnedSequence</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nve</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>

		<return>return <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>nve</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Scan to see if relation has a default for this column.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>att_tup</name><operator>-&gt;</operator><name>atthasdef</name></name> <operator>&amp;&amp;</operator> <name><name>rd_att</name><operator>-&gt;</operator><name>constr</name></name> <operator>&amp;&amp;</operator>
		<name><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttrDefault</name> <modifier>*</modifier></type><name>defval</name> <init>= <expr><name><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>defval</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndef</name> <init>= <expr><name><name>rd_att</name><operator>-&gt;</operator><name>constr</name><operator>-&gt;</operator><name>num_defval</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>--</operator><name>ndef</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>attrno</name> <operator>==</operator> <name><name>defval</name><index>[<expr><name>ndef</name></expr>]</index></name><operator>.</operator><name>adnum</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Found it, convert string representation to node tree.
				 */</comment>
				<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>defval</name><index>[<expr><name>ndef</name></expr>]</index></name><operator>.</operator><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * No per-column default, so look for a default for the type itself.  But
	 * not for generated columns.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>att_tup</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>get_typdefault</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* No default anywhere */</comment>

	<comment type="block">/*
	 * Make sure the value is coerced to the target column type; this will
	 * generally be true already, but there seem to be some corner cases
	 * involving domain defaults where it might not be true. This should match
	 * the parser's processing of non-defaulted expressions --- see
	 * transformAssignedExpr().
	 */</comment>
	<expr_stmt><expr><name>exprtype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,	<comment type="block">/* no UNKNOWN params here */</comment>
								 <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>exprtype</name></expr></argument>,
								 <argument><expr><name>atttype</name></expr></argument>, <argument><expr><name>atttypmod</name></expr></argument>,
								 <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
								 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is of type %s"</literal>
						<literal type="string">" but default expression is of type %s"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttype</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>exprtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You will need to rewrite or cast the expression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Does VALUES RTE contain any SetToDefault items? */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>searchForDefault</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;values_lists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>sublist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * When processing INSERT ... VALUES with a VALUES RTE (ie, multiple VALUES
 * lists), we have to replace any DEFAULT items in the VALUES lists with
 * the appropriate default expressions.  The other aspects of targetlist
 * rewriting need be applied only to the query's targetlist proper.
 *
 * For an auto-updatable view, each DEFAULT item in the VALUES list is
 * replaced with the default from the view, if it has one.  Otherwise it is
 * left untouched so that the underlying base relation's default can be
 * applied instead (when we later recurse to here after rewriting the query
 * to refer to the base relation instead of the view).
 *
 * For other types of relation, including rule- and trigger-updatable views,
 * all DEFAULT items are replaced, and if the target relation doesn't have a
 * default, the value is explicitly set to NULL.
 *
 * Additionally, if force_nulls is true, the target relation's defaults are
 * ignored and all DEFAULT items in the VALUES list are explicitly set to
 * NULL, regardless of the target relation's type.  This is used for the
 * product queries generated by DO ALSO rules attached to an auto-updatable
 * view, for which we will have already called this function with force_nulls
 * false.  For these product queries, we must then force any remaining DEFAULT
 * items to NULL to provide concrete values for the rule actions.
 * Essentially, this is a mix of the 2 cases above --- the original query is
 * an insert into an auto-updatable view, and the product queries are inserts
 * into a rule-updatable view.
 *
 * Note that we may have subscripted or field assignment targetlist entries,
 * as well as more complex expressions from already-replaced DEFAULT items if
 * we have recursed to here for an auto-updatable view. However, it ought to
 * be impossible for such entries to have DEFAULTs assigned to them --- we
 * should only have to replace DEFAULT items for targetlist entries that
 * contain simple Vars referencing the VALUES RTE.
 *
 * Returns true if all DEFAULT items were replaced, and false if some were
 * left untouched.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>rewriteValuesRTE</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rti</name></decl></parameter>,
				 <parameter><decl><type><name>Relation</name></type> <name>target_relation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>force_nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newValues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isAutoUpdatableView</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allReplaced</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numattrs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>attrnos</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Rebuilding all the lists is a pretty expensive proposition in a big
	 * VALUES list, and it's a waste of time if there aren't any DEFAULT
	 * placeholders.  So first scan to see if there are any.
	 *
	 * We skip this check if force_nulls is true, because we know that there
	 * are DEFAULT items present in that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_nulls</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>searchForDefault</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* nothing to do */</comment>

	<comment type="block">/*
	 * Scan the targetlist for entries referring to the VALUES RTE, and note
	 * the target attributes. As noted above, we should only need to do this
	 * for targetlist entries containing simple Vars --- nothing else in the
	 * VALUES RTE should contain DEFAULT items, and we complain if such a
	 * thing does occur.
	 */</comment>
	<expr_stmt><expr><name>numattrs</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attrnos</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>numattrs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>==</operator> <name>rti</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name> <init>= <expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attrno</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>attrno</name> <operator>&lt;=</operator> <name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>attrnos</name><index>[<expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Check if the target relation is an auto-updatable view, in which case
	 * unresolved defaults will be left untouched rather than being set to
	 * NULL.  If force_nulls is true, we always set DEFAULT items to NULL, so
	 * skip this check in that case --- it isn't an auto-updatable view.
	 */</comment>
	<expr_stmt><expr><name>isAutoUpdatableView</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_nulls</name> <operator>&amp;&amp;</operator>
		<name><name>target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>view_has_instead_trigger</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>, <argument><expr><name>CMD_INSERT</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>locks</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasUpdate</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<comment type="block">/* Look for an unconditional DO INSTEAD rule */</comment>
		<expr_stmt><expr><name>locks</name> <operator>=</operator> <call><name>matchLocks</name><argument_list>(<argument><expr><name>CMD_INSERT</name></expr></argument>, <argument><expr><name><name>target_relation</name><operator>-&gt;</operator><name>rd_rules</name></name></expr></argument>,
						   <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>locks</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule_lock</name> <init>= <expr><operator>(</operator><name>RewriteRule</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rule_lock</name><operator>-&gt;</operator><name>isInstead</name></name> <operator>&amp;&amp;</operator>
				<name><name>rule_lock</name><operator>-&gt;</operator><name>qual</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If we didn't find an unconditional DO INSTEAD rule, assume that the
		 * view is auto-updatable.  If it isn't, rewriteTargetView() will
		 * throw an error.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>isAutoUpdatableView</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>newValues</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>allReplaced</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rte-&gt;values_lists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>sublist</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newList</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name>sublist</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>numattrs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>sublist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>col</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>attrno</name> <init>= <expr><name><name>attrnos</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>SetToDefault</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>new_expr</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>attrno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot set value in column %d to DEFAULT"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>target_relation</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attrno</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_nulls</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>att_tup</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <call><name>build_column_default</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>, <argument><expr><name>attrno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* force a NULL if dropped */</comment>

				<comment type="block">/*
				 * If there is no default (ie, default is effectively NULL),
				 * we've got to explicitly set the column to NULL, unless the
				 * target relation is an auto-updatable view.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>new_expr</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>isAutoUpdatableView</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* Leave the value untouched */</comment>
						<expr_stmt><expr><name>newList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newList</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>allReplaced</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
												  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
												  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>,
												  <argument><expr><name>true</name></expr></argument>, <comment type="block">/* isnull */</comment>
												  <argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* this is to catch a NOT NULL domain constraint */</comment>
					<expr_stmt><expr><name>new_expr</name> <operator>=</operator> <call><name>coerce_to_domain</name><argument_list>(<argument><expr><name>new_expr</name></expr></argument>,
												<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
												<argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
												<argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
												<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
												<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>newList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newList</name></expr></argument>, <argument><expr><name>new_expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>newList</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newList</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>newValues</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newValues</name></expr></argument>, <argument><expr><name>newList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>values_lists</name></name> <operator>=</operator> <name>newValues</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>attrnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>allReplaced</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * rewriteTargetListUD - rewrite UPDATE/DELETE targetlist as needed
 *
 * This function adds a "junk" TLE that is needed to allow the executor to
 * find the original row for the update or delete.  When the target relation
 * is a regular table, the junk TLE emits the ctid attribute of the original
 * row.  When the target relation is a foreign table, we let the FDW decide
 * what to add.
 *
 * We used to do this during RewriteQuery(), but now that inheritance trees
 * can contain a mix of regular and foreign tables, we must postpone it till
 * planning, after the inheritance tree has been expanded.  In that way we
 * can do the right thing for each child table.
 */</comment>
<function><type><name>void</name></type>
<name>rewriteTargetListUD</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>target_rte</name></decl></parameter>,
					<parameter><decl><type><name>Relation</name></type> <name>target_relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attrname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Var</name> 		<modifier>*</modifier></type><name>varSegid</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		<name><name>target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
		<call><name>IsAppendonlyMetadataRelkind</name><argument_list>(<argument><expr><name><name>target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Emit CTID so that executor can find the row to update or delete.
		 */</comment>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
					  <argument><expr><name>SelfItemPointerAttributeNumber</name></expr></argument>,
					  <argument><expr><name>TIDOID</name></expr></argument>,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
					  <argument><expr><name>InvalidOid</name></expr></argument>,
					  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>attrname</name> <operator>=</operator> <literal type="string">"ctid"</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB also needs gp_segment_id. ctid is only unique in the same
		 * segment.
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>vartypeid</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32</name></type>		<name>type_mod</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>type_coll</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>GpSegmentIdAttributeNumber</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vartypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_mod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>varSegid</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
							   <argument><expr><name>GpSegmentIdAttributeNumber</name></expr></argument>,
							   <argument><expr><name>vartypeid</name></expr></argument>,
							   <argument><expr><name>type_mod</name></expr></argument>,
							   <argument><expr><name>type_coll</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>target_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Let the foreign table's FDW add whatever junk TLEs it wants.
		 */</comment>
		<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fdwroutine</name> <operator>=</operator> <call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>AddForeignUpdateTargets</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>fdwroutine</name><operator>-&gt;</operator><name>AddForeignUpdateTargets</name></name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>target_rte</name></expr></argument>,
												<argument><expr><name>target_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we have a row-level trigger corresponding to the operation, emit
		 * a whole-row Var so that executor will have the "old" row to pass to
		 * the trigger.  Alas, this misses system columns.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>target_relation</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>&amp;&amp;</operator>
			  <operator>(</operator><name><name>target_relation</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_after_row</name></name> <operator>||</operator>
			   <name><name>target_relation</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_update_before_row</name></name><operator>)</operator><operator>)</operator> <operator>||</operator>
			 <operator>(</operator><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name> <operator>&amp;&amp;</operator>
			  <operator>(</operator><name><name>target_relation</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_after_row</name></name> <operator>||</operator>
			   <name><name>target_relation</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>trig_delete_before_row</name></name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeWholeRowVar</name><argument_list>(<argument><expr><name>target_rte</name></expr></argument>,
								  <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>attrname</name> <operator>=</operator> <literal type="string">"wholerow"</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * GPDB also needs gp_segment_id. ctid is only unique in the same
			 * segment.
			 */</comment>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>vartypeid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int32</name></type>		<name>type_mod</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>type_coll</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>reloid</name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>target_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>get_atttypetypmodcoll</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>GpSegmentIdAttributeNumber</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vartypeid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_mod</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>type_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>varSegid</name> <operator>=</operator> <call><name>makeVar</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
								   <argument><expr><name>GpSegmentIdAttributeNumber</name></expr></argument>,
								   <argument><expr><name>vartypeid</name></expr></argument>,
								   <argument><expr><name>type_mod</name></expr></argument>,
								   <argument><expr><name>type_coll</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>var</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
							  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>attrname</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>varSegid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>varSegid</name></expr></argument>,
							  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,	<comment type="block">/* resno */</comment>
							  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"gp_segment_id"</literal></expr></argument>)</argument_list></call></expr></argument>,	<comment type="block">/* resname */</comment>
							  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>					<comment type="block">/* resjunk */</comment>

		<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * matchLocks -
 *	  match the list of locks and returns the matching rules
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>matchLocks</name><parameter_list>(<parameter><decl><type><name>CmdType</name></type> <name>event</name></decl></parameter>,
		   <parameter><decl><type><name>RuleLock</name> <modifier>*</modifier></type><name>rulelocks</name></decl></parameter>,
		   <parameter><decl><type><name>int</name></type> <name>varno</name></decl></parameter>,
		   <parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
		   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>hasUpdate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>matching_locks</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nlocks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rulelocks</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>!=</operator> <name>varno</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>nlocks</name> <operator>=</operator> <name><name>rulelocks</name><operator>-&gt;</operator><name>numLocks</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nlocks</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>oneLock</name> <init>= <expr><name><name>rulelocks</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>oneLock</name><operator>-&gt;</operator><name>event</name></name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>hasUpdate</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Suppress ON INSERT/UPDATE/DELETE rules that are disabled or
		 * configured to not fire during the current sessions replication
		 * role. ON SELECT rules will always be applied in order to keep views
		 * working even in LOCAL or REPLICA role.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>oneLock</name><operator>-&gt;</operator><name>event</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>SessionReplicationRole</name> <operator>==</operator> <name>SESSION_REPLICATION_ROLE_REPLICA</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>oneLock</name><operator>-&gt;</operator><name>enabled</name></name> <operator>==</operator> <name>RULE_FIRES_ON_ORIGIN</name> <operator>||</operator>
					<name><name>oneLock</name><operator>-&gt;</operator><name>enabled</name></name> <operator>==</operator> <name>RULE_DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else				<comment type="block">/* ORIGIN or LOCAL ROLE */</comment>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>oneLock</name><operator>-&gt;</operator><name>enabled</name></name> <operator>==</operator> <name>RULE_FIRES_ON_REPLICA</name> <operator>||</operator>
					<name><name>oneLock</name><operator>-&gt;</operator><name>enabled</name></name> <operator>==</operator> <name>RULE_DISABLED</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>oneLock</name><operator>-&gt;</operator><name>event</name></name> <operator>==</operator> <name>event</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>||</operator>
				<call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>varno</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>matching_locks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>matching_locks</name></expr></argument>, <argument><expr><name>oneLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>matching_locks</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ApplyRetrieveRule - expand an ON SELECT rule
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>ApplyRetrieveRule</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
				  <parameter><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>rt_index</name></decl></parameter>,
				  <parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeRIRs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>rule_action</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>subrte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RowMarkClause</name> <modifier>*</modifier></type><name>rc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rule</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"expected just one rule action"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rule</name><operator>-&gt;</operator><name>qual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot handle qualified ON SELECT rule"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rt_index</name> <operator>==</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have a view as the result relation of the query, and it wasn't
		 * rewritten by any rule.  This case is supported if there is an
		 * INSTEAD OF trigger that will trap attempts to insert/update/delete
		 * view rows.  The executor will check that; for the moment just plow
		 * ahead.  We have two cases:
		 *
		 * For INSERT, we needn't do anything.  The unmodified RTE will serve
		 * fine as the result relation.
		 *
		 * For UPDATE/DELETE, we need to expand the view so as to have source
		 * data for the operation.  But we also need an unmodified RTE to
		 * serve as the target.  So, copy the RTE and add the copy to the
		 * rangetable.  Note that the copy does not get added to the jointree.
		 * Also note that there's a hack in fireRIRrules to avoid calling this
		 * function again when it arrives at the copied RTE.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>parsetree</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_UPDATE</name> <operator>||</operator>
				 <name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>newrte</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rt_index</name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>newrte</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>newrte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * There's no need to do permissions checks twice, so wipe out the
			 * permissions info for the original RTE (we prefer to keep the
			 * bits set on the result RTE).
			 */</comment>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * For the most part, Vars referencing the view should remain as
			 * they are, meaning that they implicitly represent OLD values.
			 * But in the RETURNING list if any, we want such Vars to
			 * represent NEW values, so change them to reference the new RTE.
			 *
			 * Since ChangeVarNodes scribbles on the tree in-place, copy the
			 * RETURNING list first for safety.
			 */</comment>
			<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>returningList</name></name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>returningList</name></name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>,
						   <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * To allow the executor to compute the original view row to pass
			 * to the INSTEAD OF trigger, we add a resjunk whole-row Var
			 * referencing the original RTE.  This will later get expanded
			 * into a RowExpr computing all the OLD values of the view row.
			 */</comment>
			<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>makeWholeRowVar</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tle</name> <operator>=</operator> <call><name>makeTargetEntry</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>,
								  <argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">"wholerow"</literal></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Now, continue with expanding the original view RTE */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if there's a FOR [KEY] UPDATE/SHARE clause applying to this view.
	 *
	 * Note: we needn't explicitly consider any such clauses appearing in
	 * ancestor query levels; their effects have already been pushed down to
	 * here by markQueryForLocking, and will be reflected in "rc".
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>get_parse_rowmark</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a modifiable copy of the view query, and acquire needed locks on
	 * the relations it mentions.  Force at least RowShareLock for all such
	 * rels if there's a FOR [KEY] UPDATE/SHARE clause affecting this view.
	 */</comment>
	<expr_stmt><expr><name>rule_action</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>rule</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AcquireRewriteLocks</name><argument_list>(<argument><expr><name>rule_action</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>(</operator><name>rc</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If FOR [KEY] UPDATE/SHARE of view, mark all the contained tables as
	 * implicit FOR [KEY] UPDATE/SHARE, the same as the parser would have done
	 * if the view's subquery had been written out explicitly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>markQueryForLocking</name><argument_list>(<argument><expr><name>rule_action</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rule_action</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
							<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>strength</name></name></expr></argument>, <argument><expr><name><name>rc</name><operator>-&gt;</operator><name>waitPolicy</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Recursively expand any view references inside the view.
	 *
	 * Note: this must happen after markQueryForLocking.  That way, any UPDATE
	 * permission bits needed for sub-views are initially applied to their
	 * RTE_RELATION RTEs by markQueryForLocking, and then transferred to their
	 * OLD rangetable entries by the action below (in a recursive call of this
	 * routine).
	 */</comment>
	<expr_stmt><expr><name>rule_action</name> <operator>=</operator> <call><name>fireRIRrules</name><argument_list>(<argument><expr><name>rule_action</name></expr></argument>, <argument><expr><name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now, plug the view query in as a subselect, converting the relation's
	 * original RTE to a subquery RTE.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rt_index</name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_SUBQUERY</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <name>rule_action</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>security_barrier</name></name> <operator>=</operator> <call><name>RelationIsSecurityView</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Clear fields that should not be set in a subquery RTE */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>tablesample</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>			<comment type="block">/* must not be set for a subquery */</comment>

	<comment type="block">/*
	 * We move the view's permission check data down to its rangetable. The
	 * checks will actually be done against the OLD entry therein.
	 */</comment>
	<expr_stmt><expr><name>subrte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><name><name>rule_action</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>subrte</name><operator>-&gt;</operator><name>relid</name></name> <operator>==</operator> <name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subrte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subrte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subrte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subrte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>subrte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>		<comment type="block">/* no permission check on subquery itself */</comment>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>extraUpdatedCols</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>parsetree</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recursively mark all relations used by a view as FOR [KEY] UPDATE/SHARE.
 *
 * This may generate an invalid query, eg if some sub-query uses an
 * aggregate.  We leave it to the planner to detect that.
 *
 * NB: this must agree with the parser's transformLockingClause() routine.
 * However, unlike the parser we have to be careful not to mark a view's
 * OLD and NEW rels for updating.  The best way to handle that seems to be
 * to scan the jointree to determine which rels are used.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>markQueryForLocking</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>qry</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>jtnode</name></decl></parameter>,
					<parameter><decl><type><name>LockClauseStrength</name></type> <name>strength</name></decl></parameter>, <parameter><decl><type><name>LockWaitPolicy</name></type> <name>waitPolicy</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>pushedDown</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>jtnode</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>rti</name> <init>= <expr><operator>(</operator><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <name>jtnode</name><operator>)</operator><operator>-&gt;</operator><name>rtindex</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rti</name></expr></argument>, <argument><expr><name><name>qry</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>strength</name></expr></argument>, <argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>|=</operator> <name>ACL_SELECT_FOR_UPDATE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>applyLockingClause</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name>rti</name></expr></argument>, <argument><expr><name>strength</name></expr></argument>, <argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* FOR UPDATE/SHARE of subquery is propagated to subquery's rels */</comment>
			<expr_stmt><expr><call><name>markQueryForLocking</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rte</name><operator>-&gt;</operator><name>subquery</name><operator>-&gt;</operator><name>jointree</name></name></expr></argument>,
								<argument><expr><name>strength</name></expr></argument>, <argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* other RTE types are unaffected by FOR UPDATE */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>FromExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FromExpr</name>   <modifier>*</modifier></type><name>f</name> <init>= <expr><operator>(</operator><name>FromExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>f-&gt;fromlist</argument>)</argument_list></macro>
			<expr_stmt><expr><call><name>markQueryForLocking</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>strength</name></expr></argument>, <argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>, <argument><expr><name>JoinExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>JoinExpr</name>   <modifier>*</modifier></type><name>j</name> <init>= <expr><operator>(</operator><name>JoinExpr</name> <operator>*</operator><operator>)</operator> <name>jtnode</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>markQueryForLocking</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>larg</name></name></expr></argument>, <argument><expr><name>strength</name></expr></argument>, <argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>markQueryForLocking</name><argument_list>(<argument><expr><name>qry</name></expr></argument>, <argument><expr><name><name>j</name><operator>-&gt;</operator><name>rarg</name></name></expr></argument>, <argument><expr><name>strength</name></expr></argument>, <argument><expr><name>waitPolicy</name></expr></argument>, <argument><expr><name>pushedDown</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
			 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>jtnode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * fireRIRonSubLink -
 *	Apply fireRIRrules() to each SubLink (subselect in expression) found
 *	in the given tree.
 *
 * NOTE: although this has the form of a walker, we cheat and modify the
 * SubLink nodes in-place.  It is caller's responsibility to ensure that
 * no unwanted side-effects occur!
 *
 * This is unlike most of the other routines that recurse into subselects,
 * because we must take control at the SubLink node in order to replace
 * the SubLink's subselect link with the possibly-rewritten subquery.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>fireRIRonSubLink</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeRIRs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>SubLink</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SubLink</name>    <modifier>*</modifier></type><name>sub</name> <init>= <expr><operator>(</operator><name>SubLink</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Do what we came for */</comment>
		<expr_stmt><expr><name><name>sub</name><operator>-&gt;</operator><name>subselect</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>fireRIRrules</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>sub</name><operator>-&gt;</operator><name>subselect</name></name></expr></argument>,
											   <argument><expr><name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Fall through to process lefthand args of SubLink */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do NOT recurse into Query nodes, because fireRIRrules already processed
	 * subselects of subselects for us.
	 */</comment>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>fireRIRonSubLink</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * fireRIRrules -
 *	Apply all RIR rules on each rangetable entry in the given query
 *
 * activeRIRs is a list of the OIDs of views we're already processing RIR
 * rules for, used to detect/reject recursion.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>fireRIRrules</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>activeRIRs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>origResultRelation</name> <init>= <expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rt_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * don't try to convert this into a foreach loop, because rtable list can
	 * get changed each time through...
	 */</comment>
	<expr_stmt><expr><name>rt_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>rt_index</name> <operator>&lt;</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>locks</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RuleLock</name>   <modifier>*</modifier></type><name>rules</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>++</operator><name>rt_index</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>rt_index</name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * A subquery RTE can't have associated rules, so there's nothing to
		 * do to this level of the query, but we must recurse into the
		 * subquery to expand any rule references in it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>||</operator> <name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_TABLEFUNCTION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name> <operator>=</operator> <call><name>fireRIRrules</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></argument>, <argument><expr><name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Joins and other non-relation RTEs can be ignored completely.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Always ignore RIR rules for materialized views referenced in
		 * queries.  (This does not prevent refreshing MVs, since they aren't
		 * referenced in their own query definitions.)
		 *
		 * Note: in the future we might want to allow MVs to be conditionally
		 * expanded as if they were regular views, if they are not scannable.
		 * In that case this test would need to be postponed till after we've
		 * opened the rel, so that we could check its state.
		 *
		 * In the minirepro utility in GPDB, we use the expandMatViews flag
		 * to treat materialized views as regular views when dumping the
		 * DDL in order to dump dependent objects
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>parsetree</name><operator>-&gt;</operator><name>expandMatViews</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * In INSERT ... ON CONFLICT, ignore the EXCLUDED pseudo-relation;
		 * even if it points to a view, we needn't expand it, and should not
		 * because we want the RTE to remain of RTE_RELATION type.  Otherwise,
		 * it would get changed to RTE_SUBQUERY type, which is an
		 * untested/unsupported situation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>&amp;&amp;</operator>
			<name>rt_index</name> <operator>==</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>exclRelIndex</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the table is not referenced in the query, then we ignore it.
		 * This prevents infinite expansion loop due to new rtable entries
		 * inserted by expansion of a rule. A table is referenced if it is
		 * part of the join set (a source table), or is referenced by any Var
		 * nodes, or is the result table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>rt_index</name> <operator>!=</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>rangeTableEntry_used</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also, if this is a new result relation introduced by
		 * ApplyRetrieveRule, we don't want to do anything more with it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>rt_index</name> <operator>==</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>&amp;&amp;</operator>
			<name>rt_index</name> <operator>!=</operator> <name>origResultRelation</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We can use NoLock here since either the parser or
		 * AcquireRewriteLocks should have locked the rel already.
		 */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Collect the RIR rules that we must apply
		 */</comment>
		<expr_stmt><expr><name>rules</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rules</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>rules</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>locks</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rules</name><operator>-&gt;</operator><name>numLocks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>rule</name> <operator>=</operator> <name><name>rules</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rule</name><operator>-&gt;</operator><name>event</name></name> <operator>!=</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>locks</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>locks</name></expr></argument>, <argument><expr><name>rule</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * If we found any, apply them --- but first check for recursion!
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>locks</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeRIRs</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"infinite recursion detected in rules for relation \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>activeRIRs</name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>locks</argument>)</argument_list></macro>
				<block>{<block_content>
					<expr_stmt><expr><name>rule</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <call><name>ApplyRetrieveRule</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
												  <argument><expr><name>rule</name></expr></argument>,
												  <argument><expr><name>rt_index</name></expr></argument>,
												  <argument><expr><name>rel</name></expr></argument>,
												  <argument><expr><name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>

				<expr_stmt><expr><name>activeRIRs</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Recurse into subqueries in WITH */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><operator>(</operator><name>CommonTableExpr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
			<call><name>fireRIRrules</name><argument_list>(<argument><expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>, <argument><expr><name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Recurse into sublink subqueries, too.  But we already did the ones in
	 * the rtable and cteList.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>fireRIRonSubLink</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>activeRIRs</name></expr></argument>,
						  <argument><expr><name>QTW_IGNORE_RC_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Apply any row level security policies.  We do this last because it
	 * requires special recursion detection if the new quals have sublink
	 * subqueries, and if we did it in the loop above query_tree_walker would
	 * then recurse into those quals a second time.
	 */</comment>
	<expr_stmt><expr><name>rt_index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;rtable</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><operator>(</operator><name>RangeTblEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>securityQuals</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>withCheckOptions</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasRowSecurity</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasSubLinks</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>++</operator><name>rt_index</name></expr>;</expr_stmt>

		<comment type="block">/* Only normal relations can have RLS policies */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>||</operator>
			<operator>(</operator><name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			 <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fetch any new security quals that must be applied to this RTE.
		 */</comment>
		<expr_stmt><expr><call><name>get_row_security_policies</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>securityQuals</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>withCheckOptions</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>hasRowSecurity</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasSubLinks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>securityQuals</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name>withCheckOptions</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>hasSubLinks</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>acquireLocksOnSubLinks_context</name></type> <name>context</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * Recursively process the new quals, checking for infinite
				 * recursion.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>activeRIRs</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"infinite recursion detected in policy for relation \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>activeRIRs</name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * get_row_security_policies just passed back securityQuals
				 * and/or withCheckOptions, and there were SubLinks, make sure
				 * we lock any relations which are referenced.
				 *
				 * These locks would normally be acquired by the parser, but
				 * securityQuals and withCheckOptions are added post-parsing.
				 */</comment>
				<expr_stmt><expr><name><name>context</name><operator>.</operator><name>for_execute</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>acquireLocksOnSubLinks</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>securityQuals</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>acquireLocksOnSubLinks</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>withCheckOptions</name></expr></argument>,
											  <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now that we have the locks on anything added by
				 * get_row_security_policies, fire any RIR rules for them.
				 */</comment>
				<expr_stmt><expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>securityQuals</name></expr></argument>,
									   <argument><expr><name>fireRIRonSubLink</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>withCheckOptions</name></expr></argument>,
									   <argument><expr><name>fireRIRonSubLink</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name>activeRIRs</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>activeRIRs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Add the new security barrier quals to the start of the RTE's
			 * list so that they get applied before any existing barrier quals
			 * (which would have come from a security-barrier view, and should
			 * get lower priority than RLS conditions on the table itself).
			 */</comment>
			<expr_stmt><expr><name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>securityQuals</name></expr></argument>,
											 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>withCheckOptions</name></name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>withCheckOptions</name></expr></argument>,
													  <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Make sure the query is marked correctly if row level security
		 * applies, or if the new quals had sublinks.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>hasRowSecurity</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasRowSecurity</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>hasSubLinks</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<return>return <expr><name>parsetree</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Modify the given query by adding 'AND rule_qual IS NOT TRUE' to its
 * qualification.  This is used to generate suitable "else clauses" for
 * conditional INSTEAD rules.  (Unfortunately we must use "x IS NOT TRUE",
 * not just "NOT x" which the planner is much smarter about, else we will
 * do the wrong thing when the qual evaluates to NULL.)
 *
 * The rule_qual may contain references to OLD or NEW.  OLD references are
 * replaced by references to the specified rt_index (the relation that the
 * rule applies to).  NEW references are only possible for INSERT and UPDATE
 * queries on the relation itself, and so they should be replaced by copies
 * of the related entries in the query's own targetlist.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>CopyAndAddInvertedQual</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
					   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rule_qual</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>rt_index</name></decl></parameter>,
					   <parameter><decl><type><name>CmdType</name></type> <name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Don't scribble on the passed qual (it's in the relcache!) */</comment>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>new_qual</name> <init>= <expr><call><name>copyObject</name><argument_list>(<argument><expr><name>rule_qual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>acquireLocksOnSubLinks_context</name></type> <name>context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>context</name><operator>.</operator><name>for_execute</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * In case there are subqueries in the qual, acquire necessary locks and
	 * fix any deleted JOIN RTE entries.  (This is somewhat redundant with
	 * rewriteRuleAction, but not entirely ... consider restructuring so that
	 * we only need to process the qual this way once.)
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>acquireLocksOnSubLinks</name><argument_list>(<argument><expr><name>new_qual</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fix references to OLD */</comment>
	<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><name>new_qual</name></expr></argument>, <argument><expr><name>PRS2_OLD_VARNO</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Fix references to NEW */</comment>
	<if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>CMD_INSERT</name> <operator>||</operator> <name>event</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>new_qual</name> <operator>=</operator> <call><name>ReplaceVarsFromTargetList</name><argument_list>(<argument><expr><name>new_qual</name></expr></argument>,
											 <argument><expr><name>PRS2_NEW_VARNO</name></expr></argument>,
											 <argument><expr><literal type="number">0</literal></expr></argument>,
											 <argument><expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>rt_index</name></expr></argument>,
													  <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
											 <argument><expr><ternary><condition><expr><operator>(</operator><name>event</name> <operator>==</operator> <name>CMD_UPDATE</name><operator>)</operator></expr> ?</condition><then>
											 <expr><name>REPLACEVARS_CHANGE_VARNO</name></expr> </then><else>:
											 <expr><name>REPLACEVARS_SUBSTITUTE_NULL</name></expr></else></ternary></expr></argument>,
											 <argument><expr><name>rt_index</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* And attach the fixed qual */</comment>
	<expr_stmt><expr><call><name>AddInvertedQual</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>new_qual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>parsetree</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	fireRules -
 *	   Iterate through rule locks applying rules.
 *
 * Input arguments:
 *	parsetree - original query
 *	rt_index - RT index of result relation in original query
 *	event - type of rule event
 *	locks - list of rules to fire
 * Output arguments:
 *	*instead_flag - set true if any unqualified INSTEAD rule is found
 *					(must be initialized to false)
 *	*returning_flag - set true if we rewrite RETURNING clause in any rule
 *					(must be initialized to false)
 *	*qual_product - filled with modified original query if any qualified
 *					INSTEAD rule is found (must be initialized to NULL)
 * Return value:
 *	list of rule actions adjusted for use with this query
 *
 * Qualified INSTEAD rules generate their action with the qualification
 * condition added.  They also generate a modified version of the original
 * query with the negated qualification added, so that it will run only for
 * rows that the qualified action doesn't act on.  (If there are multiple
 * qualified INSTEAD rules, we AND all the negated quals onto a single
 * modified original query.)  We won't execute the original, unmodified
 * query if we find either qualified or unqualified INSTEAD rules.  If
 * we find both, the modified original query is discarded too.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>fireRules</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>,
		  <parameter><decl><type><name>int</name></type> <name>rt_index</name></decl></parameter>,
		  <parameter><decl><type><name>CmdType</name></type> <name>event</name></decl></parameter>,
		  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>locks</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>instead_flag</name></decl></parameter>,
		  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>returning_flag</name></decl></parameter>,
		  <parameter><decl><type><name>Query</name> <modifier>*</modifier><modifier>*</modifier></type><name>qual_product</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>results</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>locks</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule_lock</name> <init>= <expr><operator>(</operator><name>RewriteRule</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>event_qual</name> <init>= <expr><name><name>rule_lock</name><operator>-&gt;</operator><name>qual</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>actions</name> <init>= <expr><name><name>rule_lock</name><operator>-&gt;</operator><name>actions</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QuerySource</name></type> <name>qsrc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>r</name></decl>;</decl_stmt>

		<comment type="block">/* Determine correct QuerySource value for actions */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rule_lock</name><operator>-&gt;</operator><name>isInstead</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>event_qual</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>qsrc</name> <operator>=</operator> <name>QSRC_QUAL_INSTEAD_RULE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>qsrc</name> <operator>=</operator> <name>QSRC_INSTEAD_RULE</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>instead_flag</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>	<comment type="block">/* report unqualified INSTEAD */</comment>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>qsrc</name> <operator>=</operator> <name>QSRC_NON_INSTEAD_RULE</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>qsrc</name> <operator>==</operator> <name>QSRC_QUAL_INSTEAD_RULE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If there are INSTEAD rules with qualifications, the original
			 * query is still performed. But all the negated rule
			 * qualifications of the INSTEAD rules are added so it does its
			 * actions only in cases where the rule quals of all INSTEAD rules
			 * are false. Think of it as the default action in a case. We save
			 * this in *qual_product so RewriteQuery() can add it to the query
			 * list after we mangled it up enough.
			 *
			 * If we have already found an unqualified INSTEAD rule, then
			 * *qual_product won't be used, so don't bother building it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>instead_flag</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>qual_product</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>qual_product</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>qual_product</name> <operator>=</operator> <call><name>CopyAndAddInvertedQual</name><argument_list>(<argument><expr><operator>*</operator><name>qual_product</name></expr></argument>,
													   <argument><expr><name>event_qual</name></expr></argument>,
													   <argument><expr><name>rt_index</name></expr></argument>,
													   <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Now process the rule's actions and add them to the result list */</comment>
		<macro><name>foreach</name><argument_list>(<argument>r</argument>, <argument>actions</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>rule_action</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>rule_action</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_NOTHING</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>rule_action</name> <operator>=</operator> <call><name>rewriteRuleAction</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>rule_action</name></expr></argument>,
											<argument><expr><name>event_qual</name></expr></argument>, <argument><expr><name>rt_index</name></expr></argument>, <argument><expr><name>event</name></expr></argument>,
											<argument><expr><name>returning_flag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>rule_action</name><operator>-&gt;</operator><name>querySource</name></name> <operator>=</operator> <name>qsrc</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rule_action</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* might change later */</comment>

			<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>rule_action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>results</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_view_query - get the Query from a view's _RETURN rule.
 *
 * Caller should have verified that the relation is a view, and therefore
 * we should find an ON SELECT action.
 *
 * Note that the pointer returned is into the relcache and therefore must
 * be treated as read-only to the caller and not modified or scribbled on.
 */</comment>
<function><type><name>Query</name> <modifier>*</modifier></type>
<name>get_view_query</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>view</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>view</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>view</name><operator>-&gt;</operator><name>rd_rules</name><operator>-&gt;</operator><name>numLocks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RewriteRule</name> <modifier>*</modifier></type><name>rule</name> <init>= <expr><name><name>view</name><operator>-&gt;</operator><name>rd_rules</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rule</name><operator>-&gt;</operator><name>event</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* A _RETURN rule should have only one action */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>rule</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid _RETURN rule action specification"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>rule</name><operator>-&gt;</operator><name>actions</name></name></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"failed to find _RETURN rule for view"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * view_has_instead_trigger - does view have an INSTEAD OF trigger for event?
 *
 * If it does, we don't want to treat it as auto-updatable.  This test can't
 * be folded into view_query_is_auto_updatable because it's not an error
 * condition.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>view_has_instead_trigger</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>view</name></decl></parameter>, <parameter><decl><type><name>CmdType</name></type> <name>event</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigDesc</name> <init>= <expr><name><name>view</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CMD_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>trigDesc</name> <operator>&amp;&amp;</operator> <name><name>trigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>trigDesc</name> <operator>&amp;&amp;</operator> <name><name>trigDesc</name><operator>-&gt;</operator><name>trig_update_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>CMD_DELETE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>trigDesc</name> <operator>&amp;&amp;</operator> <name><name>trigDesc</name><operator>-&gt;</operator><name>trig_delete_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized CmdType: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * view_col_is_auto_updatable - test whether the specified column of a view
 * is auto-updatable. Returns NULL (if the column can be updated) or a message
 * string giving the reason that it cannot be.
 *
 * The returned string has not been translated; if it is shown as an error
 * message, the caller should apply _() to translate it.
 *
 * Note that the checks performed here are local to this view. We do not check
 * whether the referenced column of the underlying base relation is updatable.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>view_col_is_auto_updatable</name><parameter_list>(<parameter><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl></parameter>, <parameter><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * For now, the only updatable columns we support are those that are Vars
	 * referring to user columns of the underlying base relation.
	 *
	 * The view targetlist may contain resjunk columns (e.g., a view defined
	 * like "SELECT * FROM t ORDER BY a+b" is auto-updatable) but such columns
	 * are not auto-updatable, and in fact should never appear in the outer
	 * query's targetlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Junk view columns are not updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<name><name>var</name><operator>-&gt;</operator><name>varno</name></name> <operator>!=</operator> <name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name> <operator>||</operator>
		<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"View columns that are not columns of their base relation are not updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"View columns that refer to system columns are not updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"View columns that return whole-row references are not updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* the view column is updatable */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * view_query_is_auto_updatable - test whether the specified view definition
 * represents an auto-updatable view. Returns NULL (if the view can be updated)
 * or a message string giving the reason that it cannot be.

 * The returned string has not been translated; if it is shown as an error
 * message, the caller should apply _() to translate it.
 *
 * If check_cols is true, the view is required to have at least one updatable
 * column (necessary for INSERT/UPDATE). Otherwise the view's columns are not
 * checked for updatability. See also view_cols_are_auto_updatable.
 *
 * Note that the checks performed here are only based on the view definition.
 * We do not check whether any base relations referred to by the view are
 * updatable.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>view_query_is_auto_updatable</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>viewquery</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>check_cols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>base_rte</name></decl>;</decl_stmt>

	<comment type="block">/*----------
	 * Check if the view is simply updatable.  According to SQL-92 this means:
	 *	- No DISTINCT clause.
	 *	- Each TLE is a column reference, and each column appears at most once.
	 *	- FROM contains exactly one base relation.
	 *	- No GROUP BY or HAVING clauses.
	 *	- No set operations (UNION, INTERSECT or EXCEPT).
	 *	- No sub-queries in the WHERE clause that reference the target table.
	 *
	 * We ignore that last restriction since it would be complex to enforce
	 * and there isn't any actual benefit to disallowing sub-queries.  (The
	 * semantic issues that the standard is presumably concerned about don't
	 * arise in Postgres, since any such sub-query will not see any updates
	 * executed by the outer query anyway, thanks to MVCC snapshotting.)
	 *
	 * We also relax the second restriction by supporting part of SQL:1999
	 * feature T111, which allows for a mix of updatable and non-updatable
	 * columns, provided that an INSERT or UPDATE doesn't attempt to assign to
	 * a non-updatable column.
	 *
	 * In addition we impose these constraints, involving features that are
	 * not part of SQL-92:
	 *	- No CTEs (WITH clauses).
	 *	- No OFFSET or LIMIT clauses (this matches a SQL:2008 restriction).
	 *	- No system columns (including whole-row references) in the tlist.
	 *	- No window functions in the tlist.
	 *	- No set-returning functions in the tlist.
	 *
	 * Note that we do these checks without recursively expanding the view.
	 * If the base relation is a view, we'll recursively deal with it later.
	 *----------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>distinctClause</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views containing DISTINCT are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>groupClause</name></name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name><name>viewquery</name><operator>-&gt;</operator><name>groupingSets</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views containing GROUP BY are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>havingQual</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views containing HAVING are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views containing UNION, INTERSECT, or EXCEPT are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>cteList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views containing WITH are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>limitOffset</name></name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name><name>viewquery</name><operator>-&gt;</operator><name>limitCount</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views containing LIMIT or OFFSET are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must not allow window functions or set returning functions in the
	 * targetlist. Otherwise we might end up inserting them into the quals of
	 * the main query. We must also check for aggregates in the targetlist in
	 * case they appear without a GROUP BY.
	 *
	 * These restrictions ensure that each row of the view corresponds to a
	 * unique row in the underlying base relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>hasAggs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views that return aggregate functions are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>hasWindowFuncs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views that return window functions are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>hasTargetSRFs</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views that return set-returning functions are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The view query should select from a single base relation, which must be
	 * a table or another view.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views that do not select from a single table or view are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rtr</name> <operator>=</operator> <operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rtr</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views that do not select from a single table or view are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>base_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>base_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>!=</operator> <name>RTE_RELATION</name> <operator>||</operator>
		<operator>(</operator><name><name>base_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
		 <name><name>base_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		 <name><name>base_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		 <name><name>base_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views that do not select from a single table or view are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>base_rte</name><operator>-&gt;</operator><name>tablesample</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views containing TABLESAMPLE are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check that the view has at least one updatable column. This is required
	 * for INSERT/UPDATE but not for DELETE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>check_cols</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>viewquery-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>view_col_is_auto_updatable</name><argument_list>(<argument><expr><name>rtr</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Views that have no updatable columns are not automatically updatable."</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* the view is updatable */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * view_cols_are_auto_updatable - test whether all of the required columns of
 * an auto-updatable view are actually updatable. Returns NULL (if all the
 * required columns can be updated) or a message string giving the reason that
 * they cannot be.
 *
 * The returned string has not been translated; if it is shown as an error
 * message, the caller should apply _() to translate it.
 *
 * This should be used for INSERT/UPDATE to ensure that we don't attempt to
 * assign to any non-updatable columns.
 *
 * Additionally it may be used to retrieve the set of updatable columns in the
 * view, or if one or more of the required columns is not updatable, the name
 * of the first offending non-updatable column.
 *
 * The caller must have already verified that this is an auto-updatable view
 * using view_query_is_auto_updatable.
 *
 * Note that the checks performed here are only based on the view definition.
 * We do not check whether the referenced columns of the base relation are
 * updatable.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>view_cols_are_auto_updatable</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>viewquery</name></decl></parameter>,
							 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>required_cols</name></decl></parameter>,
							 <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier><modifier>*</modifier></type><name>updatable_cols</name></decl></parameter>,
							 <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>non_updatable_col</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>col</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The caller should have verified that this view is auto-updatable and so
	 * there should be a single base relation.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>, <argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize the optional return values */</comment>
	<if_stmt><if>if <condition>(<expr><name>updatable_cols</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>updatable_cols</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>non_updatable_col</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>non_updatable_col</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Test each view column for updatability */</comment>
	<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>-</operator><name>FirstLowInvalidHeapAttributeNumber</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>viewquery-&gt;targetList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>col_update_detail</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>col</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>col_update_detail</name> <operator>=</operator> <call><name>view_col_is_auto_updatable</name><argument_list>(<argument><expr><name>rtr</name></expr></argument>, <argument><expr><name>tle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>col_update_detail</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The column is updatable */</comment>
			<if_stmt><if>if <condition>(<expr><name>updatable_cols</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>updatable_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><operator>*</operator><name>updatable_cols</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>col</name></expr></argument>, <argument><expr><name>required_cols</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The required column is not updatable */</comment>
			<if_stmt><if>if <condition>(<expr><name>non_updatable_col</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>non_updatable_col</name> <operator>=</operator> <name><name>tle</name><operator>-&gt;</operator><name>resname</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>col_update_detail</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* all the required view columns are updatable */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * relation_is_updatable - determine which update events the specified
 * relation supports.
 *
 * Note that views may contain a mix of updatable and non-updatable columns.
 * For a view to support INSERT/UPDATE it must have at least one updatable
 * column, but there is no such restriction for DELETE. If include_cols is
 * non-NULL, then only the specified columns are considered when testing for
 * updatability.
 *
 * This is used for the information_schema views, which have separate concepts
 * of "updatable" and "trigger updatable".  A relation is "updatable" if it
 * can be updated without the need for triggers (either because it has a
 * suitable RULE, or because it is simple enough to be automatically updated).
 * A relation is "trigger updatable" if it has a suitable INSTEAD OF trigger.
 * The SQL standard regards this as not necessarily updatable, presumably
 * because there is no way of knowing what the trigger will actually do.
 * The information_schema views therefore call this function with
 * include_triggers = false.  However, other callers might only care whether
 * data-modifying SQL will work, so they can pass include_triggers = true
 * to have trigger updatability included in the result.
 *
 * The return value is a bitmask of rule event numbers indicating which of
 * the INSERT, UPDATE and DELETE operations are supported.  (We do it this way
 * so that we can test for UPDATE plus DELETE support in a single call.)
 */</comment>
<function><type><name>int</name></type>
<name>relation_is_updatable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reloid</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>include_triggers</name></decl></parameter>,
					  <parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>include_cols</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>events</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RuleLock</name>   <modifier>*</modifier></type><name>rulelocks</name></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALL_EVENTS</name></cpp:macro> <cpp:value>((1 &lt;&lt; CMD_INSERT) | (1 &lt;&lt; CMD_UPDATE) | (1 &lt;&lt; CMD_DELETE))</cpp:value></cpp:define>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>try_relation_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the relation doesn't exist, return zero rather than throwing an
	 * error.  This is helpful since scanning an information_schema view under
	 * MVCC rules can result in referencing rels that have actually been
	 * deleted already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If the relation is a table, it is always updatable */</comment>
	<comment type="block">/* GPDB: except if it's an external table, which we checked above */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>ALL_EVENTS</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Look for unconditional DO INSTEAD rules, and note supported events */</comment>
	<expr_stmt><expr><name>rulelocks</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rules</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rulelocks</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>rulelocks</name><operator>-&gt;</operator><name>numLocks</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>rulelocks</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>isInstead</name> <operator>&amp;&amp;</operator>
				<name><name>rulelocks</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>qual</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>events</name> <operator>|=</operator> <operator>(</operator><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name><name>rulelocks</name><operator>-&gt;</operator><name>rules</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>event</name><operator>)</operator> <operator>&amp;</operator> <name>ALL_EVENTS</name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* If we have rules for all events, we're done */</comment>
		<if_stmt><if>if <condition>(<expr><name>events</name> <operator>==</operator> <name>ALL_EVENTS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>events</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Similarly look for INSTEAD OF triggers, if they are to be included */</comment>
	<if_stmt><if>if <condition>(<expr><name>include_triggers</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TriggerDesc</name> <modifier>*</modifier></type><name>trigDesc</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>trigdesc</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>trigDesc</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_insert_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>events</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_INSERT</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_update_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>events</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_UPDATE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>trigDesc</name><operator>-&gt;</operator><name>trig_delete_instead_row</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>events</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_DELETE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* If we have triggers for all events, we're done */</comment>
			<if_stmt><if>if <condition>(<expr><name>events</name> <operator>==</operator> <name>ALL_EVENTS</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>events</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If this is a foreign table, check which update events it supports */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FdwRoutine</name> <modifier>*</modifier></type><name>fdwroutine</name> <init>= <expr><call><name>GetFdwRoutineForRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>events</name> <operator>|=</operator> <call><name><name>fdwroutine</name><operator>-&gt;</operator><name>IsForeignRelUpdatable</name></name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Assume presence of executor functions is sufficient */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExecForeignInsert</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>events</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_INSERT</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExecForeignUpdate</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>events</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_UPDATE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>fdwroutine</name><operator>-&gt;</operator><name>ExecForeignDelete</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>events</name> <operator>|=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_DELETE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>events</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check if this is an automatically updatable view */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>viewquery</name> <init>= <expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>view_query_is_auto_updatable</name><argument_list>(<argument><expr><name>viewquery</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>updatable_cols</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>auto_events</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>base_rte</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>baseoid</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Determine which of the view's columns are updatable. If there
			 * are none within the set of columns we are looking at, then the
			 * view doesn't support INSERT/UPDATE, but it may still support
			 * DELETE.
			 */</comment>
			<expr_stmt><expr><call><name>view_cols_are_auto_updatable</name><argument_list>(<argument><expr><name>viewquery</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
										 <argument><expr><operator>&amp;</operator><name>updatable_cols</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>include_cols</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>updatable_cols</name> <operator>=</operator> <call><name>bms_int_members</name><argument_list>(<argument><expr><name>updatable_cols</name></expr></argument>, <argument><expr><name>include_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>updatable_cols</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>auto_events</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CMD_DELETE</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* May support DELETE */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>auto_events</name> <operator>=</operator> <name>ALL_EVENTS</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* May support all events */</comment>

			<comment type="block">/*
			 * The base relation must also support these update commands.
			 * Tables are always updatable, but for any other kind of base
			 * relation we must do a recursive check limited to the columns
			 * referenced by the locally updatable columns in this view.
			 */</comment>
			<expr_stmt><expr><name>rtr</name> <operator>=</operator> <operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>base_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>, <argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>base_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>base_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
				<name><name>base_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>baseoid</name> <operator>=</operator> <name><name>base_rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>include_cols</name> <operator>=</operator> <call><name>adjust_view_column_set</name><argument_list>(<argument><expr><name>updatable_cols</name></expr></argument>,
													  <argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>auto_events</name> <operator>&amp;=</operator> <call><name>relation_is_updatable</name><argument_list>(<argument><expr><name>baseoid</name></expr></argument>,
													 <argument><expr><name>include_triggers</name></expr></argument>,
													 <argument><expr><name>include_cols</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>events</name> <operator>|=</operator> <name>auto_events</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If we reach here, the relation may support some update commands */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>events</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * adjust_view_column_set - map a set of column numbers according to targetlist
 *
 * This is used with simply-updatable views to map column-permissions sets for
 * the view columns onto the matching columns in the underlying base relation.
 * The targetlist is expected to be a list of plain Vars of the underlying
 * relation (as per the checks above in view_query_is_auto_updatable).
 */</comment>
<function><type><specifier>static</specifier> <name>Bitmapset</name> <modifier>*</modifier></type>
<name>adjust_view_column_set</name><parameter_list>(<parameter><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>cols</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>targetlist</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>col</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>col</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>col</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>cols</name></expr></argument>, <argument><expr><name>col</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* bit numbers are offset by FirstLowInvalidHeapAttributeNumber */</comment>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name> <init>= <expr><name>col</name> <operator>+</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * There's a whole-row reference to the view.  For permissions
			 * purposes, treat it as a reference to each column available from
			 * the view.  (We should *not* convert this to a whole-row
			 * reference to the base relation, since the view may not touch
			 * all columns of the base relation.)
			 */</comment>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>targetlist</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>TargetEntry</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>var</name> <operator>=</operator> <call><name>castNode</name><argument_list>(<argument><expr><name>Var</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
										<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Views do not have system columns, so we do not expect to see
			 * any other system attnos here.  If we do find one, the error
			 * case will apply.
			 */</comment>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>targetlist</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>tle</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>tle</name><operator>-&gt;</operator><name>expr</name></name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
										<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute number %d not found in view targetlist"</literal></expr></argument>,
					 <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * rewriteTargetView -
 *	  Attempt to rewrite a query where the target relation is a view, so that
 *	  the view's base relation becomes the target relation.
 *
 * Note that the base relation here may itself be a view, which may or may not
 * have INSTEAD OF triggers or rules to handle the update.  That is handled by
 * the recursion in RewriteQuery.
 */</comment>
<function><type><specifier>static</specifier> <name>Query</name> <modifier>*</modifier></type>
<name>rewriteTargetView</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>view</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>viewquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>auto_update_detail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>base_rt_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_rt_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>base_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>view_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>new_rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>base_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>view_targetlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get the Query from the view's ON SELECT rule.  We're going to munge the
	 * Query to change the view's base relation into the target relation,
	 * along with various other changes along the way, so we need to make a
	 * copy of it (get_view_query() returns a pointer into the relcache, so we
	 * have to treat it as read-only).
	 */</comment>
	<expr_stmt><expr><name>viewquery</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><call><name>get_view_query</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The view must be updatable, else fail */</comment>
	<expr_stmt><expr><name>auto_update_detail</name> <operator>=</operator>
		<call><name>view_query_is_auto_updatable</name><argument_list>(<argument><expr><name>viewquery</name></expr></argument>,
									 <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>auto_update_detail</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* messages here should match execMain.c's CheckValidResultRel */</comment>
		<switch>switch <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CMD_INSERT</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert into view \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>auto_update_detail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable inserting into the view, provide an INSTEAD OF INSERT trigger or an unconditional ON INSERT DO INSTEAD rule."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update view \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>auto_update_detail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable updating the view, provide an INSTEAD OF UPDATE trigger or an unconditional ON UPDATE DO INSTEAD rule."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CMD_DELETE</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OBJECT_NOT_IN_PREREQUISITE_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot delete from view \"%s\""</literal></expr></argument>,
								<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>auto_update_detail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"To enable deleting from the view, provide an INSTEAD OF DELETE trigger or an unconditional ON DELETE DO INSTEAD rule."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized CmdType: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For INSERT/UPDATE the modified columns must all be updatable. Note that
	 * we get the modified columns from the query's targetlist, not from the
	 * result RTE's insertedCols and/or updatedCols set, since
	 * rewriteTargetListIU may have added additional targetlist entries for
	 * view defaults, and these must also be updatable.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>modified_cols</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>non_updatable_col</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>modified_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>modified_cols</name></expr></argument>,
											   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name></name></expr>)</condition>
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;onConflict-&gt;onConflictSet</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>modified_cols</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>modified_cols</name></expr></argument>,
												   <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>auto_update_detail</name> <operator>=</operator> <call><name>view_cols_are_auto_updatable</name><argument_list>(<argument><expr><name>viewquery</name></expr></argument>,
														  <argument><expr><name>modified_cols</name></expr></argument>,
														  <argument><expr><name>NULL</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>non_updatable_col</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>auto_update_detail</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This is a different error, caused by an attempt to update a
			 * non-updatable column in an otherwise updatable view.
			 */</comment>
			<switch>switch <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert into column \"%s\" of view \"%s\""</literal></expr></argument>,
									<argument><expr><name>non_updatable_col</name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>auto_update_detail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update column \"%s\" of view \"%s\""</literal></expr></argument>,
									<argument><expr><name>non_updatable_col</name></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>auto_update_detail</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized CmdType: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Locate RTE describing the view in the outer query */</comment>
	<expr_stmt><expr><name>view_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we get here, view_query_is_auto_updatable() has verified that the
	 * view contains a single base relation.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rtr</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>RangeTblRef</name></expr></argument>, <argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>base_rt_index</name> <operator>=</operator> <name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>base_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>base_rt_index</name></expr></argument>, <argument><expr><name><name>viewquery</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>base_rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Up to now, the base relation hasn't been touched at all in our query.
	 * We need to acquire lock on it before we try to do anything with it.
	 * (The subsequent recursive call of RewriteQuery will suppose that we
	 * already have the right lock!)  Since it will become the query target
	 * relation, RowExclusiveLock is always the right thing.
	 */</comment>
	<expr_stmt><expr><name>base_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>base_rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * While we have the relation open, update the RTE's relkind, just in case
	 * it changed since this view was made (cf. AcquireRewriteLocks).
	 */</comment>
	<expr_stmt><expr><name><name>base_rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>base_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the view query contains any sublink subqueries then we need to also
	 * acquire locks on any relations they refer to.  We know that there won't
	 * be any subqueries in the range table or CTEs, so we can skip those, as
	 * in AcquireRewriteLocks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>acquireLocksOnSubLinks_context</name></type> <name>context</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>.</operator><name>for_execute</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>query_tree_walker</name><argument_list>(<argument><expr><name>viewquery</name></expr></argument>, <argument><expr><name>acquireLocksOnSubLinks</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>context</name></expr></argument>,
						  <argument><expr><name>QTW_IGNORE_RC_SUBQUERIES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Create a new target RTE describing the base relation, and add it to the
	 * outer query's rangetable.  (What's happening in the next few steps is
	 * very much like what the planner would do to "pull up" the view into the
	 * outer query.  Perhaps someday we should refactor things enough so that
	 * we can share code with the planner.)
	 *
	 * Be sure to set rellockmode to the correct thing for the target table.
	 * Since we copied the whole viewquery above, we can just scribble on
	 * base_rte instead of copying it.
	 */</comment>
	<expr_stmt><expr><name>new_rte</name> <operator>=</operator> <name>base_rte</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_rte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>=</operator> <name>RowExclusiveLock</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>new_rte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_rt_index</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * INSERTs never inherit.  For UPDATE/DELETE, we use the view query's
	 * inheritance flag for the base relation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>new_rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Adjust the view's targetlist Vars to reference the new target RTE, ie
	 * make their varnos be new_rt_index instead of base_rt_index.  There can
	 * be no Vars for other rels in the tlist, so this is sufficient to pull
	 * up the tlist expressions for use in the outer query.  The tlist will
	 * provide the replacement expressions used by ReplaceVarsFromTargetList
	 * below.
	 */</comment>
	<expr_stmt><expr><name>view_targetlist</name> <operator>=</operator> <name><name>viewquery</name><operator>-&gt;</operator><name>targetList</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>view_targetlist</name></expr></argument>,
				   <argument><expr><name>base_rt_index</name></expr></argument>,
				   <argument><expr><name>new_rt_index</name></expr></argument>,
				   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark the new target RTE for the permissions checks that we want to
	 * enforce against the view owner, as distinct from the query caller.  At
	 * the relation level, require the same INSERT/UPDATE/DELETE permissions
	 * that the query caller needs against the view.  We drop the ACL_SELECT
	 * bit that is presumably in new_rte-&gt;requiredPerms initially.
	 *
	 * Note: the original view RTE remains in the query's rangetable list.
	 * Although it will be unused in the query plan, we need it there so that
	 * the executor still performs appropriate permissions checks for the
	 * query caller's use of the view.
	 */</comment>
	<expr_stmt><expr><name><name>new_rte</name><operator>-&gt;</operator><name>checkAsUser</name></name> <operator>=</operator> <name><name>view</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_rte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name><name>view_rte</name><operator>-&gt;</operator><name>requiredPerms</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now for the per-column permissions bits.
	 *
	 * Initially, new_rte contains selectedCols permission check bits for all
	 * base-rel columns referenced by the view, but since the view is a SELECT
	 * query its insertedCols/updatedCols is empty.  We set insertedCols and
	 * updatedCols to include all the columns the outer query is trying to
	 * modify, adjusting the column numbers as needed.  But we leave
	 * selectedCols as-is, so the view owner must have read permission for all
	 * columns used in the view definition, even if some of them are not read
	 * by the outer query.  We could try to limit selectedCols to only columns
	 * used in the transformed query, but that does not correspond to what
	 * happens in ordinary SELECT usage of a view: all referenced columns must
	 * have read permission, even if optimization finds that some of them can
	 * be discarded during query transformation.  The flattening we're doing
	 * here is an optional optimization, too.  (If you are unpersuaded and
	 * want to change this, note that applying adjust_view_column_set to
	 * view_rte-&gt;selectedCols is clearly *not* the right answer, since that
	 * neglects base-rel columns used in the view's WHERE quals.)
	 *
	 * This step needs the modified view targetlist, so we have to do things
	 * in this order.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>new_rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <call><name>bms_is_empty</name><argument_list>(<argument><expr><name><name>new_rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_rte</name><operator>-&gt;</operator><name>insertedCols</name></name> <operator>=</operator> <call><name>adjust_view_column_set</name><argument_list>(<argument><expr><name><name>view_rte</name><operator>-&gt;</operator><name>insertedCols</name></name></expr></argument>,
												   <argument><expr><name>view_targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_rte</name><operator>-&gt;</operator><name>updatedCols</name></name> <operator>=</operator> <call><name>adjust_view_column_set</name><argument_list>(<argument><expr><name><name>view_rte</name><operator>-&gt;</operator><name>updatedCols</name></name></expr></argument>,
												  <argument><expr><name>view_targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Move any security barrier quals from the view RTE onto the new target
	 * RTE.  Any such quals should now apply to the new target RTE and will
	 * not reference the original view RTE in the rewritten query.
	 */</comment>
	<expr_stmt><expr><name><name>new_rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name><name>view_rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>view_rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now update all Vars in the outer query that reference the view to
	 * reference the appropriate column of the base relation instead.
	 */</comment>
	<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator>
		<call><name>ReplaceVarsFromTargetList</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
								  <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><name>view_rte</name></expr></argument>,
								  <argument><expr><name>view_targetlist</name></expr></argument>,
								  <argument><expr><name>REPLACEVARS_REPORT_ERROR</name></expr></argument>,
								  <argument><expr><literal type="number">0</literal></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update all other RTI references in the query that point to the view
	 * (for example, parsetree-&gt;resultRelation itself) to point to the new
	 * base relation instead.  Vars will not be affected since none of them
	 * reference parsetree-&gt;resultRelation any longer.
	 */</comment>
	<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>parsetree</name></expr></argument>,
				   <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>,
				   <argument><expr><name>new_rt_index</name></expr></argument>,
				   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name> <operator>==</operator> <name>new_rt_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For INSERT/UPDATE we must also update resnos in the targetlist to refer
	 * to columns of the base relation, since those indicate the target
	 * columns to be affected.
	 *
	 * Note that this destroys the resno ordering of the targetlist, but that
	 * will be fixed when we recurse through rewriteQuery, which will invoke
	 * rewriteTargetListIU again on the updated targetlist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;targetList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>view_tle</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>view_tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>view_targetlist</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>view_tle</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>view_tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>view_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>view_tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute number %d not found in view targetlist"</literal></expr></argument>,
					 <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For INSERT .. ON CONFLICT .. DO UPDATE, we must also update assorted
	 * stuff in the onConflict data structure.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>&amp;&amp;</operator>
		<name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Index</name></type>		<name>old_exclRelIndex</name></decl>,
					<decl><type ref="prev"/><name>new_exclRelIndex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>new_exclRte</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>tmp_tlist</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Like the INSERT/UPDATE code above, update the resnos in the
		 * auxiliary UPDATE targetlist to refer to columns of the base
		 * relation.
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parsetree-&gt;onConflict-&gt;onConflictSet</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>tle</name> <init>= <expr><operator>(</operator><name>TargetEntry</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>view_tle</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tle</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>view_tle</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name>view_targetlist</name></expr></argument>, <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>view_tle</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>view_tle</name><operator>-&gt;</operator><name>resjunk</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>view_tle</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>view_tle</name><operator>-&gt;</operator><name>expr</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"attribute number %d not found in view targetlist"</literal></expr></argument>,
					 <argument><expr><name><name>tle</name><operator>-&gt;</operator><name>resno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Also, create a new RTE for the EXCLUDED pseudo-relation, using the
		 * query's new base rel (which may well have a different column list
		 * from the view, hence we need a new column alias list).  This should
		 * match transformOnConflictClause.  In particular, note that the
		 * relkind is set to composite to signal that we're not dealing with
		 * an actual relation, and no permissions checks are wanted.
		 */</comment>
		<expr_stmt><expr><name>old_exclRelIndex</name> <operator>=</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>exclRelIndex</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>new_exclRte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><name>base_rel</name></expr></argument>,
													<argument><expr><name>RowExclusiveLock</name></expr></argument>,
													<argument><expr><call><name>makeAlias</name><argument_list>(<argument><expr><literal type="string">"excluded"</literal></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_exclRte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_exclRte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* other permissions fields in new_exclRte are already empty */</comment>

		<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>, <argument><expr><name>new_exclRte</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_exclRelIndex</name> <operator>=</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>exclRelIndex</name></name> <operator>=</operator>
			<call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Replace the targetlist for the EXCLUDED pseudo-relation with a new
		 * one, representing the columns from the new base relation.
		 */</comment>
		<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>exclRelTlist</name></name> <operator>=</operator>
			<call><name>BuildOnConflictExcludedTargetlist</name><argument_list>(<argument><expr><name>base_rel</name></expr></argument>, <argument><expr><name>new_exclRelIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Update all Vars in the ON CONFLICT clause that refer to the old
		 * EXCLUDED pseudo-relation.  We want to use the column mappings
		 * defined in the view targetlist, but we need the outputs to refer to
		 * the new EXCLUDED pseudo-relation rather than the new target RTE.
		 * Also notice that "EXCLUDED.*" will be expanded using the view's
		 * rowtype, which seems correct.
		 */</comment>
		<expr_stmt><expr><name>tmp_tlist</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>view_targetlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>tmp_tlist</name></expr></argument>, <argument><expr><name>new_rt_index</name></expr></argument>,
					   <argument><expr><name>new_exclRelIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>=</operator> <operator>(</operator><name>OnConflictExpr</name> <operator>*</operator><operator>)</operator>
			<call><name>ReplaceVarsFromTargetList</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name></name></expr></argument>,
									  <argument><expr><name>old_exclRelIndex</name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>,
									  <argument><expr><name>view_rte</name></expr></argument>,
									  <argument><expr><name>tmp_tlist</name></expr></argument>,
									  <argument><expr><name>REPLACEVARS_REPORT_ERROR</name></expr></argument>,
									  <argument><expr><literal type="number">0</literal></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For UPDATE/DELETE, pull up any WHERE quals from the view.  We know that
	 * any Vars in the quals must reference the one base relation, so we need
	 * only adjust their varnos to reference the new target (just the same as
	 * we did with the view targetlist).
	 *
	 * If it's a security-barrier view, its WHERE quals must be applied before
	 * quals from the outer query, so we attach them to the RTE as security
	 * barrier quals rather than adding them to the main WHERE clause.
	 *
	 * For INSERT, the view's quals can be ignored in the main query.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_INSERT</name> <operator>&amp;&amp;</operator>
		<name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>viewqual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Even though we copied viewquery already at the top of this
		 * function, we must duplicate the viewqual again here, because we may
		 * need to use the quals again below for a WithCheckOption clause.
		 */</comment>
		<expr_stmt><expr><name>viewqual</name> <operator>=</operator> <call><name>copyObject</name><argument_list>(<argument><expr><name>viewqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><name>viewqual</name></expr></argument>, <argument><expr><name>base_rt_index</name></expr></argument>, <argument><expr><name>new_rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>RelationIsSecurityView</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The view's quals go in front of existing barrier quals: those
			 * would have come from an outer level of security-barrier view,
			 * and so must get evaluated later.
			 *
			 * Note: the parsetree has been mutated, so the new_rte pointer is
			 * stale and needs to be re-computed.
			 */</comment>
			<expr_stmt><expr><name>new_rte</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>new_rt_index</name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>viewqual</name></expr></argument>, <argument><expr><name><name>new_rte</name><operator>-&gt;</operator><name>securityQuals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Do not set parsetree-&gt;hasRowSecurity, because these aren't RLS
			 * conditions (they aren't affected by enabling/disabling RLS).
			 */</comment>

			<comment type="block">/*
			 * Make sure that the query is marked correctly if the added qual
			 * has sublinks.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><name>viewqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>AddQual</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>viewqual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For INSERT/UPDATE, if the view has the WITH CHECK OPTION, or any parent
	 * view specified WITH CASCADED CHECK OPTION, add the quals from the view
	 * to the query's withCheckOptions list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_DELETE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>has_wco</name> <init>= <expr><call><name>RelationHasCheckOption</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>cascaded</name> <init>= <expr><call><name>RelationHasCascadedCheckOption</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the parent view has a cascaded check option, treat this view as
		 * if it also had a cascaded check option.
		 *
		 * New WithCheckOptions are added to the start of the list, so if
		 * there is a cascaded check option, it will be the first item in the
		 * list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>withCheckOptions</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>parent_wco</name> <init>=
			<expr><operator>(</operator><name>WithCheckOption</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>parent_wco</name><operator>-&gt;</operator><name>cascaded</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>has_wco</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>cascaded</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Add the new WithCheckOption to the start of the list, so that
		 * checks on inner views are run before checks on outer views, as
		 * required by the SQL standard.
		 *
		 * If the new check is CASCADED, we need to add it even if this view
		 * has no quals, since there may be quals on child views.  A LOCAL
		 * check can be omitted if this view has no quals.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_wco</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>cascaded</name> <operator>||</operator> <name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WithCheckOption</name> <modifier>*</modifier></type><name>wco</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>wco</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>WithCheckOption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>wco</name><operator>-&gt;</operator><name>kind</name></name> <operator>=</operator> <name>WCO_VIEW_CHECK</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>wco</name><operator>-&gt;</operator><name>relname</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>view</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>wco</name><operator>-&gt;</operator><name>polname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>wco</name><operator>-&gt;</operator><name>cascaded</name></name> <operator>=</operator> <name>cascaded</name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>withCheckOptions</name></name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>wco</name></expr></argument>,
												<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>withCheckOptions</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>viewquery</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>quals</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ChangeVarNodes</name><argument_list>(<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>, <argument><expr><name>base_rt_index</name></expr></argument>, <argument><expr><name>new_rt_index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Make sure that the query is marked correctly if the added
				 * qual has sublinks.  We can skip this check if the query is
				 * already marked, or if the command is an UPDATE, in which
				 * case the same qual will have already been added, and this
				 * check will already have been done.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>&amp;&amp;</operator>
					<name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UPDATE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>hasSubLinks</name></name> <operator>=</operator> <call><name>checkExprHasSubLink</name><argument_list>(<argument><expr><name><name>wco</name><operator>-&gt;</operator><name>qual</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>base_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>parsetree</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RewriteQuery -
 *	  rewrites the query and apply the rules again on the queries rewritten
 *
 * rewrite_events is a list of open query-rewrite actions, so we can detect
 * infinite recursion.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>RewriteQuery</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>rewrite_events</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>event</name> <init>= <expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>instead</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>returning</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>updatableview</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>qual_product</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rewritten</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc1</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First, recursively process any insert/update/delete statements in WITH
	 * clauses.  (We have to do this first because the WITH clauses may get
	 * copied into rule actions below.)
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>parsetree-&gt;cteList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommonTableExpr</name> <modifier>*</modifier></type><name>cte</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>CommonTableExpr</name></expr></argument>, <argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>ctequery</name> <init>= <expr><call><name>castNode</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newstuff</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ctequery</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>newstuff</name> <operator>=</operator> <call><name>RewriteQuery</name><argument_list>(<argument><expr><name>ctequery</name></expr></argument>, <argument><expr><name>rewrite_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Currently we can only handle unconditional, single-statement DO
		 * INSTEAD rules correctly; we have to get exactly one Query out of
		 * the rewrite operation to stuff back into the CTE node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>newstuff</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Push the single Query back into the CTE node */</comment>
			<expr_stmt><expr><name>ctequery</name> <operator>=</operator> <call><name>linitial_node</name><argument_list>(<argument><expr><name>Query</name></expr></argument>, <argument><expr><name>newstuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* WITH queries should never be canSetTag */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>ctequery</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>cte</name><operator>-&gt;</operator><name>ctequery</name></name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>ctequery</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>newstuff</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DO INSTEAD NOTHING rules are not supported for data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

			<comment type="block">/* examine queries to determine which error message to issue */</comment>
			<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>newstuff</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_QUAL_INSTEAD_RULE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conditional DO INSTEAD rules are not supported for data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_NON_INSTEAD_RULE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"DO ALSO rules are not supported for data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multi-statement DO INSTEAD rules are not supported for data-modifying statements in WITH"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * If the statement is an insert, update, or delete, adjust its targetlist
	 * as needed, and then fire INSERT/UPDATE/DELETE rules on it.
	 *
	 * SELECT rules are handled later when we have all the queries that should
	 * get executed.  Also, utilities aren't rewritten at all (do we still
	 * need that check?)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>event</name> <operator>!=</operator> <name>CMD_SELECT</name> <operator>&amp;&amp;</operator> <name>event</name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>result_relation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rt_entry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rt_entry_relation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>locks</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>product_queries</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>hasUpdate</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>values_rte_index</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>defaults_remaining</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result_relation</name> <operator>=</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result_relation</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rt_entry</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name>result_relation</name></expr></argument>, <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rt_entry</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can use NoLock here since either the parser or
		 * AcquireRewriteLocks should have locked the rel already.
		 */</comment>
		<expr_stmt><expr><name>rt_entry_relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rt_entry</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Rewrite the targetlist as needed for the command type.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>event</name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>values_rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If it's an INSERT ... VALUES (...), (...), ... there will be a
			 * single RTE for the VALUES targetlists.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RangeTblRef</name> <modifier>*</modifier></type><name>rtr</name> <init>= <expr><operator>(</operator><name>RangeTblRef</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>jointree</name><operator>-&gt;</operator><name>fromlist</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rtr</name></expr></argument>, <argument><expr><name>RangeTblRef</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr></argument>,
												  <argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>values_rte</name> <operator>=</operator> <name>rte</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>values_rte_index</name> <operator>=</operator> <name><name>rtr</name><operator>-&gt;</operator><name>rtindex</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>values_rte</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Process the main targetlist ... */</comment>
				<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator> <call><name>rewriteTargetListIU</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
															<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>,
															<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>override</name></name></expr></argument>,
															<argument><expr><name>rt_entry_relation</name></expr></argument>,
															<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* ... and the VALUES expression lists */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>rewriteValuesRTE</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>values_rte</name></expr></argument>, <argument><expr><name>values_rte_index</name></expr></argument>,
									  <argument><expr><name>rt_entry_relation</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>defaults_remaining</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Process just the main targetlist */</comment>
				<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator>
					<call><name>rewriteTargetListIU</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
										<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>,
										<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>override</name></name></expr></argument>,
										<argument><expr><name>rt_entry_relation</name></expr></argument>,
										<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>&amp;&amp;</operator>
				<name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>action</name></name> <operator>==</operator> <name>ONCONFLICT_UPDATE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name> <operator>=</operator>
					<call><name>rewriteTargetListIU</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name><operator>-&gt;</operator><name>onConflictSet</name></name></expr></argument>,
										<argument><expr><name>CMD_UPDATE</name></expr></argument>,
										<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>override</name></name></expr></argument>,
										<argument><expr><name>rt_entry_relation</name></expr></argument>,
										<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>event</name> <operator>==</operator> <name>CMD_UPDATE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name> <operator>=</operator>
				<call><name>rewriteTargetListIU</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>,
									<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr></argument>,
									<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>override</name></name></expr></argument>,
									<argument><expr><name>rt_entry_relation</name></expr></argument>,
									<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>resultRelation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>event</name> <operator>==</operator> <name>CMD_DELETE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Nothing to do here */</comment>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Collect and apply the appropriate rules.
		 */</comment>
		<expr_stmt><expr><name>locks</name> <operator>=</operator> <call><name>matchLocks</name><argument_list>(<argument><expr><name>event</name></expr></argument>, <argument><expr><name><name>rt_entry_relation</name><operator>-&gt;</operator><name>rd_rules</name></name></expr></argument>,
						   <argument><expr><name>result_relation</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hasUpdate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>product_queries</name> <operator>=</operator> <call><name>fireRules</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>,
									<argument><expr><name>result_relation</name></expr></argument>,
									<argument><expr><name>event</name></expr></argument>,
									<argument><expr><name>locks</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>instead</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>returning</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>qual_product</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have a VALUES RTE with any remaining untouched DEFAULT items,
		 * and we got any product queries, finalize the VALUES RTE for each
		 * product query (replacing the remaining DEFAULT items with NULLs).
		 * We don't do this for the original query, because we know that it
		 * must be an auto-insert on a view, and so should use the base
		 * relation's defaults for any remaining DEFAULT items.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>defaults_remaining</name> <operator>&amp;&amp;</operator> <name>product_queries</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Each product query has its own copy of the VALUES RTE at the
			 * same index in the rangetable, so we must finalize each one.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>n</argument>, <argument>product_queries</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>values_rte</name> <init>= <expr><call><name>rt_fetch</name><argument_list>(<argument><expr><name>values_rte_index</name></expr></argument>,
													 <argument><expr><name><name>pt</name><operator>-&gt;</operator><name>rtable</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>rewriteValuesRTE</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>values_rte</name></expr></argument>, <argument><expr><name>values_rte_index</name></expr></argument>,
								 <argument><expr><name>rt_entry_relation</name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* Force remaining defaults to NULL */</comment>
			</block_content>}</block>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there were no INSTEAD rules, and the target relation is a view
		 * without any INSTEAD OF triggers, see if the view can be
		 * automatically updated.  If so, we perform the necessary query
		 * transformation here and add the resulting query to the
		 * product_queries list, so that it gets recursively rewritten if
		 * necessary.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instead</name> <operator>&amp;&amp;</operator> <name>qual_product</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>rt_entry_relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>view_has_instead_trigger</name><argument_list>(<argument><expr><name>rt_entry_relation</name></expr></argument>, <argument><expr><name>event</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * This throws an error if the view can't be automatically
			 * updated, but that's OK since the query would fail at runtime
			 * anyway.
			 */</comment>
			<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <call><name>rewriteTargetView</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>rt_entry_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * At this point product_queries contains any DO ALSO rule
			 * actions. Add the rewritten query before or after those.  This
			 * must match the handling the original query would have gotten
			 * below, if we allowed it to be included again.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>product_queries</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>product_queries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>product_queries</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>product_queries</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Set the "instead" flag, as if there had been an unqualified
			 * INSTEAD, to prevent the original query from being included a
			 * second time below.  The transformation will have rewritten any
			 * RETURNING list, so we can also set "returning" to forestall
			 * throwing an error below.
			 */</comment>
			<expr_stmt><expr><name>instead</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>returning</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>updatableview</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we got any product queries, recursively rewrite them --- but
		 * first check for recursion!
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>product_queries</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>rewrite_event</name> <modifier>*</modifier></type><name>rev</name></decl>;</decl_stmt>

			<macro><name>foreach</name><argument_list>(<argument>n</argument>, <argument>rewrite_events</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>rev</name> <operator>=</operator> <operator>(</operator><name>rewrite_event</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>rev</name><operator>-&gt;</operator><name>relation</name></name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rt_entry_relation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<name><name>rev</name><operator>-&gt;</operator><name>event</name></name> <operator>==</operator> <name>event</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"infinite recursion detected in rules for relation \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rt_entry_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name>rev</name> <operator>=</operator> <operator>(</operator><name>rewrite_event</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>rewrite_event</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rev</name><operator>-&gt;</operator><name>relation</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rt_entry_relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>rev</name><operator>-&gt;</operator><name>event</name></name> <operator>=</operator> <name>event</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>rewrite_events</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>rev</name></expr></argument>, <argument><expr><name>rewrite_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<macro><name>foreach</name><argument_list>(<argument>n</argument>, <argument>product_queries</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>pt</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>n</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newstuff</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>newstuff</name> <operator>=</operator> <call><name>RewriteQuery</name><argument_list>(<argument><expr><name>pt</name></expr></argument>, <argument><expr><name>rewrite_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>, <argument><expr><name>newstuff</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>

			<expr_stmt><expr><name>rewrite_events</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>rewrite_events</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If there is an INSTEAD, and the original query has a RETURNING, we
		 * have to have found a RETURNING in the rule(s), else fail. (Because
		 * DefineQueryRewrite only allows RETURNING in unconditional INSTEAD
		 * rules, there's no need to worry whether the substituted RETURNING
		 * will actually be executed --- it must be.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>instead</name> <operator>||</operator> <name>qual_product</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<name><name>parsetree</name><operator>-&gt;</operator><name>returningList</name></name> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>returning</name></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name>event</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>CMD_INSERT</name></expr>:</case>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform INSERT RETURNING on relation \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rt_entry_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You need an unconditional ON INSERT DO INSTEAD rule with a RETURNING clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_UPDATE</name></expr>:</case>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform UPDATE RETURNING on relation \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rt_entry_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You need an unconditional ON UPDATE DO INSTEAD rule with a RETURNING clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>CMD_DELETE</name></expr>:</case>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot perform DELETE RETURNING on relation \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rt_entry_relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You need an unconditional ON DELETE DO INSTEAD rule with a RETURNING clause."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized commandType: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>event</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Updatable views are supported by ON CONFLICT, so don't prevent that
		 * case from proceeding
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>onConflict</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>product_queries</name> <operator>!=</operator> <name>NIL</name> <operator>||</operator> <name>hasUpdate</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><name>updatableview</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"INSERT with ON CONFLICT clause cannot be used with table that has INSERT or UPDATE rules"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rt_entry_relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * For INSERTs, the original query is done first; for UPDATE/DELETE, it is
	 * done last.  This is needed because update and delete rule actions might
	 * not do anything if they are invoked after the update or delete is
	 * performed. The command counter increment between the query executions
	 * makes the deleted (and maybe the updated) tuples disappear so the scans
	 * for them in the rule actions cannot find them.
	 *
	 * If we found any unqualified INSTEAD, the original query is not done at
	 * all, in any form.  Otherwise, we add the modified form if qualified
	 * INSTEADs were found, else the unmodified form.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>instead</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>CMD_INSERT</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>qual_product</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>qual_product</name></expr></argument>, <argument><expr><name>rewritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>rewritten</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>qual_product</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>, <argument><expr><name>qual_product</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>rewritten</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>rewritten</name></expr></argument>, <argument><expr><name>parsetree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the original query has a CTE list, and we generated more than one
	 * non-utility result query, we have to fail because we'll have copied the
	 * CTE list into each result query.  That would break the expectation of
	 * single evaluation of CTEs.  This could possibly be fixed by
	 * restructuring so that a CTE list can be shared across multiple Query
	 * and PlannableStatement nodes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>parsetree</name><operator>-&gt;</operator><name>cteList</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>qcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc1</argument>, <argument>rewritten</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>q</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>q</name><operator>-&gt;</operator><name>commandType</name></name> <operator>!=</operator> <name>CMD_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>qcount</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>qcount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"WITH cannot be used in a query that is rewritten by rules into multiple queries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rewritten</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * QueryRewrite -
 *	  Primary entry point to the query rewriter.
 *	  Rewrite one query via query rewrite system, possibly returning 0
 *	  or many queries.
 *
 * NOTE: the parsetree must either have come straight from the parser,
 * or have been scanned by AcquireRewriteLocks to acquire suitable locks.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>QueryRewrite</name><parameter_list>(<parameter><decl><type><name>Query</name> <modifier>*</modifier></type><name>parsetree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>input_query_id</name> <init>= <expr><name><name>parsetree</name><operator>-&gt;</operator><name>queryId</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>querylist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>results</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CmdType</name></type>		<name>origCmdType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>foundOriginalQuery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>lastInstead</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This function is only applied to top-level original queries
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_ORIGINAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parsetree</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Step 1
	 *
	 * Apply all non-SELECT rules possibly getting 0 or many queries
	 */</comment>
	<expr_stmt><expr><name>querylist</name> <operator>=</operator> <call><name>RewriteQuery</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Step 2
	 *
	 * Apply all the RIR rules on each query
	 *
	 * This is also a handy place to mark each query with the original queryId
	 */</comment>
	<expr_stmt><expr><name>results</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>querylist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>fireRIRrules</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>query</name><operator>-&gt;</operator><name>queryId</name></name> <operator>=</operator> <name>input_query_id</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>results</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>results</name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Step 3
	 *
	 * Determine which, if any, of the resulting queries is supposed to set
	 * the command-result tag; and update the canSetTag fields accordingly.
	 *
	 * If the original query is still in the list, it sets the command tag.
	 * Otherwise, the last INSTEAD query of the same kind as the original is
	 * allowed to set the tag.  (Note these rules can leave us with no query
	 * setting the tag.  The tcop code has to cope with this by setting up a
	 * default tag based on the original un-rewritten query.)
	 *
	 * The Asserts verify that at most one query in the result list is marked
	 * canSetTag.  If we aren't checking asserts, we can fall out of the loop
	 * as soon as we find the original query.
	 */</comment>
	<expr_stmt><expr><name>origCmdType</name> <operator>=</operator> <name><name>parsetree</name><operator>-&gt;</operator><name>commandType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>foundOriginalQuery</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>lastInstead</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>results</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>query</name> <init>= <expr><operator>(</operator><name>Query</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_ORIGINAL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>foundOriginalQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>foundOriginalQuery</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifndef>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>query</name><operator>-&gt;</operator><name>canSetTag</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>commandType</name></name> <operator>==</operator> <name>origCmdType</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name><name>query</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_INSTEAD_RULE</name> <operator>||</operator>
				 <name><name>query</name><operator>-&gt;</operator><name>querySource</name></name> <operator>==</operator> <name>QSRC_QUAL_INSTEAD_RULE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>lastInstead</name> <operator>=</operator> <name>query</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>foundOriginalQuery</name> <operator>&amp;&amp;</operator> <name>lastInstead</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lastInstead</name><operator>-&gt;</operator><name>canSetTag</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>results</name></expr>;</return>
</block_content>}</block></function>
</unit>
