<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/catalog/catalog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * catalog.c
 *		routines concerned with catalog naming conventions and other
 *		bits of hard-wired knowledge
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/catalog/catalog.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_auth_members.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_auth_time_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_pltemplate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_db_role_setting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_replication_origin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shdepend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shdescription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shseclabel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/toasting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_configuration_history.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_id.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_version_at_initdb.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject_metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resourcetype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resqueuecapability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resgroupcapability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_rewrite.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_stat_last_operation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_stat_last_shoperation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsAoSegmentClass</name><parameter_list>(<parameter><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Like relpath(), but gets the directory containing the data file
 * and the filename separately.
 */</comment>
<function><type><name>void</name></type>
<name>reldir_and_filename</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>BackendId</name></type> <name>backend</name></decl></parameter>, <parameter><decl><type><name>ForkNumber</name></type> <name>forknum</name></decl></parameter>,
					<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>dir</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>backend</name></expr></argument>, <argument><expr><name>forknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The base path is like "&lt;path&gt;/&lt;rnode&gt;". Split it into
	 * path and filename parts.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>path</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected path: \"%s\""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>dir</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>filename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>path</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Like relpathbackend(), but more convenient when dealing with
 * AO relations. The filename pattern is the same as for heap
 * tables, but this variant takes also 'segno' as argument.
 *
 * XXX This is very similar to _mdfd_segpath(), let's use that one
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>aorelpathbackend</name><parameter_list>(<parameter><decl><type><name>RelFileNode</name></type> <name>node</name></decl></parameter>, <parameter><decl><type><name>BackendId</name></type> <name>backend</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>segno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fullpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>path</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>relpathbackend</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>backend</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>segno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <name>path</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* be sure we have enough space for the '.segno' */</comment>
		<expr_stmt><expr><name>fullpath</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">12</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fullpath</name></expr></argument>, <argument><expr><literal type="string">"%s.%u"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>segno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>fullpath</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsSystemRelation
 *		True iff the relation is either a system catalog or a toast table.
 *		See IsCatalogRelation for the exact definition of a system catalog.
 *
 *		We treat toast tables of user relations as "system relations" for
 *		protection purposes, e.g. you can't change their schemas without
 *		special permissions.  Therefore, most uses of this function are
 *		checking whether allow_system_table_mods restrictions apply.
 *		For other purposes, consider whether you shouldn't be using
 *		IsCatalogRelation instead.
 *
 *		This function does not perform any catalog accesses.
 *		Some callers rely on that!
 */</comment>
<function><type><name>bool</name></type>
<name>IsSystemRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsSystemClass</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsSystemClass
 *		Like the above, but takes a Form_pg_class as argument.
 *		Used when we do not want to open the relation and have to
 *		search pg_class directly.
 */</comment>
<function><type><name>bool</name></type>
<name>IsSystemClass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* IsCatalogRelationOid is a bit faster, so test that first */</comment>
	<return>return <expr><operator>(</operator><call><name>IsCatalogRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IsToastClass</name><argument_list>(<argument><expr><name>reltuple</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>IsAoSegmentClass</name><argument_list>(<argument><expr><name>reltuple</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsCatalogRelation
 *		True iff the relation is a system catalog.
 *
 *		By a system catalog, we mean one that is created during the bootstrap
 *		phase of initdb.  That includes not just the catalogs per se, but
 *		also their indexes, and TOAST tables and indexes if any.
 *
 *		This function does not perform any catalog accesses.
 *		Some callers rely on that!
 */</comment>
<function><type><name>bool</name></type>
<name>IsCatalogRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsCatalogRelationOid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsCatalogRelationOid
 *		True iff the relation identified by this OID is a system catalog.
 *
 *		By a system catalog, we mean one that is created during the bootstrap
 *		phase of initdb.  That includes not just the catalogs per se, but
 *		also their indexes, and TOAST tables and indexes if any.
 *
 *		This function does not perform any catalog accesses.
 *		Some callers rely on that!
 */</comment>
<function><type><name>bool</name></type>
<name>IsCatalogRelationOid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We consider a relation to be a system catalog if it has an OID that was
	 * manually assigned or assigned by genbki.pl.  This includes all the
	 * defined catalogs, their indexes, and their TOAST tables and indexes.
	 *
	 * This rule excludes the relations in information_schema, which are not
	 * integral to the system and can be treated the same as user relations.
	 * (Since it's valid to drop and recreate information_schema, any rule
	 * that did not act this way would be wrong.)
	 *
	 * This test is reliable since an OID wraparound will skip this range of
	 * OIDs; see GetNewObjectId().
	 */</comment>
	<return>return <expr><operator>(</operator><name>relid</name> <operator>&lt;</operator> <operator>(</operator><name>Oid</name><operator>)</operator> <name>FirstBootstrapObjectId</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsToastRelation
 *		True iff relation is a TOAST support relation (or index).
 *
 *		Does not perform any catalog accesses.
 */</comment>
<function><type><name>bool</name></type>
<name>IsToastRelation</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * What we actually check is whether the relation belongs to a pg_toast
	 * namespace.  This should be equivalent because of restrictions that are
	 * enforced elsewhere against creating user relations in, or moving
	 * relations into/out of, a pg_toast namespace.  Notice also that this
	 * will not say "true" for toast tables belonging to other sessions' temp
	 * tables; we expect that other mechanisms will prevent access to those.
	 */</comment>
	<return>return <expr><call><name>IsToastNamespace</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsToastClass
 *		Like the above, but takes a Form_pg_class as argument.
 *		Used when we do not want to open the relation and have to
 *		search pg_class directly.
 */</comment>
<function><type><name>bool</name></type>
<name>IsToastClass</name><parameter_list>(<parameter><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relnamespace</name> <init>= <expr><name><name>reltuple</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>IsToastNamespace</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsAoSegmentClass
 *		Like the above, but takes a Form_pg_class as argument.
 *		Used when we do not want to open the relation and have to
 *		search pg_class directly.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsAoSegmentClass</name><parameter_list>(<parameter><decl><type><name>Form_pg_class</name></type> <name>reltuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relnamespace</name> <init>= <expr><name><name>reltuple</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>IsAoSegmentNamespace</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsCatalogNamespace
 *		True iff namespace is pg_catalog.
 *
 *		Does not perform any catalog accesses.
 *
 * NOTE: the reason this isn't a macro is to avoid having to include
 * catalog/pg_namespace.h in a lot of places.
 */</comment>
<function><type><name>bool</name></type>
<name>IsCatalogNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>namespaceId</name> <operator>==</operator> <name>PG_CATALOG_NAMESPACE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsToastNamespace
 *		True iff namespace is pg_toast or my temporary-toast-table namespace.
 *
 *		Does not perform any catalog accesses.
 *
 * Note: this will return false for temporary-toast-table namespaces belonging
 * to other backends.  Those are treated the same as other backends' regular
 * temp table namespaces, and access is prevented where appropriate.
 * If you need to check for those, you may be able to use isAnyTempNamespace,
 * but beware that that does involve a catalog access.
 */</comment>
<function><type><name>bool</name></type>
<name>IsToastNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>namespaceId</name> <operator>==</operator> <name>PG_TOAST_NAMESPACE</name><operator>)</operator> <operator>||</operator>
		<call><name>isTempToastNamespace</name><argument_list>(<argument><expr><name>namespaceId</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsAoSegmentNamespace
 *		True iff namespace is pg_aoseg.
 *
 * NOTE: the reason this isn't a macro is to avoid having to include
 * catalog/pg_namespace.h in a lot of places.
 */</comment>
<function><type><name>bool</name></type>
<name>IsAoSegmentNamespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>namespaceId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>namespaceId</name> <operator>==</operator> <name>PG_AOSEGMENT_NAMESPACE</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsReservedName
 *		True iff name starts with the pg_ prefix.
 *
 *		For some classes of objects, the prefix pg_ is reserved for
 *		system objects only.  As of 8.0, this was only true for
 *		schema and tablespace names.  With 9.6, this is also true
 *		for roles.
 *
 *      As of Greenplum 4.0 we also reserve the prefix gp_
 */</comment>
<function><type><name>bool</name></type>
<name>IsReservedName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* ugly coding for speed */</comment>
	<return>return <expr><operator>(</operator><operator>(</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'g'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'p'</literal> <operator>&amp;&amp;</operator> <name><name>name</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetReservedPrefix
 *		Given a string that is a reserved name return the portion of
 *      the name that makes it reserved - the reserved prefix.
 *
 *      Current return values include "pg_" and "gp_"
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetReservedPrefix</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>		<modifier>*</modifier></type><name>prefix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsReservedName</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prefix</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>prefix</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsSharedRelation
 *		Given the OID of a relation, determine whether it's supposed to be
 *		shared across an entire database cluster.
 *
 * In older releases, this had to be hard-wired so that we could compute the
 * locktag for a relation and lock it before examining its catalog entry.
 * Since we now have MVCC catalog access, the race conditions that made that
 * a hard requirement are gone, so we could look at relaxing this restriction.
 * However, if we scanned the pg_class entry to find relisshared, and only
 * then locked the relation, pg_class could get updated in the meantime,
 * forcing us to scan the relation again, which would definitely be complex
 * and might have undesirable performance consequences.  Fortunately, the set
 * of shared relations is fairly static, so a hand-maintained list of their
 * OIDs isn't completely impractical.
 */</comment>
<function><type><name>bool</name></type>
<name>IsSharedRelation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* These are the shared catalogs (look for BKI_SHARED_RELATION) */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>AuthIdRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthMemRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DatabaseRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PLTemplateRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDescriptionRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDependRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedSecLabelRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>TableSpaceRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DbRoleSettingRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ReplicationOriginRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SubscriptionRelationId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* GPDB additions */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>GpIdRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>GpVersionRelationId</name> <operator>||</operator>

		<comment type="block">/* MPP-6929: metadata tracking */</comment>
		<name>relationId</name> <operator>==</operator> <name>StatLastShOpRelationId</name> <operator>||</operator>

		<name>relationId</name> <operator>==</operator> <name>ResQueueRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResourceTypeRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResQueueCapabilityRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResGroupRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResGroupCapabilityRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>GpConfigHistoryRelationId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>GpSegmentConfigRelationId</name> <operator>||</operator>

		<name>relationId</name> <operator>==</operator> <name>AuthTimeConstraintRelationId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* These are their indexes (see indexing.h) */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>AuthIdRolnameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthIdOidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthMemRoleMemIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthMemMemRoleIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DatabaseNameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DatabaseOidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PLTemplateNameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDescriptionObjIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDependDependerIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedDependReferenceIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SharedSecLabelObjectIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>TablespaceOidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>TablespaceNameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>DbRoleSettingDatidRolidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ReplicationOriginIdentIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ReplicationOriginNameIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SubscriptionObjectIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>SubscriptionNameIndexId</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* GPDB added indexes */</comment>
	<if_stmt><if>if <condition>(<comment type="block">/* MPP-6929: metadata tracking */</comment>
		<expr><name>relationId</name> <operator>==</operator> <name>StatLastShOpClassidObjidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>StatLastShOpClassidObjidStaactionnameIndexId</name> <operator>||</operator>

		<name>relationId</name> <operator>==</operator> <name>ResQueueOidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResQueueRsqnameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResourceTypeOidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResourceTypeRestypidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResourceTypeResnameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResQueueCapabilityResqueueidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResQueueCapabilityRestypidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResGroupOidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResGroupRsgnameIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResGroupCapabilityResgroupidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>ResGroupCapabilityResgroupidResLimittypeIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthIdRolResQueueIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthIdRolResGroupIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>GpSegmentConfigContentPreferred_roleIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>GpSegmentConfigDbidIndexId</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>AuthTimeConstraintAuthIdIndexId</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* These are their toast tables and toast indexes (see toasting.h) */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>PgAuthidToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgAuthidToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgDatabaseToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgDatabaseToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgDbRoleSettingToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgDbRoleSettingToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgPlTemplateToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgPlTemplateToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgReplicationOriginToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgReplicationOriginToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgShdescriptionToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgShdescriptionToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgShseclabelToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgShseclabelToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgSubscriptionToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgSubscriptionToastIndex</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgTablespaceToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>PgTablespaceToastIndex</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* GPDB added toast tables and their indexes */</comment>
	<if_stmt><if>if <condition>(<expr><name>relationId</name> <operator>==</operator> <name>GpSegmentConfigToastTable</name> <operator>||</operator>
		<name>relationId</name> <operator>==</operator> <name>GpSegmentConfigToastIndex</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * OIDs for catalog object are normally allocated in the master, and
 * executor nodes should just use the OIDs passed by the master. But
 * there are some exceptions.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>RelationNeedsSynchronizedOIDs</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsCatalogNamespace</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<switch>switch<condition>(<expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * pg_largeobject is more like a user table, and has
			 * different contents in each segment and master.
			 *
			 * Large objects don't work very consistently in GPDB. They are not
			 * distributed in the segments, but rather stored in the master node.
			 * Or actually, it depends on which node the lo_create() function
			 * happens to run, which isn't very deterministic.
			 */</comment>
			<case>case <expr><name>LargeObjectRelationId</name></expr>:</case>
			<case>case <expr><name>LargeObjectMetadataRelationId</name></expr>:</case>
				<return>return <expr><name>false</name></expr>;</return>

			<comment type="block">/*
			 * We don't currently synchronize the OIDs of these catalogs.
			 * It's a bit sketchy that we don't, but we get away with it
			 * because these OIDs don't appear in any of the Node structs
			 * that are dispatched from master to segments. (Except for the
			 * OIDs, the contents of these tables should be in sync.)
			 */</comment>
			<case>case <expr><name>RewriteRelationId</name></expr>:</case>
			<case>case <expr><name>TriggerRelationId</name></expr>:</case>
				<return>return <expr><name>false</name></expr>;</return>

			<comment type="block">/* Event triggers are only stored and fired in the QD. */</comment>
			<case>case <expr><name>EventTriggerRelationId</name></expr>:</case>
				<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * All other system catalogs are assumed to need synchronized
		 * OIDs.
		 */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNewOidWithIndex
 *		Generate a new OID that is unique within the system relation.
 *
 * Since the OID is not immediately inserted into the table, there is a
 * race condition here; but a problem could occur only if someone else
 * managed to cycle through 2^32 OIDs and generate the same OID before we
 * finish inserting our row.  This seems unlikely to be a problem.  Note
 * that if we had to *commit* the row to end the race condition, the risk
 * would be rather higher; therefore we use SnapshotAny in the test, so that
 * we will see uncommitted rows.  (We used to use SnapshotDirty, but that has
 * the disadvantage that it ignores recently-deleted rows, creating a risk
 * of transient conflicts for as long as our own MVCC snapshots think a
 * recently-deleted row is live.  The risk is far higher when selecting TOAST
 * OIDs, because SnapshotToast considers dead rows as active indefinitely.)
 *
 * Note that we are effectively assuming that the table has a relatively small
 * number of entries (much less than 2^32) and there aren't very long runs of
 * consecutive existing OIDs.  This is a mostly reasonable assumption for
 * system catalogs.
 *
 * This is exported separately because there are cases where we want to use
 * an index that will not be recognized by RelationGetOidIndex: TOAST tables
 * have indexes that are usable, but have multiple columns and are on
 * ordinary columns rather than a true OID column.  This code will work
 * anyway, so long as the OID is the index's first column.  The caller must
 * pass in the actual heap attnum of the OID column, however.
 *
 * Caller must have a suitable lock on the relation.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetNewOidWithIndex</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>relation</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>indexId</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>oidcolumn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>collides</name></decl>;</decl_stmt>

	<comment type="block">/* Only system relations are supported */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* In bootstrap mode, we don't have any indexes to use */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>GetNewObjectId</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We should never be asked to generate a new pg_type OID during
	 * pg_upgrade; doing so would risk collisions with the OIDs it wants to
	 * assign.  Hitting this assert means there's some path where we failed to
	 * ensure that a type OID is determined by commands in the dump script.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsBinaryUpgrade</name> <operator>||</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TypeRelationId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Generate new OIDs until we find one not in the table */</comment>
	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>newOid</name> <operator>=</operator> <call><name>GetNewObjectId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
					<argument><expr><name>oidcolumn</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* see notes above about using SnapshotAny */</comment>
		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>SnapshotAny</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>collides</name> <operator>=</operator> <call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* GPDB: Also check that this OID hasn't been preallocated */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>collides</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsOidAcceptable</name><argument_list>(<argument><expr><name>newOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>collides</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>collides</name></expr>)</condition>;</do>

	<comment type="block">/*
	 * Most catalog objects need to have the same OID in the master and all
	 * segments. When creating a new object, the master should allocate the
	 * OID and tell the segments to use the same, so segments should have no
	 * need to ever allocate OIDs on their own. Therefore, give a WARNING if
	 * GetNewOid() is called in a segment. (There are a few exceptions, see
	 * RelationNeedsSynchronizedOIDs()).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <call><name>RelationNeedsSynchronizedOIDs</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"allocated OID %u for relation \"%s\" in segment"</literal></expr></argument>,
			 <argument><expr><name>newOid</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>newOid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>GpCheckRelFileCollision</name><parameter_list>(<parameter><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rpath</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>collides</name></decl>;</decl_stmt>

	<comment type="block">/* Check for existing file of same name */</comment>
	<expr_stmt><expr><name>rpath</name> <operator>=</operator> <call><name>relpath</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>, <argument><expr><name>MAIN_FORKNUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>rpath</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collides</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Here we have a little bit of a dilemma: if errno is something
		 * other than ENOENT, should we declare a collision and loop? In
		 * practice it seems best to go ahead regardless of the errno.  If
		 * there is a colliding file we will get an smgr failure when we
		 * attempt to create the new relation file.
		 */</comment>
		<expr_stmt><expr><name>collides</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>collides</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetNewRelFileNode
 *		Generate a new relfilenode number that is unique within the
 *		database of the given tablespace.
 *
 * If the relfilenode will also be used as the relation's OID, pass the
 * opened pg_class catalog, and this routine will guarantee that the result
 * is also an unused OID within pg_class.  If the result is to be used only
 * as a relfilenode for an existing relation, pass NULL for pg_class.
 * (in GPDB, 'pg_class' is unused, there is a different mechanism to avoid
 * clashes, across the whole cluster.)
 *
 * As with GetNewOidWithIndex(), there is some theoretical risk of a race
 * condition, but it doesn't seem worth worrying about.
 *
 * Note: we don't support using this in bootstrap mode.  All relations
 * created by bootstrap have preassigned OIDs, so there's no need.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetNewRelFileNode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>reltablespace</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pg_class</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelFileNodeBackend</name></type> <name>rnode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>collides</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BackendId</name></type>	<name>backend</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If we ever get here during pg_upgrade, there's something wrong; all
	 * relfilenode assignments during a binary-upgrade run should be
	 * determined by commands in the dump script.
	 *
	 * GPDB: Totally OK in Greenplum. We don't use the table's OID as its
	 * initial relfilenode, and rely on this in binary upgrade, too.
	 */</comment>
	<comment type="line">//Assert(!IsBinaryUpgrade);</comment>

	<switch>switch <condition>(<expr><name>relpersistence</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELPERSISTENCE_TEMP</name></expr>:</case>
			<expr_stmt><expr><name>backend</name> <operator>=</operator> <call><name>BackendIdForTempRelations</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELPERSISTENCE_UNLOGGED</name></expr>:</case>
		<case>case <expr><name>RELPERSISTENCE_PERMANENT</name></expr>:</case>
			<expr_stmt><expr><name>backend</name> <operator>=</operator> <name>InvalidBackendId</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid relpersistence: %c"</literal></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>InvalidOid</name></expr>;</return>	<comment type="block">/* placate compiler */</comment>
	</block_content>}</block></switch>

	<comment type="block">/* This logic should match RelationInitPhysicalAddr */</comment>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name> <operator>=</operator> <ternary><condition><expr><name>reltablespace</name></expr> ?</condition><then> <expr><name>reltablespace</name></expr> </then><else>: <expr><name>MyDatabaseTableSpace</name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>dbNode</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name> <operator>==</operator> <name>GLOBALTABLESPACE_OID</name><operator>)</operator></expr> ?</condition><then> <expr><name>InvalidOid</name></expr> </then><else>: <expr><name>MyDatabaseId</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * The relpath will vary based on the backend ID, so we must initialize
	 * that properly here to make sure that any collisions based on filename
	 * are properly detected.
	 */</comment>
	<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <name>backend</name></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Generate the Relfilenode */</comment>
		<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name> <operator>=</operator> <call><name>GetNewSegRelfilenode</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsOidAcceptable</name><argument_list>(<argument><expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>collides</name> <operator>=</operator> <call><name>GpCheckRelFileCollision</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>collides</name> <operator>&amp;&amp;</operator> <name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>spcNode</name></name> <operator>!=</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * GPDB_91_MERGE_FIXME: check again for a collision with a temp
			 * table (if this is a normal relation) or a normal table (if this
			 * is a temp relation).
			 *
			 * The shared buffer manager currently assumes that relfilenodes of
			 * relations stored in shared buffers can't conflict, which is
			 * trivially true in upstream because temp tables don't use shared
			 * buffers at all. We have to make this additional check to make
			 * sure of that.
			 */</comment>
			<expr_stmt><expr><name><name>rnode</name><operator>.</operator><name>backend</name></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>backend</name> <operator>==</operator> <name>InvalidBackendId</name><operator>)</operator></expr> ?</condition><then> <expr><name>TempRelBackendId</name></expr>
														  </then><else>: <expr><name>InvalidBackendId</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>collides</name> <operator>=</operator> <call><name>GpCheckRelFileCollision</name><argument_list>(<argument><expr><name>rnode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block> while <condition>(<expr><name>collides</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Calling GetNewRelFileNode returns new relfilenode = %d"</literal></expr></argument>, <argument><expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>rnode</name><operator>.</operator><name>node</name><operator>.</operator><name>relNode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SQL callable interface for GetNewOidWithIndex().  Outside of initdb's
 * direct insertions into catalog tables, and recovering from corruption, this
 * should rarely be needed.
 *
 * Function is intentionally not documented in the user facing docs.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_nextoid</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>reloid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Name</name></type>		<name>attname</name> <init>= <expr><call><name>PG_GETARG_NAME</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>idxoid</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>idx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>newoid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * As this function is not intended to be used during normal running, and
	 * only supports system catalogs (which require superuser permissions to
	 * modify), just checking for superuser ought to not obstruct valid
	 * usecases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to call pg_nextoid()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>idx</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>idxoid</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemRelation</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_nextoid() can only be used on system catalogs"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>idx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indrelid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" does not belong to table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>atttuple</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>reloid</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" of relation \"%s\" does not exist"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>attform</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>attform</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>attform</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>!=</operator> <name>OIDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is not of type oid"</literal></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IndexRelationGetNumberOfKeyAttributes</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator>
		<name><name>idx</name><operator>-&gt;</operator><name>rd_index</name><operator>-&gt;</operator><name>indkey</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <name>attno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"index \"%s\" is not the index for column \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>idx</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newoid</name> <operator>=</operator> <call><name>GetNewOidWithIndex</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>idxoid</name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>idx</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>newoid</name></expr>;</return>
</block_content>}</block></function>
</unit>
