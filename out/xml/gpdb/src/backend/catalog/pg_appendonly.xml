<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/catalog/pg_appendonly.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_appendonly.c
 *	  routines to support manipulation of the pg_appendonly relation
 *
 * Portions Copyright (c) 2008, Greenplum Inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2006, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	    src/backend/catalog/pg_appendonly.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am_d.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_fastsequence.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>TransferAppendonlyEntries</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>fromrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>torelid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SwapAppendonlyEntries</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>entryRelId1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>entryRelId2</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Adds an entry into the pg_appendonly catalog table. The entry
 * includes the new relfilenode of the appendonly relation that 
 * was just created and an initial eof and reltuples values of 0
 */</comment>
<function><type><name>void</name></type>
<name>InsertAppendOnlyEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, 
					  <parameter><decl><type><name>int</name></type> <name>blocksize</name></decl></parameter>, 
					  <parameter><decl><type><name>int</name></type> <name>safefswritesize</name></decl></parameter>, 
					  <parameter><decl><type><name>int</name></type> <name>compresslevel</name></decl></parameter>,
					  <parameter><decl><type><name>bool</name></type> <name>checksum</name></decl></parameter>,
                      <parameter><decl><type><name>bool</name></type> <name>columnstore</name></decl></parameter>,
					  <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>compresstype</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>segrelid</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>blkdirrelid</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>blkdiridxid</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>visimaprelid</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>visimapidxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_appendonly_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_appendonly_tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>compresstype_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/*
     * Open and lock the pg_appendonly catalog.
     */</comment>
	<expr_stmt><expr><name>pg_appendonly_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AppendOnlyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>natts</name> <operator>=</operator> <name>Natts_pg_appendonly</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>values</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nulls</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>natts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GPDB_12_MERGE_FIXME:
	 *		Consider not storing the parsed values for blocksize, compresstype,
	 *		compresslevel and checksum as those are also present in StdRdOptions
	 *		of Relcache.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>compresstype</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>compresstype_name</name></expr></argument>, <argument><expr><name>compresstype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>compresstype_name</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_relid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_blocksize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>blocksize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_safefswritesize</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>safefswritesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_compresslevel</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>compresslevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_checksum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>checksum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_compresstype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>compresstype_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_columnstore</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>columnstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_segrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>segrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_blkdirrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>blkdirrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_blkdiridxid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>blkdiridxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_visimaprelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>visimaprelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_appendonly_visimapidxid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>visimapidxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * form the tuple and insert it
	 */</comment>
	<expr_stmt><expr><name>pg_appendonly_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* insert a new tuple */</comment>
	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><name>pg_appendonly_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
     * Close the pg_appendonly_rel relcache entry without unlocking.
     * We have updated the catalog: consequently the lock must be 
	 * held until end of transaction.
     */</comment>
    <expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>void</name></type>
<name>GetAppendOnlyEntryAttributes</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
							 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>blocksize</name></decl></parameter>,
							 <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>safefswritesize</name></decl></parameter>,
							 <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>compresslevel</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>checksum</name></decl></parameter>,
							 <parameter><decl><type><name>NameData</name> <modifier>*</modifier></type><name>compresstype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_appendonly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type>	<name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type>	<name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_appendonly</name></type>	<name>aoForm</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_appendonly</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AppendOnlyRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_appendonly_relid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>, <argument><expr><name>AppendOnlyRelidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing pg_appendonly entry for relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aoForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_appendonly</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>blocksize</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>blocksize</name> <operator>=</operator> <name><name>aoForm</name><operator>-&gt;</operator><name>blocksize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>safefswritesize</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>safefswritesize</name> <operator>=</operator> <name><name>aoForm</name><operator>-&gt;</operator><name>safefswritesize</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>compresslevel</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>compresslevel</name> <operator>=</operator> <name><name>aoForm</name><operator>-&gt;</operator><name>compresslevel</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>checksum</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>checksum</name> <operator>=</operator> <name><name>aoForm</name><operator>-&gt;</operator><name>checksum</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>compresstype</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><name>compresstype</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>aoForm</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Finish up scan and close pg_appendonly catalog. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the OIDs of the auxiliary relations and their indexes for an appendonly
 * relation.
 *
 * The OIDs will be retrieved only when the corresponding output variable is
 * not NULL.
 *
 * 'appendOnlyMetaDataSnapshot' can be passed as NULL, which means use the
 * latest snapshot, like in systable_beginscan.
 */</comment>
<function><type><name>void</name></type>
<name>GetAppendOnlyEntryAuxOids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
						  <parameter><decl><type><name>Snapshot</name></type> <name>appendOnlyMetaDataSnapshot</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>segrelid</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>blkdirrelid</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>blkdiridxid</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>visimaprelid</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>visimapidxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_appendonly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_appendonly</name></type>	<name>aoForm</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check the pg_appendonly relation to be certain the ao table
	 * is there.
	 */</comment>
	<expr_stmt><expr><name>pg_appendonly</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AppendOnlyRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_appendonly_relid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>, <argument><expr><name>AppendOnlyRelidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>appendOnlyMetaDataSnapshot</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing pg_appendonly entry for relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aoForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_appendonly</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>segrelid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>segrelid</name> <operator>=</operator> <name><name>aoForm</name><operator>-&gt;</operator><name>segrelid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>blkdirrelid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>blkdirrelid</name> <operator>=</operator> <name><name>aoForm</name><operator>-&gt;</operator><name>blkdirrelid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>blkdiridxid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>blkdiridxid</name> <operator>=</operator> <name><name>aoForm</name><operator>-&gt;</operator><name>blkdiridxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>visimaprelid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>visimaprelid</name> <operator>=</operator> <name><name>aoForm</name><operator>-&gt;</operator><name>visimaprelid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>visimapidxid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>visimapidxid</name> <operator>=</operator> <name><name>aoForm</name><operator>-&gt;</operator><name>visimapidxid</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Finish up scan and close pg_appendonly catalog. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>GetAppendOnlyEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>Form_pg_appendonly</name></type> <name>aoEntry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_appendonly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_appendonly</name></type>	<name>aoForm</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check the pg_appendonly relation to be certain the ao table
	 * is there.
	 */</comment>
	<expr_stmt><expr><name>pg_appendonly</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AppendOnlyRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_appendonly_relid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>, <argument><expr><name>AppendOnlyRelidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing pg_appendonly entry for relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aoForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_appendonly</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>aoEntry</name></expr></argument>, <argument><expr><name>aoForm</name></expr></argument>, <argument><expr><name>APPENDONLY_TUPLE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finish up scan and close pg_appendonly catalog. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the segrelid and/or blkdirrelid if the input new values
 * are valid OIDs.
 */</comment>
<function><type><name>void</name></type>
<name>UpdateAppendOnlyEntryAuxOids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>newSegrelid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>newBlkdirrelid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>newBlkdiridxid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>newVisimaprelid</name></decl></parameter>,
							 <parameter><decl><type><name>Oid</name></type> <name>newVisimapidxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_appendonly</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>, <decl><type ref="prev"/><name>newTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>newValues</name><index>[<expr><name>Natts_pg_appendonly</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>newNulls</name><index>[<expr><name>Natts_pg_appendonly</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replace</name><index>[<expr><name>Natts_pg_appendonly</name></expr>]</index></name></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * Check the pg_appendonly relation to be certain the ao table 
	 * is there. 
	 */</comment>
	<expr_stmt><expr><name>pg_appendonly</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AppendOnlyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_appendonly_relid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>, <argument><expr><name>AppendOnlyRelidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"missing pg_appendonly entry for relation \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>newValues</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>newValues</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>newNulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>newNulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newSegrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_appendonly_segrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_pg_appendonly_segrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newSegrelid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newBlkdirrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_appendonly_blkdirrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_pg_appendonly_blkdirrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newBlkdirrelid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newBlkdiridxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_appendonly_blkdiridxid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_pg_appendonly_blkdiridxid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newBlkdiridxid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newVisimaprelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_appendonly_visimaprelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_pg_appendonly_visimaprelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newVisimaprelid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newVisimapidxid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_appendonly_visimapidxid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_pg_appendonly_visimapidxid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>newVisimapidxid</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>newTuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>newValues</name></expr></argument>, <argument><expr><name>newNulls</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newTuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finish up scan and close appendonly catalog. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_appendonly</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also cause flush the relcache entry for the parent relation. */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove all pg_appendonly entries that the table we are DROPing
 * refers to (using the table's relfilenode)
 *
 * The gp_fastsequence entries associate with the table is also
 * deleted here.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveAppendonlyEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_appendonly_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type> <name>aosegrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	
	<comment type="block">/*
	 * now remove the pg_appendonly entry 
	 */</comment>
	<expr_stmt><expr><name>pg_appendonly_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AppendOnlyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_appendonly_relid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><name>AppendOnlyRelidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"appendonly table relid \"%d\" does not exist in "</literal>
						<literal type="string">"pg_appendonly"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>isNull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>datum</name> <init>= <expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_appendonly_segrelid</name></expr></argument>,
								   <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>aosegrelid</name> <operator>=</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aosegrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Piggyback here to remove gp_fastsequence entries */</comment>
	<expr_stmt><expr><call><name>RemoveFastSequenceEntry</name><argument_list>(<argument><expr><name>aosegrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete the appendonly table entry from the catalog (pg_appendonly).
	 */</comment>
	<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* Finish up scan and close appendonly catalog. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Does 2 things:
 * 	Sever existing dependencies: oid -&gt; *
 * 	Create a new dependency: oid -&gt; baseOid
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TransferDependencyLink</name><parameter_list>(
	<parameter><decl><type><name>Oid</name></type> <name>baseOid</name></decl></parameter>, 
	<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>,
	<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tabletype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> 	<name>baseobject</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type>	<name>newobject</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>			<name>count</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>baseobject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newobject</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ObjectAddress</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>baseOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete old dependency */</comment>
	<expr_stmt><expr><name>count</name> <operator>=</operator> <call><name>deleteDependencyRecordsFor</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"expected one dependency record for %s table, oid %u, found %ld"</literal></expr></argument>,
			 <argument><expr><name>tabletype</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Register new dependencies */</comment>
	<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>baseobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>baseOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>oid</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>newobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>baseobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_INTERNAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>HeapTuple</name></type> 
<name>GetAppendEntryForMove</name><parameter_list>(
	<parameter><decl><type><name>Relation</name></type>	<name>pg_appendonly_rel</name></decl></parameter>,
	<parameter><decl><type><name>TupleDesc</name></type>	<name>pg_appendonly_dsc</name></decl></parameter>,
	<parameter><decl><type><name>Oid</name></type> 		<name>relId</name></decl></parameter>,
	<parameter><decl><type><name>Oid</name> 		<modifier>*</modifier></type><name>aosegrelid</name></decl></parameter>,
	<parameter><decl><type><name>Oid</name> 		<modifier>*</modifier></type><name>aoblkdirrelid</name></decl></parameter>,
	<parameter><decl><type><name>Oid</name>         <modifier>*</modifier></type><name>aovisimaprelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_appendonly_relid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><name>AppendOnlyRelidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"pg_appendonly tuple not found for relation: %u"</literal></expr></argument>, <argument><expr><name>relId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

    <expr_stmt><expr><operator>*</operator><name>aosegrelid</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
							   <argument><expr><name>Anum_pg_appendonly_segrelid</name></expr></argument>,
							   <argument><expr><name>pg_appendonly_dsc</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"got invalid segrelid value: NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	

    <expr_stmt><expr><operator>*</operator><name>aoblkdirrelid</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								  <argument><expr><name>Anum_pg_appendonly_blkdirrelid</name></expr></argument>,
								  <argument><expr><name>pg_appendonly_dsc</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"got invalid blkdirrelid value: NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	
 
	<expr_stmt><expr><operator>*</operator><name>aovisimaprelid</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>,
								   <argument><expr><name>Anum_pg_appendonly_visimaprelid</name></expr></argument>,
								   <argument><expr><name>pg_appendonly_dsc</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if<condition>(<expr><name>isNull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"got invalid visimaprelid value: NULL"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finish up the scan. */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This function acts as a controller of catalog actions that needs to be
 * performed when we have an AT involving AO/AOCO table, where the original
 * table could be rewritten.
 *
 * Parameters:
 * relform1: original table that is the target of the AT operation.
 * relform2: newly created temp table that rows have been CTASed into.
 *
 * The actions vary on a case-by-case basis:
 * 1. If we are not changing the table's AM, we need to swap the pg_appendonly
 *	entries between the temp table and the original table and rewire aux
 *	table dependencies.
 * 2. If we are changing the table's AM, we need to transfer the pg_appendonly
 *	entry of one table to the other and rewire aux table dependencies. See
 *	individual case bodies for more details.
 */</comment>
<function><type><name>void</name></type>
<name>ATAOEntries</name><parameter_list>(<parameter><decl><type><name>Form_pg_class</name></type> <name>relform1</name></decl></parameter>, <parameter><decl><type><name>Form_pg_class</name></type> <name>relform2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch<condition>(<expr><name><name>relform1</name><operator>-&gt;</operator><name>relam</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>HEAP_TABLE_AM_OID</name></expr>:</case>
			<switch>switch<condition>(<expr><name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>AO_ROW_TABLE_AM_OID</name></expr>:</case>
					<comment type="block">/*
					 * Since the newly created AO table temp relid will be
					 * dropped from the catalog (later on in finish_heap_swap()),
					 * we ensure that the:
					 * 1. newly created pg_appendonly row carries the original
					 * 		heap relid.
					 * 2. newly created AO aux tables depend on the original
					 * 		heap relid.
					 */</comment>
					<expr_stmt><expr><call><name>TransferAppendonlyEntries</name><argument_list>(<argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AO_COLUMN_TABLE_AM_OID</name></expr>:</case>
					<expr_stmt><expr><call><name>TransferAppendonlyEntries</name><argument_list>(<argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>HEAP_TABLE_AM_OID</name></expr>:</case>
				<default>default:</default>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>AO_ROW_TABLE_AM_OID</name></expr>:</case>
			<switch>switch<condition>(<expr><name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>HEAP_TABLE_AM_OID</name></expr>:</case>
					<comment type="block">/*
					 * Since the newly created heap table temp relid will be
					 * dropped from the catalog (later on in finish_heap_swap()),
					 * we ensure that the:
					 * 1. original AO table's pg_appendonly row carries the heap
					 * 		temp table's relid.
					 * 2. original AO table's AO aux tables now depend on the
					 * 		heap temp table's relid.
					 * This way when the heap temp table relid is dropped from
					 * the catalog, the pg_appendonly row and aux tables also
					 * follow suit.
					 */</comment>
					<expr_stmt><expr><call><name>TransferAppendonlyEntries</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AO_ROW_TABLE_AM_OID</name></expr>:</case>
					<expr_stmt><expr><call><name>SwapAppendonlyEntries</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AO_COLUMN_TABLE_AM_OID</name></expr>:</case>
					<expr_stmt><expr><call><name>SwapAppendonlyEntries</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"alter table does not support switch from AO to given access method"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>
		<case>case <expr><name>AO_COLUMN_TABLE_AM_OID</name></expr>:</case>
			<switch>switch<condition>(<expr><name><name>relform2</name><operator>-&gt;</operator><name>relam</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>HEAP_TABLE_AM_OID</name></expr>:</case>
					<comment type="block">/* For pg_appendonly entries, it's the same as AO-&gt;Heap. */</comment>
					<expr_stmt><expr><call><name>TransferAppendonlyEntries</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* Remove the pg_attribute_encoding entries, since heap tables shouldn't have these. */</comment>
					<expr_stmt><expr><call><name>RemoveAttributeEncodingsByRelid</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AO_ROW_TABLE_AM_OID</name></expr>:</case>
					<comment type="block">/* For pg_appendonly entries, it's same as AO-&gt;AO/CO. */</comment>
					<expr_stmt><expr><call><name>SwapAppendonlyEntries</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* For pg_attribute_encoding entries, it's same as AOCO-&gt;heap.*/</comment>
					<expr_stmt><expr><call><name>RemoveAttributeEncodingsByRelid</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>AO_COLUMN_TABLE_AM_OID</name></expr>:</case>
					<expr_stmt><expr><call><name>SwapAppendonlyEntries</name><argument_list>(<argument><expr><name><name>relform1</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>, <argument><expr><name><name>relform2</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"alter table does not support switch from AOCO to given access method"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Transfer the pg_appendonly_entry of the relation identified by fromrelid to
 * the relation identified by torelid.
 *
 * This is done by simply overwriting the relid field of the pg_appendonly row
 * for fromrelid with value = torelid.
 *
 * For completeness, also rewire the aux table dependencies to point to torelid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>TransferAppendonlyEntries</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>fromrelid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>torelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_appendonly_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>pg_appendonly_dsc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pg_appendonly_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> 		<modifier>*</modifier></type><name>newValues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> 		<modifier>*</modifier></type><name>newNulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> 		<modifier>*</modifier></type><name>replace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aosegrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aoblkdirrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aovisimaprelid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_appendonly_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AppendOnlyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_appendonly_dsc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_appendonly_tuple</name> <operator>=</operator> <call><name>GetAppendEntryForMove</name><argument_list>(
		<argument><expr><name>pg_appendonly_rel</name></expr></argument>,
		<argument><expr><name>pg_appendonly_dsc</name></expr></argument>,
		<argument><expr><name>fromrelid</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>aosegrelid</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>aoblkdirrelid</name></expr></argument>,
		<argument><expr><operator>&amp;</operator><name>aovisimaprelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newValues</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>pg_appendonly_dsc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newNulls</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>pg_appendonly_dsc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replace</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>pg_appendonly_dsc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_appendonly_relid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_pg_appendonly_relid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>torelid</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>pg_appendonly_tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>pg_appendonly_tuple</name></expr></argument>, <argument><expr><name>pg_appendonly_dsc</name></expr></argument>,
								   <argument><expr><name>newValues</name></expr></argument>, <argument><expr><name>newNulls</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pg_appendonly_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>pg_appendonly_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>pg_appendonly_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aosegrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TransferDependencyLink</name><argument_list>(<argument><expr><name>torelid</name></expr></argument>, <argument><expr><name>aosegrelid</name></expr></argument>, <argument><expr><literal type="string">"aoseg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aoblkdirrelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TransferDependencyLink</name><argument_list>(<argument><expr><name>torelid</name></expr></argument>, <argument><expr><name>aoblkdirrelid</name></expr></argument>, <argument><expr><literal type="string">"aoblkdir"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aovisimaprelid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>TransferDependencyLink</name><argument_list>(<argument><expr><name>torelid</name></expr></argument>, <argument><expr><name>aovisimaprelid</name></expr></argument>, <argument><expr><literal type="string">"aovisimap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Swap pg_appendonly entries between tables and transfer aux table dependencies.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SwapAppendonlyEntries</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>entryRelId1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>entryRelId2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_appendonly_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>pg_appendonly_dsc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tupleCopy1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tupleCopy2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name> 		<modifier>*</modifier></type><name>newValues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> 		<modifier>*</modifier></type><name>newNulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name> 		<modifier>*</modifier></type><name>replace</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aosegrelid1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aoblkdirrelid1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aovisimaprelid1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aosegrelid2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aoblkdirrelid2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>aovisimaprelid2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_appendonly_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AppendOnlyRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pg_appendonly_dsc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>tupleCopy1</name> <operator>=</operator> <call><name>GetAppendEntryForMove</name><argument_list>(
							<argument><expr><name>pg_appendonly_rel</name></expr></argument>,
							<argument><expr><name>pg_appendonly_dsc</name></expr></argument>,
							<argument><expr><name>entryRelId1</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>aosegrelid1</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>aoblkdirrelid1</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>aovisimaprelid1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupleCopy2</name> <operator>=</operator> <call><name>GetAppendEntryForMove</name><argument_list>(
							<argument><expr><name>pg_appendonly_rel</name></expr></argument>,
							<argument><expr><name>pg_appendonly_dsc</name></expr></argument>,
							<argument><expr><name>entryRelId2</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>aosegrelid2</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>aoblkdirrelid2</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>aovisimaprelid2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Since gp_fastsequence entry is referenced by aosegrelid, it rides along  */</comment>
	<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tupleCopy1</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>simple_heap_delete</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tupleCopy2</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * (Re)insert.
	 */</comment>
	<expr_stmt><expr><name>newValues</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>pg_appendonly_dsc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Datum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newNulls</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>pg_appendonly_dsc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>replace</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>pg_appendonly_dsc</name><operator>-&gt;</operator><name>natts</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_appendonly_relid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_pg_appendonly_relid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>entryRelId2</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupleCopy1</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tupleCopy1</name></expr></argument>, <argument><expr><name>pg_appendonly_dsc</name></expr></argument>,
								  <argument><expr><name>newValues</name></expr></argument>, <argument><expr><name>newNulls</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><name>tupleCopy1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tupleCopy1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>newValues</name><index>[<expr><name>Anum_pg_appendonly_relid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>entryRelId1</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tupleCopy2</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tupleCopy2</name></expr></argument>, <argument><expr><name>pg_appendonly_dsc</name></expr></argument>,
								  <argument><expr><name>newValues</name></expr></argument>, <argument><expr><name>newNulls</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><name>tupleCopy2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tupleCopy2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_appendonly_rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newValues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newNulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aosegrelid1</name> <operator>||</operator> <name>aosegrelid2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>aosegrelid1</name> <operator>!=</operator> <name>aosegrelid2</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aosegrelid1</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TransferDependencyLink</name><argument_list>(<argument><expr><name>entryRelId2</name></expr></argument>, <argument><expr><name>aosegrelid1</name></expr></argument>, <argument><expr><literal type="string">"aoseg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aosegrelid2</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TransferDependencyLink</name><argument_list>(<argument><expr><name>entryRelId1</name></expr></argument>, <argument><expr><name>aosegrelid2</name></expr></argument>, <argument><expr><literal type="string">"aoseg"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aoblkdirrelid1</name> <operator>||</operator> <name>aoblkdirrelid2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>aoblkdirrelid1</name> <operator>!=</operator> <name>aoblkdirrelid2</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aoblkdirrelid1</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TransferDependencyLink</name><argument_list>(<argument><expr><name>entryRelId2</name></expr></argument>, <argument><expr><name>aoblkdirrelid1</name></expr></argument>, <argument><expr><literal type="string">"aoblkdir"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aoblkdirrelid2</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TransferDependencyLink</name><argument_list>(<argument><expr><name>entryRelId1</name></expr></argument>, <argument><expr><name>aoblkdirrelid2</name></expr></argument>, <argument><expr><literal type="string">"aoblkdir"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>aovisimaprelid1</name> <operator>||</operator> <name>aovisimaprelid2</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>aovisimaprelid1</name> <operator>!=</operator> <name>aovisimaprelid2</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aovisimaprelid1</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TransferDependencyLink</name><argument_list>(<argument><expr><name>entryRelId2</name></expr></argument>, <argument><expr><name>aovisimaprelid1</name></expr></argument>, <argument><expr><literal type="string">"aovisimap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>aovisimaprelid2</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>TransferDependencyLink</name><argument_list>(<argument><expr><name>entryRelId1</name></expr></argument>, <argument><expr><name>aovisimaprelid2</name></expr></argument>, <argument><expr><literal type="string">"aovisimap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

</unit>
