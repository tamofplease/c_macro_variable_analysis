<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/catalog/pg_shdepend.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * pg_shdepend.c
 *	  routines to support manipulation of the pg_shdepend relation
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/catalog/pg_shdepend.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_conversion.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_default_acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_data_wrapper.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_server.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_largeobject_metadata.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_shdepend.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_user_mapping.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/alter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/collationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/conversioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/event_trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/extension.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/proclang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/publicationcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/schemacmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/subscriptioncmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<typedef>typedef <type><enum>enum
<block>{
	<decl><name>LOCAL_OBJECT</name></decl>,
	<decl><name>SHARED_OBJECT</name></decl>,
	<decl><name>REMOTE_OBJECT</name></decl>
}</block></enum></type> <name>SharedDependencyObjectType</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>deptype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedDependencyObjectType</name></type> <name>objtype</name></decl>;</decl_stmt>
}</block></struct></type> <name>ShDependObjectInfo</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getOidListDiff</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nlist1</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nlist2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>classIdGetDbId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shdepChangeDep</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>sdepRel</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objsubid</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name></type> <name>refclassid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjid</name></decl></parameter>,
						   <parameter><decl><type><name>SharedDependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shdepAddDependency</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>sdepRel</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objsubId</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>refclassId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjId</name></decl></parameter>,
							   <parameter><decl><type><name>SharedDependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>shdepDropDependency</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>sdepRel</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objsubId</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>drop_subobjects</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>refclassId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjId</name></decl></parameter>,
								<parameter><decl><type><name>SharedDependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>storeObjectDescription</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>descs</name></decl></parameter>,
								   <parameter><decl><type><name>SharedDependencyObjectType</name></type> <name>type</name></decl></parameter>,
								   <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
								   <parameter><decl><type><name>SharedDependencyType</name></type> <name>deptype</name></decl></parameter>,
								   <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>isSharedObjectPinned</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>sdepRel</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * recordSharedDependencyOn
 *
 * Record a dependency between 2 objects via their respective ObjectAddresses.
 * The first argument is the dependent object, the second the one it
 * references (which must be a shared object).
 *
 * This locks the referenced object and makes sure it still exists.
 * Then it creates an entry in pg_shdepend.  The lock is kept until
 * the end of the transaction.
 *
 * Dependencies on pinned objects are not recorded.
 */</comment>
<function><type><name>void</name></type>
<name>recordSharedDependencyOn</name><parameter_list>(<parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>depender</name></decl></parameter>,
						 <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>referenced</name></decl></parameter>,
						 <parameter><decl><type><name>SharedDependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sdepRel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Objects in pg_shdepend can't have SubIds.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>depender</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>referenced</name><operator>-&gt;</operator><name>objectSubId</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * During bootstrap, do nothing since pg_shdepend may not exist yet.
	 * initdb will fill in appropriate pg_shdepend entries after bootstrap.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sdepRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the referenced object is pinned, do nothing. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isSharedObjectPinned</name><argument_list>(<argument><expr><name><name>referenced</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>referenced</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>,
							  <argument><expr><name>sdepRel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>shdepAddDependency</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name><name>depender</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>depender</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>,
						   <argument><expr><name><name>depender</name><operator>-&gt;</operator><name>objectSubId</name></name></expr></argument>,
						   <argument><expr><name><name>referenced</name><operator>-&gt;</operator><name>classId</name></name></expr></argument>, <argument><expr><name><name>referenced</name><operator>-&gt;</operator><name>objectId</name></name></expr></argument>,
						   <argument><expr><name>deptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * recordDependencyOnOwner
 *
 * A convenient wrapper of recordSharedDependencyOn -- register the specified
 * user as owner of the given object.
 *
 * Note: it's the caller's responsibility to ensure that there isn't an owner
 * entry for the object already.
 */</comment>
<function><type><name>void</name></type>
<name>recordDependencyOnOwner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>owner</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>classId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>objectId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AuthIdRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordSharedDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>SHARED_DEPENDENCY_OWNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shdepChangeDep
 *
 * Update shared dependency records to account for an updated referenced
 * object.  This is an internal workhorse for operations such as changing
 * an object's owner.
 *
 * There must be no more than one existing entry for the given dependent
 * object and dependency type!	So in practice this can only be used for
 * updating SHARED_DEPENDENCY_OWNER entries, which should have that property.
 *
 * If there is no previous entry, we assume it was referencing a PINned
 * object, so we create a new entry.  If the new referenced object is
 * PINned, we don't create an entry (and drop the old one, if any).
 *
 * sdepRel must be the pg_shdepend relation, already opened and suitably
 * locked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shdepChangeDep</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>sdepRel</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>classid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objsubid</name></decl></parameter>,
			   <parameter><decl><type><name>Oid</name></type> <name>refclassid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjid</name></decl></parameter>,
			   <parameter><decl><type><name>SharedDependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dbid</name> <init>= <expr><call><name>classIdGetDbId</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>oldtup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>scantup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure the new referenced object doesn't go away while we record the
	 * dependency.
	 */</comment>
	<expr_stmt><expr><call><name>shdepLockAndCheckObject</name><argument_list>(<argument><expr><name>refclassid</name></expr></argument>, <argument><expr><name>refobjid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look for a previous entry
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_dbid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_objsubid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
				<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>SharedDependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>scantup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Ignore if not of the target dependency type */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_shdepend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>scantup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>deptype</name> <operator>!=</operator> <name>deptype</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Caller screwed up if multiple matches */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldtup</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				 <argument><expr><literal type="string">"multiple pg_shdepend entries for object %u/%u/%d deptype %c"</literal></expr></argument>,
				 <argument><expr><name>classid</name></expr></argument>, <argument><expr><name>objid</name></expr></argument>, <argument><expr><name>objsubid</name></expr></argument>, <argument><expr><name>deptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>scantup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>isSharedObjectPinned</name><argument_list>(<argument><expr><name>refclassid</name></expr></argument>, <argument><expr><name>refobjid</name></expr></argument>, <argument><expr><name>sdepRel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No new entry needed, so just delete existing entry if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>oldtup</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>oldtup</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Need to update existing entry */</comment>
		<decl_stmt><decl><type><name>Form_pg_shdepend</name></type> <name>shForm</name> <init>= <expr><operator>(</operator><name>Form_pg_shdepend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Since oldtup is a copy, we can just modify it in-memory */</comment>
		<expr_stmt><expr><name><name>shForm</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>=</operator> <name>refclassid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>shForm</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>=</operator> <name>refobjid</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>oldtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Need to insert new entry */</comment>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_shdepend</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_shdepend</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_dbid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_classid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_objid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_objsubid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>objsubid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_refclassid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>refclassid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_refobjid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>refobjid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_deptype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>deptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * we are reusing oldtup just to avoid declaring a new variable, but
		 * it's certainly a new tuple
		 */</comment>
		<expr_stmt><expr><name>oldtup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldtup</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>oldtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * changeDependencyOnOwner
 *
 * Update the shared dependencies to account for the new owner.
 *
 * Note: we don't need an objsubid argument because only whole objects
 * have owners.
 */</comment>
<function><type><name>void</name></type>
<name>changeDependencyOnOwner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newOwnerId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sdepRel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sdepRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust the SHARED_DEPENDENCY_OWNER entry */</comment>
	<expr_stmt><expr><call><name>shdepChangeDep</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>,
				   <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
				   <argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>,
				   <argument><expr><name>SHARED_DEPENDENCY_OWNER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*----------
	 * There should never be a SHARED_DEPENDENCY_ACL entry for the owner,
	 * so get rid of it if there is one.  This can happen if the new owner
	 * was previously granted some rights to the object.
	 *
	 * This step is analogous to aclnewowner's removal of duplicate entries
	 * in the ACL.  We have to do it to handle this scenario:
	 *		A grants some rights on an object to B
	 *		ALTER OWNER changes the object's owner to B
	 *		ALTER OWNER changes the object's owner to C
	 * The third step would remove all mention of B from the object's ACL,
	 * but we'd still have a SHARED_DEPENDENCY_ACL for B if we did not do
	 * things this way.
	 *
	 * The rule against having a SHARED_DEPENDENCY_ACL entry for the owner
	 * allows us to fix things up in just this one place, without having
	 * to make the various ALTER OWNER routines each know about it.
	 *----------
	 */</comment>
	<expr_stmt><expr><call><name>shdepDropDependency</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						<argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>newOwnerId</name></expr></argument>,
						<argument><expr><name>SHARED_DEPENDENCY_ACL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getOidListDiff
 *		Helper for updateAclDependencies.
 *
 * Takes two Oid arrays and removes elements that are common to both arrays,
 * leaving just those that are in one input but not the other.
 * We assume both arrays have been sorted and de-duped.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getOidListDiff</name><parameter_list>(<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>list1</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nlist1</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>list2</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nlist2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>in1</name></decl>,
				<decl><type ref="prev"/><name>in2</name></decl>,
				<decl><type ref="prev"/><name>out1</name></decl>,
				<decl><type ref="prev"/><name>out2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>in1</name> <operator>=</operator> <name>in2</name> <operator>=</operator> <name>out1</name> <operator>=</operator> <name>out2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>in1</name> <operator>&lt;</operator> <operator>*</operator><name>nlist1</name> <operator>&amp;&amp;</operator> <name>in2</name> <operator>&lt;</operator> <operator>*</operator><name>nlist2</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>list1</name><index>[<expr><name>in1</name></expr>]</index></name> <operator>==</operator> <name><name>list2</name><index>[<expr><name>in2</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* skip over duplicates */</comment>
			<expr_stmt><expr><name>in1</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>in2</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>list1</name><index>[<expr><name>in1</name></expr>]</index></name> <operator>&lt;</operator> <name><name>list2</name><index>[<expr><name>in2</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* list1[in1] is not in list2 */</comment>
			<expr_stmt><expr><name><name>list1</name><index>[<expr><name>out1</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>list1</name><index>[<expr><name>in1</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* list2[in2] is not in list1 */</comment>
			<expr_stmt><expr><name><name>list2</name><index>[<expr><name>out2</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>list2</name><index>[<expr><name>in2</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* any remaining list1 entries are not in list2 */</comment>
	<while>while <condition>(<expr><name>in1</name> <operator>&lt;</operator> <operator>*</operator><name>nlist1</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>list1</name><index>[<expr><name>out1</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>list1</name><index>[<expr><name>in1</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* any remaining list2 entries are not in list1 */</comment>
	<while>while <condition>(<expr><name>in2</name> <operator>&lt;</operator> <operator>*</operator><name>nlist2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>list2</name><index>[<expr><name>out2</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>list2</name><index>[<expr><name>in2</name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>nlist1</name> <operator>=</operator> <name>out1</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nlist2</name> <operator>=</operator> <name>out2</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * updateAclDependencies
 *		Update the pg_shdepend info for an object's ACL during GRANT/REVOKE.
 *
 * classId, objectId, objsubId: identify the object whose ACL this is
 * ownerId: role owning the object
 * noldmembers, oldmembers: array of roleids appearing in old ACL
 * nnewmembers, newmembers: array of roleids appearing in new ACL
 *
 * We calculate the differences between the new and old lists of roles,
 * and then insert or delete from pg_shdepend as appropriate.
 *
 * Note that we can't just insert all referenced roles blindly during GRANT,
 * because we would end up with duplicate registered dependencies.  We could
 * check for existence of the tuples before inserting, but that seems to be
 * more expensive than what we are doing here.  Likewise we can't just delete
 * blindly during REVOKE, because the user may still have other privileges.
 * It is also possible that REVOKE actually adds dependencies, due to
 * instantiation of a formerly implicit default ACL (although at present,
 * all such dependencies should be for the owning role, which we ignore here).
 *
 * NOTE: Both input arrays must be sorted and de-duped.  (Typically they
 * are extracted from an ACL array by aclmembers(), which takes care of
 * both requirements.)	The arrays are pfreed before return.
 */</comment>
<function><type><name>void</name></type>
<name>updateAclDependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objsubId</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name></type> <name>ownerId</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>noldmembers</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>oldmembers</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>nnewmembers</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>newmembers</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sdepRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Remove entries that are common to both lists; those represent existing
	 * dependencies we don't need to change.
	 *
	 * OK to overwrite the inputs since we'll pfree them anyway.
	 */</comment>
	<expr_stmt><expr><call><name>getOidListDiff</name><argument_list>(<argument><expr><name>oldmembers</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>noldmembers</name></expr></argument>, <argument><expr><name>newmembers</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nnewmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>noldmembers</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>nnewmembers</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>sdepRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add new dependencies that weren't already present */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nnewmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name> <init>= <expr><name><name>newmembers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Skip the owner: he has an OWNER shdep entry instead. (This is
			 * not just a space optimization; it makes ALTER OWNER easier. See
			 * notes in changeDependencyOnOwner.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>roleid</name> <operator>==</operator> <name>ownerId</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Skip pinned roles; they don't need dependency entries */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>isSharedObjectPinned</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>sdepRel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>shdepAddDependency</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><name>objsubId</name></expr></argument>,
							   <argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
							   <argument><expr><name>SHARED_DEPENDENCY_ACL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Drop no-longer-used old dependencies */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>noldmembers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name> <init>= <expr><name><name>oldmembers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Skip the owner, same as above */</comment>
			<if_stmt><if>if <condition>(<expr><name>roleid</name> <operator>==</operator> <name>ownerId</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Skip pinned roles */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>isSharedObjectPinned</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>sdepRel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>shdepDropDependency</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><name>objsubId</name></expr></argument>,
								<argument><expr><name>false</name></expr></argument>,	<comment type="block">/* exact match on objsubId */</comment>
								<argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>,
								<argument><expr><name>SHARED_DEPENDENCY_ACL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>oldmembers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>oldmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>newmembers</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>newmembers</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A struct to keep track of dependencies found in other databases.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dbOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>
}</block></struct></type> <name>remoteDep</name>;</typedef>

<comment type="block">/*
 * qsort comparator for ShDependObjectInfo items
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>shared_dependency_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShDependObjectInfo</name> <modifier>*</modifier></type><name>obja</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ShDependObjectInfo</name> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ShDependObjectInfo</name> <modifier>*</modifier></type><name>objb</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>ShDependObjectInfo</name> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Primary sort key is OID ascending.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>objectId</name></name> <operator>&lt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>objectId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>objectId</name></name> <operator>&gt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>objectId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Next sort on catalog ID, in case identical OIDs appear in different
	 * catalogs.  Sort direction is pretty arbitrary here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>classId</name></name> <operator>&lt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>classId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>classId</name></name> <operator>&gt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>classId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Sort on object subId.
	 *
	 * We sort the subId as an unsigned int so that 0 (the whole object) will
	 * come first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>obja</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>objb</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>objectSubId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>obja</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator> <name><name>objb</name><operator>-&gt;</operator><name>object</name><operator>.</operator><name>objectSubId</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Last, sort on deptype, in case the same object has multiple dependency
	 * types.  (Note that there's no need to consider objtype, as that's
	 * determined by the catalog OID.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>deptype</name></name> <operator>&lt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>deptype</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>obja</name><operator>-&gt;</operator><name>deptype</name></name> <operator>&gt;</operator> <name><name>objb</name><operator>-&gt;</operator><name>deptype</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * checkSharedDependencies
 *
 * Check whether there are shared dependency entries for a given shared
 * object; return true if so.
 *
 * In addition, return a string containing a newline-separated list of object
 * descriptions that depend on the shared object, or NULL if none is found.
 * We actually return two such strings; the "detail" result is suitable for
 * returning to the client as an errdetail() string, and is limited in size.
 * The "detail_log" string is potentially much longer, and should be emitted
 * to the server log only.
 *
 * We can find three different kinds of dependencies: dependencies on objects
 * of the current database; dependencies on shared objects; and dependencies
 * on objects local to other databases.  We can (and do) provide descriptions
 * of the two former kinds of objects, but we can't do that for "remote"
 * objects, so we just provide a count of them.
 *
 * If we find a SHARED_DEPENDENCY_PIN entry, we can error out early.
 */</comment>
<function><type><name>bool</name></type>
<name>checkSharedDependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>,
						<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>detail_msg</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>detail_log_msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sdepRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numReportedDeps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numNotReportedDeps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numNotReportedDbs</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>remDeps</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ShDependObjectInfo</name> <modifier>*</modifier></type><name>objects</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numobjects</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>allocedobjects</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>descs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>alldescs</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We limit the number of dependencies reported to the client to
	 * MAX_REPORTED_DEPS, since client software may not deal well with
	 * enormous error strings.  The server log always gets a full report.
	 *
	 * For stability of regression test results, we sort local and shared
	 * objects by OID before reporting them.  We don't worry about the order
	 * in which other databases are reported, though.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_REPORTED_DEPS</name></cpp:macro> <cpp:value>100</cpp:value></cpp:define>

	<expr_stmt><expr><name>allocedobjects</name> <operator>=</operator> <literal type="number">128</literal></expr>;</expr_stmt>		<comment type="block">/* arbitrary initial array size */</comment>
	<expr_stmt><expr><name>objects</name> <operator>=</operator> <operator>(</operator><name>ShDependObjectInfo</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name>allocedobjects</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShDependObjectInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>numobjects</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>descs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alldescs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sdepRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>SharedDependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_shdepend</name></type> <name>sdepForm</name> <init>= <expr><operator>(</operator><name>Form_pg_shdepend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* This case can be dispatched quickly */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sdepForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>SHARED_DEPENDENCY_PIN</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>classId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>objectId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop %s because it is required by the database system"</literal></expr></argument>,
							<argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>classid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>objsubid</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If it's a dependency local to this database or it's a shared
		 * object, add it to the objects array.
		 *
		 * If it's a remote dependency, keep track of it so we can report the
		 * number of them later.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name> <operator>==</operator> <name>MyDatabaseId</name> <operator>||</operator>
			<name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>numobjects</name> <operator>&gt;=</operator> <name>allocedobjects</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>allocedobjects</name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>objects</name> <operator>=</operator> <operator>(</operator><name>ShDependObjectInfo</name> <operator>*</operator><operator>)</operator>
					<call><name>repalloc</name><argument_list>(<argument><expr><name>objects</name></expr></argument>,
							 <argument><expr><name>allocedobjects</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ShDependObjectInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>objects</name><index>[<expr><name>numobjects</name></expr>]</index></name><operator>.</operator><name>object</name> <operator>=</operator> <name>object</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>objects</name><index>[<expr><name>numobjects</name></expr>]</index></name><operator>.</operator><name>deptype</name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>deptype</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>objects</name><index>[<expr><name>numobjects</name></expr>]</index></name><operator>.</operator><name>objtype</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name> <operator>==</operator> <name>MyDatabaseId</name><operator>)</operator></expr> ?</condition><then>
				<expr><name>LOCAL_OBJECT</name></expr> </then><else>: <expr><name>SHARED_OBJECT</name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>numobjects</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* It's not local nor shared, so it must be remote. */</comment>
			<decl_stmt><decl><type><name>remoteDep</name>  <modifier>*</modifier></type><name>dep</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>stored</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * XXX this info is kept on a simple List.  Maybe it's not good
			 * for performance, but using a hash table seems needlessly
			 * complex.  The expected number of databases is not high anyway,
			 * I suppose.
			 */</comment>
			<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>remDeps</argument>)</argument_list></macro>
			<block>{<block_content>
				<expr_stmt><expr><name>dep</name> <operator>=</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>dep</name><operator>-&gt;</operator><name>dbOid</name></name> <operator>==</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>count</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>stored</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>stored</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>dep</name> <operator>=</operator> <operator>(</operator><name>remoteDep</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>remoteDep</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>dbOid</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>dep</name><operator>-&gt;</operator><name>count</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>remDeps</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>remDeps</name></expr></argument>, <argument><expr><name>dep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Sort and report local and shared objects.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numobjects</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>objects</name></expr></argument>, <argument><expr><name>numobjects</name></expr></argument>,
			  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ShDependObjectInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>shared_dependency_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numobjects</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>numReportedDeps</name> <operator>&lt;</operator> <name>MAX_REPORTED_DEPS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numReportedDeps</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>storeObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>descs</name></expr></argument>,
								   <argument><expr><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objtype</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>object</name></expr></argument>,
								   <argument><expr><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>deptype</name></expr></argument>,
								   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numNotReportedDeps</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>storeObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alldescs</name></expr></argument>,
							   <argument><expr><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>objtype</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>object</name></expr></argument>,
							   <argument><expr><name><name>objects</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>deptype</name></expr></argument>,
							   <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Summarize dependencies in remote databases.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>remDeps</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>remoteDep</name>  <modifier>*</modifier></type><name>dep</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>DatabaseRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>dep</name><operator>-&gt;</operator><name>dbOid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>numReportedDeps</name> <operator>&lt;</operator> <name>MAX_REPORTED_DEPS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numReportedDeps</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>storeObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>descs</name></expr></argument>, <argument><expr><name>REMOTE_OBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>,
								   <argument><expr><name>SHARED_DEPENDENCY_INVALID</name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numNotReportedDbs</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>storeObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>alldescs</name></expr></argument>, <argument><expr><name>REMOTE_OBJECT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>object</name></expr></argument>,
							   <argument><expr><name>SHARED_DEPENDENCY_INVALID</name></expr></argument>, <argument><expr><name><name>dep</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>objects</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>remDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>descs</name><operator>.</operator><name>len</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>descs</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>alldescs</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>detail_msg</name> <operator>=</operator> <operator>*</operator><name>detail_log_msg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>numNotReportedDeps</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>descs</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"\nand %d other object "</literal>
										  <literal type="string">"(see server log for list)"</literal></expr></argument>,
										  <argument><expr><literal type="string">"\nand %d other objects "</literal>
										  <literal type="string">"(see server log for list)"</literal></expr></argument>,
										  <argument><expr><name>numNotReportedDeps</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>numNotReportedDeps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>numNotReportedDbs</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>descs</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"\nand objects in %d other database "</literal>
										  <literal type="string">"(see server log for list)"</literal></expr></argument>,
										  <argument><expr><literal type="string">"\nand objects in %d other databases "</literal>
										  <literal type="string">"(see server log for list)"</literal></expr></argument>,
										  <argument><expr><name>numNotReportedDbs</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name>numNotReportedDbs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>detail_msg</name> <operator>=</operator> <name><name>descs</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>detail_log_msg</name> <operator>=</operator> <name><name>alldescs</name><operator>.</operator><name>data</name></name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * copyTemplateDependencies
 *
 * Routine to create the initial shared dependencies of a new database.
 * We simply copy the dependencies from the template database.
 */</comment>
<function><type><name>void</name></type>
<name>copyTemplateDependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>templateDbId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newDbId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sdepRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>sdepDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogIndexState</name></type> <name>indstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_shdepend</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_shdepend</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replace</name><index>[<expr><name>Natts_pg_shdepend</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sdepRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sdepDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indstate</name> <operator>=</operator> <call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scan all entries with dbid = templateDbId */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_dbid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>templateDbId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>SharedDependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up to copy the tuples except for inserting newDbId */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>replace</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replace</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>replace</name><index>[<expr><name>Anum_pg_shdepend_dbid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_dbid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>newDbId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Copy the entries of the original database, changing the database Id to
	 * that of the new database.  Note that because we are not copying rows
	 * with dbId == 0 (ie, rows describing dependent shared objects) we won't
	 * copy the ownership dependency of the template database itself; this is
	 * what we want.
	 */</comment>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>newtup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>sdepDesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>replace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleInsertWithInfo</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>, <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * dropDatabaseDependencies
 *
 * Delete pg_shdepend entries corresponding to a database that's being
 * dropped.
 */</comment>
<function><type><name>void</name></type>
<name>dropDatabaseDependencies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>databaseId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sdepRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sdepRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, delete all the entries that have the database Oid in the dbid
	 * field.
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_dbid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>databaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* We leave the other index fields unspecified */</comment>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>SharedDependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now delete all entries corresponding to the database itself */</comment>
	<expr_stmt><expr><call><name>shdepDropDependency</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>databaseId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>,
						<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						<argument><expr><name>SHARED_DEPENDENCY_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * deleteSharedDependencyRecordsFor
 *
 * Delete all pg_shdepend entries corresponding to an object that's being
 * dropped or modified.  The object is assumed to be either a shared object
 * or local to the current database (the classId tells us which).
 *
 * If objectSubId is zero, we are deleting a whole object, so get rid of
 * pg_shdepend entries for subobjects as well.
 */</comment>
<function><type><name>void</name></type>
<name>deleteSharedDependencyRecordsFor</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objectSubId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sdepRel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sdepRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>shdepDropDependency</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><name>objectSubId</name></expr></argument>,
						<argument><expr><operator>(</operator><name>objectSubId</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>,
						<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						<argument><expr><name>SHARED_DEPENDENCY_INVALID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shdepAddDependency
 *		Internal workhorse for inserting into pg_shdepend
 *
 * sdepRel must be the pg_shdepend relation, already opened and suitably
 * locked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shdepAddDependency</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>sdepRel</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objsubId</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>refclassId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjId</name></decl></parameter>,
				   <parameter><decl><type><name>SharedDependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_shdepend</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_shdepend</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Make sure the object doesn't go away while we record the dependency on
	 * it.  DROP routines should lock the object exclusively before they check
	 * shared dependencies.
	 */</comment>
	<expr_stmt><expr><call><name>shdepLockAndCheckObject</name><argument_list>(<argument><expr><name>refclassId</name></expr></argument>, <argument><expr><name>refobjId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Form the new tuple and record the dependency.
	 */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_dbid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>classIdGetDbId</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_classid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_objid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_objsubid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>objsubId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_refclassid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>refclassId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_refobjid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>refobjId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_shdepend_deptype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>deptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>sdepRel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up */</comment>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shdepDropDependency
 *		Internal workhorse for deleting entries from pg_shdepend.
 *
 * We drop entries having the following properties:
 *	dependent object is the one identified by classId/objectId/objsubId
 *	if refclassId isn't InvalidOid, it must match the entry's refclassid
 *	if refobjId isn't InvalidOid, it must match the entry's refobjid
 *	if deptype isn't SHARED_DEPENDENCY_INVALID, it must match entry's deptype
 *
 * If drop_subobjects is true, we ignore objsubId and consider all entries
 * matching classId/objectId.
 *
 * sdepRel must be the pg_shdepend relation, already opened and suitably
 * locked.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>shdepDropDependency</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>sdepRel</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>objsubId</name></decl></parameter>,
					<parameter><decl><type><name>bool</name></type> <name>drop_subobjects</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>refclassId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>refobjId</name></decl></parameter>,
					<parameter><decl><type><name>SharedDependencyType</name></type> <name>deptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/* Scan for entries matching the dependent object */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_dbid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>classIdGetDbId</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_classid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_objid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>drop_subobjects</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_shdepend_objsubid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT4EQ</name></expr></argument>,
					<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>objsubId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>SharedDependDependerIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_shdepend</name></type> <name>shdepForm</name> <init>= <expr><operator>(</operator><name>Form_pg_shdepend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Filter entries according to additional parameters */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>refclassId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>shdepForm</name><operator>-&gt;</operator><name>refclassid</name></name> <operator>!=</operator> <name>refclassId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>refobjId</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>shdepForm</name><operator>-&gt;</operator><name>refobjid</name></name> <operator>!=</operator> <name>refobjId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>deptype</name> <operator>!=</operator> <name>SHARED_DEPENDENCY_INVALID</name> <operator>&amp;&amp;</operator>
			<name><name>shdepForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>!=</operator> <name>deptype</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* OK, delete it */</comment>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * classIdGetDbId
 *
 * Get the database Id that should be used in pg_shdepend, given the OID
 * of the catalog containing the object.  For shared objects, it's 0
 * (InvalidOid); for all other objects, it's the current database Id.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>classIdGetDbId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dbId</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dbId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>dbId</name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>dbId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * shdepLockAndCheckObject
 *
 * Lock the object that we are about to record a dependency on.
 * After it's locked, verify that it hasn't been dropped while we
 * weren't looking.  If the object has been dropped, this function
 * does not return!
 */</comment>
<function><type><name>void</name></type>
<name>shdepLockAndCheckObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* AccessShareLock should be OK, since we are not modifying the object */</comment>
	<expr_stmt><expr><call><name>LockSharedObject</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>objectId</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>classId</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AuthIdRelationId</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"role %u was concurrently dropped"</literal></expr></argument>,
								<argument><expr><name>objectId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

			<comment type="block">/*
			 * Currently, this routine need not support any other shared
			 * object types besides roles.  If we wanted to record explicit
			 * dependencies on databases or tablespaces, we'd need code along
			 * these lines:
			 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
		<case>case <expr><name>TableSpaceRelationId</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* For lack of a syscache on pg_tablespace, do this: */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tablespace</name> <init>= <expr><call><name>get_tablespace_name</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>tablespace</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tablespace %u was concurrently dropped"</literal></expr></argument>,
									<argument><expr><name>objectId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tablespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<case>case <expr><name>DatabaseRelationId</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* For lack of a syscache on pg_database, do this: */</comment>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>database</name> <init>= <expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>database</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database %u was concurrently dropped"</literal></expr></argument>,
									<argument><expr><name>objectId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>database</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>


		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized shared classId: %u"</literal></expr></argument>, <argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * storeObjectDescription
 *		Append the description of a dependent object to "descs"
 *
 * While searching for dependencies of a shared object, we stash the
 * descriptions of dependent objects we find in a single string, which we
 * later pass to ereport() in the DETAIL field when somebody attempts to
 * drop a referenced shared object.
 *
 * When type is LOCAL_OBJECT or SHARED_OBJECT, we expect object to be the
 * dependent object, deptype is the dependency type, and count is not used.
 * When type is REMOTE_OBJECT, we expect object to be the database object,
 * and count to be nonzero; deptype is not used in this case.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>storeObjectDescription</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>descs</name></decl></parameter>,
					   <parameter><decl><type><name>SharedDependencyObjectType</name></type> <name>type</name></decl></parameter>,
					   <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>object</name></decl></parameter>,
					   <parameter><decl><type><name>SharedDependencyType</name></type> <name>deptype</name></decl></parameter>,
					   <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>objdesc</name> <init>= <expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><name>object</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* separate entries with a newline */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>descs</name><operator>-&gt;</operator><name>len</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>descs</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>LOCAL_OBJECT</name></expr>:</case>
		<case>case <expr><name>SHARED_OBJECT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>deptype</name> <operator>==</operator> <name>SHARED_DEPENDENCY_OWNER</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>descs</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"owner of %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>objdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>deptype</name> <operator>==</operator> <name>SHARED_DEPENDENCY_ACL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>descs</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"privileges for %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>objdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>deptype</name> <operator>==</operator> <name>SHARED_DEPENDENCY_POLICY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>descs</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"target of %s"</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>objdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized dependency type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>deptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>REMOTE_OBJECT</name></expr>:</case>
			<comment type="block">/* translator: %s will always be "database %s" */</comment>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>descs</name></expr></argument>, <argument><expr><call><name>ngettext</name><argument_list>(<argument><expr><literal type="string">"%d object in %s"</literal></expr></argument>,
											 <argument><expr><literal type="string">"%d objects in %s"</literal></expr></argument>,
											 <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name>count</name></expr></argument>, <argument><expr><name>objdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized object type: %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>objdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * isSharedObjectPinned
 *		Return whether a given shared object has a SHARED_DEPENDENCY_PIN entry.
 *
 * sdepRel must be the pg_shdepend relation, already opened and suitably
 * locked.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>isSharedObjectPinned</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>classId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>objectId</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>sdepRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_refclassid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_shdepend_refobjid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objectId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>SharedDependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Since we won't generate additional pg_shdepend entries for pinned
	 * objects, there can be at most one entry referencing a pinned object.
	 * Hence, it's sufficient to look at the first returned tuple; we don't
	 * need to loop.
	 */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_shdepend</name></type> <name>shdepForm</name> <init>= <expr><operator>(</operator><name>Form_pg_shdepend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>shdepForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>SHARED_DEPENDENCY_PIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * shdepDropOwned
 *
 * Drop the objects owned by any one of the given RoleIds.  If a role has
 * access to an object, the grant will be removed as well (but the object
 * will not, of course).
 *
 * We can revoke grants immediately while doing the scan, but drops are
 * saved up and done all at once with performMultipleDeletions.  This
 * is necessary so that we don't get failures from trying to delete
 * interdependent objects in the wrong order.
 */</comment>
<function><type><name>void</name></type>
<name>shdepDropOwned</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>roleids</name></decl></parameter>, <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sdepRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddresses</name> <modifier>*</modifier></type><name>deleteobjs</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>deleteobjs</name> <operator>=</operator> <call><name>new_object_addresses</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't need this strong a lock here, but we'll call routines that
	 * acquire RowExclusiveLock.  Better get that right now to avoid potential
	 * deadlock failures.
	 */</comment>
	<expr_stmt><expr><name>sdepRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For each role, find the dependent objects and drop them using the
	 * regular (non-shared) dependency management.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>roleids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<comment type="block">/* Doesn't work for pinned objects */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>isSharedObjectPinned</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>sdepRel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AuthIdRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>roleid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop objects owned by %s because they are "</literal>
							<literal type="string">"required by the database system"</literal></expr></argument>,
							<argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_shdepend_refclassid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_shdepend_refobjid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>SharedDependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_shdepend</name></type> <name>sdepForm</name> <init>= <expr><operator>(</operator><name>Form_pg_shdepend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * We only operate on shared objects and objects in the current
			 * database
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name> <operator>!=</operator> <name>MyDatabaseId</name> <operator>&amp;&amp;</operator>
				<name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<switch>switch <condition>(<expr><name><name>sdepForm</name><operator>-&gt;</operator><name>deptype</name></name></expr>)</condition>
			<block>{<block_content>
					<comment type="block">/* Shouldn't happen */</comment>
				<case>case <expr><name>SHARED_DEPENDENCY_PIN</name></expr>:</case>
				<case>case <expr><name>SHARED_DEPENDENCY_INVALID</name></expr>:</case>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected dependency type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>SHARED_DEPENDENCY_ACL</name></expr>:</case>
					<expr_stmt><expr><call><name>RemoveRoleFromObjectACL</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>,
											<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>classid</name></name></expr></argument>,
											<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>SHARED_DEPENDENCY_POLICY</name></expr>:</case>
					<comment type="block">/* If unable to remove role from policy, remove policy. */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RemoveRoleFromObjectPolicy</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>,
													<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>classid</name></name></expr></argument>,
													<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>classid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>objsubid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>deleteobjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
				<case>case <expr><name>SHARED_DEPENDENCY_OWNER</name></expr>:</case>
					<comment type="block">/* If a local object, save it for deletion below */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name> <operator>==</operator> <name>MyDatabaseId</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>classid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name><name>sdepForm</name><operator>-&gt;</operator><name>objsubid</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>add_exact_object_address</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>, <argument><expr><name>deleteobjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * For stability of deletion-report ordering, sort the objects into
	 * approximate reverse creation order before deletion.  (This might also
	 * make the deletion go a bit faster, since there's less chance of having
	 * to rearrange the objects due to dependencies.)
	 */</comment>
	<expr_stmt><expr><call><name>sort_object_addresses</name><argument_list>(<argument><expr><name>deleteobjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the dependency mechanism does the actual work */</comment>
	<expr_stmt><expr><call><name>performMultipleDeletions</name><argument_list>(<argument><expr><name>deleteobjs</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free_object_addresses</name><argument_list>(<argument><expr><name>deleteobjs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * shdepReassignOwned
 *
 * Change the owner of objects owned by any of the roles in roleids to
 * newrole.  Grants are not touched.
 */</comment>
<function><type><name>void</name></type>
<name>shdepReassignOwned</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>roleids</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>newrole</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>sdepRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't need this strong a lock here, but we'll call routines that
	 * acquire RowExclusiveLock.  Better get that right now to avoid potential
	 * deadlock problems.
	 */</comment>
	<expr_stmt><expr><name>sdepRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>SharedDependRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>roleids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>roleid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Refuse to work on pinned roles */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>isSharedObjectPinned</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>, <argument><expr><name>roleid</name></expr></argument>, <argument><expr><name>sdepRel</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>obj</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AuthIdRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>roleid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>obj</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot reassign ownership of objects owned by %s because they are required by the database system"</literal></expr></argument>,
							<argument><expr><call><name>getObjectDescription</name><argument_list>(<argument><expr><operator>&amp;</operator><name>obj</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * There's no need to tell the whole truth, which is that we
			 * didn't track these dependencies at all ...
			 */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_shdepend_refclassid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>AuthIdRelationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_shdepend_refobjid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>SharedDependReferenceIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_shdepend</name></type> <name>sdepForm</name> <init>= <expr><operator>(</operator><name>Form_pg_shdepend</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We only operate on shared objects and objects in the current
			 * database
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name> <operator>!=</operator> <name>MyDatabaseId</name> <operator>&amp;&amp;</operator>
				<name><name>sdepForm</name><operator>-&gt;</operator><name>dbid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Unexpected because we checked for pins above */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sdepForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>==</operator> <name>SHARED_DEPENDENCY_PIN</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected shared pin"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* We leave non-owner dependencies alone */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sdepForm</name><operator>-&gt;</operator><name>deptype</name></name> <operator>!=</operator> <name>SHARED_DEPENDENCY_OWNER</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* Issue the appropriate ALTER OWNER call */</comment>
			<switch>switch <condition>(<expr><name><name>sdepForm</name><operator>-&gt;</operator><name>classid</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>TypeRelationId</name></expr>:</case>
					<expr_stmt><expr><call><name>AlterTypeOwner_oid</name><argument_list>(<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newrole</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>NamespaceRelationId</name></expr>:</case>
					<expr_stmt><expr><call><name>AlterSchemaOwner_oid</name><argument_list>(<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>RelationRelationId</name></expr>:</case>

					<comment type="block">/*
					 * Pass recursing = true so that we don't fail on indexes,
					 * owned sequences, etc when we happen to visit them
					 * before their parent table.
					 */</comment>
					<expr_stmt><expr><call><name>ATExecChangeOwner</name><argument_list>(<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newrole</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DefaultAclRelationId</name></expr>:</case>

					<comment type="block">/*
					 * Ignore default ACLs; they should be handled by DROP
					 * OWNED, not REASSIGN OWNED.
					 */</comment>
					<break>break;</break>

				<case>case <expr><name>UserMappingRelationId</name></expr>:</case>
					<comment type="block">/* ditto */</comment>
					<break>break;</break>

				<case>case <expr><name>ForeignServerRelationId</name></expr>:</case>
					<expr_stmt><expr><call><name>AlterForeignServerOwner_oid</name><argument_list>(<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>ForeignDataWrapperRelationId</name></expr>:</case>
					<expr_stmt><expr><call><name>AlterForeignDataWrapperOwner_oid</name><argument_list>(<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>EventTriggerRelationId</name></expr>:</case>
					<expr_stmt><expr><call><name>AlterEventTriggerOwner_oid</name><argument_list>(<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>PublicationRelationId</name></expr>:</case>
					<expr_stmt><expr><call><name>AlterPublicationOwner_oid</name><argument_list>(<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>SubscriptionRelationId</name></expr>:</case>
					<expr_stmt><expr><call><name>AlterSubscriptionOwner_oid</name><argument_list>(<argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>, <argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>

					<comment type="block">/* Generic alter owner cases */</comment>
				<case>case <expr><name>CollationRelationId</name></expr>:</case>
				<case>case <expr><name>ConversionRelationId</name></expr>:</case>
				<case>case <expr><name>OperatorRelationId</name></expr>:</case>
				<case>case <expr><name>ProcedureRelationId</name></expr>:</case>
				<case>case <expr><name>LanguageRelationId</name></expr>:</case>
				<case>case <expr><name>LargeObjectRelationId</name></expr>:</case>
				<case>case <expr><name>OperatorFamilyRelationId</name></expr>:</case>
				<case>case <expr><name>OperatorClassRelationId</name></expr>:</case>
				<case>case <expr><name>ExtensionRelationId</name></expr>:</case>
				<case>case <expr><name>StatisticExtRelationId</name></expr>:</case>
				<case>case <expr><name>TableSpaceRelationId</name></expr>:</case>
				<case>case <expr><name>DatabaseRelationId</name></expr>:</case>
				<case>case <expr><name>TSConfigRelationId</name></expr>:</case>
				<case>case <expr><name>TSDictionaryRelationId</name></expr>:</case>
					<block>{<block_content>
						<decl_stmt><decl><type><name>Oid</name></type>			<name>classId</name> <init>= <expr><name><name>sdepForm</name><operator>-&gt;</operator><name>classid</name></name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>Relation</name></type>	<name>catalog</name></decl>;</decl_stmt>

						<if_stmt><if>if <condition>(<expr><name>classId</name> <operator>==</operator> <name>LargeObjectRelationId</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>classId</name> <operator>=</operator> <name>LargeObjectMetadataRelationId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><name>catalog</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>classId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>AlterObjectOwner_internal</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>objid</name></name></expr></argument>,
												  <argument><expr><name>newrole</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalog</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected classid %u"</literal></expr></argument>, <argument><expr><name><name>sdepForm</name><operator>-&gt;</operator><name>classid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
			</block_content>}</block></switch>
			<comment type="block">/* Make sure the next iteration will see my changes */</comment>
			<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>sdepRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
