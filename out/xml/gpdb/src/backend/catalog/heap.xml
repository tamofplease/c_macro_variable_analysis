<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/catalog/heap.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * heap.c
 *	  code to create and destroy POSTGRES heap relations
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/catalog/heap.c
 *
 *
 * INTERFACE ROUTINES
 *		heap_create()			- Create an uncataloged heap relation
 *		heap_create_with_catalog() - Create a cataloged relation
 *		heap_drop_with_catalog() - Removes named relation from catalogs
 *
 * NOTES
 *	  this code taken from access/heap/create.c, which contains
 *	  the old heap_create_with_catalog, amcreate, and amdestroy.
 *	  those routines will soon call these routines using the function
 *	  manager,
 *	  just like the poorly named "NewXXX" routines do.  The
 *	  "New" routines are all going to die soon, once and for all!
 *		-cim 1/13/91
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/binary_upgrade.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_distribution_policy.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/objectaccess.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/partition.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attrdef.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_attribute_encoding.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_auth_members.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_foreign_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_partitioned_table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_subscription_rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/storage_xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/typecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_collate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"partitioning/partdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/partcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/oid_dispatch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_appendonly.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_stat_last_operation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_stat_last_shoperation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/gp_partition_template.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbsreh.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"foreign/foreign.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>             <comment type="block">/* CDB: GetMemoryChunkContext */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>MetaTrackAddUpdInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>			<name>classid</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name></type>			<name>objoid</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name></type>			<name>relowner</name></decl></parameter>,
									<parameter><decl><type><name>char</name><modifier>*</modifier></type>		<name>actionname</name></decl></parameter>,
									<parameter><decl><type><name>char</name><modifier>*</modifier></type>		<name>subtype</name></decl></parameter>,
									<parameter><decl><type><name>Relation</name></type>	<name>rel</name></decl></parameter>,
									<parameter><decl><type><name>HeapTuple</name></type>	<name>old_tuple</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AddNewRelationTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pg_class_desc</name></decl></parameter>,
								<parameter><decl><type><name>Relation</name></type> <name>new_rel_desc</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>new_rel_oid</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>new_type_oid</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>reloftype</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>relowner</name></decl></parameter>,
								<parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>,
								<parameter><decl><type><name>TransactionId</name></type> <name>relfrozenxid</name></decl></parameter>,
								<parameter><decl><type><name>TransactionId</name></type> <name>relminmxid</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name></type> <name>relacl</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ObjectAddress</name></type> <name>AddNewRelationType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>typeNamespace</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>new_rel_oid</name></decl></parameter>,
										<parameter><decl><type><name>char</name></type> <name>new_rel_kind</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>ownerid</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>new_row_type</name></decl></parameter>,
										<parameter><decl><type><name>Oid</name></type> <name>new_array_type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>RelationRemoveInheritance</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>StoreRelCheck</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ccname</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_validated</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inhcount</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_no_inherit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>StoreConstraints</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cooked_constraints</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>MergeWithExistingConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ccname</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>allow_merge</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>is_initially_valid</name></decl></parameter>,
										<parameter><decl><type><name>bool</name></type> <name>is_no_inherit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>SetRelationNumChecks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numchecks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>cookConstraint</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
							<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>raw_constraint</name></decl></parameter>,
							<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>insert_ordered_unique_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------------------------------------------------------------
 *				XXX UGLY HARD CODED BADNESS FOLLOWS XXX
 *
 *		these should all be moved to someplace in the lib/catalog
 *		module, if not obliterated first.
 * ----------------------------------------------------------------
 */</comment>


<comment type="block">/*
 * Note:
 *		Should the system special case these attributes in the future?
 *		Advantage:	consume much less space in the ATTRIBUTE relation.
 *		Disadvantage:  special cases will be all over the place.
 */</comment>

<comment type="block">/*
 * The initializers below do not include trailing variable length fields,
 * but that's OK - we're never going to reference anything beyond the
 * fixed-size portion of the structure anyway.
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name>a1</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>attname</name> <operator>=</operator> <block>{<expr><literal type="string">"ctid"</literal></expr>}</block></expr>,
	<expr><operator>.</operator><name>atttypid</name> <operator>=</operator> <name>TIDOID</name></expr>,
	<expr><operator>.</operator><name>attlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ItemPointerData</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>attnum</name> <operator>=</operator> <name>SelfItemPointerAttributeNumber</name></expr>,
	<expr><operator>.</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>atttypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>attbyval</name> <operator>=</operator> <name>false</name></expr>,
	<expr><operator>.</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>,
	<expr><operator>.</operator><name>attalign</name> <operator>=</operator> <literal type="char">'s'</literal></expr>,
	<expr><operator>.</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attislocal</name> <operator>=</operator> <name>true</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name>a2</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>attname</name> <operator>=</operator> <block>{<expr><literal type="string">"xmin"</literal></expr>}</block></expr>,
	<expr><operator>.</operator><name>atttypid</name> <operator>=</operator> <name>XIDOID</name></expr>,
	<expr><operator>.</operator><name>attlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>attnum</name> <operator>=</operator> <name>MinTransactionIdAttributeNumber</name></expr>,
	<expr><operator>.</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>atttypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>attbyval</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>,
	<expr><operator>.</operator><name>attalign</name> <operator>=</operator> <literal type="char">'i'</literal></expr>,
	<expr><operator>.</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attislocal</name> <operator>=</operator> <name>true</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name>a3</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>attname</name> <operator>=</operator> <block>{<expr><literal type="string">"cmin"</literal></expr>}</block></expr>,
	<expr><operator>.</operator><name>atttypid</name> <operator>=</operator> <name>CIDOID</name></expr>,
	<expr><operator>.</operator><name>attlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CommandId</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>attnum</name> <operator>=</operator> <name>MinCommandIdAttributeNumber</name></expr>,
	<expr><operator>.</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>atttypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>attbyval</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>,
	<expr><operator>.</operator><name>attalign</name> <operator>=</operator> <literal type="char">'i'</literal></expr>,
	<expr><operator>.</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attislocal</name> <operator>=</operator> <name>true</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name>a4</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>attname</name> <operator>=</operator> <block>{<expr><literal type="string">"xmax"</literal></expr>}</block></expr>,
	<expr><operator>.</operator><name>atttypid</name> <operator>=</operator> <name>XIDOID</name></expr>,
	<expr><operator>.</operator><name>attlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>attnum</name> <operator>=</operator> <name>MaxTransactionIdAttributeNumber</name></expr>,
	<expr><operator>.</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>atttypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>attbyval</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>,
	<expr><operator>.</operator><name>attalign</name> <operator>=</operator> <literal type="char">'i'</literal></expr>,
	<expr><operator>.</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attislocal</name> <operator>=</operator> <name>true</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name>a5</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>attname</name> <operator>=</operator> <block>{<expr><literal type="string">"cmax"</literal></expr>}</block></expr>,
	<expr><operator>.</operator><name>atttypid</name> <operator>=</operator> <name>CIDOID</name></expr>,
	<expr><operator>.</operator><name>attlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CommandId</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>attnum</name> <operator>=</operator> <name>MaxCommandIdAttributeNumber</name></expr>,
	<expr><operator>.</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>atttypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>attbyval</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>,
	<expr><operator>.</operator><name>attalign</name> <operator>=</operator> <literal type="char">'i'</literal></expr>,
	<expr><operator>.</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attislocal</name> <operator>=</operator> <name>true</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * We decided to call this attribute "tableoid" rather than say
 * "classoid" on the basis that in the future there may be more than one
 * table of a particular class/type. In any case table is still the word
 * used in SQL.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name></type> <name>a6</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>attname</name> <operator>=</operator> <block>{<expr><literal type="string">"tableoid"</literal></expr>}</block></expr>,
	<expr><operator>.</operator><name>atttypid</name> <operator>=</operator> <name>OIDOID</name></expr>,
	<expr><operator>.</operator><name>attlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>attnum</name> <operator>=</operator> <name>TableOidAttributeNumber</name></expr>,
	<expr><operator>.</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>atttypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>attbyval</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>,
	<expr><operator>.</operator><name>attalign</name> <operator>=</operator> <literal type="char">'i'</literal></expr>,
	<expr><operator>.</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attislocal</name> <operator>=</operator> <name>true</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*CDB*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>FormData_pg_attribute</name></type> <name>a8</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>attname</name> <operator>=</operator> <block>{<expr><literal type="string">"gp_segment_id"</literal></expr>}</block></expr>,
	<expr><operator>.</operator><name>atttypid</name> <operator>=</operator> <name>INT4OID</name></expr>,
	<expr><operator>.</operator><name>attlen</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>,
	<expr><operator>.</operator><name>attnum</name> <operator>=</operator> <name>GpSegmentIdAttributeNumber</name></expr>,
	<expr><operator>.</operator><name>attcacheoff</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>atttypmod</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>.</operator><name>attbyval</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attstorage</name> <operator>=</operator> <literal type="char">'p'</literal></expr>,
	<expr><operator>.</operator><name>attalign</name> <operator>=</operator> <literal type="char">'i'</literal></expr>,
	<expr><operator>.</operator><name>attnotnull</name> <operator>=</operator> <name>true</name></expr>,
	<expr><operator>.</operator><name>attislocal</name> <operator>=</operator> <name>true</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type><name><name>SysAtt</name><index>[]</index></name> <init>= <expr><block>{<expr><operator>&amp;</operator><name>a1</name></expr>, <expr><operator>&amp;</operator><name>a2</name></expr>, <expr><operator>&amp;</operator><name>a3</name></expr>, <expr><operator>&amp;</operator><name>a4</name></expr>, <expr><operator>&amp;</operator><name>a5</name></expr>, <expr><operator>&amp;</operator><name>a6</name></expr>, <expr><operator>&amp;</operator><name>a8</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This function returns a Form_pg_attribute pointer for a system attribute.
 * Note that we elog if the presented attno is invalid, which would only
 * happen if there's a problem upstream.
 */</comment>
<function><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type>
<name>SystemAttributeDefinition</name><parameter_list>(<parameter><decl><type><name>AttrNumber</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>attno</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>attno</name> <operator>&lt;</operator> <operator>-</operator><operator>(</operator><name>int</name><operator>)</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>SysAtt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid system attribute number %d"</literal></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name><name>SysAtt</name><index>[<expr><operator>-</operator><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * If the given name is a system attribute name, return a Form_pg_attribute
 * pointer for a prototype definition.  If not, return NULL.
 */</comment>
<function><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type>
<name>SystemAttributeByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>SysAtt</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>att</name> <init>= <expr><name><name>SysAtt</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>att</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* ----------------------------------------------------------------
 *				XXX END OF UGLY HARD CODED BADNESS XXX
 * ---------------------------------------------------------------- */</comment>


<comment type="block">/* ----------------------------------------------------------------
 *		heap_create		- Create an uncataloged heap relation
 *
 *		Note API change: the caller must now always provide the OID
 *		to use for the relation.  The relfilenode may (and, normally,
 *		should) be left unspecified.
 *
 *		rel-&gt;rd_rel is initialized by RelationBuildLocalRelation,
 *		and is mostly zeroes at return.
 * ----------------------------------------------------------------
 */</comment>
<function><type><name>Relation</name></type>
<name>heap_create</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>relnamespace</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>reltablespace</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>relfilenode</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>accessmtd</name></decl></parameter>,
			<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>,
			<parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>,
			<parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>shared_relation</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>mapped_relation</name></decl></parameter>,
			<parameter><decl><type><name>bool</name></type> <name>allow_system_table_mods</name></decl></parameter>,
			<parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>relfrozenxid</name></decl></parameter>,
			<parameter><decl><type><name>MultiXactId</name> <modifier>*</modifier></type><name>relminmxid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>create_storage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<comment type="block">/* The caller must have provided an OID for the relation. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't allow creating relations in pg_catalog directly, even though it
	 * is allowed to move user defined relations there. Semantics with search
	 * paths including pg_catalog are too confusing for now.
	 *
	 * But allow creating indexes on relations in pg_catalog even if
	 * allow_system_table_mods = off, upper layers already guarantee it's on a
	 * user defined relation, not a system one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>allow_system_table_mods</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><call><name>IsCatalogNamespace</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_INDEX</name><operator>)</operator> <operator>||</operator>
		 <call><name>IsToastNamespace</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call> <operator>||</operator>
		 <call><name>IsAoSegmentNamespace</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
		<call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to create \"%s.%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"System catalog modifications are currently disallowed."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>relfrozenxid</name> <operator>=</operator> <name>InvalidTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>relminmxid</name> <operator>=</operator> <name>InvalidMultiXactId</name></expr>;</expr_stmt>

	<comment type="block">/* Handle reltablespace for specific relkinds. */</comment>
	<switch>switch <condition>(<expr><name>relkind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
		<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>

			<comment type="block">/*
			 * Force reltablespace to zero if the relation has no physical
			 * storage.  This is mainly just for cleanliness' sake.
			 *
			 * Partitioned tables and indexes don't have physical storage
			 * either, but we want to keep their tablespace settings so that
			 * their children can inherit it.
			 */</comment>
			<expr_stmt><expr><name>reltablespace</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>

			<comment type="block">/*
			 * Force reltablespace to zero for sequences, since we don't
			 * support moving them around into different tablespaces.
			 */</comment>
			<expr_stmt><expr><name>reltablespace</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Decide whether to create storage. If caller passed a valid relfilenode,
	 * storage is already created, so don't do it here.  Also don't create it
	 * for relkinds without physical storage.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>RELKIND_HAS_STORAGE</name><argument_list>(<argument><expr><name>relkind</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>relfilenode</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>create_storage</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>create_storage</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<comment type="block">/*
		 * In PostgreSQL, the relation OID is used as the relfilenode initially.
		 * In GPDB, relfilenode is assigned using a separate counter. Pass '1'
		 * to RelationBuildLocalRelation() to signal that it should assign a
		 * a new value.
		 */</comment>
		<expr_stmt><expr><name>relfilenode</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Never allow a pg_class entry to explicitly specify the database's
	 * default tablespace in reltablespace; force it to zero instead. This
	 * ensures that if the database is cloned with a different default
	 * tablespace, the pg_class entry will still match where CREATE DATABASE
	 * will put the physically copied relation.
	 *
	 * Yes, this is a bit of a hack.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>reltablespace</name> <operator>==</operator> <name>MyDatabaseTableSpace</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>reltablespace</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * build the relcache entry.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>RelationBuildLocalRelation</name><argument_list>(<argument><expr><name>relname</name></expr></argument>,
									 <argument><expr><name>relnamespace</name></expr></argument>,
									 <argument><expr><name>tupDesc</name></expr></argument>,
									 <argument><expr><name>relid</name></expr></argument>,
									 <argument><expr><name>accessmtd</name></expr></argument>,
									 <argument><expr><name>relfilenode</name></expr></argument>,
									 <argument><expr><name>reltablespace</name></expr></argument>,
									 <argument><expr><name>shared_relation</name></expr></argument>,
									 <argument><expr><name>mapped_relation</name></expr></argument>,
									 <argument><expr><name>relpersistence</name></expr></argument>,
									 <argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Have the storage manager create the relation's disk file, if needed.
	 *
	 * For relations the callback creates both the main and the init fork, for
	 * indexes only the main fork is created. The other forks will be created
	 * on demand.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>create_storage</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationOpenSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
			<case>case <expr><name>RELKIND_COMPOSITE_TYPE</name></expr>:</case>
			<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<case>case <expr><name>RELKIND_PARTITIONED_INDEX</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
			<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
				<expr_stmt><expr><call><name>RelationCreateStorage</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>, <argument><expr><name>relpersistence</name></expr></argument>, <argument><expr><name>SMGR_MD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
			<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
			<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
				<expr_stmt><expr><call><name>table_relation_set_new_filenode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>,
												<argument><expr><name>relpersistence</name></expr></argument>,
												<argument><expr><name>relfrozenxid</name></expr></argument>, <argument><expr><name>relminmxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>RELKIND_AOSEGMENTS</name></expr>:</case>
			<case>case <expr><name>RELKIND_AOVISIMAP</name></expr>:</case>
			<case>case <expr><name>RELKIND_AOBLOCKDIR</name></expr>:</case>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_tableam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>table_relation_set_new_filenode</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_node</name></name></expr></argument>,
												<argument><expr><name>relpersistence</name></expr></argument>,
												<argument><expr><name>relfrozenxid</name></expr></argument>, <argument><expr><name>relminmxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * AO tables don't use the buffer manager, better to not keep the
		 * smgr open for it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RelationCloseSmgr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------------------------------------------------------------
 *		heap_create_with_catalog		- Create a cataloged relation
 *
 *		this is done in multiple steps:
 *
 *		1) CheckAttributeNamesTypes() is used to make certain the tuple
 *		   descriptor contains a valid set of attribute names and types
 *
 *		2) pg_class is opened and get_relname_relid()
 *		   performs a scan to ensure that no relation with the
 *		   same name already exists.
 *
 *		3) heap_create() is called to create the new relation on disk.
 *
 *		4) TypeCreate() is called to define a new type corresponding
 *		   to the new relation.
 *
 *		5) AddNewRelationTuple() is called to register the
 *		   relation in pg_class.
 *
 *		6) AddNewAttributeTuples() is called to register the
 *		   new relation's schema in pg_attribute.
 *
 *		7) StoreConstraints is called ()		- vadim 08/22/97
 *
 *		8) the relations are closed and the new relation's oid
 *		   is returned.
 *
 * ----------------------------------------------------------------
 */</comment>

<comment type="block">/* --------------------------------
 *		CheckAttributeNamesTypes
 *
 *		this is used to make certain the tuple descriptor contains a
 *		valid set of attribute names and datatypes.  a problem simply
 *		generates ereport(ERROR) which aborts the current transaction.
 *
 *		relkind is the relkind of the relation to be created.
 *		flags controls which datatypes are allowed, cf CheckAttributeType.
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>CheckAttributeNamesTypes</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Sanity check on column count */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>natts</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>natts</name></expr></argument> &gt;</argument_list></name> <name>MaxHeapAttributeNumber</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_COLUMNS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"tables can have at most %d columns"</literal></expr></argument>,
						<argument><expr><name>MaxHeapAttributeNumber</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * first check for collision with system attribute names
	 *
	 * Skip this for a view or type relation, since those don't have system
	 * attributes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>SystemAttributeByName</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column name \"%s\" conflicts with a system column name"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * next check for repeated attribute names
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_COLUMN</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column name \"%s\" specified more than once"</literal></expr></argument>,
								<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>j</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<comment type="block">/*
	 * next check the attribute types
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attname</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>atttypid</name></expr></argument>,
						   <argument><expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>attcollation</name></expr></argument>,
						   <argument><expr><name>NIL</name></expr></argument>, <comment type="block">/* assume we're creating a new rowtype */</comment>
						   <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		CheckAttributeType
 *
 *		Verify that the proposed datatype of an attribute is legal.
 *		This is needed mainly because there are types (and pseudo-types)
 *		in the catalogs that we do not support as elements of real tuples.
 *		We also check some other properties required of a table column.
 *
 * If the attribute is being proposed for addition to an existing table or
 * composite type, pass a one-element list of the rowtype OID as
 * containing_rowtypes.  When checking a to-be-created rowtype, it's
 * sufficient to pass NIL, because there could not be any recursive reference
 * to a not-yet-existing rowtype.
 *
 * flags is a bitmask controlling which datatypes we allow.  For the most
 * part, pseudo-types are disallowed as attribute types, but there are some
 * exceptions: ANYARRAYOID, RECORDOID, and RECORDARRAYOID can be allowed
 * in some cases.  (This works because values of those type classes are
 * self-identifying to some extent.  However, RECORDOID and RECORDARRAYOID
 * are reliably identifiable only within a session, since the identity info
 * may use a typmod that is only locally assigned.  The caller is expected
 * to know whether these cases are safe.)
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>CheckAttributeType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>atttypid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>attcollation</name></decl></parameter>,
				   <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>containing_rowtypes</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>att_typtype</name> <init>= <expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>att_typelem</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * In executor nodes, don't bother checking, as the dispatcher should've
		 * checked this already.
		 */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>att_typtype</name> <operator>==</operator> <name>TYPTYPE_PSEUDO</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We disallow pseudo-type columns, with the exception of ANYARRAY,
		 * RECORD, and RECORD[] when the caller says that those are OK.
		 *
		 * We don't need to worry about recursive containment for RECORD and
		 * RECORD[] because (a) no named composite type should be allowed to
		 * contain those, and (b) two "anonymous" record types couldn't be
		 * considered to be the same type, so infinite recursion isn't
		 * possible.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name>atttypid</name> <operator>==</operator> <name>ANYARRAYOID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHKATYPE_ANYARRAY</name><operator>)</operator><operator>)</operator> <operator>||</operator>
			  <operator>(</operator><name>atttypid</name> <operator>==</operator> <name>RECORDOID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHKATYPE_ANYRECORD</name><operator>)</operator><operator>)</operator> <operator>||</operator>
			  <operator>(</operator><name>atttypid</name> <operator>==</operator> <name>RECORDARRAYOID</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHKATYPE_ANYRECORD</name><operator>)</operator><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" has pseudo-type %s"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>att_typtype</name> <operator>==</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If it's a domain, recurse to check its base type.
		 */</comment>
		<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attcollation</name></expr></argument>,
						   <argument><expr><name>containing_rowtypes</name></expr></argument>,
						   <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>att_typtype</name> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a composite type, recurse into its attributes.
		 */</comment>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check for self-containment.  Eventually we might be able to allow
		 * this (just return without complaint, if so) but it's not clear how
		 * many other places would require anti-recursion defenses before it
		 * would be safe to allow tables to contain their own rowtype.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>list_member_oid</name><argument_list>(<argument><expr><name>containing_rowtypes</name></expr></argument>, <argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"composite type %s cannot be made a member of itself"</literal></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>containing_rowtypes</name> <operator>=</operator> <call><name>lcons_oid</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>containing_rowtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><call><name>get_typ_typrelid</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>attr</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>,
							   <argument><expr><name>containing_rowtypes</name></expr></argument>,
							   <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>containing_rowtypes</name> <operator>=</operator> <call><name>list_delete_first</name><argument_list>(<argument><expr><name>containing_rowtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>(</operator><name>att_typelem</name> <operator>=</operator> <call><name>get_element_type</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Must recurse into array types, too, in case they are composite.
		 */</comment>
		<expr_stmt><expr><call><name>CheckAttributeType</name><argument_list>(<argument><expr><name>attname</name></expr></argument>, <argument><expr><name>att_typelem</name></expr></argument>, <argument><expr><name>attcollation</name></expr></argument>,
						   <argument><expr><name>containing_rowtypes</name></expr></argument>,
						   <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This might not be strictly invalid per SQL standard, but it is pretty
	 * useless, and it cannot be dumped, so we must disallow it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>attcollation</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>type_is_collatable</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no collation was derived for column \"%s\" with collatable type %s"</literal></expr></argument>,
						<argument><expr><name>attname</name></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* MPP-6929: metadata tracking */</comment>
<comment type="block">/* --------------------------------
 *		MetaTrackAddObject
 *
 *		Track creation of object in pg_stat_last_operation. The
 *		arguments are:
 *
 *		classid		- the oid of the table containing the object, eg
 *					  "pg_class" for a relation
 *		objoid		- the oid of the object itself in the specified table
 *		relowner	- role ? user ?
 *		actionname	- generally CREATE for this case
 *		subtype		- some generic descriptive, eg TABLE for a "CREATE TABLE"
 *
 *
 * --------------------------------
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type> <name>MetaTrackAddUpdInternal</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>			<name>classid</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name></type>			<name>objoid</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name></type>			<name>relowner</name></decl></parameter>,
									<parameter><decl><type><name>char</name><modifier>*</modifier></type>		<name>actionname</name></decl></parameter>,
									<parameter><decl><type><name>char</name><modifier>*</modifier></type>		<name>subtype</name></decl></parameter>,
									<parameter><decl><type><name>Relation</name></type>	<name>rel</name></decl></parameter>,
									<parameter><decl><type><name>HeapTuple</name></type>	<name>old_tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>new_tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_stat_last_operation</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>Natts_pg_stat_last_operation</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_record_repl</name><index>[<expr><name>Natts_pg_stat_last_operation</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>uname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>aname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>roletup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>Natts_pg_stat_last_operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>new_record_repl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>Natts_pg_stat_last_operation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_stat_last_operation_classid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_stat_last_operation_objid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>aname</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aname</name></expr></argument>, <argument><expr><name>actionname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_stat_last_operation_staactionname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>aname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_stat_last_operation_stasysid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set this column to update */</comment>
	<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_stat_last_operation_stasysid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>uname</name><operator>.</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>roletup</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>,
							 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relowner</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>roletup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_authid</name></type> <name>authid_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_authid</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>roletup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>namecpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uname</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>authid_tup</name><operator>-&gt;</operator><name>rolname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>roletup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Generate numeric OID if we don't find an entry */</comment>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name>uname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><name>relowner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_stat_last_operation_stausename</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>uname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set this column to update */</comment>
	<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_stat_last_operation_stausename</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_stat_last_operation_stasubtype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set this column to update */</comment>
	<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_stat_last_operation_stasubtype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_stat_last_operation_statime</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* set this column to update */</comment>
	<expr_stmt><expr><name><name>new_record_repl</name><index>[<expr><name>Anum_pg_stat_last_operation_statime</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>old_tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>old_tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>values</name></expr></argument>,
									  <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>new_record_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>old_tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>new_tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>old_tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>new_tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function> <comment type="block">/* end MetaTrackAddUpdInternal */</comment>


<function><type><name>void</name></type> <name>MetaTrackAddObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>		<name>classid</name></decl></parameter>, 
						<parameter><decl><type><name>Oid</name></type>		<name>objoid</name></decl></parameter>, 
						<parameter><decl><type><name>Oid</name></type>		<name>relowner</name></decl></parameter>,
						<parameter><decl><type><name>char</name><modifier>*</modifier></type>	<name>actionname</name></decl></parameter>,
						<parameter><decl><type><name>char</name><modifier>*</modifier></type>	<name>subtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>StatLastShOpRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>StatLastOpRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>MetaTrackAddUpdInternal</name><argument_list>(<argument><expr><name>classid</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>relowner</name></expr></argument>,
							<argument><expr><name>actionname</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>,
							<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*	CommandCounterIncrement(); */</comment>

</block_content>}</block></function> <comment type="block">/* end MetaTrackAddObject */</comment>

<function><type><name>void</name></type> <name>MetaTrackUpdObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>		<name>classid</name></decl></parameter>, 
						<parameter><decl><type><name>Oid</name></type>		<name>objoid</name></decl></parameter>, 
						<parameter><decl><type><name>Oid</name></type>		<name>relowner</name></decl></parameter>,
						<parameter><decl><type><name>char</name><modifier>*</modifier></type>	<name>actionname</name></decl></parameter>,
						<parameter><decl><type><name>char</name><modifier>*</modifier></type>	<name>subtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>StatLastShOpRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_shoperation_classid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_shoperation_objid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_shoperation_staactionname</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
					<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>actionname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								  <argument><expr><name>StatLastShOpClassidObjidStaactionnameIndexId</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>StatLastOpRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_operation_classid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_operation_objid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_operation_staactionname</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
					<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>actionname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								  <argument><expr><name>StatLastOpClassidObjidStaactionnameIndexId</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* should be a unique index - only 1 answer... */</comment>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MetaTrackAddUpdInternal</name><argument_list>(<argument><expr><name>classid</name></expr></argument>, <argument><expr><name>objoid</name></expr></argument>, <argument><expr><name>relowner</name></expr></argument>,
								<argument><expr><name>actionname</name></expr></argument>, <argument><expr><name>subtype</name></expr></argument>,
								<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ii</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add it if it didn't already exist */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ii</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MetaTrackAddObject</name><argument_list>(<argument><expr><name>classid</name></expr></argument>, 
						   <argument><expr><name>objoid</name></expr></argument>, 
						   <argument><expr><name>relowner</name></expr></argument>,
						   <argument><expr><name>actionname</name></expr></argument>,
						   <argument><expr><name>subtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

</block_content>}</block></function> <comment type="block">/* end MetaTrackUpdObject */</comment>
<function><type><name>void</name></type> <name>MetaTrackDropObject</name><parameter_list>(<parameter><decl><type><name>Oid</name></type>		<name>classid</name></decl></parameter>, 
						 <parameter><decl><type><name>Oid</name></type>		<name>objoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsSharedRelation</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* DELETE FROM pg_stat_last_shoperation WHERE classid = :1 AND objid = :2 */</comment>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>StatLastShOpRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_shoperation_classid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_shoperation_objid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								  <argument><expr><name>StatLastShOpClassidObjidStaactionnameIndexId</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* DELETE FROM pg_stat_last_operation WHERE classid = :1 AND objid = :2 */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>StatLastOpRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_operation_classid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>classid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_stat_last_operation_objid</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>objoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>desc</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>,
								  <argument><expr><name>StatLastOpClassidObjidStaactionnameIndexId</name></expr></argument>,
								  <argument><expr><name>true</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function> <comment type="block">/* end MetaTrackDropObject */</comment>

<comment type="block">/*
 * InsertPgAttributeTuple
 *		Construct and insert a new tuple in pg_attribute.
 *
 * Caller has already opened and locked pg_attribute.  new_attribute is the
 * attribute to insert.  attcacheoff is always initialized to -1, attacl and
 * attoptions are always initialized to NULL.
 *
 * indstate is the index state for CatalogTupleInsertWithInfo.  It can be
 * passed as NULL, in which case we'll fetch the necessary info.  (Don't do
 * this when inserting multiple attributes, because it's a tad more
 * expensive.)
 */</comment>
<function><type><name>void</name></type>
<name>InsertPgAttributeTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pg_attribute_rel</name></decl></parameter>,
					   <parameter><decl><type><name>Form_pg_attribute</name></type> <name>new_attribute</name></decl></parameter>,
					   <parameter><decl><type><name>CatalogIndexState</name></type> <name>indstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/* This is a tad tedious, but way cleaner than what we used to do... */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>new_attribute</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_atttypid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attstattarget</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attstattarget</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attndims</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attndims</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attcacheoff</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_atttypmod</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attbyval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attstorage</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attstorage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attalign</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attnotnull</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attnotnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_atthasdef</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>atthasdef</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_atthasmissing</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attidentity</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attidentity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attgenerated</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attgenerated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attisdropped</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attisdropped</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attislocal</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attislocal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attinhcount</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attinhcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attribute_attcollation</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>new_attribute</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* start out with empty permissions and empty options */</comment>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_attribute_attacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_attribute_attoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_attribute_attfdwoptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_attribute_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finally insert the new tuple, update the indexes, and clean up */</comment>
	<if_stmt><if>if <condition>(<expr><name>indstate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleInsertWithInfo</name><argument_list>(<argument><expr><name>pg_attribute_rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>, <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_attribute_rel</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		AddNewAttributeTuples
 *
 *		this registers the new relation's schema by adding
 *		tuples to pg_attribute.
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddNewAttributeTuples</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>new_rel_oid</name></decl></parameter>,
					  <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
					  <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatalogIndexState</name></type> <name>indstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
				<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * open pg_attribute and its indexes.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indstate</name> <operator>=</operator> <call><name>CatalogOpenIndexes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * First we add the user attributes.  This is also a convenient place to
	 * add dependencies on their datatypes and collations.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>natts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>attr</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Fill in the correct relation OID */</comment>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attrelid</name></name> <operator>=</operator> <name>new_rel_oid</name></expr>;</expr_stmt>
		<comment type="block">/* Make sure this is OK, too */</comment>
		<expr_stmt><expr><name><name>attr</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>InsertPgAttributeTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>attr</name></expr></argument>, <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add dependency info */</comment>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>new_rel_oid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The default collation is pinned, so don't bother recording it */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>CollationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>attr</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Next we add the system attributes.  Skip OID if rel has no OIDs. Skip
	 * all for a view or type relation.  We don't bother with making datatype
	 * dependencies here, since presumably all these types are pinned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator> <name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>SysAtt</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FormData_pg_attribute</name></type> <name>attStruct</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>attStruct</name></expr></argument>, <argument><expr><name><name>SysAtt</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FormData_pg_attribute</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Fill in the correct relation OID in the copied tuple */</comment>
			<expr_stmt><expr><name><name>attStruct</name><operator>.</operator><name>attrelid</name></name> <operator>=</operator> <name>new_rel_oid</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>InsertPgAttributeTuple</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>attStruct</name></expr></argument>, <argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * clean up
	 */</comment>
	<expr_stmt><expr><call><name>CatalogCloseIndexes</name><argument_list>(<argument><expr><name>indstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		InsertPgClassTuple
 *
 *		Construct and insert a new tuple in pg_class.
 *
 * Caller has already opened and locked pg_class.
 * Tuple data is taken from new_rel_desc-&gt;rd_rel, except for the
 * variable-width fields which are not present in a cached reldesc.
 * relacl and reloptions are passed in Datum form (to avoid having
 * to reference the data types in heap.h).  Pass (Datum) 0 to set them
 * to NULL.
 * --------------------------------
 */</comment>
<function><type><name>void</name></type>
<name>InsertPgClassTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pg_class_desc</name></decl></parameter>,
				   <parameter><decl><type><name>Relation</name></type> <name>new_rel_desc</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>new_rel_oid</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>relacl</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>rd_rel</name> <init>= <expr><name><name>new_rel_desc</name><operator>-&gt;</operator><name>rd_rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/* This is a tad tedious, but way cleaner than what we used to do... */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_oid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>new_rel_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relname</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>NameGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>rd_rel</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relnamespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_reltype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_reloftype</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reloftype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relowner</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relowner</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relam</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relam</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relfilenode</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relfilenode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_reltablespace</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relpages</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relpages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_reltuples</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relallvisible</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relallvisible</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_reltoastrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relhasindex</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relhasindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relisshared</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relpersistence</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relpersistence</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relkind</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relnatts</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relchecks</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relchecks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relhasrules</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relhasrules</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relhastriggers</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relrowsecurity</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relforcerowsecurity</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relforcerowsecurity</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relhassubclass</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relhassubclass</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relispopulated</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relispopulated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relreplident</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relreplident</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relispartition</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relrewrite</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relrewrite</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relfrozenxid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>TransactionIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relminmxid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>MultiXactIdGetDatum</name><argument_list>(<argument><expr><name><name>rd_rel</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>relacl</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>relacl</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_class_relacl</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>reloptions</name> <operator>!=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>reloptions</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_class_reloptions</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* relpartbound is set by updating this tuple, if necessary */</comment>
	<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finally insert the new tuple, update the indexes, and clean up */</comment>
	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		AddNewRelationTuple
 *
 *		this registers the new relation in the catalogs by
 *		adding a tuple to pg_class.
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AddNewRelationTuple</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pg_class_desc</name></decl></parameter>,
					<parameter><decl><type><name>Relation</name></type> <name>new_rel_desc</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>new_rel_oid</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>new_type_oid</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>reloftype</name></decl></parameter>,
					<parameter><decl><type><name>Oid</name></type> <name>relowner</name></decl></parameter>,
					<parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>,
					<parameter><decl><type><name>TransactionId</name></type> <name>relfrozenxid</name></decl></parameter>,
					<parameter><decl><type><name>TransactionId</name></type> <name>relminmxid</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name></type> <name>relacl</name></decl></parameter>,
					<parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>new_rel_reltup</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * first we update some of the information in our uncataloged relation's
	 * relation descriptor.
	 */</comment>
	<expr_stmt><expr><name>new_rel_reltup</name> <operator>=</operator> <name><name>new_rel_desc</name><operator>-&gt;</operator><name>rd_rel</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>relkind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
		<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
		<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
		<case>case <expr><name>RELKIND_TOASTVALUE</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOSEGMENTS</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOBLOCKDIR</name></expr>:</case>
		<case>case <expr><name>RELKIND_AOVISIMAP</name></expr>:</case>
			<comment type="block">/* The relation is real, but as yet empty */</comment>
			<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
			<comment type="block">/* Sequences always have a known size */</comment>
			<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* Views, etc, have no disk storage */</comment>
			<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relpages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relallvisible</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Initialize relfrozenxid and relminmxid */</comment>
	<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relfrozenxid</name></name> <operator>=</operator> <name>relfrozenxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relminmxid</name></name> <operator>=</operator> <name>relminmxid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relowner</name></name> <operator>=</operator> <name>relowner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>reltype</name></name> <operator>=</operator> <name>new_type_oid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>reloftype</name></name> <operator>=</operator> <name>reloftype</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name>relkind</name></expr>;</expr_stmt>

	<comment type="block">/* relispartition is always set by updating this tuple later */</comment>
	<expr_stmt><expr><name><name>new_rel_reltup</name><operator>-&gt;</operator><name>relispartition</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_rel_desc</name><operator>-&gt;</operator><name>rd_att</name><operator>-&gt;</operator><name>tdtypeid</name></name> <operator>=</operator> <name>new_type_oid</name></expr>;</expr_stmt>

	<comment type="block">/* Now build and insert the tuple */</comment>
	<expr_stmt><expr><call><name>InsertPgClassTuple</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>new_rel_desc</name></expr></argument>, <argument><expr><name>new_rel_oid</name></expr></argument>,
					   <argument><expr><name>relacl</name></expr></argument>, <argument><expr><name>reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		AddNewRelationType -
 *
 *		define a composite type corresponding to the new relation
 * --------------------------------
 */</comment>
<function><type><specifier>static</specifier> <name>ObjectAddress</name></type>
<name>AddNewRelationType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>typeName</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>typeNamespace</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>new_rel_oid</name></decl></parameter>,
				   <parameter><decl><type><name>char</name></type> <name>new_rel_kind</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>ownerid</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>new_row_type</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>new_array_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return
		<expr><call><name>TypeCreate</name><argument_list>(<argument><expr><name>new_row_type</name></expr></argument>,	<comment type="block">/* optional predetermined OID */</comment>
				   <argument><expr><name>typeName</name></expr></argument>,	<comment type="block">/* type name */</comment>
				   <argument><expr><name>typeNamespace</name></expr></argument>,	<comment type="block">/* type namespace */</comment>
				   <argument><expr><name>new_rel_oid</name></expr></argument>, <comment type="block">/* relation oid */</comment>
				   <argument><expr><name>new_rel_kind</name></expr></argument>,	<comment type="block">/* relation kind */</comment>
				   <argument><expr><name>ownerid</name></expr></argument>,		<comment type="block">/* owner's ID */</comment>
				   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,			<comment type="block">/* internal size (varlena) */</comment>
				   <argument><expr><name>TYPTYPE_COMPOSITE</name></expr></argument>,	<comment type="block">/* type-type (composite) */</comment>
				   <argument><expr><name>TYPCATEGORY_COMPOSITE</name></expr></argument>,	<comment type="block">/* type-category (ditto) */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* composite types are never preferred */</comment>
				   <argument><expr><name>DEFAULT_TYPDELIM</name></expr></argument>,	<comment type="block">/* default array delimiter */</comment>
				   <argument><expr><name>F_RECORD_IN</name></expr></argument>, <comment type="block">/* input procedure */</comment>
				   <argument><expr><name>F_RECORD_OUT</name></expr></argument>,	<comment type="block">/* output procedure */</comment>
				   <argument><expr><name>F_RECORD_RECV</name></expr></argument>,	<comment type="block">/* receive procedure */</comment>
				   <argument><expr><name>F_RECORD_SEND</name></expr></argument>,	<comment type="block">/* send procedure */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodin procedure - none */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodout procedure - none */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* analyze procedure - default */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* array element type - irrelevant */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* this is not an array type */</comment>
				   <argument><expr><name>new_array_type</name></expr></argument>,	<comment type="block">/* array type if any */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* domain base type - irrelevant */</comment>
				   <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* default value - none */</comment>
				   <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* default binary representation */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* passed by reference */</comment>
				   <argument><expr><literal type="char">'d'</literal></expr></argument>,			<comment type="block">/* alignment - must be the largest! */</comment>
				   <argument><expr><literal type="char">'x'</literal></expr></argument>,			<comment type="block">/* fully TOASTable */</comment>
				   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,			<comment type="block">/* typmod */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* array dimensions for typBaseType */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* Type NOT NULL */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</return> <comment type="block">/* rowtypes never have a collation */</comment>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		heap_create_with_catalog
 *
 *		creates a new cataloged relation.  see comments above.
 *
 * Arguments:
 *	relname: name to give to new rel
 *	relnamespace: OID of namespace it goes in
 *	reltablespace: OID of tablespace it goes in
 *	relid: OID to assign to new rel, or InvalidOid to select a new OID
 *	reltypeid: OID to assign to rel's rowtype, or InvalidOid to select one
 *	reloftypeid: if a typed table, OID of underlying type; else InvalidOid
 *	ownerid: OID of new rel's owner
 *	tupdesc: tuple descriptor (source of column definitions)
 *	cooked_constraints: list of precooked check constraints and defaults
 *	relkind: relkind for new rel
 *	relpersistence: rel's persistence status (permanent, temp, or unlogged)
 *	shared_relation: true if it's to be a shared relation
 *	mapped_relation: true if the relation will use the relfilenode map
 *	oncommit: ON COMMIT marking (only relevant if it's a temp table)
 *	reloptions: reloptions in Datum form, or (Datum) 0 if none
 *	use_user_acl: true if should look for user-defined default permissions;
 *		if false, relacl is always set NULL
 *	allow_system_table_mods: true to allow creation in system namespaces
 *	is_internal: is this a system-generated catalog?
 *  valid_opts: Validate the reloptions or not?
 *
 * Output parameters:
 *	typaddress: if not null, gets the object address of the new pg_type entry
 *
 * Returns the OID of the new relation
 * --------------------------------
 */</comment>
<function><type><name>Oid</name></type>
<name>heap_create_with_catalog</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>relnamespace</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>reltablespace</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>reltypeid</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>reloftypeid</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>ownerid</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>accessmtd</name></decl></parameter>,
						 <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
						 <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cooked_constraints</name></decl></parameter>,
						 <parameter><decl><type><name>char</name></type> <name>relkind</name></decl></parameter>,
						 <parameter><decl><type><name>char</name></type> <name>relpersistence</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>shared_relation</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>mapped_relation</name></decl></parameter>,
						 <parameter><decl><type><name>OnCommitAction</name></type> <name>oncommit</name></decl></parameter>,
                         <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>GpPolicy</name></name> <modifier>*</modifier></type><name>policy</name></decl></parameter>,
						 <parameter><decl><type><name>Datum</name></type> <name>reloptions</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>use_user_acl</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>allow_system_table_mods</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>,
						 <parameter><decl><type><name>Oid</name></type> <name>relrewrite</name></decl></parameter>,
						 <parameter><decl><type><name>ObjectAddress</name> <modifier>*</modifier></type><name>typaddress</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>valid_opts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>new_rel_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Acl</name>		   <modifier>*</modifier></type><name>relacl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>existing_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>old_type_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>new_type_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>new_type_addr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>new_array_oid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>relfrozenxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>relminmxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relarrayname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>pg_class_desc</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * sanity checks
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call> <operator>||</operator> <call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/*
	 * Validate proposed tupdesc for the desired relkind.  If
	 * allow_system_table_mods is on, allow ANYARRAY to be used; this is a
	 * hack to allow creating pg_statistic and cloning it during VACUUM FULL.
	 */</comment>
	<expr_stmt><expr><call><name>CheckAttributeNamesTypes</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>allow_system_table_mods</name></expr> ?</condition><then> <expr><name>CHKATYPE_ANYARRAY</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This would fail later on anyway, if the relation already exists.  But
	 * by catching it here we can emit a nicer error message.
	 */</comment>
	<expr_stmt><expr><name>existing_relid</name> <operator>=</operator> <call><name>get_relname_relid</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>existing_relid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_TABLE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"relation \"%s\" already exists"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Since we are going to create a rowtype as well, also check for
	 * collision with an existing type name.  If there is one and it's an
	 * autogenerated array, we can rename it out of the way; otherwise we can
	 * at least give a good error message.
	 */</comment>
	<expr_stmt><expr><name>old_type_oid</name> <operator>=</operator> <call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>TYPENAMENSP</name></expr></argument>, <argument><expr><name>Anum_pg_type_oid</name></expr></argument>,
								   <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>old_type_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>moveArrayTypeName</name><argument_list>(<argument><expr><name>old_type_oid</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type \"%s\" already exists"</literal></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"A relation has an associated type of the same name, "</literal>
							 <literal type="string">"so you must use a name that doesn't conflict "</literal>
							 <literal type="string">"with any existing type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Shared relations must be in pg_global (last-ditch check)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shared_relation</name> <operator>&amp;&amp;</operator> <name>reltablespace</name> <operator>!=</operator> <name>GLOBALTABLESPACE_OID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"shared relations must be placed in pg_global tablespace"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Allocate an OID for the relation, unless we were told what to use.
	 *
	 * In PostgreSQL, the OID will be the relfilenode as well, but in GPDB
	 * that is assigned separately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>GetNewOidForRelation</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>ClassOidIndexId</name></expr></argument>, <argument><expr><name>Anum_pg_class_oid</name></expr></argument>,
									 <argument><expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine the relation's initial permissions.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>use_user_acl</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>relkind</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
			<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
			<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
			<case>case <expr><name>RELKIND_FOREIGN_TABLE</name></expr>:</case>
			<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
				<expr_stmt><expr><name>relacl</name> <operator>=</operator> <call><name>get_user_default_acl</name><argument_list>(<argument><expr><name>OBJECT_TABLE</name></expr></argument>, <argument><expr><name>ownerid</name></expr></argument>,
											  <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
				<expr_stmt><expr><name>relacl</name> <operator>=</operator> <call><name>get_user_default_acl</name><argument_list>(<argument><expr><name>OBJECT_SEQUENCE</name></expr></argument>, <argument><expr><name>ownerid</name></expr></argument>,
											  <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>relacl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>relacl</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Create the relcache entry (mostly dummy at this point) and the physical
	 * disk file.  (If we fail further down, it's the smgr's responsibility to
	 * remove the disk file again.)
	 */</comment>
	<expr_stmt><expr><name>new_rel_desc</name> <operator>=</operator> <call><name>heap_create</name><argument_list>(<argument><expr><name>relname</name></expr></argument>,
							   <argument><expr><name>relnamespace</name></expr></argument>,
							   <argument><expr><name>reltablespace</name></expr></argument>,
							   <argument><expr><name>relid</name></expr></argument>,
							   <argument><expr><name>InvalidOid</name></expr></argument>,
							   <argument><expr><name>accessmtd</name></expr></argument>,
							   <argument><expr><name>tupdesc</name></expr></argument>,
							   <argument><expr><name>relkind</name></expr></argument>,
							   <argument><expr><name>relpersistence</name></expr></argument>,
							   <argument><expr><name>shared_relation</name></expr></argument>,
							   <argument><expr><name>mapped_relation</name></expr></argument>,
							   <argument><expr><name>allow_system_table_mods</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>relfrozenxid</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>relminmxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>==</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>new_rel_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>new_rel_desc</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrewrite</name></name> <operator>=</operator> <name>relrewrite</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decide whether to create an array type over the relation's rowtype. We
	 * do not create any array types for system catalogs (ie, those made
	 * during initdb). We do not create them where the use of a relation as
	 * such is an implementation detail: toast tables, sequences and indexes.
	 *
	 * Also not for the auxiliary heaps created for bitmap indexes or append-
	 * only tables.
	 *
	 * GPDB:
	 * In Greenplum, if user using the GPDB's create partition table syntax,
	 * it may failed with typename collision since the child partition table
	 * name is generated from user input, which may cause relarrayname exceed
	 * NAMEDATALEN and gets truncated. Then the name may same with other child
	 * table's.
	 *
	 * The below code is different from upstream since we preassign type
	 * OID first on QD and use the name as key to retrieve the pre-assigned
	 * OID from QE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name>  <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>new_rel_desc</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
							  <name>relkind</name> <operator>==</operator> <name>RELKIND_VIEW</name> <operator>||</operator>
							  <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
							  <name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
							  <name>relkind</name> <operator>==</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>||</operator>
							  <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>relnamespace</name> <operator>!=</operator> <name>PG_BITMAPINDEX_NAMESPACE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* OK, so pre-assign a type OID for the array type */</comment>
		<expr_stmt><expr><name>relarrayname</name> <operator>=</operator> <call><name>makeArrayTypeName</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we are expected to get a preassigned Oid but receive InvalidOid,
		 * get a new Oid. This can happen during upgrades from GPDB4 to 5 where
		 * array types over relation rowtypes were introduced so there are no
		 * pre-existing array types to dump from the old cluster
		 */</comment>
		<expr_stmt><expr><name>new_array_oid</name> <operator>=</operator> <call><name>AssignTypeArrayOid</name><argument_list>(<argument><expr><name>relarrayname</name></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Since defining a relation also defines a complex type, we add a new
	 * system type corresponding to the new relation.  The OID of the type can
	 * be preselected by the caller, but if reltypeid is InvalidOid, we'll
	 * generate a new OID for it.
	 *
	 * NOTE: we could get a unique-index failure here, in case someone else is
	 * creating the same type name in parallel but hadn't committed yet when
	 * we checked for a duplicate name above.
	 */</comment>
	<expr_stmt><expr><name>new_type_addr</name> <operator>=</operator> <call><name>AddNewRelationType</name><argument_list>(<argument><expr><name>relname</name></expr></argument>,
									   <argument><expr><name>relnamespace</name></expr></argument>,
									   <argument><expr><name>relid</name></expr></argument>,
									   <argument><expr><name>relkind</name></expr></argument>,
									   <argument><expr><name>ownerid</name></expr></argument>,
									   <argument><expr><name>reltypeid</name></expr></argument>,
									   <argument><expr><name>new_array_oid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_type_oid</name> <operator>=</operator> <name><name>new_type_addr</name><operator>.</operator><name>objectId</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>typaddress</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>typaddress</name> <operator>=</operator> <name>new_type_addr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Now make the array type if wanted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>new_array_oid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>relarrayname</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>relarrayname</name> <operator>=</operator> <call><name>makeArrayTypeName</name><argument_list>(<argument><expr><name>relname</name></expr></argument>, <argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>TypeCreate</name><argument_list>(<argument><expr><name>new_array_oid</name></expr></argument>,	<comment type="block">/* force the type's OID to this */</comment>
				   <argument><expr><name>relarrayname</name></expr></argument>,	<comment type="block">/* Array type name */</comment>
				   <argument><expr><name>relnamespace</name></expr></argument>,	<comment type="block">/* Same namespace as parent */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* Not composite, no relationOid */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* relkind, also N/A here */</comment>
				   <argument><expr><name>ownerid</name></expr></argument>,		<comment type="block">/* owner's ID */</comment>
				   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,			<comment type="block">/* Internal size (varlena) */</comment>
				   <argument><expr><name>TYPTYPE_BASE</name></expr></argument>,	<comment type="block">/* Not composite - typelem is */</comment>
				   <argument><expr><name>TYPCATEGORY_ARRAY</name></expr></argument>,	<comment type="block">/* type-category (array) */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* array types are never preferred */</comment>
				   <argument><expr><name>DEFAULT_TYPDELIM</name></expr></argument>,	<comment type="block">/* default array delimiter */</comment>
				   <argument><expr><name>F_ARRAY_IN</name></expr></argument>,	<comment type="block">/* array input proc */</comment>
				   <argument><expr><name>F_ARRAY_OUT</name></expr></argument>, <comment type="block">/* array output proc */</comment>
				   <argument><expr><name>F_ARRAY_RECV</name></expr></argument>,	<comment type="block">/* array recv (bin) proc */</comment>
				   <argument><expr><name>F_ARRAY_SEND</name></expr></argument>,	<comment type="block">/* array send (bin) proc */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodin procedure - none */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* typmodout procedure - none */</comment>
				   <argument><expr><name>F_ARRAY_TYPANALYZE</name></expr></argument>,	<comment type="block">/* array analyze procedure */</comment>
				   <argument><expr><name>new_type_oid</name></expr></argument>,	<comment type="block">/* array element type - the rowtype */</comment>
				   <argument><expr><name>true</name></expr></argument>,		<comment type="block">/* yes, this is an array type */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* this has no array type */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* domain base type - irrelevant */</comment>
				   <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* default value - none */</comment>
				   <argument><expr><name>NULL</name></expr></argument>,		<comment type="block">/* default binary representation */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* passed by reference */</comment>
				   <argument><expr><literal type="char">'d'</literal></expr></argument>,			<comment type="block">/* alignment - must be the largest! */</comment>
				   <argument><expr><literal type="char">'x'</literal></expr></argument>,			<comment type="block">/* fully TOASTable */</comment>
				   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,			<comment type="block">/* typmod */</comment>
				   <argument><expr><literal type="number">0</literal></expr></argument>,			<comment type="block">/* array dimensions for typBaseType */</comment>
				   <argument><expr><name>false</name></expr></argument>,		<comment type="block">/* Type NOT NULL */</comment>
				   <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* rowtypes never have a collation */</comment>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relarrayname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this is an append-only relation, add an entry in pg_appendonly.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>new_rel_desc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StdRdOptions</name> <modifier>*</modifier></type><name>stdRdOptions</name> <init>= <expr><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator><call><name>default_reloptions</name><argument_list>(<argument><expr><name>reloptions</name></expr></argument>,
																	 <argument><expr><operator>!</operator><name>valid_opts</name></expr></argument>,
																	 <argument><expr><name>RELOPT_KIND_APPENDOPTIMIZED</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>InsertAppendOnlyEntry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>,
							  <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>blocksize</name></name></expr></argument>,
							  <argument><expr><name>gp_safefswritesize</name></expr></argument>,
							  <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>compresslevel</name></name></expr></argument>,
							  <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>checksum</name></name></expr></argument>,
							  <argument><expr><call><name>RelationIsAoCols</name><argument_list>(<argument><expr><name>new_rel_desc</name></expr></argument>)</argument_list></call></expr></argument>,
							  <argument><expr><name><name>stdRdOptions</name><operator>-&gt;</operator><name>compresstype</name></name></expr></argument>,
							  <argument><expr><name>InvalidOid</name></expr></argument>,
							  <argument><expr><name>InvalidOid</name></expr></argument>,
							  <argument><expr><name>InvalidOid</name></expr></argument>,
							  <argument><expr><name>InvalidOid</name></expr></argument>,
							  <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * now create an entry in pg_class for the relation.
	 *
	 * NOTE: we could get a unique-index failure here, in case someone else is
	 * creating the same relation name in parallel but hadn't committed yet
	 * when we checked for a duplicate name above.
	 */</comment>
	<expr_stmt><expr><call><name>AddNewRelationTuple</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>,
						<argument><expr><name>new_rel_desc</name></expr></argument>,
						<argument><expr><name>relid</name></expr></argument>,
						<argument><expr><name>new_type_oid</name></expr></argument>,
						<argument><expr><name>reloftypeid</name></expr></argument>,
						<argument><expr><name>ownerid</name></expr></argument>,
						<argument><expr><name>relkind</name></expr></argument>,
						<argument><expr><name>relfrozenxid</name></expr></argument>,
						<argument><expr><name>relminmxid</name></expr></argument>,
						<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>relacl</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><name>reloptions</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * now add tuples to pg_attribute for the attributes in our new relation.
	 */</comment>
	<expr_stmt><expr><call><name>AddNewAttributeTuples</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>new_rel_desc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>relkind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a dependency link to force the relation to be deleted if its
	 * namespace is.  Also make a dependency link to its owner, as well as
	 * dependencies for any roles mentioned in the default ACL.
	 *
	 * For composite types, these dependencies are tracked for the pg_type
	 * entry, so we needn't record them here.  Likewise, TOAST tables don't
	 * need a namespace dependency (they live in a pinned namespace) nor an
	 * owner dependency (they depend indirectly through the parent table), nor
	 * should they have any ACL entries.  The same applies for extension
	 * dependencies.
	 *
	 * Also, skip this in bootstrap mode, since we don't make dependencies
	 * while bootstrapping.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
		<name>relkind</name> <operator>!=</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>,
					<decl><type ref="prev"/><name>referenced</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>NamespaceRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relnamespace</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>recordDependencyOnOwner</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>ownerid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>recordDependencyOnNewAcl</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ownerid</name></expr></argument>, <argument><expr><name>relacl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>recordDependencyOnCurrentExtension</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>reloftypeid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>TypeRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>reloftypeid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Make a dependency link to force the relation to be deleted if its
		 * access method is. Do this only for relation, materialized views and
		 * partitioned tables.
		 *
		 * No need to add an explicit dependency for the toast table, as the
		 * main table depends on it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			<name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			<name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AccessMethodRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>accessmtd</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Post creation hook for new relation */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHookArg</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Store any supplied constraints and defaults.
	 *
	 * NB: this may do a CommandCounterIncrement and rebuild the relcache
	 * entry, so the relation must be valid and self-consistent at this point.
	 * In particular, there are not yet constraints and defaults anywhere.
	 */</comment>
	<expr_stmt><expr><call><name>StoreConstraints</name><argument_list>(<argument><expr><name>new_rel_desc</name></expr></argument>, <argument><expr><name>cooked_constraints</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there's a special on-commit action, remember it
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oncommit</name> <operator>!=</operator> <name>ONCOMMIT_NOOP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>register_on_commit_action</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>oncommit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * CDB: If caller gave us a distribution policy, store the distribution
	 * key column list in the gp_distribution_policy catalog and attach a
	 * copy to the relcache entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>policy</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator>
			 <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator>
			 <name>IsBinaryUpgrade</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			   <name>relkind</name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>||</operator>
			   <name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
			   <name>relkind</name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><call><name>GetMemoryChunkContext</name><argument_list>(<argument><expr><name>new_rel_desc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>new_rel_desc</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name> <operator>=</operator> <call><name>GpPolicyCopy</name><argument_list>(<argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GpPolicyStore</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>policy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition> <comment type="block">/* MPP-11313: */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>doIt</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>subtyp</name> <init>= <expr><literal type="string">"TABLE"</literal></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name>relkind</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RELKIND_PARTITIONED_TABLE</name></expr>:</case>
			<case>case <expr><name>RELKIND_RELATION</name></expr>:</case>
				<break>break;</break>
			<case>case <expr><name>RELKIND_INDEX</name></expr>:</case>
				<expr_stmt><expr><name>subtyp</name> <operator>=</operator> <literal type="string">"INDEX"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RELKIND_SEQUENCE</name></expr>:</case>
				<expr_stmt><expr><name>subtyp</name> <operator>=</operator> <literal type="string">"SEQUENCE"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RELKIND_VIEW</name></expr>:</case>
				<expr_stmt><expr><name>subtyp</name> <operator>=</operator> <literal type="string">"VIEW"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>RELKIND_MATVIEW</name></expr>:</case>
				<expr_stmt><expr><name>subtyp</name> <operator>=</operator> <literal type="string">"MATVIEW"</literal></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><name>doIt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<comment type="block">/* MPP-7576: don't track internal namespace tables */</comment>
		<switch>switch <condition>(<expr><name>relnamespace</name></expr>)</condition> 
		<block>{<block_content>
			<case>case <expr><name>PG_CATALOG_NAMESPACE</name></expr>:</case>
				<comment type="block">/* MPP-7773: don't track objects in system namespace
				 * if modifying system tables (eg during upgrade)  
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>allowSystemTableMods</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>doIt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

			<case>case <expr><name>PG_TOAST_NAMESPACE</name></expr>:</case>
			<case>case <expr><name>PG_BITMAPINDEX_NAMESPACE</name></expr>:</case>
			<case>case <expr><name>PG_AOSEGMENT_NAMESPACE</name></expr>:</case>
				<expr_stmt><expr><name>doIt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* MPP-7572: not valid if in any temporary namespace */</comment>
		<if_stmt><if>if <condition>(<expr><name>doIt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>doIt</name> <operator>=</operator> <operator>(</operator><operator>!</operator><operator>(</operator><call><name>isAnyTempNamespace</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* MPP-6929: metadata tracking */</comment>
		<if_stmt><if>if <condition>(<expr><name>doIt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>MetaTrackAddObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
							   <argument><expr><name>relid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <comment type="block">/* not ownerid */</comment>
							   <argument><expr><literal type="string">"CREATE"</literal></expr></argument>, <argument><expr><name>subtyp</name></expr></argument>
					)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * ok, the relation has been cataloged, so close our relations and return
	 * the OID of the newly created relation.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>new_rel_desc</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* do not unlock till end of xact */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>relid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		RelationRemoveInheritance
 *
 * Formerly, this routine checked for child relations and aborted the
 * deletion if any were found.  Now we rely on the dependency mechanism
 * to check for or delete child relations.  By the time we get here,
 * there are no children and we need only remove any pg_inherits rows
 * linking this relation to its parent(s).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationRemoveInheritance</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>catalogRelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>catalogRelation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_inherits_inhrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>InheritsRelidSeqnoIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>catalogRelation</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		DeleteRelationTuple
 *
 * Remove pg_class row for the given relid.
 *
 * Note: this is shared by relation deletion and index deletion.  It's
 * not intended for use anyplace else.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteRelationTuple</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_class_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/* Grab an appropriate lock on the pg_class relation */</comment>
	<expr_stmt><expr><name>pg_class_desc</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* delete the relation tuple from pg_class, and finish up */</comment>
	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		DeleteAttributeTuples
 *
 * Remove pg_attribute rows for the given relid.
 *
 * Note: this is shared by relation deletion and index deletion.  It's
 * not intended for use anyplace else.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteAttributeTuples</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttup</name></decl>;</decl_stmt>

	<comment type="block">/* Grab an appropriate lock on the pg_attribute relation */</comment>
	<expr_stmt><expr><name>attrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use the index to scan only attributes of the target relation */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete all the matching tuples */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>atttup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atttup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Clean up after the scan */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		DeleteSystemAttributeTuples
 *
 * Remove pg_attribute rows for system columns of the given relid.
 *
 * Note: this is only used when converting a table to a view.  Views don't
 * have system columns, so we should remove them from pg_attribute.
 */</comment>
<function><type><name>void</name></type>
<name>DeleteSystemAttributeTuples</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttup</name></decl>;</decl_stmt>

	<comment type="block">/* Grab an appropriate lock on the pg_attribute relation */</comment>
	<expr_stmt><expr><name>attrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use the index to scan only system attributes of the target relation */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attribute_attnum</name></expr></argument>,
				<argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2LE</name></expr></argument>,
				<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>AttributeRelidNumIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete all the matching tuples */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>atttup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atttup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Clean up after the scan */</comment>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		RemoveAttributeById
 *
 * This is the guts of ALTER TABLE DROP COLUMN: actually mark the attribute
 * deleted in pg_attribute.  We also remove pg_statistic entries for it.
 * (Everything else needed, such as getting rid of any pg_attrdef entry,
 * is handled by dependency.c.)
 */</comment>
<function><type><name>void</name></type>
<name>RemoveAttributeById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attr_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>newattname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab an exclusive lock on the target table, which we will NOT release
	 * until end of transaction.  (In the simple case where we are directly
	 * dropping this column, ATExecDropColumn already did this ... but when
	 * cascading from a drop of some other object, we may not have any lock.)
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
			 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* System attribute (probably OID) ... just delete the row */</comment>

		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Dropping user attributes is lots harder */</comment>

		<comment type="block">/* Mark the attribute as dropped */</comment>
		<expr_stmt><expr><name><name>attStruct</name><operator>-&gt;</operator><name>attisdropped</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set the type OID to invalid.  A dropped attribute's type link
		 * cannot be relied on (once the attribute is dropped, the type might
		 * be too). Fortunately we do not need the type row --- the only
		 * really essential information is the type's typlen and typalign,
		 * which are preserved in the attribute's attlen and attalign.  We set
		 * atttypid to zero here as a means of catching code that incorrectly
		 * expects it to be valid.
		 */</comment>
		<expr_stmt><expr><name><name>attStruct</name><operator>-&gt;</operator><name>atttypid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<comment type="block">/* Remove any NOT NULL constraint the column may have */</comment>
		<expr_stmt><expr><name><name>attStruct</name><operator>-&gt;</operator><name>attnotnull</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* We don't want to keep stats for it anymore */</comment>
		<expr_stmt><expr><name><name>attStruct</name><operator>-&gt;</operator><name>attstattarget</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Unset this so no one tries to look up the generation expression */</comment>
		<expr_stmt><expr><name><name>attStruct</name><operator>-&gt;</operator><name>attgenerated</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Change the column name to something that isn't likely to conflict
		 */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>newattname</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>newattname</name></expr></argument>)</argument_list></sizeof></expr></argument>,
				 <argument><expr><literal type="string">"........pg.dropped.%d........"</literal></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>namestrcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>attStruct</name><operator>-&gt;</operator><name>attname</name></name><operator>)</operator></expr></argument>, <argument><expr><name>newattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clear the missing value if any */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attStruct</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name><name>valuesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>nullsAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>replacesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>

			<comment type="block">/* update the tuple - set atthasmissing and attmissingval */</comment>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>valuesAtt</name><index>[<expr><name>Anum_pg_attribute_atthasmissing</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator>
				<call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replacesAtt</name><index>[<expr><name>Anum_pg_attribute_atthasmissing</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>valuesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nullsAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replacesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Because updating the pg_attribute row will trigger a relcache flush for
	 * the target relation, we need not do anything else to notify other
	 * backends of the change.
	 */</comment>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveStatistics</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		RemoveAttrDefault
 *
 * If the specified relation/attribute has a default, remove it.
 * (If no default, raise error if complain is true, else return quietly.)
 */</comment>
<function><type><name>void</name></type>
<name>RemoveAttrDefault</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
				  <parameter><decl><type><name>DropBehavior</name></type> <name>behavior</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>complain</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>internal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrdef_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankeys</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>attrdef_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttrDefaultRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attrdef_adrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankeys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attrdef_adnum</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
				<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>attrdef_rel</name></expr></argument>, <argument><expr><name>AttrDefaultIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>scankeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There should be at most one matching tuple, but we loop anyway */</comment>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attrdef</name></type> <name>attrtuple</name> <init>= <expr><operator>(</operator><name>Form_pg_attrdef</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AttrDefaultRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>attrtuple</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>behavior</name></expr></argument>,
						<argument><expr><ternary><condition><expr><name>internal</name></expr> ?</condition><then> <expr><name>PERFORM_DELETION_INTERNAL</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrdef_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>complain</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find attrdef tuple for relation %u attnum %d"</literal></expr></argument>,
			 <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		RemoveAttrDefaultById
 *
 * Remove a pg_attrdef entry specified by OID.  This is the guts of
 * attribute-default removal.  Note it should be called via performDeletion,
 * not directly.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveAttrDefaultById</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>attrdefId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrdef_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attr_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>myrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankeys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>myrelid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>myattnum</name></decl>;</decl_stmt>

	<comment type="block">/* Grab an appropriate lock on the pg_attrdef relation */</comment>
	<expr_stmt><expr><name>attrdef_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttrDefaultRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Find the pg_attrdef tuple */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_attrdef_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>attrdefId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>attrdef_rel</name></expr></argument>, <argument><expr><name>AttrDefaultOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>scankeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find tuple for attrdef %u"</literal></expr></argument>, <argument><expr><name>attrdefId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>myrelid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attrdef</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>adrelid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>myattnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_attrdef</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>adnum</name></expr>;</expr_stmt>

	<comment type="block">/* Get an exclusive lock on the relation owning the attribute */</comment>
	<expr_stmt><expr><name>myrel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we can delete the pg_attrdef row */</comment>
	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>attrdef_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrdef_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Fix the pg_attribute row */</comment>
	<expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>myattnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
			 <argument><expr><name>myattnum</name></expr></argument>, <argument><expr><name>myrelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>atthasdef</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Our update of the pg_attribute row will force a relcache rebuild, so
	 * there's nothing else to do here.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Keep lock on attribute's rel until end of xact */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>myrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * heap_drop_with_catalog	- removes specified relation from catalogs
 *
 * Note that this routine is not responsible for dropping objects that are
 * linked to the pg_class entry via dependencies (for example, indexes and
 * constraints).  Those are deleted by the dependency-tracing logic in
 * dependency.c before control gets here.  In general, therefore, this routine
 * should never be called directly; go through performDeletion() instead.
 */</comment>
<function><type><name>void</name></type>
<name>heap_drop_with_catalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_appendonly_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>parentOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>,
				<decl><type ref="prev"/><name>defaultPartOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * To drop a partition safely, we must grab exclusive lock on its parent,
	 * because another backend might be about to execute a query on the parent
	 * table.  If it relies on previously cached partition descriptor, then it
	 * could attempt to access the just-dropped relation as its partition. We
	 * must therefore take a table lock strong enough to prevent all queries
	 * on the table from proceeding until we commit and send out a
	 * shared-cache-inval notice that will make them update their partition
	 * descriptors.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>parentOid</name> <operator>=</operator> <call><name>get_partition_parent</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is not the default partition, dropping it will change the
		 * default partition's partition constraint, so we must lock it.
		 */</comment>
		<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator> <call><name>get_default_partition_oid</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>relid</name> <operator>!=</operator> <name>defaultPartOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open and lock the relation.
	 */</comment>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>relation_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>is_appendonly_rel</name> <operator>=</operator> <call><name>RelationIsAppendOptimized</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * There can no longer be anyone *else* touching the relation, but we
	 * might still have open queries or cursors, or pending trigger events, in
	 * our own session.
	 */</comment>
	<expr_stmt><expr><call><name>CheckTableNotInUse</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="string">"DROP TABLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This effectively deletes all rows in the table, and may be done in a
	 * serializable transaction.  In that case we must record a rw-conflict in
	 * to this transaction from each transaction holding a predicate lock on
	 * the table.
	 */</comment>
	<expr_stmt><expr><call><name>CheckTableForSerializableConflictIn</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete pg_foreign_table tuple first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ForeignTableRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>FOREIGNTABLEREL</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for foreign table %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If a partitioned table, delete the pg_partitioned_table tuple.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemovePartitionKeyByRelId</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If a partitioned table, delete the gp_partition_template tuples.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveGpPartitionTemplateByRelId</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the relation being dropped is the default partition itself,
	 * invalidate its entry in pg_partitioned_table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name>defaultPartOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_default_partition_oid</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Schedule unlinking of the relation's physical files at commit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_VIEW</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_COMPOSITE_TYPE</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RelationDropStorage</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remove distribution policy, if any.
 	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_FOREIGN_TABLE</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GpPolicyRemove</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Attribute encoding
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>RemoveAttributeEncodingsByRelid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Close relcache entry, but *keep* AccessExclusiveLock (unless this is
	 * a child partition) on the relation until transaction commit.  This
	 * ensures no one else will try to do something with the doomed relation.
	 */</comment>
	<expr_stmt><expr><call><name>relation_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove any associated relation synchronization states.
	 */</comment>
	<expr_stmt><expr><call><name>RemoveSubscriptionRel</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Forget any ON COMMIT action for the rel
	 */</comment>
	<expr_stmt><expr><call><name>remove_on_commit_action</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Flush the relation from the relcache.  We want to do this before
	 * starting to remove catalog entries, just to be certain that no relcache
	 * entry rebuild will happen partway through.  (That should not really
	 * matter, since we don't do CommandCounterIncrement here, but let's be
	 * safe.)
	 */</comment>
	<expr_stmt><expr><call><name>RelationForgetRelation</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * remove inheritance information
	 */</comment>
	<expr_stmt><expr><call><name>RelationRemoveInheritance</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * delete statistics
	 */</comment>
	<expr_stmt><expr><call><name>RemoveStatistics</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * delete attribute tuples
	 */</comment>
	<expr_stmt><expr><call><name>DeleteAttributeTuples</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * delete relation tuple
	 */</comment>
	<expr_stmt><expr><call><name>DeleteRelationTuple</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If this is not the default partition, the partition constraint of
		 * the default partition has changed to include the portion of the key
		 * space previously covered by the dropped partition.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>relid</name> <operator>!=</operator> <name>defaultPartOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Invalidate the parent's relcache so that the partition is no longer
		 * included in its partition descriptor.
		 */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>parentOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* keep the lock */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * delete error log file
	 */</comment>
	<expr_stmt><expr><call><name>ErrorLogDelete</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * append-only table? delete the corresponding pg_appendonly tuple
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_appendonly_rel</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveAppendonlyEntry</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* MPP-6929: metadata tracking */</comment>
	<expr_stmt><expr><call><name>MetaTrackDropObject</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>,
						<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RelationClearMissing
 *
 * Set atthasmissing and attmissingval to false/null for all attributes
 * where they are currently set. This can be safely and usefully done if
 * the table is rewritten (e.g. by VACUUM FULL or CLUSTER) where we know there
 * are no rows left with less than a full complement of attributes.
 *
 * The caller must have an AccessExclusive lock on the relation.
 */</comment>
<function><type><name>void</name></type>
<name>RelationClearMissing</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attr_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>natts</name> <init>= <expr><call><name>RelationGetNumberOfAttributes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>attnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>repl_val</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_null</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>repl_repl</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attrtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>,
				<decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>repl_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>repl_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>repl_val</name><index>[<expr><name>Anum_pg_attribute_atthasmissing</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repl_null</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_atthasmissing</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>repl_repl</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>


	<comment type="block">/* Get a lock on pg_attribute */</comment>
	<expr_stmt><expr><name>attr_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* process each non-system attribute, including any dropped columns */</comment>
	<for>for <control>(<init><expr><name>attnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>attnum</name> <operator>&lt;=</operator> <name>natts</name></expr>;</condition> <incr><expr><name>attnum</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
				 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>attrtuple</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ignore any where atthasmissing is not true */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>attrtuple</name><operator>-&gt;</operator><name>atthasmissing</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>repl_val</name></expr></argument>, <argument><expr><name>repl_null</name></expr></argument>, <argument><expr><name>repl_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Our update of the pg_attribute rows will force a relcache rebuild, so
	 * there's nothing else to do here.
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attr_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SetAttrMissing
 *
 * Set the missing value of a single attribute. This should only be used by
 * binary upgrade. Takes an AccessExclusive lock on the relation owning the
 * attribute.
 */</comment>
<function><type><name>void</name></type>
<name>SetAttrMissing</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>valuesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nullsAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>replacesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>missingval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrrel</name></decl>,
				<decl><type ref="prev"/><name>tablerel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttup</name></decl>,
				<decl><type ref="prev"/><name>newtup</name></decl>;</decl_stmt>

	<comment type="block">/* lock the table the attribute belongs to */</comment>
	<expr_stmt><expr><name>tablerel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lock the attribute row and get the data */</comment>
	<expr_stmt><expr><name>attrrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>atttup</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %s of relation %u"</literal></expr></argument>,
			 <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get an array value from the value string */</comment>
	<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>OidFunctionCall3</name><argument_list>(<argument><expr><name>F_ARRAY_IN</name></expr></argument>,
								  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>attStruct</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>attStruct</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* update the tuple - set atthasmissing and attmissingval */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>valuesAtt</name><index>[<expr><name>Anum_pg_attribute_atthasmissing</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replacesAtt</name><index>[<expr><name>Anum_pg_attribute_atthasmissing</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>valuesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>missingval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>replacesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>newtup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up */</comment>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>tablerel</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store a default expression for column attnum of relation rel.
 *
 * Returns the OID of the new pg_attrdef tuple.
 *
 * add_column_mode must be true if we are storing the default for a new
 * attribute, and false if it's for an already existing attribute. The reason
 * for this is that the missing value must never be updated after it is set,
 * which can only be when a column is added to the table. Otherwise we would
 * in effect be changing existing tuples.
 *
 * In GPDB in add_column_mode, the QD evaluates the default expression, and
 * the QEs must use the pre-computed value. In QD, this function evaluates
 * the value - like in upstream - and returns it in
 * *missingval_p/missingIsNull_p. In the QE, the caller is expected to pass
 * the pre-computed values in missingval/missingIsNull.
 */</comment>
<function><type><name>Oid</name></type>
<name>StoreAttrDefault</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
				 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>cookedMissingVal</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>missingval_p</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>missingIsNull_p</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>add_column_mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>adbin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>adrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>attrrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>atttup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>attStruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>attgenerated</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>attrdefOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>colobject</name></decl>,
				<decl><type ref="prev"/><name>defobject</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>adrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttrDefaultRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Flatten expression to string form for storage.
	 */</comment>
	<expr_stmt><expr><name>adbin</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make the pg_attrdef entry.
	 */</comment>
	<expr_stmt><expr><name>attrdefOid</name> <operator>=</operator> <call><name>GetNewOidForAttrDefault</name><argument_list>(<argument><expr><name>adrel</name></expr></argument>, <argument><expr><name>AttrDefaultOidIndexId</name></expr></argument>,
										 <argument><expr><name>Anum_pg_attrdef_oid</name></expr></argument>,
										 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attrdef_oid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>attrdefOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attrdef_adrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attrdef_adnum</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_attrdef_adbin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>adrel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>adrel</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>defobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>AttrDefaultRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>defobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>attrdefOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>defobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>adrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* now can free some of the stuff allocated above */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>Anum_pg_attrdef_adbin</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>adbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the pg_attribute entry for the column to show that a default
	 * exists.
	 */</comment>
	<expr_stmt><expr><name>attrrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>AttributeRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>atttup</name> <operator>=</operator> <call><name>SearchSysCacheCopy2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
			 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>attStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attgenerated</name> <operator>=</operator> <name><name>attStruct</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>attStruct</name><operator>-&gt;</operator><name>atthasdef</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>defAttStruct</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ExprState</name>  <modifier>*</modifier></type><name>exprState</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr2</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>valuesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nullsAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>replacesAtt</name><index>[<expr><name>Natts_pg_attribute</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>missingval</name> <init>= <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>missingIsNull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>valuesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nullsAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>valuesAtt</name><index>[<expr><name>Anum_pg_attribute_atthasdef</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>replacesAtt</name><index>[<expr><name>Anum_pg_attribute_atthasdef</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>add_column_mode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>attgenerated</name> <operator>&amp;&amp;</operator> <name>cookedMissingVal</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>cookedMissingVal</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>missingval</name> <operator>=</operator> <operator>*</operator><name>missingval_p</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>missingIsNull</name> <operator>=</operator> <operator>*</operator><name>missingIsNull_p</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>add_column_mode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>attgenerated</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>expr2</name> <operator>=</operator> <call><name>expression_planner</name><argument_list>(<argument><expr><name>expr2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>exprState</name> <operator>=</operator> <call><name>ExecPrepareExpr</name><argument_list>(<argument><expr><name>expr2</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>ExecEvalExpr</name><argument_list>(<argument><expr><name>exprState</name></expr></argument>, <argument><expr><name>econtext</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>missingIsNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>defAttStruct</name> <operator>=</operator> <call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name>attnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>missingIsNull</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* if the default evaluates to NULL, just store a NULL array */</comment>
				<expr_stmt><expr><name>missingval</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* otherwise make a one-element array of the value */</comment>
				<expr_stmt><expr><name>missingval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(
											 <argument><expr><call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>missingval</name></expr></argument>,
															 <argument><expr><literal type="number">1</literal></expr></argument>,
															 <argument><expr><name><name>defAttStruct</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>,
															 <argument><expr><name><name>defAttStruct</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>,
															 <argument><expr><name><name>defAttStruct</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>,
															 <argument><expr><name><name>defAttStruct</name><operator>-&gt;</operator><name>attalign</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>add_column_mode</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>attgenerated</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>valuesAtt</name><index>[<expr><name>Anum_pg_attribute_atthasmissing</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>!</operator><name>missingIsNull</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replacesAtt</name><index>[<expr><name>Anum_pg_attribute_atthasmissing</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>valuesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>missingval</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>replacesAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nullsAtt</name><index>[<expr><name>Anum_pg_attribute_attmissingval</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>missingIsNull</name></expr>;</expr_stmt>

			<expr_stmt><expr><operator>*</operator><name>cookedMissingVal</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>missingval_p</name> <operator>=</operator> <name>missingval</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>missingIsNull_p</name> <operator>=</operator> <name>missingIsNull</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>atttup</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>)</argument_list></call></expr></argument>,
								   <argument><expr><name>valuesAtt</name></expr></argument>, <argument><expr><name>nullsAtt</name></expr></argument>, <argument><expr><name>replacesAtt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>atttup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* GPDB: don't free it, it's returned to the caller */</comment>
		<comment type="line">//if (!missingIsNull)</comment>
		<comment type="line">//	pfree(DatumGetPointer(missingval));</comment>

	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>attrrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>atttup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make a dependency so that the pg_attrdef entry goes away if the column
	 * (or whole table) is deleted.
	 */</comment>
	<expr_stmt><expr><name><name>colobject</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colobject</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>colobject</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <name>attnum</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>defobject</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>colobject</name></expr></argument>, <argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Record dependencies on objects used in the expression, too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>attgenerated</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Generated column: Dropping anything that the generation expression
		 * refers to automatically drops the generated column.
		 */</comment>
		<expr_stmt><expr><call><name>recordDependencyOnSingleRelExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>colobject</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>,
										<argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Normal default: Dropping anything that the default refers to
		 * requires CASCADE and drops the default only.
		 */</comment>
		<expr_stmt><expr><call><name>recordDependencyOnSingleRelExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>defobject</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>,
										<argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Post creation hook for attribute defaults.
	 *
	 * XXX. ALTER TABLE ALTER COLUMN SET/DROP DEFAULT is implemented with a
	 * couple of deletion/creation of the attribute's default entry, so the
	 * callee should check existence of an older version of this entry if it
	 * needs to distinguish.
	 */</comment>
	<expr_stmt><expr><call><name>InvokeObjectPostCreateHookArg</name><argument_list>(<argument><expr><name>AttrDefaultRelationId</name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>attrdefOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Store a check-constraint expression for the given relation.
 *
 * Caller is responsible for updating the count of constraints
 * in the pg_class entry for the relation.
 *
 * The OID of the new constraint is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>StoreRelCheck</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ccname</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>is_validated</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>inhcount</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>is_no_inherit</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccbin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>varList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>keycount</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name>	   <modifier>*</modifier></type><name>attNos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Flatten expression to string form for storage.
	 */</comment>
	<expr_stmt><expr><name>ccbin</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find columns of rel that are used in expr
	 *
	 * NB: pull_var_clause is okay here only because we don't allow subselects
	 * in check constraints; it would fail to examine the contents of
	 * subselects.
	 */</comment>
	<expr_stmt><expr><name>varList</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keycount</name> <operator>=</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>varList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>keycount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>vl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>attNos</name> <operator>=</operator> <operator>(</operator><name>int16</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>keycount</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int16</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>foreach</name><argument_list>(<argument>vl</argument>, <argument>varList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>vl</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>i</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>attNos</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt></block_content></block></for>
			<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>attNos</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><name>keycount</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>attNos</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Partitioned tables do not contain any rows themselves, so a NO INHERIT
	 * constraint makes no sense.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_no_inherit</name> <operator>&amp;&amp;</operator>
		<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TABLE_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot add NO INHERIT constraint to partitioned table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Create the Check Constraint
	 */</comment>
	<expr_stmt><expr><name>constrOid</name> <operator>=</operator>
		<call><name>CreateConstraintEntry</name><argument_list>(<argument><expr><name>ccname</name></expr></argument>,	<comment type="block">/* Constraint Name */</comment>
							  <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,	<comment type="block">/* namespace */</comment>
							  <argument><expr><name>CONSTRAINT_CHECK</name></expr></argument>, <comment type="block">/* Constraint Type */</comment>
							  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* Is Deferrable */</comment>
							  <argument><expr><name>false</name></expr></argument>,	<comment type="block">/* Is Deferred */</comment>
							  <argument><expr><name>is_validated</name></expr></argument>,
							  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no parent constraint */</comment>
							  <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,	<comment type="block">/* relation */</comment>
							  <argument><expr><name>attNos</name></expr></argument>,	<comment type="block">/* attrs in the constraint */</comment>
							  <argument><expr><name>keycount</name></expr></argument>, <comment type="block">/* # key attrs in the constraint */</comment>
							  <argument><expr><name>keycount</name></expr></argument>, <comment type="block">/* # total attrs in the constraint */</comment>
							  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* not a domain constraint */</comment>
							  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no associated index */</comment>
							  <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* Foreign key fields */</comment>
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>,
							  <argument><expr><literal type="char">' '</literal></expr></argument>,
							  <argument><expr><literal type="char">' '</literal></expr></argument>,
							  <argument><expr><literal type="char">' '</literal></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* not an exclusion constraint */</comment>
							  <argument><expr><name>expr</name></expr></argument>, <comment type="block">/* Tree form of check constraint */</comment>
							  <argument><expr><name>ccbin</name></expr></argument>,	<comment type="block">/* Binary form of check constraint */</comment>
							  <argument><expr><name>is_local</name></expr></argument>, <comment type="block">/* conislocal */</comment>
							  <argument><expr><name>inhcount</name></expr></argument>, <comment type="block">/* coninhcount */</comment>
							  <argument><expr><name>is_no_inherit</name></expr></argument>,	<comment type="block">/* connoinherit */</comment>
							  <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* internally constructed? */</comment>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ccbin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>constrOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Store defaults and constraints (passed as a list of CookedConstraint).
 *
 * Each CookedConstraint struct is modified to store the new catalog tuple OID.
 *
 * NOTE: only pre-cooked expressions will be passed this way, which is to
 * say expressions inherited from an existing relation.  Newly parsed
 * expressions can be added later, by direct calls to StoreAttrDefault
 * and StoreRelCheck (see AddRelationNewConstraints()).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>StoreConstraints</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>cooked_constraints</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>numchecks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>cooked_constraints</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<comment type="block">/*
	 * Deparsing of constraint expressions will fail unless the just-created
	 * pg_attribute tuples for this relation are made visible.  So, bump the
	 * command counter.  CAUTION: this will cause a relcache entry rebuild.
	 */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>cooked_constraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>con</name> <init>= <expr><operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>CONSTR_DEFAULT</name></expr>:</case>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <call><name>StoreAttrDefault</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>is_internal</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>CONSTR_CHECK</name></expr>:</case>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator>
					<call><name>StoreRelCheck</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>expr</name></name></expr></argument>,
								  <argument><expr><operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>skip_validation</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>,
								  <argument><expr><name><name>con</name><operator>-&gt;</operator><name>inhcount</name></name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>is_no_inherit</name></name></expr></argument>,
								  <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>numchecks</name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized constraint type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>con</name><operator>-&gt;</operator><name>contype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>numchecks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetRelationNumChecks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>numchecks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AddRelationNewConstraints
 *
 * Add new column default expressions and/or constraint check expressions
 * to an existing relation.  This is defined to do both for efficiency in
 * DefineRelation, but of course you can do just one or the other by passing
 * empty lists.
 *
 * rel: relation to be modified
 * newColDefaults: list of RawColumnDefault structures
 * newConstraints: list of Constraint nodes
 * allow_merge: true if check constraints may be merged with existing ones
 * is_local: true if definition is local, false if it's inherited
 * is_internal: true if result of some internal process, not a user request
 *
 * All entries in newColDefaults will be processed.  Entries in newConstraints
 * will be processed only if they are CONSTR_CHECK type.
 *
 * Returns a list of CookedConstraint nodes that shows the cooked form of
 * the default and constraint expressions added to the relation.
 *
 * NB: caller should have opened rel with AccessExclusiveLock, and should
 * hold that lock till end of transaction.  Also, we assume the caller has
 * done a CommandCounterIncrement if necessary to make the relation's catalog
 * tuples visible.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>AddRelationNewConstraints</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>newColDefaults</name></decl></parameter>,
						  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>newConstraints</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>allow_merge</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>is_internal</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queryString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>cookedConstraints</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupleDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleConstr</name> <modifier>*</modifier></type><name>oldconstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numoldchecks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numchecks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>checknames</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CookedConstraint</name> <modifier>*</modifier></type><name>cooked</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get info about existing constraints.
	 */</comment>
	<expr_stmt><expr><name>tupleDesc</name> <operator>=</operator> <call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldconstr</name> <operator>=</operator> <name><name>tupleDesc</name><operator>-&gt;</operator><name>constr</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldconstr</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numoldchecks</name> <operator>=</operator> <name><name>oldconstr</name><operator>-&gt;</operator><name>num_check</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>numoldchecks</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Create a dummy ParseState and insert the target relation as its sole
	 * rangetable entry.  We need a ParseState for transformExpr.
	 */</comment>
	<expr_stmt><expr><name>pstate</name> <operator>=</operator> <call><name>make_parsestate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_sourcetext</name></name> <operator>=</operator> <name>queryString</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>addRangeTableEntryForRelation</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>,
										<argument><expr><name>rel</name></expr></argument>,
										<argument><expr><name>AccessShareLock</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addRTEtoQuery</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Process column default expressions.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>newColDefaults</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RawColumnDefault</name> <modifier>*</modifier></type><name>colDef</name> <init>= <expr><operator>(</operator><name>RawColumnDefault</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>atp</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>attnum</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>defOid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>cookDefault</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>raw_default</name></name></expr></argument>,
						   <argument><expr><name><name>atp</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><name><name>atp</name><operator>-&gt;</operator><name>atttypmod</name></name></expr></argument>,
						   <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>atp</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><name><name>atp</name><operator>-&gt;</operator><name>attgenerated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the expression is just a NULL constant, we do not bother to make
		 * an explicit pg_attrdef entry, since the default behavior is
		 * equivalent.  This applies to column defaults, but not for
		 * generation expressions.
		 *
		 * Note a nonobvious property of this test: if the column is of a
		 * domain type, what we'll get is not a bare null Const but a
		 * CoerceToDomain expr, so we will not discard the default.  This is
		 * critical because the column default needs to be retained to
		 * override any default that the domain might have.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<operator>(</operator><operator>!</operator><name><name>colDef</name><operator>-&gt;</operator><name>generated</name></name> <operator>&amp;&amp;</operator>
			 <call><name>IsA</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>castNode</name><argument_list>(<argument><expr><name>Const</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>constisnull</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* If the DEFAULT is volatile we cannot use a missing value */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>colDef</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>&amp;&amp;</operator> <call><name>contain_volatile_functions</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>colDef</name><operator>-&gt;</operator><name>missingMode</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>defOid</name> <operator>=</operator> <call><name>StoreAttrDefault</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>attnum</name></name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>colDef</name><operator>-&gt;</operator><name>hasCookedMissingVal</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>colDef</name><operator>-&gt;</operator><name>missingVal</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>colDef</name><operator>-&gt;</operator><name>missingIsNull</name></name></expr></argument>,
								  <argument><expr><name>is_internal</name></expr></argument>,
								  <argument><expr><name><name>colDef</name><operator>-&gt;</operator><name>missingMode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cooked</name> <operator>=</operator> <operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <name>defOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <name><name>colDef</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>is_local</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <ternary><condition><expr><name>is_local</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_no_inherit</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cookedConstraints</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cookedConstraints</name></expr></argument>, <argument><expr><name>cooked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Process constraint expressions.
	 */</comment>
	<expr_stmt><expr><name>numchecks</name> <operator>=</operator> <name>numoldchecks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>checknames</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>newConstraints</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Constraint</name> <modifier>*</modifier></type><name>cdef</name> <init>= <expr><operator>(</operator><name>Constraint</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ccname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>constrOid</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cdef</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTR_CHECK</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>cdef</name><operator>-&gt;</operator><name>raw_expr</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cdef</name><operator>-&gt;</operator><name>cooked_expr</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Transform raw parsetree to executable expression, and verify
			 * it's valid as a CHECK constraint.
			 */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>cookConstraint</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>cdef</name><operator>-&gt;</operator><name>raw_expr</name></name></expr></argument>,
								  <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cdef</name><operator>-&gt;</operator><name>cooked_expr</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Here, we assume the parser will only pass us valid CHECK
			 * expressions, so we do no particular checking.
			 */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><name><name>cdef</name><operator>-&gt;</operator><name>cooked_expr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * Check name uniqueness, or generate a name if none was given.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>cdef</name><operator>-&gt;</operator><name>conname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell2</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>ccname</name> <operator>=</operator> <name><name>cdef</name><operator>-&gt;</operator><name>conname</name></name></expr>;</expr_stmt>
			<comment type="block">/* Check against other new constraints */</comment>
			<comment type="block">/* Needed because we don't do CommandCounterIncrement in loop */</comment>
			<macro><name>foreach</name><argument_list>(<argument>cell2</argument>, <argument>checknames</argument>)</argument_list></macro>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ccname</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"check constraint \"%s\" already exists"</literal></expr></argument>,
									<argument><expr><name>ccname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>

			<comment type="block">/* save name for future checks */</comment>
			<expr_stmt><expr><name>checknames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>checknames</name></expr></argument>, <argument><expr><name>ccname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check against pre-existing constraints.  If we are allowed to
			 * merge with an existing constraint, there's no more to do here.
			 * (We omit the duplicate constraint from the result, which is
			 * what ATAddCheckConstraint wants.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>MergeWithExistingConstraint</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ccname</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>,
											<argument><expr><name>allow_merge</name></expr></argument>, <argument><expr><name>is_local</name></expr></argument>,
											<argument><expr><name><name>cdef</name><operator>-&gt;</operator><name>initially_valid</name></name></expr></argument>,
											<argument><expr><name><name>cdef</name><operator>-&gt;</operator><name>is_no_inherit</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * When generating a name, we want to create "tab_col_check" for a
			 * column constraint and "tab_check" for a table constraint.  We
			 * no longer have any info about the syntactic positioning of the
			 * constraint phrase, so we approximate this by seeing whether the
			 * expression references more than one column.  (If the user
			 * played by the rules, the result is the same...)
			 *
			 * Note: pull_var_clause() doesn't descend into sublinks, but we
			 * eliminated those above; and anyway this only needs to be an
			 * approximate answer.
			 */</comment>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>vars</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>colname</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* eliminate duplicates */</comment>
			<expr_stmt><expr><name>vars</name> <operator>=</operator> <call><name>list_union</name><argument_list>(<argument><expr><name>NIL</name></expr></argument>, <argument><expr><name>vars</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <call><name>get_attname</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>vars</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>colname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>ccname</name> <operator>=</operator> <call><name>ChooseConstraintName</name><argument_list>(<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>colname</name></expr></argument>,
										  <argument><expr><literal type="string">"check"</literal></expr></argument>,
										  <argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><name>checknames</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* save name for future checks */</comment>
			<expr_stmt><expr><name>checknames</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>checknames</name></expr></argument>, <argument><expr><name>ccname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/*
		 * OK, store it.
		 */</comment>
		<expr_stmt><expr><name>constrOid</name> <operator>=</operator>
			<call><name>StoreRelCheck</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ccname</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name><name>cdef</name><operator>-&gt;</operator><name>initially_valid</name></name></expr></argument>, <argument><expr><name>is_local</name></expr></argument>,
						  <argument><expr><ternary><condition><expr><name>is_local</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>cdef</name><operator>-&gt;</operator><name>is_no_inherit</name></name></expr></argument>, <argument><expr><name>is_internal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>numchecks</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>cooked</name> <operator>=</operator> <operator>(</operator><name>CookedConstraint</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CookedConstraint</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>contype</name></name> <operator>=</operator> <name>CONSTR_CHECK</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>conoid</name></name> <operator>=</operator> <name>constrOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <name>ccname</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>attnum</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>expr</name></name> <operator>=</operator> <name>expr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>skip_validation</name></name> <operator>=</operator> <name><name>cdef</name><operator>-&gt;</operator><name>skip_validation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_local</name></name> <operator>=</operator> <name>is_local</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>inhcount</name></name> <operator>=</operator> <ternary><condition><expr><name>is_local</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cooked</name><operator>-&gt;</operator><name>is_no_inherit</name></name> <operator>=</operator> <name><name>cdef</name><operator>-&gt;</operator><name>is_no_inherit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>cookedConstraints</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>cookedConstraints</name></expr></argument>, <argument><expr><name>cooked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* Cleanup the parse state */</comment>
	<expr_stmt><expr><call><name>free_parsestate</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the count of constraints in the relation's pg_class tuple. We do
	 * this even if there was no change, in order to ensure that an SI update
	 * message is sent out for the pg_class tuple, which will force other
	 * backends to rebuild their relcache entries for the rel. (This is
	 * critical if we added defaults but not constraints.)
	 */</comment>
	<expr_stmt><expr><call><name>SetRelationNumChecks</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>numchecks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>cookedConstraints</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check for a pre-existing check constraint that conflicts with a proposed
 * new one, and either adjust its conislocal/coninhcount settings or throw
 * error as needed.
 *
 * Returns true if merged (constraint is a duplicate), or false if it's
 * got a so-far-unique name, or throws error if conflict.
 *
 * XXX See MergeConstraintsIntoExisting too if you change this code.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>MergeWithExistingConstraint</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ccname</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>expr</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>allow_merge</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>is_initially_valid</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>is_no_inherit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conDesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>conscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<comment type="block">/* Search for a pg_constraint entry with same name and relation */</comment>
	<expr_stmt><expr><name>conDesc</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>found</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_contypid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>ccname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conDesc</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There can be at most one matching row */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Found it.  Conflicts if not identical check constraint */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>==</operator> <name>CONSTRAINT_CHECK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>fastgetattr</name><argument_list>(<argument><expr><name>tup</name></expr></argument>,
							  <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>,
							  <argument><expr><name><name>conDesc</name><operator>-&gt;</operator><name>rd_att</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"null conbin for rel %s"</literal></expr></argument>,
					 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>expr</name></expr></argument>, <argument><expr><call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the existing constraint is purely inherited (no local
		 * definition) then interpret addition of a local constraint as a
		 * legal merge.  This allows ALTER ADD CONSTRAINT on parent and child
		 * tables to be given in either order with same end state.  However if
		 * the relation is a partition, all inherited constraints are always
		 * non-local, including those that were merged.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_local</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>allow_merge</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <operator>!</operator><name>allow_merge</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DUPLICATE_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" for relation \"%s\" already exists"</literal></expr></argument>,
							<argument><expr><name>ccname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If the child constraint is "no inherit" then cannot merge */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" conflicts with non-inherited constraint on relation \"%s\""</literal></expr></argument>,
							<argument><expr><name>ccname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Must not change an existing inherited constraint to "no inherit"
		 * status.  That's because inherited constraints should be able to
		 * propagate to lower-level children.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>is_no_inherit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" conflicts with inherited constraint on relation \"%s\""</literal></expr></argument>,
							<argument><expr><name>ccname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the child constraint is "not valid" then cannot merge with a
		 * valid parent constraint.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>is_initially_valid</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>con</name><operator>-&gt;</operator><name>convalidated</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"constraint \"%s\" conflicts with NOT VALID constraint on relation \"%s\""</literal></expr></argument>,
							<argument><expr><name>ccname</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* OK to update the tuple */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr> ?</condition><then> <expr><name>DEBUG1</name></expr> </then><else>: <expr><name>NOTICE</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"merging constraint \"%s\" with inherited definition"</literal></expr></argument>,
						<argument><expr><name>ccname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>heap_copytuple</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In case of partitions, an inherited constraint must be inherited
		 * only once since it cannot have multiple parents and it is never
		 * considered local.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relispartition</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>is_local</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>conislocal</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>coninhcount</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>is_no_inherit</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>con</name><operator>-&gt;</operator><name>connoinherit</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>conDesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>conscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>conDesc</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>found</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Update the count of constraints in the relation's pg_class tuple.
 *
 * Caller had better hold exclusive lock on the relation.
 *
 * An important side effect is that a SI update message will be sent out for
 * the pg_class tuple, which will force other backends to rebuild their
 * relcache entries for the rel.  Also, this backend will rebuild its
 * own relcache entry at the next CommandCounterIncrement.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>SetRelationNumChecks</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numchecks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>relStruct</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>relrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>relStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relStruct</name><operator>-&gt;</operator><name>relchecks</name></name> <operator>!=</operator> <name>numchecks</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>relStruct</name><operator>-&gt;</operator><name>relchecks</name></name> <operator>=</operator> <name>numchecks</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>relrel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>reltup</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Skip the disk update, but force relcache inval anyway */</comment>
		<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>reltup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relrel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check for references to generated columns
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_nested_generated_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name> <init>= <expr><name>context</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <call><name>rt_fetch</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>AttributeNumberIsValid</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>get_attgenerated</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use generated column \"%s\" in column generation expression"</literal></expr></argument>,
							<argument><expr><call><name>get_attname</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"A generated column cannot reference another generated column."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>parser_errposition</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>location</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>check_nested_generated_walker</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>context</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_nested_generated</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>check_nested_generated_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>pstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Take a raw default and convert it to a cooked format ready for
 * storage.
 *
 * Parse state should be set up to recognize any vars that might appear
 * in the expression.  (Even though we plan to reject vars, it's more
 * user-friendly to give the correct error message than "unknown var".)
 *
 * If atttypid is not InvalidOid, coerce the expression to the specified
 * type (and typmod atttypmod).   attname is only needed in this case:
 * it is used in the error message, if any.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>cookDefault</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
			<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>raw_default</name></decl></parameter>,
			<parameter><decl><type><name>Oid</name></type> <name>atttypid</name></decl></parameter>,
			<parameter><decl><type><name>int32</name></type> <name>atttypmod</name></decl></parameter>,
			<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>,
			<parameter><decl><type><name>char</name></type> <name>attgenerated</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>raw_default</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Transform raw parsetree to executable expression.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>raw_default</name></expr></argument>, <argument><expr><ternary><condition><expr><name>attgenerated</name></expr> ?</condition><then> <expr><name>EXPR_KIND_GENERATED_COLUMN</name></expr> </then><else>: <expr><name>EXPR_KIND_COLUMN_DEFAULT</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attgenerated</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>check_nested_generated</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>contain_mutable_functions</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"generation expression is not immutable"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For a default expression, transformExpr() should have rejected
		 * column references.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>contain_var_clause</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Coerce the expression to the correct type and typmod, if given. This
	 * should match the parser's processing of non-defaulted expressions ---
	 * see transformAssignedExpr().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>type_id</name> <init>= <expr><call><name>exprType</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_to_target_type</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><name>type_id</name></expr></argument>,
									 <argument><expr><name>atttypid</name></expr></argument>, <argument><expr><name>atttypmod</name></expr></argument>,
									 <argument><expr><name>COERCION_ASSIGNMENT</name></expr></argument>,
									 <argument><expr><name>COERCE_IMPLICIT_CAST</name></expr></argument>,
									 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>expr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"column \"%s\" is of type %s"</literal>
							<literal type="string">" but default expression is of type %s"</literal></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>atttypid</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type_id</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You will need to rewrite or cast the expression."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Finally, take care of collations in the finished expression.
	 */</comment>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Take a raw CHECK constraint expression and convert it to a cooked format
 * ready for storage.
 *
 * Parse state must be set up to recognize any vars that might appear
 * in the expression.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>cookConstraint</name><parameter_list>(<parameter><decl><type><name>ParseState</name> <modifier>*</modifier></type><name>pstate</name></decl></parameter>,
			   <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>raw_constraint</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Transform raw parsetree to executable expression.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>transformExpr</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>raw_constraint</name></expr></argument>, <argument><expr><name>EXPR_KIND_CHECK_CONSTRAINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure it yields a boolean result.
	 */</comment>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>coerce_to_boolean</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>, <argument><expr><literal type="string">"CHECK"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Take care of collations.
	 */</comment>
	<expr_stmt><expr><call><name>assign_expr_collations</name><argument_list>(<argument><expr><name>pstate</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure no outside relations are referred to (this is probably dead
	 * code now that add_missing_from is history).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>pstate</name><operator>-&gt;</operator><name>p_rtable</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_COLUMN_REFERENCE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only table \"%s\" can be referenced in check constraint"</literal></expr></argument>,
						<argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RemoveStatistics --- remove entries in pg_statistic for a rel or column
 *
 * If attnum is zero, remove all entries for rel; else remove only the one(s)
 * for that column.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveStatistics</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pgstatistic</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>key</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>pgstatistic</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>StatisticRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_statistic_starelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><name>Anum_pg_statistic_staattnum</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
					<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nkeys</name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pgstatistic</name></expr></argument>, <argument><expr><name>StatisticRelidAttnumInhIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>nkeys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* we must loop even when attnum != 0, in case of inherited stats */</comment>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>pgstatistic</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pgstatistic</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RelationTruncateIndexes - truncate all indexes associated
 * with the heap relation to zero tuples.
 *
 * The routine will truncate and then reconstruct the indexes on
 * the specified relation.  Caller must hold exclusive lock on rel.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>RelationTruncateIndexes</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>heapRelation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indlist</name></decl>;</decl_stmt>

	<comment type="block">/* Ask the relcache to produce a list of the indexes of the rel */</comment>
	<macro><name>foreach</name><argument_list>(<argument>indlist</argument>, <argument>RelationGetIndexList(heapRelation)</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>indexId</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>indlist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>currentIndex</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>

		<comment type="block">/* Open the index relation; use exclusive lock, just to be sure */</comment>
		<expr_stmt><expr><name>currentIndex</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>indexId</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Fetch info needed for index_build */</comment>
		<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>currentIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now truncate the actual file (and discard buffers) */</comment>
		<expr_stmt><expr><call><name>RelationTruncate</name><argument_list>(<argument><expr><name>currentIndex</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize the index and rebuild */</comment>
		<comment type="block">/* Note: we do not need to re-establish pkey setting */</comment>
		<expr_stmt><expr><call><name>index_build</name><argument_list>(<argument><expr><name>heapRelation</name></expr></argument>, <argument><expr><name>currentIndex</name></expr></argument>, <argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* We're done with this index */</comment>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>currentIndex</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 *	 heap_truncate
 *
 *	 This routine deletes all data within all the specified relations.
 *
 * This is not transaction-safe!  There is another, transaction-safe
 * implementation in commands/tablecmds.c.  We now use this only for
 * ON COMMIT truncation of temporary tables, where it doesn't matter.
 */</comment>
<function><type><name>void</name></type>
<name>heap_truncate</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relations</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/* Open relations for processing, and grab exclusive access on each */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>rid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>rid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relations</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>relations</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* GPDB does not support all FK feature but keeps FK grammar recognition,
	 * which reduces migration manual workload from other databases.
	 * We do not want to reject relation truncate if the relation contains FK
	 * satisfied tuple, so skip heap_truncate_check_FKs function call.
	 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	<comment type="block">/* Don't allow truncate on tables that are referenced by foreign keys */</comment>
	heap_truncate_check_FKs(relations, true);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* OK to do it */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Truncate the relation */</comment>
		<expr_stmt><expr><call><name>heap_truncate_one_rel</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Close the relation, but keep exclusive lock on it until commit */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 *	 heap_truncate_one_rel
 *
 *	 This routine deletes all data within the specified relation.
 *
 * This is not transaction-safe, because the truncation is done immediately
 * and cannot be rolled back later.  Caller is responsible for having
 * checked permissions etc, and must have obtained AccessExclusiveLock.
 */</comment>
<function><type><name>void</name></type>
<name>heap_truncate_one_rel</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>toastrelid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Truncate the relation.  Partitioned tables have no storage, so there is
	 * nothing to do for them here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Truncate the underlying relation */</comment>
	<expr_stmt><expr><call><name>table_relation_nontransactional_truncate</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If the relation has indexes, truncate the indexes too */</comment>
	<expr_stmt><expr><call><name>RelationTruncateIndexes</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If there is a toast table, truncate that too */</comment>
	<expr_stmt><expr><name>toastrelid</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>toastrelid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>toastrel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>toastrelid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>table_relation_nontransactional_truncate</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RelationTruncateIndexes</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* keep the lock... */</comment>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>toastrel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * heap_truncate_check_FKs
 *		Check for foreign keys referencing a list of relations that
 *		are to be truncated, and raise error if there are any
 *
 * We disallow such FKs (except self-referential ones) since the whole point
 * of TRUNCATE is to not scan the individual rows to be thrown away.
 *
 * This is split out so it can be shared by both implementations of truncate.
 * Caller should already hold a suitable lock on the relations.
 *
 * tempTables is only used to select an appropriate error message.
 */</comment>
<function><type><name>void</name></type>
<name>heap_truncate_check_FKs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relations</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>tempTables</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dependents</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Build a list of OIDs of the interesting relations.
	 *
	 * If a relation has no triggers, then it can neither have FKs nor be
	 * referenced by a FK from another table, so we can ignore it.  For
	 * partitioned tables, FKs have no triggers, so we must include them
	 * anyway.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>relations</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name> <operator>||</operator>
			<name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Fast path: if no relation has triggers, none has FKs either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oids</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, must scan pg_constraint.  We make one pass with all the
	 * relations considered; if this finds nothing, then all is well.
	 */</comment>
	<expr_stmt><expr><name>dependents</name> <operator>=</operator> <call><name>heap_truncate_find_FKs</name><argument_list>(<argument><expr><name>oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dependents</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise we repeat the scan once per relation to identify a particular
	 * pair of relations to complain about.  This is pretty slow, but
	 * performance shouldn't matter much in a failure path.  The reason for
	 * doing things this way is to ensure that the message produced is not
	 * dependent on chance row locations within pg_constraint.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell2</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>dependents</name> <operator>=</operator> <call><name>heap_truncate_find_FKs</name><argument_list>(<argument><expr><call><name>list_make1_oid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>cell2</argument>, <argument>dependents</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>relid2</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>oids</name></expr></argument>, <argument><expr><name>relid2</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>relname2</name> <init>= <expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name>relid2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>tempTables</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported ON COMMIT and foreign key combination"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" references \"%s\", but they do not have the same ON COMMIT setting."</literal></expr></argument>,
									   <argument><expr><name>relname2</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot truncate a table referenced in a foreign key constraint"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table \"%s\" references \"%s\"."</literal></expr></argument>,
									   <argument><expr><name>relname2</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Truncate table \"%s\" at the same time, "</literal>
									 <literal type="string">"or use TRUNCATE ... CASCADE."</literal></expr></argument>,
									 <argument><expr><name>relname2</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * heap_truncate_find_FKs
 *		Find relations having foreign keys referencing any of the given rels
 *
 * Input and result are both lists of relation OIDs.  The result contains
 * no duplicates, does *not* include any rels that were already in the input
 * list, and is sorted in OID order.  (The last property is enforced mainly
 * to guarantee consistent behavior in the regression tests; we don't want
 * behavior to change depending on chance locations of rows in pg_constraint.)
 *
 * Note: caller should already have appropriate lock on all rels mentioned
 * in relationIds.  Since adding or dropping an FK requires exclusive lock
 * on both rels, this ensures that the answer will be stable.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>heap_truncate_find_FKs</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>relationIds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>fkeyRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>fkeyScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must scan pg_constraint.  Right now, it is a seqscan because there is
	 * no available index on confrelid.
	 */</comment>
	<expr_stmt><expr><name>fkeyRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fkeyScan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>fkeyRel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
								  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>fkeyScan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>con</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Not a foreign key */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>con</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Not referencing one of our list of tables */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>relationIds</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>confrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Add referencer unless already in input or result list */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>relationIds</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>insert_ordered_unique_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>con</name><operator>-&gt;</operator><name>conrelid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>fkeyScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>fkeyRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * insert_ordered_unique_oid
 *		Insert a new Oid into a sorted list of Oids, preserving ordering,
 *		and eliminating duplicates
 *
 * Building the ordered list this way is O(N^2), but with a pretty small
 * constant, so for the number of entries we expect it will probably be
 * faster than trying to apply qsort().  It seems unlikely someone would be
 * trying to truncate a table with thousands of dependent tables ...
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>insert_ordered_unique_oid</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>list</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<comment type="block">/* Does the datum belong at the front? */</comment>
	<if_stmt><if>if <condition>(<expr><name>list</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name>datum</name> <operator>&lt;</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>lcons_oid</name><argument_list>(<argument><expr><name>datum</name></expr></argument>, <argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* Does it match the first entry? */</comment>
	<if_stmt><if>if <condition>(<expr><name>datum</name> <operator>==</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>list</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* duplicate, so don't insert */</comment>
	<comment type="block">/* No, so find the entry it belongs after */</comment>
	<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>curr</name> <init>= <expr><call><name>lnext</name><argument_list>(<argument><expr><name>prev</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>curr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>datum</name> <operator>&lt;</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* it belongs after 'prev', before 'curr' */</comment>

		<if_stmt><if>if <condition>(<expr><name>datum</name> <operator>==</operator> <call><name>lfirst_oid</name><argument_list>(<argument><expr><name>curr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>list</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* duplicate, so don't insert */</comment>

		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>curr</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Insert datum into list after 'prev' */</comment>
	<expr_stmt><expr><call><name>lappend_cell_oid</name><argument_list>(<argument><expr><name>list</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>list</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StorePartitionKey
 *		Store information about the partition key rel into the catalog
 */</comment>
<function><type><name>void</name></type>
<name>StorePartitionKey</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>,
				  <parameter><decl><type><name>char</name></type> <name>strategy</name></decl></parameter>,
				  <parameter><decl><type><name>int16</name></type> <name>partnatts</name></decl></parameter>,
				  <parameter><decl><type><name>AttrNumber</name> <modifier>*</modifier></type><name>partattrs</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>partexprs</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partopclass</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>partcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int2vector</name> <modifier>*</modifier></type><name>partattrs_vec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>partopclass_vec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>partcollation_vec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>partexprDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_partitioned_table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>Natts_pg_partitioned_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>Natts_pg_partitioned_table</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>myself</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>referenced</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the partition attribute numbers, opclass OIDs into arrays */</comment>
	<expr_stmt><expr><name>partattrs_vec</name> <operator>=</operator> <call><name>buildint2vector</name><argument_list>(<argument><expr><name>partattrs</name></expr></argument>, <argument><expr><name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partopclass_vec</name> <operator>=</operator> <call><name>buildoidvector</name><argument_list>(<argument><expr><name>partopclass</name></expr></argument>, <argument><expr><name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partcollation_vec</name> <operator>=</operator> <call><name>buildoidvector</name><argument_list>(<argument><expr><name>partcollation</name></expr></argument>, <argument><expr><name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert the expressions (if any) to a text datum */</comment>
	<if_stmt><if>if <condition>(<expr><name>partexprs</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>exprString</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>exprString</name> <operator>=</operator> <call><name>nodeToString</name><argument_list>(<argument><expr><name>partexprs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>partexprDatum</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>exprString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>exprString</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>partexprDatum</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>pg_partitioned_table</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PartitionedRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Only this can ever be NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>partexprDatum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>Anum_pg_partitioned_table_partexprs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_partitioned_table_partrelid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_partitioned_table_partstrat</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CharGetDatum</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_partitioned_table_partnatts</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>partnatts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_partitioned_table_partdefid</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_partitioned_table_partattrs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>partattrs_vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_partitioned_table_partclass</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>partopclass_vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_partitioned_table_partcollation</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>partcollation_vec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>values</name><index>[<expr><name>Anum_pg_partitioned_table_partexprs</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>partexprDatum</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pg_partitioned_table</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CatalogTupleInsert</name><argument_list>(<argument><expr><name>pg_partitioned_table</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pg_partitioned_table</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Mark this relation as dependent on a few things as follows */</comment>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>myself</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Operator class and collation per key column */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>partnatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>OperatorClassRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>partopclass</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* The default collation is pinned, so don't bother recording it */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>CollationRelationId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name><name>partcollation</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>referenced</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>recordDependencyOn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>referenced</name></expr></argument>, <argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Anything mentioned in the expressions.  We must ignore the column
	 * references, which will depend on the table itself; there is no separate
	 * partition key object.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partexprs</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>recordDependencyOnSingleRelExpr</name><argument_list>(<argument><expr><operator>&amp;</operator><name>myself</name></expr></argument>,
										<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>partexprs</name></expr></argument>,
										<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>DEPENDENCY_NORMAL</name></expr></argument>,
										<argument><expr><name>DEPENDENCY_AUTO</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We must invalidate the relcache so that the next
	 * CommandCounterIncrement() will cause the same to be rebuilt using the
	 * information in just created catalog entry.
	 */</comment>
	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	RemovePartitionKeyByRelId
 *		Remove pg_partitioned_table entry for a relation
 */</comment>
<function><type><name>void</name></type>
<name>RemovePartitionKeyByRelId</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>PartitionedRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for partition key of relation %u"</literal></expr></argument>,
			 <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CatalogTupleDelete</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * StorePartitionBound
 *		Update pg_class tuple of rel to store the partition bound and set
 *		relispartition to true
 *
 * If this is the default partition, also update the default partition OID in
 * pg_partitioned_table.
 *
 * Also, invalidate the parent's relcache, so that the next rebuild will load
 * the new partition's info into its partition descriptor.  If there is a
 * default partition, we must invalidate its relcache entry as well.
 */</comment>
<function><type><name>void</name></type>
<name>StorePartitionBound</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>parent</name></decl></parameter>, <parameter><decl><type><name>PartitionBoundSpec</name> <modifier>*</modifier></type><name>bound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>classRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>,
				<decl><type ref="prev"/><name>newtuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>new_val</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>new_null</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>,
				<decl><type ref="prev"/><name><name>new_repl</name><index>[<expr><name>Natts_pg_class</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>defaultPartOid</name></decl>;</decl_stmt>

	<comment type="block">/* Update pg_class tuple */</comment>
	<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
								<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>,
			 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>classForm</name><operator>-&gt;</operator><name>relispartition</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_class_relpartbound</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Fill in relpartbound value */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_val</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_null</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>new_repl</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_repl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_val</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><call><name>nodeToString</name><argument_list>(<argument><expr><name>bound</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_null</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>new_repl</name><index>[<expr><name>Anum_pg_class_relpartbound</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newtuple</name> <operator>=</operator> <call><name>heap_modify_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>new_val</name></expr></argument>, <argument><expr><name>new_null</name></expr></argument>, <argument><expr><name>new_repl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Also set the flag */</comment>
	<expr_stmt><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relispartition</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CatalogTupleUpdate</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newtuple</name><operator>-&gt;</operator><name>t_self</name></name></expr></argument>, <argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>newtuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're storing bounds for the default partition, update
	 * pg_partitioned_table too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bound</name><operator>-&gt;</operator><name>is_default</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>update_default_partition_oid</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make these updates visible */</comment>
	<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The partition constraint for the default partition depends on the
	 * partition bounds of every other partition, so we must invalidate the
	 * relcache entry for that partition every time a partition is added or
	 * removed.
	 */</comment>
	<expr_stmt><expr><name>defaultPartOid</name> <operator>=</operator> <call><name>get_default_oid_from_partdesc</name><argument_list>(<argument><expr><call><name>RelationGetPartitionDesc</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CacheInvalidateRelcacheByRelid</name><argument_list>(<argument><expr><name>defaultPartOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>CacheInvalidateRelcache</name><argument_list>(<argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
