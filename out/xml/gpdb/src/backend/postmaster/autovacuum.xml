<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/postmaster/autovacuum.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * autovacuum.c
 *
 * PostgreSQL Integrated Autovacuum Daemon
 *
 * The autovacuum system is structured in two different kinds of processes: the
 * autovacuum launcher and the autovacuum worker.  The launcher is an
 * always-running process, started by the postmaster when the autovacuum GUC
 * parameter is set.  The launcher schedules autovacuum workers to be started
 * when appropriate.  The workers are the processes which execute the actual
 * vacuuming; they connect to a database as determined in the launcher, and
 * once connected they examine the catalogs to select the tables to vacuum.
 *
 * The autovacuum launcher cannot start the worker processes by itself,
 * because doing so would cause robustness issues (namely, failure to shut
 * them down on exceptional conditions, and also, since the launcher is
 * connected to shared memory and is thus subject to corruption there, it is
 * not as robust as the postmaster).  So it leaves that task to the postmaster.
 *
 * There is an autovacuum shared memory area, where the launcher stores
 * information about the database it wants vacuumed.  When it wants a new
 * worker to start, it sets a flag in shared memory and sends a signal to the
 * postmaster.  Then postmaster knows nothing more than it must start a worker;
 * so it forks a new child, which turns into a worker.  This new process
 * connects to shared memory, and there it can inspect the information that the
 * launcher has set up.
 *
 * If the fork() call fails in the postmaster, it sets a flag in the shared
 * memory area, and sends a signal to the launcher.  The launcher, upon
 * noticing the flag, can try starting the worker again by resending the
 * signal.  Note that the failure can only be transient (fork failure due to
 * high load, memory pressure, too many processes, etc); more permanent
 * problems, like failure to connect to a database, are detected later in the
 * worker and dealt with just by having the worker exit normally.  The launcher
 * will launch a new worker again later, per schedule.
 *
 * When the worker is done vacuuming it sends SIGUSR2 to the launcher.  The
 * launcher then wakes up and is able to launch another worker, if the schedule
 * is so tight that a new worker is needed immediately.  At this time the
 * launcher can also balance the settings for the various remaining workers'
 * cost-based vacuum delay feature.
 *
 * Note that there can be more than one worker in a database concurrently.
 * They will store the table they are currently vacuuming in shared memory, so
 * that other workers avoid being blocked waiting for the vacuum lock for that
 * table.  They will also reload the pgstats data just before vacuuming each
 * table, to avoid vacuuming a table that was just finished being vacuumed by
 * another worker and thus is no longer noted in shared memory.  However,
 * there is a window (caused by pgstat delay) on which a worker may choose a
 * table that was already vacuumed; this is a bug in the current design.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/postmaster/autovacuum.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*-------------------------------------------------------------------------
 * GPDB:
 *
 * Distributed auto vacuum means to trigger auto vacuum on QD, and QD
 * manages to dispatch the vacuum request to QEs as distributed transaction.
 *
 * In GPDB there is no distributed auto vacuum yet. For now, all auto vaccums
 * happen on segments locally and do not interact with other auto vaccums.
 *
 * GPDB team had a detailed discussion about distributed auto vacuum. We have
 * no plan for GPDB7, and will determine the approach in future based on
 * feedback from customer.
 *
 * More tech details about distributed auto vacuum for future reference:
 *
 * What's the benefits of the distributed auto vacuum? It might be better global
 * consistency because local auto vacuum happens in different times and different
 * transactions. We can also expect relieving performance jitter theoretically if
 * we can control cluster-size auto vacuum. In addition, we may be able to clean
 * some code because the code of local auto vacuum and distributed user-invoked
 * vacuum are inter-laying for now.
 *
 * Furthermore, we are still not certain about benefit of the consistency produced
 * by distributed auto vacuum. Theoretically, we can get more precise statis info
 * accordingly, but we need more feedback to evaluate the benefit for customer.
 *
 * What's the disadvantages? There might be possible troubles to align to upstream
 * vacuum codes since PG vacuum always happens locally. Importing more complexity
 * is another concern.
 *
 * In MPP setting it's kind of expected all nodes will have a similar activity or
 * bloat on the table (especially catalog tables should have the same effect on all
 * segments), though that's not really true for OLTP user tables. Hence making the
 * global decision to vacuum a table or not, instead of local can become
 * disadvantageous. For example, only one segment has heavy bloat on a table and
 * the rest of the segments are not. Global/distributed vacuum unnecessarily will
 * trigger on all segments even if not required.
 *
 * A possible solution is a kind of unbalanced strategy: when a distributed auto
 * vacuum is triggered, we don't need to perform actual vacuum on all segments. A
 * segment can determine not to perform actual vacuum if it has heavy bloat. Since
 * auto vacuum is repeated, the vacuum is supposed to be finished at sometime with
 * light workload in future. There might also be space for more complex scheduling
 * strategy of distributed auto vacuum based on performance monitoring.
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/multixact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/reloptions.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/catalog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/dependency.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_database.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/dbcommands.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fork_process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pmsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/sinvaladt.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timeout.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>


<comment type="block">/*
 * GUC parameters
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>autovacuum_start_daemon</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>autovacuum_max_workers</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>autovacuum_work_mem</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>autovacuum_naptime</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>autovacuum_vac_thresh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>autovacuum_vac_scale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>autovacuum_anl_thresh</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>autovacuum_anl_scale</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>autovacuum_freeze_max_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>autovacuum_multixact_freeze_max_age</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>double</name></type>		<name>autovacuum_vac_cost_delay</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>autovacuum_vac_cost_limit</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>Log_autovacuum_min_duration</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* how long to keep pgstat data in the launcher, in milliseconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STATS_READ_DELAY</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/* the minimum allowed time between two awakenings of the launcher */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MIN_AUTOVAC_SLEEPTIME</name></cpp:macro> <cpp:value>100.0</cpp:value></cpp:define> <comment type="block">/* milliseconds */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_AUTOVAC_SLEEPTIME</name></cpp:macro> <cpp:value>300</cpp:value></cpp:define>	<comment type="block">/* seconds */</comment>

<comment type="block">/* Flags to tell if we are in an autovacuum process */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>am_autovacuum_launcher</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>am_autovacuum_worker</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Flags set by signal handlers */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGUSR2</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGTERM</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Comparison points for determining whether freeze_max_age is exceeded */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>TransactionId</name></type> <name>recentXid</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MultiXactId</name></type> <name>recentMulti</name></decl>;</decl_stmt>

<comment type="block">/* Default freeze ages to use for autovacuum (varies by database) */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>default_freeze_min_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>default_freeze_table_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>default_multixact_freeze_min_age</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>default_multixact_freeze_table_age</name></decl>;</decl_stmt>

<comment type="block">/* Memory context for long-lived data */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>AutovacMemCxt</name></decl>;</decl_stmt>

<comment type="block">/* struct to keep track of databases in launcher */</comment>
<typedef>typedef <type><struct>struct <name>avl_dbase</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>adl_datid</name></decl>;</decl_stmt>		<comment type="block">/* hash key -- must be first */</comment>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>adl_next_worker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>adl_score</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>adl_node</name></decl>;</decl_stmt>
}</block></struct></type> <name>avl_dbase</name>;</typedef>

<comment type="block">/* struct to keep track of databases in worker */</comment>
<typedef>typedef <type><struct>struct <name>avw_dbase</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>adw_datid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>adw_allowconn</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>adw_name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>adw_frozenxid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>adw_minmulti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>adw_entry</name></decl>;</decl_stmt>
}</block></struct></type> <name>avw_dbase</name>;</typedef>

<comment type="block">/* struct to keep track of tables to vacuum and/or analyze, in 1st pass */</comment>
<typedef>typedef <type><struct>struct <name>av_relation</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ar_toastrelid</name></decl>;</decl_stmt>	<comment type="block">/* hash key - must be first */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ar_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>ar_hasrelopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AutoVacOpts</name></type> <name>ar_reloptions</name></decl>;</decl_stmt>	<comment type="block">/* copy of AutoVacOpts from the main table's
								 * reloptions, or NULL if none */</comment>
}</block></struct></type> <name>av_relation</name>;</typedef>

<comment type="block">/* struct to keep track of tables to vacuum and/or analyze, after rechecking */</comment>
<typedef>typedef <type><struct>struct <name>autovac_table</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>at_relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacuumParams</name></type> <name>at_params</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>at_vacuum_cost_delay</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>at_vacuum_cost_limit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>at_dobalance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>at_sharedrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>at_relname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>at_nspname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>at_datname</name></decl>;</decl_stmt>
}</block></struct></type> <name>autovac_table</name>;</typedef>

<comment type="block">/*-------------
 * This struct holds information about a single worker's whereabouts.  We keep
 * an array of these in shared memory, sized according to
 * autovacuum_max_workers.
 *
 * wi_links		entry into free list or running list
 * wi_dboid		OID of the database this worker is supposed to work on
 * wi_tableoid	OID of the table currently being vacuumed, if any
 * wi_sharedrel flag indicating whether table is marked relisshared
 * wi_proc		pointer to PGPROC of the running worker, NULL if not started
 * wi_launchtime Time at which this worker was launched
 * wi_cost_*	Vacuum cost-based delay parameters current in this worker
 *
 * All fields are protected by AutovacuumLock, except for wi_tableoid and
 * wi_sharedrel which are protected by AutovacuumScheduleLock (note these
 * two fields are read-only for everyone except that worker itself).
 *-------------
 */</comment>
<typedef>typedef <type><struct>struct <name>WorkerInfoData</name>
<block>{
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>wi_links</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>wi_dboid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>wi_tableoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>wi_proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>wi_launchtime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wi_dobalance</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wi_sharedrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>wi_cost_delay</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wi_cost_limit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wi_cost_limit_base</name></decl>;</decl_stmt>
}</block></struct></type> <name>WorkerInfoData</name>;</typedef>

<typedef>typedef <type><name><name>struct</name> <name>WorkerInfoData</name></name> <modifier>*</modifier></type><name>WorkerInfo</name>;</typedef>

<comment type="block">/*
 * Possible signals received by the launcher from remote processes.  These are
 * stored atomically in shared memory so that other processes can set them
 * without locking.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>AutoVacForkFailed</name></decl>,			<comment type="block">/* failed trying to start a worker */</comment>
	<decl><name>AutoVacRebalance</name></decl>,			<comment type="block">/* rebalance the cost limits */</comment>
	<decl><name>AutoVacNumSignals</name></decl>			<comment type="block">/* must be last */</comment>
}</block></enum></type>			<name>AutoVacuumSignal</name>;</typedef>

<comment type="block">/*
 * Autovacuum workitem array, stored in AutoVacuumShmem-&gt;av_workItems.  This
 * list is mostly protected by AutovacuumLock, except that if an item is
 * marked 'active' other processes must not modify the work-identifying
 * members.
 */</comment>
<typedef>typedef <type><struct>struct <name>AutoVacuumWorkItem</name>
<block>{
	<decl_stmt><decl><type><name>AutoVacuumWorkItemType</name></type> <name>avw_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>avw_used</name></decl>;</decl_stmt>		<comment type="block">/* below data is valid */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>avw_active</name></decl>;</decl_stmt>		<comment type="block">/* being processed */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>avw_database</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>avw_relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BlockNumber</name></type> <name>avw_blockNumber</name></decl>;</decl_stmt>
}</block></struct></type> <name>AutoVacuumWorkItem</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_WORKITEMS</name></cpp:macro>	<cpp:value>256</cpp:value></cpp:define>

<comment type="block">/*-------------
 * The main autovacuum shmem struct.  On shared memory we store this main
 * struct and the array of WorkerInfo structs.  This struct keeps:
 *
 * av_signal		set by other processes to indicate various conditions
 * av_launcherpid	the PID of the autovacuum launcher
 * av_freeWorkers	the WorkerInfo freelist
 * av_runningWorkers the WorkerInfo non-free queue
 * av_startingWorker pointer to WorkerInfo currently being started (cleared by
 *					the worker itself as soon as it's up and running)
 * av_workItems		work item array
 *
 * This struct is protected by AutovacuumLock, except for av_signal and parts
 * of the worker list (see above).
 *-------------
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>sig_atomic_t</name></type> <name><name>av_signal</name><index>[<expr><name>AutoVacNumSignals</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>av_launcherpid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name></type>	<name>av_freeWorkers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name></type>	<name>av_runningWorkers</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkerInfo</name></type>	<name>av_startingWorker</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AutoVacuumWorkItem</name></type> <name><name>av_workItems</name><index>[<expr><name>NUM_WORKITEMS</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>AutoVacuumShmemStruct</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>AutoVacuumShmemStruct</name> <modifier>*</modifier></type><name>AutoVacuumShmem</name></decl>;</decl_stmt>

<comment type="block">/*
 * the database list (of avl_dbase elements) in the launcher, and the context
 * that contains it
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>DatabaseList</name> <init>= <expr><call><name>DLIST_STATIC_INIT</name><argument_list>(<argument><expr><name>DatabaseList</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>MemoryContext</name></type> <name>DatabaseListCxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Pointer to my own WorkerInfo, valid on each worker */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>WorkerInfo</name></type> <name>MyWorkerInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* PID of launcher, valid only in worker while shutting down */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>AutovacuumLauncherPid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>avlauncher_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>avworker_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>NON_EXEC_STATIC</name> <name>void</name></type> <name>AutoVacWorkerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><name>NON_EXEC_STATIC</name> <name>void</name></type> <name>AutoVacLauncherMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>do_start_worker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>launcher_determine_sleep</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>canlaunch</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>,
									 <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>nap</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>launch_worker</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>get_database_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>rebuild_database_list</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>newdb</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>db_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>autovac_balance_cost</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_autovacuum</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreeWorkerInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>autovac_table</name> <modifier>*</modifier></type><name>table_recheck_autovac</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>table_toast_map</name></decl></parameter>,
											<parameter><decl><type><name>TupleDesc</name></type> <name>pg_class_desc</name></decl></parameter>,
											<parameter><decl><type><name>int</name></type> <name>effective_multixact_freeze_max_age</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>relation_needs_vacanalyze</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AutoVacOpts</name> <modifier>*</modifier></type><name>relopts</name></decl></parameter>,
									  <parameter><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl></parameter>,
									  <parameter><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl></parameter>,
									  <parameter><decl><type><name>int</name></type> <name>effective_multixact_freeze_max_age</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>dovacuum</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>doanalyze</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>wraparound</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>autovacuum_do_vac_analyze</name><parameter_list>(<parameter><decl><type><name>autovac_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>,
									  <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>AutoVacOpts</name> <modifier>*</modifier></type><name>extract_autovac_opts</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>,
										 <parameter><decl><type><name>TupleDesc</name></type> <name>pg_class_desc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>get_pgstat_tabentry_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isshared</name></decl></parameter>,
													  <parameter><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>,
													  <parameter><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>perform_work_item</name><parameter_list>(<parameter><decl><type><name>AutoVacuumWorkItem</name> <modifier>*</modifier></type><name>workitem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>autovac_report_activity</name><parameter_list>(<parameter><decl><type><name>autovac_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>autovac_report_workitem</name><parameter_list>(<parameter><decl><type><name>AutoVacuumWorkItem</name> <modifier>*</modifier></type><name>workitem</name></decl></parameter>,
									<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>av_sighup_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>avl_sigusr2_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>avl_sigterm_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>autovac_refresh_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>



<comment type="block" format="doxygen">/********************************************************************
 *					  AUTOVACUUM LAUNCHER CODE
 ********************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<comment type="block">/*
 * forkexec routine for the autovacuum launcher process.
 *
 * Format up the arglist, then fork and exec.
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>avlauncher_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forkavlauncher"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* filled in by postmaster_forkexec */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * We need this set from the outside, before InitProcess is called
 */</comment>
<function><type><name>void</name></type>
<name>AutovacuumLauncherIAm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>am_autovacuum_launcher</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Main entry point for autovacuum launcher process, to be called from the
 * postmaster.
 */</comment>
<function><type><name>int</name></type>
<name>StartAutoVacLauncher</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>AutoVacPID</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<switch>switch <condition>(<expr><operator>(</operator><name>AutoVacPID</name> <operator>=</operator> <call><name>avlauncher_forkexec</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<switch>switch <condition>(<expr><operator>(</operator><name>AutoVacPID</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork autovacuum launcher process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* in postmaster child ... */</comment>
			<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close the postmaster's sockets */</comment>
			<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AutoVacLauncherMain</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>AutoVacPID</name></expr>;</return>
	</block_content>}</block></switch></block_content></block></switch>

	<comment type="block">/* shouldn't get here */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Main loop for the autovacuum launcher process.
 */</comment>
<function><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>AutoVacLauncherMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sigjmp_buf</name></type>	<name>local_sigjmp_buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>am_autovacuum_launcher</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Identify myself via ps */</comment>
	<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><call><name>pgstat_get_backend_desc</name><argument_list>(<argument><expr><name>B_AUTOVAC_LAUNCHER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"autovacuum launcher started"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>PostAuthDelay</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PostAuthDelay</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>InitProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up signal handlers.  We operate on databases much like a regular
	 * backend, so we use the same signal handling.  See equivalent code in
	 * tcop/postgres.c.
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>av_sighup_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>avl_sigterm_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* establishes SIGALRM handler */</comment>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>avl_sigusr2_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Early initialization */</comment>
	<expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a per-backend PGPROC struct in shared memory, except in the
	 * EXEC_BACKEND case where this was done in SubPostmasterMain. We must do
	 * this before we can use LWLocks (and in the EXEC_BACKEND case we already
	 * had to do some stuff with LWLocks).
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
	<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a memory context that we will do all our work in.  We do this so
	 * that we can reset the context during error recovery and thereby avoid
	 * possible memory leaks.
	 */</comment>
	<expr_stmt><expr><name>AutovacMemCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										  <argument><expr><literal type="string">"Autovacuum Launcher"</literal></expr></argument>,
										  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If an exception is encountered, processing resumes here.
	 *
	 * This code is a stripped down version of PostgresMain error recovery.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* since not using PG_TRY, must reset error stack by hand */</comment>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Prevents interrupts while cleaning up */</comment>
		<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Forget any pending QueryCancel or timeout request */</comment>
		<expr_stmt><expr><call><name>disable_all_timeouts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt> <comment type="block">/* second to avoid race condition */</comment>

		<comment type="block">/* Report the error to the server log */</comment>
		<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Abort the current transaction in order to recover */</comment>
		<expr_stmt><expr><call><name>AbortCurrentTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Release any other resources, for the case where we were not in a
		 * transaction.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockReleaseAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AbortBufferIO</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* this is probably dead code, but let's be safe: */</comment>
		<if_stmt><if>if <condition>(<expr><name>AuxProcessResourceOwner</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReleaseAuxProcessResources</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>AtEOXact_Buffers</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_SMgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_Files</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_HashTables</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now return to normal top-level context and clear ErrorContext for
		 * next time.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Flush any leaked data in the top-level context */</comment>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* don't leave dangling pointers to freed memory */</comment>
		<expr_stmt><expr><name>DatabaseListCxt</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DatabaseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make sure pgstat also considers our stat data as gone.  Note: we
		 * mustn't use autovac_refresh_stats here.
		 */</comment>
		<expr_stmt><expr><call><name>pgstat_clear_snapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can allow interrupts again */</comment>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if in shutdown mode, no need for anything further; just go away */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>shutdown</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Sleep at least 1 second after any error.  We don't want to be
		 * filling the error logs as fast as we can.
		 */</comment>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We can now handle ereport(ERROR) */</comment>
	<expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

	<comment type="block">/* must unblock signals before calling rebuild_database_list */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set always-secure search path.  Launcher doesn't connect to a database,
	 * so this has no effect.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"search_path"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force zero_damaged_pages OFF in the autovac process, even if it is set
	 * in postgresql.conf.  We don't really want such a dangerous option being
	 * applied non-interactively.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"zero_damaged_pages"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force settable timeouts off to avoid letting these settings prevent
	 * regular maintenance from being executed.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"statement_timeout"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"lock_timeout"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"idle_in_transaction_session_timeout"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>,
					<argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force default_transaction_isolation to READ COMMITTED.  We don't want
	 * to pay the overhead of serializable mode, nor add any risk of causing
	 * deadlocks or delaying other transactions.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"default_transaction_isolation"</literal></expr></argument>, <argument><expr><literal type="string">"read committed"</literal></expr></argument>,
					<argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/*
 * In GPDB, we only want an autovacuum worker to start once we know
 * there is a database to vacuum. Therefore, we never want emergency mode
 * to start a worker immediately.
 *
 * Note: when the emergency mode is running it is possible to continuously
 * start an autovacuum worker. Within the worker, the PMSIGNAL_START_AUTOVAC_LAUNCHER
 * signal is sent when a database is found that is old enough to be vacuumed. If
 * the database chosen is connectable, the launcher will never select it and the
 * worker will continue to signal for a new launcher.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	<comment type="block">/*
	 * In emergency mode, just start a worker (unless shutdown was requested)
	 * and go away.
	 */</comment>
	if (!AutoVacuumingActive())
	{
		if (!got_SIGTERM)
			do_start_worker();
		proc_exit(0);			<comment type="block">/* done */</comment>
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_launcherpid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create the initial database list.  The invariant we want this list to
	 * keep is that it's ordered by decreasing next_time.  As soon as an entry
	 * is updated to a higher time, it will be moved to the front (which is
	 * correct because the only operation is to add autovacuum_naptime to the
	 * entry, and time always increases).
	 */</comment>
	<expr_stmt><expr><call><name>rebuild_database_list</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* loop until shutdown request */</comment>
	<while>while <condition>(<expr><operator>!</operator><name>got_SIGTERM</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>nap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>current_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>can_launch</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * This loop is a bit different from the normal use of WaitLatch,
		 * because we'd like to sleep before the first launch of a child
		 * process.  So it's WaitLatch, then ResetLatch, then check for
		 * wakening conditions.
		 */</comment>

		<expr_stmt><expr><call><name>launcher_determine_sleep</name><argument_list>(<argument><expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_freeWorkers</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Wait until naptime expires or we get some type of signal (all the
		 * signal handlers will wake us by calling SetLatch).
		 */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
						 <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
						 <argument><expr><operator>(</operator><name><name>nap</name><operator>.</operator><name>tv_sec</name></name> <operator>*</operator> <literal type="number">1000L</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><name><name>nap</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000L</literal><operator>)</operator></expr></argument>,
						 <argument><expr><name>WAIT_EVENT_AUTOVACUUM_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Process sinval catchup interrupts that happened while sleeping */</comment>
		<expr_stmt><expr><call><name>ProcessCatchupInterrupt</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* the normal shutdown case */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_SIGTERM</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* shutdown requested in config file? */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AutoVacuumingActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/* rebalance in case the default cost parameters changed */</comment>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>autovac_balance_cost</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* rebuild the list in case the naptime changed */</comment>
			<expr_stmt><expr><call><name>rebuild_database_list</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * a worker finished, or postmaster signalled failure to start a
		 * worker
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_SIGUSR2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGUSR2</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<comment type="block">/* rebalance cost limits, if needed */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_signal</name><index>[<expr><name>AutoVacRebalance</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_signal</name><index>[<expr><name>AutoVacRebalance</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>autovac_balance_cost</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_signal</name><index>[<expr><name>AutoVacForkFailed</name></expr>]</index></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If the postmaster failed to start a new worker, we sleep
				 * for a little while and resend the signal.  The new worker's
				 * state is still in memory, so this is sufficient.  After
				 * that, we restart the main loop.
				 *
				 * XXX should we put a limit to the number of times we retry?
				 * I don't think it makes much sense, because a future start
				 * of a worker will continue to fail in the same way.
				 */</comment>
				<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_signal</name><index>[<expr><name>AutoVacForkFailed</name></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* 1s */</comment>
				<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_WORKER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * There are some conditions that we need to check before trying to
		 * start a worker.  First, we need to make sure that there is a worker
		 * slot available.  Second, we need to make sure that no other worker
		 * failed while starting up.
		 */</comment>

		<expr_stmt><expr><name>current_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>can_launch</name> <operator>=</operator> <operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_freeWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>waittime</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>WorkerInfo</name></type>	<name>worker</name> <init>= <expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We can't launch another worker when another one is still
			 * starting up (or failed while doing so), so just sleep for a bit
			 * more; that worker will wake us up again as soon as it's ready.
			 * We will only wait autovacuum_naptime seconds (up to a maximum
			 * of 60 seconds) for this to happen however.  Note that failure
			 * to connect to a particular database is not a problem here,
			 * because the worker removes itself from the startingWorker
			 * pointer before trying to connect.  Problems detected by the
			 * postmaster (like fork() failure) are also reported and handled
			 * differently.  The only problems that may cause this code to
			 * fire are errors in the earlier sections of AutoVacWorkerMain,
			 * before the worker removes the WorkerInfo from the
			 * startingWorker pointer.
			 */</comment>
			<expr_stmt><expr><name>waittime</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>autovacuum_naptime</name></expr></argument>, <argument><expr><literal type="number">60</literal></expr></argument>)</argument_list></call> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_launchtime</name></name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>,
										   <argument><expr><name>waittime</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * No other process can put a worker in starting mode, so if
				 * startingWorker is still INVALID after exchanging our lock,
				 * we assume it's the same one we saw above (so we don't
				 * recheck the launch time).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>worker</name> <operator>=</operator> <name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_dboid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_tableoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_sharedrel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_proc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_launchtime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_freeWorkers</name></name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name><name>worker</name><operator>-&gt;</operator><name>wi_links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"worker took too long to start; canceled"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>can_launch</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* either shared or exclusive */</comment>

		<comment type="block">/* if we can't do anything, just go back to sleep */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>can_launch</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* We're OK to start a new worker */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DatabaseList</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Special case when the list is empty: start a worker right away.
			 * This covers the initial case, when no database is in pgstats
			 * (thus the list is empty).  Note that the constraints in
			 * launcher_determine_sleep keep us from starting workers too
			 * quickly (at most once every autovacuum_naptime when the list is
			 * empty).
			 */</comment>
			<expr_stmt><expr><call><name>launch_worker</name><argument_list>(<argument><expr><name>current_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * because rebuild_database_list constructs a list with most
			 * distant adl_next_worker first, we obtain our database from the
			 * tail of the list.
			 */</comment>
			<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>avdb</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>avdb</name> <operator>=</operator> <call><name>dlist_tail_element</name><argument_list>(<argument><expr><name>avl_dbase</name></expr></argument>, <argument><expr><name>adl_node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DatabaseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * launch a worker if next_worker is right now or it is in the
			 * past
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>avdb</name><operator>-&gt;</operator><name>adl_next_worker</name></name></expr></argument>,
										   <argument><expr><name>current_time</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>launch_worker</name><argument_list>(<argument><expr><name>current_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Normal exit from the autovac launcher is here */</comment>
<label><name>shutdown</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"autovacuum launcher shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_launcherpid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>				<comment type="block">/* done */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the time to sleep, based on the database list.
 *
 * The "canlaunch" parameter indicates whether we can start a worker right now,
 * for example due to the workers being all busy.  If this is false, we will
 * cause a long sleep, which will be interrupted when a worker exits.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>launcher_determine_sleep</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>canlaunch</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>timeval</name></name> <modifier>*</modifier></type><name>nap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We sleep until the next scheduled vacuum.  We trust that when the
	 * database list was built, care was taken so that no entries have times
	 * in the past; if the first entry has too close a next_worker value, or a
	 * time in the past, we will sleep a small nominal time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>canlaunch</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nap</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <name>autovacuum_naptime</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nap</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DatabaseList</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>current_time</name> <init>= <expr><call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>next_wakeup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>avdb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>secs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>usecs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>avdb</name> <operator>=</operator> <call><name>dlist_tail_element</name><argument_list>(<argument><expr><name>avl_dbase</name></expr></argument>, <argument><expr><name>adl_node</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DatabaseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>next_wakeup</name> <operator>=</operator> <name><name>avdb</name><operator>-&gt;</operator><name>adl_next_worker</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TimestampDifference</name><argument_list>(<argument><expr><name>current_time</name></expr></argument>, <argument><expr><name>next_wakeup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>secs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>usecs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>nap</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <name>secs</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nap</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <name>usecs</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* list is empty, sleep for whole autovacuum_naptime seconds  */</comment>
		<expr_stmt><expr><name><name>nap</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <name>autovacuum_naptime</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nap</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If the result is exactly zero, it means a database had an entry with
	 * time in the past.  Rebuild the list so that the databases are evenly
	 * distributed again, and recalculate the time to sleep.  This can happen
	 * if there are more tables needing vacuum than workers, and they all take
	 * longer to vacuum than autovacuum_naptime.
	 *
	 * We only recurse once.  rebuild_database_list should always return times
	 * in the future, but it seems best not to trust too much on that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nap</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>nap</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>recursing</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>rebuild_database_list</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>launcher_determine_sleep</name><argument_list>(<argument><expr><name>canlaunch</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>nap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The smallest time we'll allow the launcher to sleep. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nap</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>nap</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>&lt;=</operator> <name>MIN_AUTOVAC_SLEEPTIME</name> <operator>*</operator> <literal type="number">1000</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>nap</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nap</name><operator>-&gt;</operator><name>tv_usec</name></name> <operator>=</operator> <name>MIN_AUTOVAC_SLEEPTIME</name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the sleep time is too large, clamp it to an arbitrary maximum (plus
	 * any fractional seconds, for simplicity).  This avoids an essentially
	 * infinite sleep in strange cases like the system clock going backwards a
	 * few years.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>nap</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>&gt;</operator> <name>MAX_AUTOVAC_SLEEPTIME</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>nap</name><operator>-&gt;</operator><name>tv_sec</name></name> <operator>=</operator> <name>MAX_AUTOVAC_SLEEPTIME</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build an updated DatabaseList.  It must only contain databases that appear
 * in pgstats, and must be sorted by next_worker from highest to lowest,
 * distributed regularly across the next autovacuum_naptime interval.
 *
 * Receives the Oid of the database that made this list be generated (we call
 * this the "new" database, because when the database was already present on
 * the list, we expect that this function is not called at all).  The
 * preexisting list, if any, will be used to preserve the order of the
 * databases in the autovacuum_naptime period.  The new database is put at the
 * end of the interval.  The actual values are not saved, which should not be
 * much of a problem.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>rebuild_database_list</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>newdb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dblist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>newcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>score</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nelems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>dbhash</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<comment type="block">/* use fresh stats */</comment>
	<expr_stmt><expr><call><name>autovac_refresh_stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>,
								   <argument><expr><literal type="string">"AV dblist"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmpcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>newcxt</name></expr></argument>,
								   <argument><expr><literal type="string">"tmp AV dblist"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Implementing this is not as simple as it sounds, because we need to put
	 * the new database at the end of the list; next the databases that were
	 * already on the list, and finally (at the tail of the list) all the
	 * other databases that are not on the existing list.
	 *
	 * To do this, we build an empty hash table of scored databases.  We will
	 * start with the lowest score (zero) for the new database, then
	 * increasing scores for the databases in the existing list, in order, and
	 * lastly increasing scores for all databases gotten via
	 * get_database_list() that are not already on the hash.
	 *
	 * Then we will put all the hash elements into an array, sort the array by
	 * score, and finally put the array elements into the new doubly linked
	 * list.
	 */</comment>
	<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>avl_dbase</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>tmpcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbhash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"db hash"</literal></expr></argument>, <argument><expr><literal type="number">20</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hctl</name></expr></argument>,	<comment type="block">/* magic number here FIXME */</comment>
						 <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* start by inserting the new database */</comment>
	<expr_stmt><expr><name>score</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>newdb</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<comment type="block">/* only consider this database if it has a pgstat entry */</comment>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_dbentry</name><argument_list>(<argument><expr><name>newdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we assume it isn't found because the hash was just created */</comment>
			<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>dbhash</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newdb</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* hash_search already filled in the key */</comment>
			<expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>adl_score</name></name> <operator>=</operator> <name>score</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* next_worker is filled in later */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Now insert the databases from the existing list */</comment>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;DatabaseList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>avdb</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>avl_dbase</name></expr></argument>, <argument><expr><name>adl_node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * skip databases with no stat entries -- in particular, this gets rid
		 * of dropped databases
		 */</comment>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_dbentry</name><argument_list>(<argument><expr><name><name>avdb</name><operator>-&gt;</operator><name>adl_datid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>dbhash</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>avdb</name><operator>-&gt;</operator><name>adl_datid</name></name><operator>)</operator></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* hash_search already filled in the key */</comment>
			<expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>adl_score</name></name> <operator>=</operator> <name>score</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* next_worker is filled in later */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* finally, insert all qualifying databases not previously inserted */</comment>
	<expr_stmt><expr><name>dblist</name> <operator>=</operator> <call><name>get_database_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>dblist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>avw_dbase</name>  <modifier>*</modifier></type><name>avdb</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

		<comment type="block">/* only consider databases with a pgstat entry */</comment>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_dbentry</name><argument_list>(<argument><expr><name><name>avdb</name><operator>-&gt;</operator><name>adw_datid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>db</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>dbhash</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>avdb</name><operator>-&gt;</operator><name>adw_datid</name></name><operator>)</operator></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* only update the score if the database was not already on the hash */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* hash_search already filled in the key */</comment>
			<expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>adl_score</name></name> <operator>=</operator> <name>score</name><operator>++</operator></expr>;</expr_stmt>
			<comment type="block">/* next_worker is filled in later */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><name>nelems</name> <operator>=</operator> <name>score</name></expr>;</expr_stmt>

	<comment type="block">/* from here on, the allocated memory belongs to the new list */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>newcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DatabaseList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nelems</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>current_time</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>millis_increment</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>dbary</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>db</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>seq</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* put all the hash elements into an array */</comment>
		<expr_stmt><expr><name>dbary</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>nelems</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>avl_dbase</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>, <argument><expr><name>dbhash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>(</operator><name>db</name> <operator>=</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>seq</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>dbary</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>avl_dbase</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* sort the array */</comment>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name>dbary</name></expr></argument>, <argument><expr><name>nelems</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>avl_dbase</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>db_comparator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Determine the time interval between databases in the schedule. If
		 * we see that the configured naptime would take us to sleep times
		 * lower than our min sleep time (which launcher_determine_sleep is
		 * coded not to allow), silently use a larger naptime (but don't touch
		 * the GUC variable).
		 */</comment>
		<expr_stmt><expr><name>millis_increment</name> <operator>=</operator> <literal type="number">1000.0</literal> <operator>*</operator> <name>autovacuum_naptime</name> <operator>/</operator> <name>nelems</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>millis_increment</name> <operator>&lt;=</operator> <name>MIN_AUTOVAC_SLEEPTIME</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>millis_increment</name> <operator>=</operator> <name>MIN_AUTOVAC_SLEEPTIME</name> <operator>*</operator> <literal type="number">1.1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>current_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * move the elements from the array into the dllist, setting the
		 * next_worker while walking the array
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>db</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>dbary</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>current_time</name> <operator>=</operator> <call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>current_time</name></expr></argument>,
													   <argument><expr><name>millis_increment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>db</name><operator>-&gt;</operator><name>adl_next_worker</name></name> <operator>=</operator> <name>current_time</name></expr>;</expr_stmt>

			<comment type="block">/* later elements should go closer to the head of the list */</comment>
			<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DatabaseList</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>db</name><operator>-&gt;</operator><name>adl_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* all done, clean up memory */</comment>
	<if_stmt><if>if <condition>(<expr><name>DatabaseListCxt</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>DatabaseListCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>DatabaseListCxt</name> <operator>=</operator> <name>newcxt</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* qsort comparator for avl_dbase, using adl_score */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>db_comparator</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>avl_dbase</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>adl_score</name> <operator>==</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>avl_dbase</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>adl_score</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><operator>(</operator><operator>(</operator><operator>(</operator><specifier>const</specifier> <name>avl_dbase</name> <operator>*</operator><operator>)</operator> <name>a</name><operator>)</operator><operator>-&gt;</operator><name>adl_score</name> <operator>&lt;</operator> <operator>(</operator><operator>(</operator><specifier>const</specifier> <name>avl_dbase</name> <operator>*</operator><operator>)</operator> <name>b</name><operator>)</operator><operator>-&gt;</operator><name>adl_score</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * do_start_worker
 *
 * Bare-bones procedure for starting an autovacuum worker from the launcher.
 * It determines what database to work on, sets up shared memory stuff and
 * signals postmaster to start the worker.  It fails gracefully if invoked when
 * autovacuum_workers are already active.
 *
 * Return value is the OID of the database that the worker is going to process,
 * or InvalidOid if no worker was actually started.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>do_start_worker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dblist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidForceLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiForceLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>for_xid_wrap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>for_multi_wrap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>avw_dbase</name>  <modifier>*</modifier></type><name>avdb</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>current_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>skipit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>retval</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpcxt</name></decl>,
				<decl><type ref="prev"/><name>oldcxt</name></decl>;</decl_stmt>

	<comment type="block">/* return quickly when there are no free workers */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_freeWorkers</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create and switch to a temporary context to avoid leaking the memory
	 * allocated for the database list.
	 */</comment>
	<expr_stmt><expr><name>tmpcxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
								   <argument><expr><literal type="string">"Start worker tmp cxt"</literal></expr></argument>,
								   <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* use fresh stats */</comment>
	<expr_stmt><expr><call><name>autovac_refresh_stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get a list of databases */</comment>
	<expr_stmt><expr><name>dblist</name> <operator>=</operator> <call><name>get_database_list</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine the oldest datfrozenxid/relfrozenxid that we will allow to
	 * pass without forcing a vacuum.  (This limit can be tightened for
	 * particular tables, but not loosened.)
	 */</comment>
	<expr_stmt><expr><name>recentXid</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xidForceLimit</name> <operator>=</operator> <name>recentXid</name> <operator>-</operator> <name>autovacuum_freeze_max_age</name></expr>;</expr_stmt>
	<comment type="block">/* ensure it's a "normal" XID, else TransactionIdPrecedes misbehaves */</comment>
	<comment type="block">/* this can cause the limit to go backwards by 3, but that's OK */</comment>
	<if_stmt><if>if <condition>(<expr><name>xidForceLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidForceLimit</name> <operator>-=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Also determine the oldest datminmxid we will consider. */</comment>
	<expr_stmt><expr><name>recentMulti</name> <operator>=</operator> <call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>multiForceLimit</name> <operator>=</operator> <name>recentMulti</name> <operator>-</operator> <call><name>MultiXactMemberFreezeThreshold</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>multiForceLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>multiForceLimit</name> <operator>-=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Choose a database to connect to.  We pick the database that was least
	 * recently auto-vacuumed, or one that needs vacuuming to prevent Xid
	 * wraparound-related data loss.  If any db at risk of Xid wraparound is
	 * found, we pick the one with oldest datfrozenxid, independently of
	 * autovacuum times; similarly we pick the one with the oldest datminmxid
	 * if any is in MultiXactId wraparound.  Note that those in Xid wraparound
	 * danger are given more priority than those in multi wraparound danger.
	 *
	 * Note that a database with no stats entry is not considered, except for
	 * Xid wraparound purposes.  The theory is that if no one has ever
	 * connected to it since the stats were last initialized, it doesn't need
	 * vacuuming.
	 *
	 * XXX This could be improved if we had more info about whether it needs
	 * vacuuming before connecting to it.  Perhaps look through the pgstats
	 * data for the database's tables?  One idea is to keep track of the
	 * number of new and dead tuples per database in pgstats.  However it
	 * isn't clear how to construct a metric that measures that and not cause
	 * starvation for less busy databases.
	 */</comment>
	<expr_stmt><expr><name>avdb</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>for_xid_wrap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>for_multi_wrap</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>current_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>dblist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>avw_dbase</name>  <modifier>*</modifier></type><name>tmp</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

		<comment type="block">/* Check to see if this one is at risk of wraparound */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>adw_frozenxid</name></name></expr></argument>, <argument><expr><name>xidForceLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>avdb</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>adw_frozenxid</name></name></expr></argument>,
									  <argument><expr><name><name>avdb</name><operator>-&gt;</operator><name>adw_frozenxid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>avdb</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>for_xid_wrap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>for_xid_wrap</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if>			<comment type="block">/* ignore not-at-risk DBs */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>adw_minmulti</name></name></expr></argument>, <argument><expr><name>multiForceLimit</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>avdb</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>adw_minmulti</name></name></expr></argument>, <argument><expr><name><name>avdb</name><operator>-&gt;</operator><name>adw_minmulti</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>avdb</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>for_multi_wrap</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>for_multi_wrap</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* ignore not-at-risk DBs */</comment>

		<comment type="block">/* Find pgstat entry if any */</comment>
		<expr_stmt><expr><name><name>tmp</name><operator>-&gt;</operator><name>adw_entry</name></name> <operator>=</operator> <call><name>pgstat_fetch_stat_dbentry</name><argument_list>(<argument><expr><name><name>tmp</name><operator>-&gt;</operator><name>adw_datid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Skip a database with no pgstat entry; it means it hasn't seen any
		 * activity.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tmp</name><operator>-&gt;</operator><name>adw_entry</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Also, skip a database that appears on the database list as having
		 * been processed recently (less than autovacuum_naptime seconds ago).
		 * We do this so that we don't select a database which we just
		 * selected, but that pgstat hasn't gotten around to updating the last
		 * autovacuum time yet.
		 */</comment>
		<expr_stmt><expr><name>skipit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<macro><name>dlist_reverse_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;DatabaseList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>dbp</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>avl_dbase</name></expr></argument>, <argument><expr><name>adl_node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>dbp</name><operator>-&gt;</operator><name>adl_datid</name></name> <operator>==</operator> <name><name>tmp</name><operator>-&gt;</operator><name>adw_datid</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Skip this database if its next_worker value falls between
				 * the current time and the current time plus naptime.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name><name>dbp</name><operator>-&gt;</operator><name>adl_next_worker</name></name></expr></argument>,
												<argument><expr><name>current_time</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>current_time</name></expr></argument>,
												<argument><expr><name><name>dbp</name><operator>-&gt;</operator><name>adl_next_worker</name></name></expr></argument>,
												<argument><expr><name>autovacuum_naptime</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>skipit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<if_stmt><if>if <condition>(<expr><name>skipit</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Remember the db with oldest autovac time.  (If we are here, both
		 * tmp-&gt;entry and db-&gt;entry must be non-null.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>avdb</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			<name><name>tmp</name><operator>-&gt;</operator><name>adw_entry</name><operator>-&gt;</operator><name>last_autovac_time</name></name> <operator>&lt;</operator> <name><name>avdb</name><operator>-&gt;</operator><name>adw_entry</name><operator>-&gt;</operator><name>last_autovac_time</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>avdb</name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Found a database -- process it */</comment>
	<if_stmt><if>if <condition>(<expr><name>avdb</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerInfo</name></type>	<name>worker</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>wptr</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get a worker entry from the freelist.  We checked above, so there
		 * really should be a free slot.
		 */</comment>
		<expr_stmt><expr><name>wptr</name> <operator>=</operator> <call><name>dlist_pop_head_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_freeWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>worker</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>WorkerInfoData</name></expr></argument>, <argument><expr><name>wi_links</name></expr></argument>, <argument><expr><name>wptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_dboid</name></name> <operator>=</operator> <name><name>avdb</name><operator>-&gt;</operator><name>adw_datid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_proc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_launchtime</name></name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name> <operator>=</operator> <name>worker</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SendPostmasterSignal</name><argument_list>(<argument><expr><name>PMSIGNAL_START_AUTOVAC_WORKER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <name><name>avdb</name><operator>-&gt;</operator><name>adw_datid</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>skipit</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we skipped all databases on the list, rebuild it, because it
		 * probably contains a dropped database.
		 */</comment>
		<expr_stmt><expr><call><name>rebuild_database_list</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmpcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retval</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * launch_worker
 *
 * Wrapper for starting a worker from the launcher.  Besides actually starting
 * it, update the database list to reflect the next time that another one will
 * need to be started on the selected database.  The actual database choice is
 * left to do_start_worker.
 *
 * This routine is also expected to insert an entry into the database list if
 * the selected database was previously absent from the list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>launch_worker</name><parameter_list>(<parameter><decl><type><name>TimestampTz</name></type> <name>now</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dbid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>dbid</name> <operator>=</operator> <call><name>do_start_worker</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Walk the database list and update the corresponding entry.  If the
		 * database is not on the list, we'll recreate the list.
		 */</comment>
		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;DatabaseList</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>avl_dbase</name>  <modifier>*</modifier></type><name>avdb</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>avl_dbase</name></expr></argument>, <argument><expr><name>adl_node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>avdb</name><operator>-&gt;</operator><name>adl_datid</name></name> <operator>==</operator> <name>dbid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * add autovacuum_naptime seconds to the current time, and use
				 * that as the new "next_worker" field for this database.
				 */</comment>
				<expr_stmt><expr><name><name>avdb</name><operator>-&gt;</operator><name>adl_next_worker</name></name> <operator>=</operator>
					<call><name>TimestampTzPlusMilliseconds</name><argument_list>(<argument><expr><name>now</name></expr></argument>, <argument><expr><name>autovacuum_naptime</name> <operator>*</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>dlist_move_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name>DatabaseList</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * If the database was not present in the database list, we rebuild
		 * the list.  It's possible that the database does not get into the
		 * list anyway, for example if it's a database that doesn't have a
		 * pgstat entry, but this is not a problem because we don't want to
		 * schedule workers regularly into those in any case.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>rebuild_database_list</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Called from postmaster to signal a failure to fork a process to become
 * worker.  The postmaster should kill(SIGUSR2) the launcher shortly
 * after calling this function.
 */</comment>
<function><type><name>void</name></type>
<name>AutoVacWorkerFailed</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_signal</name><index>[<expr><name>AutoVacForkFailed</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGHUP: set flag to re-read config file at next convenient time */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>av_sighup_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR2: a worker is up and running, or just finished, or failed to fork */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>avl_sigusr2_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGUSR2</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGTERM: time to die */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>avl_sigterm_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGTERM</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/********************************************************************
 *					  AUTOVACUUM WORKER CODE
 ********************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<comment type="block">/*
 * forkexec routines for the autovacuum worker.
 *
 * Format up the arglist, then fork and exec.
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>avworker_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forkavworker"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* filled in by postmaster_forkexec */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * We need this set from the outside, before InitProcess is called
 */</comment>
<function><type><name>void</name></type>
<name>AutovacuumWorkerIAm</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>am_autovacuum_worker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Main entry point for autovacuum worker process.
 *
 * This code is heavily based on pgarch.c, q.v.
 */</comment>
<function><type><name>int</name></type>
<name>StartAutoVacWorker</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>worker_pid</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<switch>switch <condition>(<expr><operator>(</operator><name>worker_pid</name> <operator>=</operator> <call><name>avworker_forkexec</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<switch>switch <condition>(<expr><operator>(</operator><name>worker_pid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork autovacuum worker process: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* in postmaster child ... */</comment>
			<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close the postmaster's sockets */</comment>
			<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>AutoVacWorkerMain</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<default>default:</default>
			<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>worker_pid</name></expr>;</return>
	</block_content>}</block></switch></block_content></block></switch>

	<comment type="block">/* shouldn't get here */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AutoVacWorkerMain
 */</comment>
<function><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>AutoVacWorkerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sigjmp_buf</name></type>	<name>local_sigjmp_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>dbid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>am_autovacuum_worker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* MPP-4990: Autovacuum always runs as utility-mode */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>Gp_role</name> <operator>=</operator> <name>GP_ROLE_DISPATCH</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>Gp_role</name> <operator>=</operator> <name>GP_ROLE_UTILITY</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Identify myself via ps */</comment>
	<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><call><name>pgstat_get_backend_desc</name><argument_list>(<argument><expr><name>B_AUTOVAC_WORKER</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * PreAuthDelay is a debugging aid for investigating problems in the 
	 * authentication cycle. 
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>PreAuthDelay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PreAuthDelay</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>InitProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up signal handlers.  We operate on databases much like a regular
	 * backend, so we use the same signal handling.  See equivalent code in
	 * tcop/postgres.c.
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>av_sighup_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SIGINT is used to signal canceling the current table's vacuum; SIGTERM
	 * means abort and exit cleanly, and SIGQUIT means abandon ship.
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>StatementCancelHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>die</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>InitializeTimeouts</name><argument_list>()</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* establishes SIGALRM handler */</comment>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>procsignal_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGFPE</name></expr></argument>, <argument><expr><name>FloatExceptionHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Early initialization */</comment>
	<expr_stmt><expr><call><name>BaseInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a per-backend PGPROC struct in shared memory, except in the
	 * EXEC_BACKEND case where this was done in SubPostmasterMain. We must do
	 * this before we can use LWLocks (and in the EXEC_BACKEND case we already
	 * had to do some stuff with LWLocks).
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
	<expr_stmt><expr><call><name>InitProcess</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * If an exception is encountered, processing resumes here.
	 *
	 * See notes in postgres.c about the design of this coding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Prevents interrupts while cleaning up */</comment>
		<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Report the error to the server log */</comment>
		<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can now go away.  Note that because we called InitProcess, a
		 * callback was registered to do ProcKill, which will clean up
		 * necessary state.
		 */</comment>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We can now handle ereport(ERROR) */</comment>
	<expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set always-secure search path, so malicious users can't redirect user
	 * code (e.g. pg_index.indexprs).  (That code runs in a
	 * SECURITY_RESTRICTED_OPERATION sandbox, so malicious users could not
	 * take control of the entire autovacuum worker in any case.)
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"search_path"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force zero_damaged_pages OFF in the autovac process, even if it is set
	 * in postgresql.conf.  We don't really want such a dangerous option being
	 * applied non-interactively.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"zero_damaged_pages"</literal></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force settable timeouts off to avoid letting these settings prevent
	 * regular maintenance from being executed.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"statement_timeout"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"lock_timeout"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>, <argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"idle_in_transaction_session_timeout"</literal></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>,
					<argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force default_transaction_isolation to READ COMMITTED.  We don't want
	 * to pay the overhead of serializable mode, nor add any risk of causing
	 * deadlocks or delaying other transactions.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"default_transaction_isolation"</literal></expr></argument>, <argument><expr><literal type="string">"read committed"</literal></expr></argument>,
					<argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force synchronous replication off to allow regular maintenance even if
	 * we are waiting for standbys to connect. This is important to ensure we
	 * aren't blocked from performing anti-wraparound tasks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>synchronous_commit</name> <operator>&gt;</operator> <name>SYNCHRONOUS_COMMIT_LOCAL_FLUSH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"synchronous_commit"</literal></expr></argument>, <argument><expr><literal type="string">"local"</literal></expr></argument>,
						<argument><expr><name>PGC_SUSET</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the info about the database we're going to work on.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * beware of startingWorker being INVALID; this should normally not
	 * happen, but if a worker fails after forking and before this, the
	 * launcher might have decided to remove it from the queue and start
	 * again.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>MyWorkerInfo</name> <operator>=</operator> <name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbid</name> <operator>=</operator> <name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_dboid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_proc</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>

		<comment type="block">/* insert into the running list */</comment>
		<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_runningWorkers</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * remove from the "starting" pointer, so that the launcher can start
		 * a new worker if required
		 */</comment>
		<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>FreeWorkerInfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* wake up the launcher */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_launcherpid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>kill</name><argument_list>(<argument><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_launcherpid</name></name></expr></argument>, <argument><expr><name>SIGUSR2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no worker entry for me, go away */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"autovacuum worker started without a worker entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dbid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>dbname</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Report autovac startup to the stats collector.  We deliberately do
		 * this before InitPostgres, so that the last_autovac_time will get
		 * updated even if the connection attempt fails.  This is to prevent
		 * autovac from getting "stuck" repeatedly selecting an unopenable
		 * database, rather than making any progress on stuff it can connect
		 * to.
		 */</comment>
		<expr_stmt><expr><call><name>pgstat_report_autovac</name><argument_list>(<argument><expr><name>dbid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Connect to the selected database
		 *
		 * Note: if we have selected a just-deleted database (due to using
		 * stale stats info), we'll fail and exit here.
		 */</comment>
		<expr_stmt><expr><call><name>InitPostgres</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>dbid</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SetProcessingMode</name><argument_list>(<argument><expr><name>NormalProcessing</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>dbname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"autovacuum: processing database \"%s\""</literal></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
			<argument><expr><literal type="string">"auto_vac_worker_before_do_autovacuum"</literal></expr></argument>, <argument><expr><name>DDLNotSpecified</name></expr></argument>,
			<argument><expr><name>dbname</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<if_stmt><if>if <condition>(<expr><name>PostAuthDelay</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>PostAuthDelay</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* And do an appropriate amount of work */</comment>
		<expr_stmt><expr><name>recentXid</name> <operator>=</operator> <call><name>ReadNewTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>recentMulti</name> <operator>=</operator> <call><name>ReadNextMultiXactId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>do_autovacuum</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The launcher will be notified of my death in ProcKill, *if* we managed
	 * to get a worker slot at all
	 */</comment>

	<comment type="block">/* All done, go away */</comment>
	<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return a WorkerInfo to the free list
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreeWorkerInfo</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MyWorkerInfo</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Wake the launcher up so that he can launch a new worker immediately
		 * if required.  We only save the launcher's PID in local memory here;
		 * the actual signal will be sent when the PGPROC is recycled.  Note
		 * that we always do this, so that the launcher can rebalance the cost
		 * limit setting of the remaining workers.
		 *
		 * We somewhat ignore the risk that the launcher changes its PID
		 * between us reading it and the actual kill; we expect ProcKill to be
		 * called shortly after us, and we assume that PIDs are not reused too
		 * quickly after a process exits.
		 */</comment>
		<expr_stmt><expr><name>AutovacuumLauncherPid</name> <operator>=</operator> <name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_launcherpid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_dboid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_tableoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_sharedrel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_proc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_launchtime</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_dobalance</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_cost_delay</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_cost_limit</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_cost_limit_base</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_freeWorkers</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* not mine anymore */</comment>
		<expr_stmt><expr><name>MyWorkerInfo</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * now that we're inactive, cause a rebalancing of the surviving
		 * workers
		 */</comment>
		<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_signal</name><index>[<expr><name>AutoVacRebalance</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the cost-based delay parameters, so that multiple workers consume
 * each a fraction of the total available I/O.
 */</comment>
<function><type><name>void</name></type>
<name>AutoVacuumUpdateDelay</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MyWorkerInfo</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>VacuumCostDelay</name> <operator>=</operator> <name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_cost_delay</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumCostLimit</name> <operator>=</operator> <name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_cost_limit</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * autovac_balance_cost
 *		Recalculate the cost limit setting for each active worker.
 *
 * Caller must hold the AutovacuumLock in exclusive mode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>autovac_balance_cost</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The idea here is that we ration out I/O equally.  The amount of I/O
	 * that a worker can consume is determined by cost_limit/cost_delay, so we
	 * try to equalize those ratios rather than the raw limit settings.
	 *
	 * note: in cost_limit, zero also means use value from elsewhere, because
	 * zero is not a valid value.
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>vac_cost_limit</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>autovacuum_vac_cost_limit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then>
								  <expr><name>autovacuum_vac_cost_limit</name></expr> </then><else>: <expr><name>VacuumCostLimit</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>vac_cost_delay</name> <init>= <expr><operator>(</operator><ternary><condition><expr><name>autovacuum_vac_cost_delay</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr> ?</condition><then>
								  <expr><name>autovacuum_vac_cost_delay</name></expr> </then><else>: <expr><name>VacuumCostDelay</name></expr></else></ternary><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>cost_total</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>cost_avail</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<comment type="block">/* not set? nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>vac_cost_limit</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>vac_cost_delay</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* calculate the total base cost limit of participating active workers */</comment>
	<expr_stmt><expr><name>cost_total</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;AutoVacuumShmem-&gt;av_runningWorkers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerInfo</name></type>	<name>worker</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>WorkerInfoData</name></expr></argument>, <argument><expr><name>wi_links</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>wi_proc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>worker</name><operator>-&gt;</operator><name>wi_dobalance</name></name> <operator>&amp;&amp;</operator>
			<name><name>worker</name><operator>-&gt;</operator><name>wi_cost_limit_base</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>worker</name><operator>-&gt;</operator><name>wi_cost_delay</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cost_total</name> <operator>+=</operator>
				<operator>(</operator><name>double</name><operator>)</operator> <name><name>worker</name><operator>-&gt;</operator><name>wi_cost_limit_base</name></name> <operator>/</operator> <name><name>worker</name><operator>-&gt;</operator><name>wi_cost_delay</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* there are no cost limits -- nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><name>cost_total</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Adjust cost limit of each active worker to balance the total of cost
	 * limit to autovacuum_vacuum_cost_limit.
	 */</comment>
	<expr_stmt><expr><name>cost_avail</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>vac_cost_limit</name> <operator>/</operator> <name>vac_cost_delay</name></expr>;</expr_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;AutoVacuumShmem-&gt;av_runningWorkers</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerInfo</name></type>	<name>worker</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>WorkerInfoData</name></expr></argument>, <argument><expr><name>wi_links</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>wi_proc</name></name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>worker</name><operator>-&gt;</operator><name>wi_dobalance</name></name> <operator>&amp;&amp;</operator>
			<name><name>worker</name><operator>-&gt;</operator><name>wi_cost_limit_base</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>worker</name><operator>-&gt;</operator><name>wi_cost_delay</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>limit</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator>
			<operator>(</operator><name>cost_avail</name> <operator>*</operator> <name><name>worker</name><operator>-&gt;</operator><name>wi_cost_limit_base</name></name> <operator>/</operator> <name>cost_total</name><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * We put a lower bound of 1 on the cost_limit, to avoid division-
			 * by-zero in the vacuum code.  Also, in case of roundoff trouble
			 * in these calculations, let's be sure we don't ever set
			 * cost_limit to more than the base value.
			 */</comment>
			<expr_stmt><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_cost_limit</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>limit</name></expr></argument>,
											<argument><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_cost_limit_base</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>wi_proc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"autovac_balance_cost(pid=%u db=%u, rel=%u, dobalance=%s cost_limit=%d, cost_limit_base=%d, cost_delay=%g)"</literal></expr></argument>,
				 <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_dboid</name></name></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_tableoid</name></name></expr></argument>,
				 <argument><expr><ternary><condition><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_dobalance</name></name></expr> ?</condition><then> <expr><literal type="string">"yes"</literal></expr> </then><else>: <expr><literal type="string">"no"</literal></expr></else></ternary></expr></argument>,
				 <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_cost_limit</name></name></expr></argument>, <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_cost_limit_base</name></name></expr></argument>,
				 <argument><expr><name><name>worker</name><operator>-&gt;</operator><name>wi_cost_delay</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * get_database_list
 *		Return a list of all databases found in pg_database.
 *
 * The list and associated data is allocated in the caller's memory context,
 * which is in charge of ensuring that it's properly cleaned up afterwards.
 *
 * Note: this is the only function in which the autovacuum launcher uses a
 * transaction.  Although we aren't attached to any particular database and
 * therefore can't access most catalogs, we do have enough infrastructure
 * to do a seqscan on pg_database.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>get_database_list</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dblist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>resultcxt</name></decl>;</decl_stmt>

	<comment type="block">/* This is the context that we will allocate our output data in */</comment>
	<expr_stmt><expr><name>resultcxt</name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Start a transaction so we can access pg_database, and get a snapshot.
	 * We don't have a use for the snapshot itself, but we're interested in
	 * the secondary effect that it sets RecentGlobalXmin.  (This is critical
	 * for anything that reads heap pages, because HOT may decide to prune
	 * them even if the process doesn't attempt to modify any tuples.)
	 */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>DatabaseRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_database</name></type> <name>pgdatabase</name> <init>= <expr><operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>avw_dbase</name>  <modifier>*</modifier></type><name>avdb</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Allocate our results in the caller's context, not the
		 * transaction's. We do this inside the loop, and restore the original
		 * context at the end, so that leaky things like heap_getnext() are
		 * not called in a potentially long-lived context.
		 */</comment>
		<expr_stmt><expr><name>oldcxt</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>resultcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>avdb</name> <operator>=</operator> <operator>(</operator><name>avw_dbase</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>avw_dbase</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>avdb</name><operator>-&gt;</operator><name>adw_datid</name></name> <operator>=</operator> <name><name>pgdatabase</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>avdb</name><operator>-&gt;</operator><name>adw_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>pgdatabase</name><operator>-&gt;</operator><name>datname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>avdb</name><operator>-&gt;</operator><name>adw_frozenxid</name></name> <operator>=</operator> <name><name>pgdatabase</name><operator>-&gt;</operator><name>datfrozenxid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>avdb</name><operator>-&gt;</operator><name>adw_minmulti</name></name> <operator>=</operator> <name><name>pgdatabase</name><operator>-&gt;</operator><name>datminmxid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>avdb</name><operator>-&gt;</operator><name>adw_allowconn</name></name> <operator>=</operator> <name><name>pgdatabase</name><operator>-&gt;</operator><name>datallowconn</name></name></expr>;</expr_stmt>
		<comment type="block">/* this gets set later: */</comment>
		<expr_stmt><expr><name><name>avdb</name><operator>-&gt;</operator><name>adw_entry</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>dblist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>dblist</name></expr></argument>, <argument><expr><name>avdb</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dblist</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process a database table-by-table
 *
 * Note that CHECK_FOR_INTERRUPTS is supposed to be used in certain spots in
 * order not to ignore shutdown commands for too long.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_autovacuum</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>classRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TableScanDesc</name></type> <name>relScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_database</name></type> <name>dbForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>table_oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>orphan_oids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>table_toast_map</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier><specifier>volatile</specifier></type> <name>cell</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>pg_class_desc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>effective_multixact_freeze_max_age</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>did_vacuum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_concurrent_worker</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * StartTransactionCommand and CommitTransactionCommand will automatically
	 * switch to other contexts.  We need this one to keep the list of
	 * relations to vacuum/analyze across transactions.
	 */</comment>
	<expr_stmt><expr><name>AutovacMemCxt</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
										  <argument><expr><literal type="string">"AV worker"</literal></expr></argument>,
										  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * may be NULL if we couldn't find an entry (only happens if we are
	 * forcing a vacuum for anti-wrap purposes).
	 */</comment>
	<expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_dbentry</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Start a transaction so our commands have one to play into. */</comment>
	<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clean up any dead statistics collector entries for this DB. We always
	 * want to do this exactly once per DB-processing cycle, even if we find
	 * nothing worth vacuuming in the database.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_vacuum_stat</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the multixact age for which freezing is urgent.  This is
	 * normally autovacuum_multixact_freeze_max_age, but may be less if we are
	 * short of multixact member space.
	 */</comment>
	<expr_stmt><expr><name>effective_multixact_freeze_max_age</name> <operator>=</operator> <call><name>MultiXactMemberFreezeThreshold</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the pg_database entry and select the default freeze ages. We use
	 * zero in template and nonconnectable databases, else the system-wide
	 * default.
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>DATABASEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for database %u"</literal></expr></argument>, <argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>dbForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_database</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dbForm</name><operator>-&gt;</operator><name>datistemplate</name></name> <operator>||</operator> <operator>!</operator><name><name>dbForm</name><operator>-&gt;</operator><name>datallowconn</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>default_freeze_min_age</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_freeze_table_age</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_multixact_freeze_min_age</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_multixact_freeze_table_age</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>default_freeze_min_age</name> <operator>=</operator> <name>vacuum_freeze_min_age</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_freeze_table_age</name> <operator>=</operator> <name>vacuum_freeze_table_age</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_multixact_freeze_min_age</name> <operator>=</operator> <name>vacuum_multixact_freeze_min_age</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>default_multixact_freeze_table_age</name> <operator>=</operator> <name>vacuum_multixact_freeze_table_age</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* StartTransactionCommand changed elsewhere */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The database hash where pgstat keeps shared relations */</comment>
	<expr_stmt><expr><name>shared</name> <operator>=</operator> <call><name>pgstat_fetch_stat_dbentry</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>classRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>RelationRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create a copy so we can use it after closing pg_class */</comment>
	<expr_stmt><expr><name>pg_class_desc</name> <operator>=</operator> <call><name>CreateTupleDescCopy</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* create hash table for toast &lt;-&gt; main relid mapping */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>av_relation</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><name>table_toast_map</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"TOAST to main relid map"</literal></expr></argument>,
								  <argument><expr><literal type="number">100</literal></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
								  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Scan pg_class to determine which tables to vacuum.
	 *
	 * We do this in two passes: on the first one we collect the list of plain
	 * relations and materialized views, and on the second one we collect
	 * TOAST tables. The reason for doing the second pass is that during it we
	 * want to use the main relation's pg_class.reloptions entry if the TOAST
	 * table does not have any, and we cannot obtain it unless we know
	 * beforehand what's the main table OID.
	 *
	 * We need to check TOAST tables separately because in cases with short,
	 * wide tables there might be proportionally much more activity in the
	 * TOAST table than in its parent.
	 */</comment>
	<expr_stmt><expr><name>relScan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * On the first pass, we collect main tables to vacuum, and also the main
	 * table relid to TOAST relid mapping.
	 */</comment>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>relScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AutoVacOpts</name> <modifier>*</modifier></type><name>relopts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dovacuum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>doanalyze</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>wraparound</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_RELATION</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_MATVIEW</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOSEGMENTS</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOBLOCKDIR</name> <operator>&amp;&amp;</operator>
			<name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_AOVISIMAP</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check if it is a temp table (presumably, of some other backend's).
		 * We cannot safely process other backends' temp tables.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * GPDB: Skip process temp tables since the temp namespace for QD and QE
			 * is using gp_session_id as suffix instead of backendID.
			 * And performDeletion() only execute delete on current node.
			 */</comment>
			<continue>continue;</continue>

			<comment type="block">/*
			 * We just ignore it if the owning backend is still active and
			 * using the temporary schema.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isTempNamespaceInUse</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The table seems to be orphaned -- although it might be that
				 * the owning backend has already deleted it and exited; our
				 * pg_class scan snapshot is not necessarily up-to-date
				 * anymore, so we could be looking at a committed-dead entry.
				 * Remember it so we can try to delete it later.
				 */</comment>
				<expr_stmt><expr><name>orphan_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>orphan_oids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Fetch reloptions and the pgstat entry for this table */</comment>
		<expr_stmt><expr><name>relopts</name> <operator>=</operator> <call><name>extract_autovac_opts</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>pg_class_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tabentry</name> <operator>=</operator> <call><name>get_pgstat_tabentry_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>,
											 <argument><expr><name>shared</name></expr></argument>, <argument><expr><name>dbentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Check if it needs vacuum or analyze */</comment>
		<expr_stmt><expr><call><name>relation_needs_vacanalyze</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relopts</name></expr></argument>, <argument><expr><name>classForm</name></expr></argument>, <argument><expr><name>tabentry</name></expr></argument>,
								  <argument><expr><name>effective_multixact_freeze_max_age</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>dovacuum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doanalyze</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wraparound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Relations that need work are added to table_oids */</comment>
		<if_stmt><if>if <condition>(<expr><name>dovacuum</name> <operator>||</operator> <name>doanalyze</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>table_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>table_oids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Remember TOAST associations for the second pass.  Note: we must do
		 * this whether or not the table is going to be vacuumed, because we
		 * don't automatically vacuum toast tables along the parent table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>av_relation</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>hentry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>table_toast_map</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name><name>classForm</name><operator>-&gt;</operator><name>reltoastrelid</name></name></expr></argument>,
								 <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* hash_search already filled in the key */</comment>
				<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>ar_relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>ar_hasrelopts</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>relopts</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>hentry</name><operator>-&gt;</operator><name>ar_hasrelopts</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>hentry</name><operator>-&gt;</operator><name>ar_reloptions</name></name></expr></argument>, <argument><expr><name>relopts</name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AutoVacOpts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>relScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* second pass: check TOAST tables */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
				<argument><expr><name>Anum_pg_class_relkind</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_CHAREQ</name></expr></argument>,
				<argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>RELKIND_TOASTVALUE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>relScan</name> <operator>=</operator> <call><name>table_beginscan_catalog</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>tuple</name> <operator>=</operator> <call><name>heap_getnext</name><argument_list>(<argument><expr><name>relScan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AutoVacOpts</name> <modifier>*</modifier></type><name>relopts</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>dovacuum</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>doanalyze</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>wraparound</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We cannot safely process other backends' temp tables, so skip 'em.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * fetch reloptions -- if this toast table does not have them, try the
		 * main rel
		 */</comment>
		<expr_stmt><expr><name>relopts</name> <operator>=</operator> <call><name>extract_autovac_opts</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>pg_class_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>relopts</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>av_relation</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>hentry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>table_toast_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name><name>hentry</name><operator>-&gt;</operator><name>ar_hasrelopts</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>relopts</name> <operator>=</operator> <operator>&amp;</operator><name><name>hentry</name><operator>-&gt;</operator><name>ar_reloptions</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Fetch the pgstat entry for this table */</comment>
		<expr_stmt><expr><name>tabentry</name> <operator>=</operator> <call><name>get_pgstat_tabentry_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>,
											 <argument><expr><name>shared</name></expr></argument>, <argument><expr><name>dbentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>relation_needs_vacanalyze</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>relopts</name></expr></argument>, <argument><expr><name>classForm</name></expr></argument>, <argument><expr><name>tabentry</name></expr></argument>,
								  <argument><expr><name>effective_multixact_freeze_max_age</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>dovacuum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doanalyze</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wraparound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ignore analyze for toast tables */</comment>
		<if_stmt><if>if <condition>(<expr><name>dovacuum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>table_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>table_oids</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>table_endscan</name><argument_list>(<argument><expr><name>relScan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>classRel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Recheck orphan temporary tables, and if they still seem orphaned, drop
	 * them.  We'll eat a transaction per dropped table, which might seem
	 * excessive, but we should only need to do anything as a result of a
	 * previous backend crash, so this should not happen often enough to
	 * justify "optimizing".  Using separate transactions ensures that we
	 * don't bloat the lock table if there are many temp tables to be dropped,
	 * and it ensures that we don't lose work if a deletion attempt fails.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>orphan_oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ObjectAddress</name></type> <name>object</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Check for user-requested abort.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to lock the table.  If we can't get the lock immediately,
		 * somebody else is using (or dropping) the table, so it's not our
		 * concern anymore.  Having the lock prevents race conditions below.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ConditionalLockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Re-fetch the pg_class tuple and re-check whether it still seems to
		 * be an orphaned temp table.  If it's not there or no longer the same
		 * relation, ignore it.
		 */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* be sure to drop useless lock so we don't bloat lock table */</comment>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Make all the same tests made in the loop above.  In event of OID
		 * counter wraparound, the pg_class entry we have now might be
		 * completely unrelated to the one we saw before.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>(</operator><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
			   <name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_MATVIEW</name><operator>)</operator> <operator>&amp;&amp;</operator>
			  <name><name>classForm</name><operator>-&gt;</operator><name>relpersistence</name></name> <operator>==</operator> <name>RELPERSISTENCE_TEMP</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>isTempNamespaceInUse</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>AccessExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* OK, let's delete it */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"autovacuum: dropping orphan temp table \"%s.%s.%s\""</literal></expr></argument>,
						<argument><expr><call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>classId</name></name> <operator>=</operator> <name>RelationRelationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectId</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>object</name><operator>.</operator><name>objectSubId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>performDeletion</name><argument_list>(<argument><expr><operator>&amp;</operator><name>object</name></expr></argument>, <argument><expr><name>DROP_CASCADE</name></expr></argument>,
						<argument><expr><name>PERFORM_DELETION_INTERNAL</name> <operator>|</operator>
						<name>PERFORM_DELETION_QUIETLY</name> <operator>|</operator>
						<name>PERFORM_DELETION_SKIP_EXTENSIONS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * To commit the deletion, end current transaction and start a new
		 * one.  Note this also releases the lock we took.
		 */</comment>
		<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* StartTransactionCommand changed current memory context */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Create a buffer access strategy object for VACUUM to use.  We want to
	 * use the same one across all the vacuum operations we perform, since the
	 * point is for VACUUM not to blow out the shared cache.
	 */</comment>
	<expr_stmt><expr><name>bstrategy</name> <operator>=</operator> <call><name>GetAccessStrategy</name><argument_list>(<argument><expr><name>BAS_VACUUM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * create a memory context to act as fake PortalContext, so that the
	 * contexts created in the vacuum code are cleaned up for each table.
	 */</comment>
	<expr_stmt><expr><name>PortalContext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>,
										  <argument><expr><literal type="string">"Autovacuum Portal"</literal></expr></argument>,
										  <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Perform operations on collected tables.
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>cell</argument>, <argument>table_oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>cell</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classTup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>autovac_table</name> <modifier>*</modifier></type><name>tab</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isshared</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>skipit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>stdVacuumCostDelay</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>stdVacuumCostLimit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dlist_iter</name></type>	<name>iter</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for config changes before processing each collected table.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * You might be tempted to bail out if we see autovacuum is now
			 * disabled.  Must resist that temptation -- this might be a
			 * for-wraparound emergency worker, in which case that would be
			 * entirely inappropriate.
			 */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Find out whether the table is shared or not.  (It's slightly
		 * annoying to fetch the syscache entry just for this, but in typical
		 * cases it adds little cost because table_recheck_autovac would
		 * refetch the entry anyway.  We could buy that back by copying the
		 * tuple here and passing it to table_recheck_autovac, but that
		 * increases the odds of that function working with stale data.)
		 */</comment>
		<expr_stmt><expr><name>classTup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* somebody deleted the rel, forget it */</comment>
		<expr_stmt><expr><name>isshared</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relisshared</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Hold schedule lock from here until we've claimed the table.  We
		 * also need the AutovacuumLock to walk the worker array, but that one
		 * can just be a shared lock.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumScheduleLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check whether the table is being vacuumed concurrently by another
		 * worker.
		 */</comment>
		<expr_stmt><expr><name>skipit</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;AutoVacuumShmem-&gt;av_runningWorkers</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkerInfo</name></type>	<name>worker</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>WorkerInfoData</name></expr></argument>, <argument><expr><name>wi_links</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* ignore myself */</comment>
			<if_stmt><if>if <condition>(<expr><name>worker</name> <operator>==</operator> <name>MyWorkerInfo</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<comment type="block">/* ignore workers in other databases (unless table is shared) */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>worker</name><operator>-&gt;</operator><name>wi_sharedrel</name></name> <operator>&amp;&amp;</operator> <name><name>worker</name><operator>-&gt;</operator><name>wi_dboid</name></name> <operator>!=</operator> <name>MyDatabaseId</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>worker</name><operator>-&gt;</operator><name>wi_tableoid</name></name> <operator>==</operator> <name>relid</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>skipit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>found_concurrent_worker</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>skipit</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumScheduleLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Store the table's OID in shared memory before releasing the
		 * schedule lock, so that other workers don't try to vacuum it
		 * concurrently.  (We claim it here so as not to hold
		 * AutovacuumScheduleLock while rechecking the stats.)
		 */</comment>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_tableoid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_sharedrel</name></name> <operator>=</operator> <name>isshared</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumScheduleLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check whether pgstat data still says we need to vacuum this table.
		 * It could have changed if something else processed the table while
		 * we weren't looking.
		 *
		 * Note: we have a special case in pgstat code to ensure that the
		 * stats we read are as up-to-date as possible, to avoid the problem
		 * that somebody just finished vacuuming this table.  The window to
		 * the race condition is not closed but it is very small.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>table_recheck_autovac</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>table_toast_map</name></expr></argument>, <argument><expr><name>pg_class_desc</name></expr></argument>,
									<argument><expr><name>effective_multixact_freeze_max_age</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tab</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* someone else vacuumed the table, or it went away */</comment>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumScheduleLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_tableoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_sharedrel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumScheduleLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Remember the prevailing values of the vacuum cost GUCs.  We have to
		 * restore these at the bottom of the loop, else we'll compute wrong
		 * values in the next iteration of autovac_balance_cost().
		 */</comment>
		<expr_stmt><expr><name>stdVacuumCostDelay</name> <operator>=</operator> <name>VacuumCostDelay</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stdVacuumCostLimit</name> <operator>=</operator> <name>VacuumCostLimit</name></expr>;</expr_stmt>

		<comment type="block">/* Must hold AutovacuumLock while mucking with cost balance info */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* advertise my cost delay parameters for the balancing algorithm */</comment>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_dobalance</name></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>at_dobalance</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_cost_delay</name></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>at_vacuum_cost_delay</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_cost_limit</name></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>at_vacuum_cost_limit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_cost_limit_base</name></name> <operator>=</operator> <name><name>tab</name><operator>-&gt;</operator><name>at_vacuum_cost_limit</name></name></expr>;</expr_stmt>

		<comment type="block">/* do a balance */</comment>
		<expr_stmt><expr><call><name>autovac_balance_cost</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* set the active cost parameters from the result of that */</comment>
		<expr_stmt><expr><call><name>AutoVacuumUpdateDelay</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* done */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clean up memory before each iteration */</comment>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Save the relation name for a possible error message, to avoid a
		 * catalog lookup in case of an error.  If any of these return NULL,
		 * then the relation has been dropped since last we checked; skip it.
		 * Note: they must live in a long-lived memory context because we call
		 * vacuum and analyze in different transactions.
		 */</comment>

		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_nspname</name></name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_datname</name></name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name> <operator>||</operator> <operator>!</operator><name><name>tab</name><operator>-&gt;</operator><name>at_nspname</name></name> <operator>||</operator> <operator>!</operator><name><name>tab</name><operator>-&gt;</operator><name>at_datname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>deleted</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We will abort vacuuming the current table if something errors out,
		 * and continue with the next one in schedule; in particular, this
		 * happens if we are interrupted with SIGINT.
		 */</comment>
		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/* Use PortalContext for any per-table allocations */</comment>
			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* have at it */</comment>
			<expr_stmt><expr><call><name>autovacuum_do_vac_analyze</name><argument_list>(<argument><expr><name>tab</name></expr></argument>, <argument><expr><name>bstrategy</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Clear a possible query-cancel signal, to avoid a late reaction
			 * to an automatically-sent signal because of vacuuming the
			 * current table (we're done with it, so it would make no sense to
			 * cancel at this point.)
			 */</comment>
			<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/*
			 * Abort the transaction, start a new one, and proceed with the
			 * next table in our list.
			 */</comment>
			<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"automatic vacuum of table \"%s.%s.%s\""</literal></expr></argument>,
						   <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_datname</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_nspname</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"automatic analyze of table \"%s.%s.%s\""</literal></expr></argument>,
						   <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_datname</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_nspname</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* this resets the PGXACT flags too */</comment>
			<expr_stmt><expr><call><name>AbortOutOfAnyTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
			<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
				<argument><expr><literal type="string">"auto_vac_worker_abort"</literal></expr></argument>, <argument><expr><name>DDLNotSpecified</name></expr></argument>,
				<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/* restart our transaction for the following operations */</comment>
			<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Make sure we're back in AutovacMemCxt */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>did_vacuum</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* the PGXACT flags are reset at the next end of transaction */</comment>

		<comment type="block">/* be tidy */</comment>
<label><name>deleted</name>:</label>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>at_datname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_datname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>at_nspname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_nspname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Remove my info from shared memory.  We could, but intentionally
		 * don't, clear wi_cost_limit and friends --- this is on the
		 * assumption that we probably have more to do with similar cost
		 * settings, so we don't want to give up our share of I/O for a very
		 * short interval and thereby thrash the global balance.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumScheduleLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_tableoid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyWorkerInfo</name><operator>-&gt;</operator><name>wi_sharedrel</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumScheduleLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* restore vacuum cost GUCs for the next iteration */</comment>
		<expr_stmt><expr><name>VacuumCostDelay</name> <operator>=</operator> <name>stdVacuumCostDelay</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>VacuumCostLimit</name> <operator>=</operator> <name>stdVacuumCostLimit</name></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Perform additional work items, as requested by backends.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_WORKITEMS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AutoVacuumWorkItem</name> <modifier>*</modifier></type><name>workitem</name> <init>= <expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_workItems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>workitem</name><operator>-&gt;</operator><name>avw_used</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_active</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_database</name></name> <operator>!=</operator> <name>MyDatabaseId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* claim this one, and release lock while performing it */</comment>
		<expr_stmt><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>perform_work_item</name><argument_list>(<argument><expr><name>workitem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Check for config changes before acquiring lock for further jobs.
		 */</comment>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* and mark it done */</comment>
		<expr_stmt><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_used</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We leak table_toast_map here (among other things), but since we're
	 * going away soon, it's not a problem.
	 */</comment>

	<comment type="block">/*
	 * Update pg_database.datfrozenxid, and truncate pg_xact if possible. We
	 * only need to do this once, not after each table.
	 *
	 * Even if we didn't vacuum anything, it may still be important to do
	 * this, because one indirect effect of vac_update_datfrozenxid() is to
	 * update ShmemVariableCache-&gt;xidVacLimit.  That might need to be done
	 * even if we haven't vacuumed anything, because relations with older
	 * relfrozenxid values or other databases with older datfrozenxid values
	 * might have been dropped, allowing xidVacLimit to advance.
	 *
	 * However, it's also important not to do this blindly in all cases,
	 * because when autovacuum=off this will restart the autovacuum launcher.
	 * If we're not careful, an infinite loop can result, where workers find
	 * no work to do and restart the launcher, which starts another worker in
	 * the same database that finds no work to do.  To prevent that, we skip
	 * this if (1) we found no work to do and (2) we skipped at least one
	 * table due to concurrent autovacuum activity.  In that case, the other
	 * worker has already done it, or will do so when it finishes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>did_vacuum</name> <operator>||</operator> <operator>!</operator><name>found_concurrent_worker</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>vac_update_datfrozenxid</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Finally close out the last transaction. */</comment>
	<expr_stmt><expr><call><name>CommitTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Execute a previously registered work item.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>perform_work_item</name><parameter_list>(<parameter><decl><type><name>AutoVacuumWorkItem</name> <modifier>*</modifier></type><name>workitem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cur_datname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cur_nspname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cur_relname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note we do not store table info in MyWorkerInfo, since this is not
	 * vacuuming proper.
	 */</comment>

	<comment type="block">/*
	 * Save the relation name for a possible error message, to avoid a catalog
	 * lookup in case of an error.  If any of these return NULL, then the
	 * relation has been dropped since last we checked; skip it.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>==</operator> <name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cur_relname</name> <operator>=</operator> <call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_relation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_nspname</name> <operator>=</operator> <call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>get_rel_namespace</name><argument_list>(<argument><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_relation</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cur_datname</name> <operator>=</operator> <call><name>get_database_name</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>cur_relname</name> <operator>||</operator> <operator>!</operator><name>cur_nspname</name> <operator>||</operator> <operator>!</operator><name>cur_datname</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>deleted2</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>autovac_report_workitem</name><argument_list>(<argument><expr><name>workitem</name></expr></argument>, <argument><expr><name>cur_nspname</name></expr></argument>, <argument><expr><name>cur_relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* clean up memory before each work item */</comment>
	<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We will abort the current work item if something errors out, and
	 * continue with the next one; in particular, this happens if we are
	 * interrupted with SIGINT.  Note that this means that the work item list
	 * can be lossy.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Use PortalContext for any per-work-item allocations */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* have at it */</comment>
		<switch>switch <condition>(<expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_type</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>AVW_BRINSummarizeRange</name></expr>:</case>
				<expr_stmt><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>brin_summarize_range_internal</name></expr></argument>,
									<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_relation</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>int64</name><operator>)</operator> <name><name>workitem</name><operator>-&gt;</operator><name>avw_blockNumber</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"unrecognized work item found: type %d"</literal></expr></argument>,
					 <argument><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Clear a possible query-cancel signal, to avoid a late reaction to
		 * an automatically-sent signal because of vacuuming the current table
		 * (we're done with it, so it would make no sense to cancel at this
		 * point.)
		 */</comment>
		<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Abort the transaction, start a new one, and proceed with the next
		 * table in our list.
		 */</comment>
		<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"processing work entry for relation \"%s.%s.%s\""</literal></expr></argument>,
				   <argument><expr><name>cur_datname</name></expr></argument>, <argument><expr><name>cur_nspname</name></expr></argument>, <argument><expr><name>cur_relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* this resets the PGXACT flags too */</comment>
		<expr_stmt><expr><call><name>AbortOutOfAnyTransaction</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>PortalContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* restart our transaction for the following operations */</comment>
		<expr_stmt><expr><call><name>StartTransactionCommand</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure we're back in AutovacMemCxt */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>AutovacMemCxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We intentionally do not set did_vacuum here */</comment>

	<comment type="block">/* be tidy */</comment>
<label><name>deleted2</name>:</label>
	<if_stmt><if>if <condition>(<expr><name>cur_datname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur_datname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cur_nspname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur_nspname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>cur_relname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cur_relname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * extract_autovac_opts
 *
 * Given a relation's pg_class tuple, return the AutoVacOpts portion of
 * reloptions, if set; otherwise, return NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>AutoVacOpts</name> <modifier>*</modifier></type>
<name>extract_autovac_opts</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>tup</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>pg_class_desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>relopts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AutoVacOpts</name> <modifier>*</modifier></type><name>av</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_RELATION</name> <operator>||</operator>
		   <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_MATVIEW</name> <operator>||</operator>
		   <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>||</operator>
		   <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_AOSEGMENTS</name> <operator>||</operator>
		   <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator> <name>RELKIND_AOBLOCKDIR</name> <operator>||</operator>
		   <operator>(</operator><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>relkind</name> <operator>==</operator>  <name>RELKIND_AOVISIMAP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<expr_stmt><expr><name>relopts</name> <operator>=</operator> <call><name>extractRelOptions</name><argument_list>(<argument><expr><name>tup</name></expr></argument>, <argument><expr><name>pg_class_desc</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>relopts</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>av</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AutoVacOpts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>av</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><operator>(</operator><operator>(</operator><name>StdRdOptions</name> <operator>*</operator><operator>)</operator> <name>relopts</name><operator>)</operator><operator>-&gt;</operator><name>autovacuum</name><operator>)</operator></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AutoVacOpts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>relopts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>av</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_pgstat_tabentry_relid
 *
 * Fetch the pgstat entry of a table, either local to a database or shared.
 */</comment>
<function><type><specifier>static</specifier> <name>PgStat_StatTabEntry</name> <modifier>*</modifier></type>
<name>get_pgstat_tabentry_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isshared</name></decl></parameter>, <parameter><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>,
						  <parameter><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>isshared</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tabentry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>shared</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>,
								   <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>dbentry</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>tabentry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>dbentry</name><operator>-&gt;</operator><name>tables</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>,
							   <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>tabentry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * table_recheck_autovac
 *
 * Recheck whether a table still needs vacuum or analyze.  Return value is a
 * valid autovac_table pointer if it does, NULL otherwise.
 *
 * Note that the returned autovac_table does not have the name fields set.
 */</comment>
<function><type><specifier>static</specifier> <name>autovac_table</name> <modifier>*</modifier></type>
<name>table_recheck_autovac</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>HTAB</name> <modifier>*</modifier></type><name>table_toast_map</name></decl></parameter>,
					  <parameter><decl><type><name>TupleDesc</name></type> <name>pg_class_desc</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>effective_multixact_freeze_max_age</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>classTup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dovacuum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>doanalyze</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>autovac_table</name> <modifier>*</modifier></type><name>tab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PgStat_StatDBEntry</name> <modifier>*</modifier></type><name>dbentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>wraparound</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AutoVacOpts</name> <modifier>*</modifier></type><name>avopts</name></decl>;</decl_stmt>

	<comment type="block">/* use fresh stats */</comment>
	<expr_stmt><expr><call><name>autovac_refresh_stats</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>shared</name> <operator>=</operator> <call><name>pgstat_fetch_stat_dbentry</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dbentry</name> <operator>=</operator> <call><name>pgstat_fetch_stat_dbentry</name><argument_list>(<argument><expr><name>MyDatabaseId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fetch the relation's relcache entry */</comment>
	<expr_stmt><expr><name>classTup</name> <operator>=</operator> <call><name>SearchSysCacheCopy1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>classForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the applicable reloptions.  If it is a TOAST table, try to get the
	 * main table reloptions if the toast table itself doesn't have.
	 */</comment>
	<expr_stmt><expr><name>avopts</name> <operator>=</operator> <call><name>extract_autovac_opts</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>, <argument><expr><name>pg_class_desc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name> <operator>&amp;&amp;</operator>
		<name>avopts</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>table_toast_map</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>av_relation</name> <modifier>*</modifier></type><name>hentry</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>hentry</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>table_toast_map</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name> <operator>&amp;&amp;</operator> <name><name>hentry</name><operator>-&gt;</operator><name>ar_hasrelopts</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>avopts</name> <operator>=</operator> <operator>&amp;</operator><name><name>hentry</name><operator>-&gt;</operator><name>ar_reloptions</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* fetch the pgstat table entry */</comment>
	<expr_stmt><expr><name>tabentry</name> <operator>=</operator> <call><name>get_pgstat_tabentry_relid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relisshared</name></name></expr></argument>,
										 <argument><expr><name>shared</name></expr></argument>, <argument><expr><name>dbentry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>relation_needs_vacanalyze</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>avopts</name></expr></argument>, <argument><expr><name>classForm</name></expr></argument>, <argument><expr><name>tabentry</name></expr></argument>,
							  <argument><expr><name>effective_multixact_freeze_max_age</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>dovacuum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>doanalyze</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wraparound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ignore ANALYZE for toast tables */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_TOASTVALUE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>doanalyze</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* OK, it needs something done */</comment>
	<if_stmt><if>if <condition>(<expr><name>doanalyze</name> <operator>||</operator> <name>dovacuum</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>freeze_min_age</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>freeze_table_age</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>multixact_freeze_min_age</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>multixact_freeze_table_age</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>vac_cost_limit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>vac_cost_delay</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>log_min_duration</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Calculate the vacuum cost parameters and the freeze ages.  If there
		 * are options set in pg_class.reloptions, use them; in the case of a
		 * toast table, try the main table too.  Otherwise use the GUC
		 * defaults, autovacuum's own first and plain vacuum second.
		 */</comment>

		<comment type="block">/* -1 in autovac setting means use plain vacuum_cost_delay */</comment>
		<expr_stmt><expr><name>vac_cost_delay</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>avopts</name> <operator>&amp;&amp;</operator> <name><name>avopts</name><operator>-&gt;</operator><name>vacuum_cost_delay</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
			?</condition><then> <expr><name><name>avopts</name><operator>-&gt;</operator><name>vacuum_cost_delay</name></name></expr>
			</then><else>: <expr><ternary><condition><expr><operator>(</operator><name>autovacuum_vac_cost_delay</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
			?</condition><then> <expr><name>autovacuum_vac_cost_delay</name></expr>
			</then><else>: <expr><name>VacuumCostDelay</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* 0 or -1 in autovac setting means use plain vacuum_cost_limit */</comment>
		<expr_stmt><expr><name>vac_cost_limit</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>avopts</name> <operator>&amp;&amp;</operator> <name><name>avopts</name><operator>-&gt;</operator><name>vacuum_cost_limit</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>
			?</condition><then> <expr><name><name>avopts</name><operator>-&gt;</operator><name>vacuum_cost_limit</name></name></expr>
			</then><else>: <expr><ternary><condition><expr><operator>(</operator><name>autovacuum_vac_cost_limit</name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>
			?</condition><then> <expr><name>autovacuum_vac_cost_limit</name></expr>
			</then><else>: <expr><name>VacuumCostLimit</name></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* -1 in autovac setting means use log_autovacuum_min_duration */</comment>
		<expr_stmt><expr><name>log_min_duration</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>avopts</name> <operator>&amp;&amp;</operator> <name><name>avopts</name><operator>-&gt;</operator><name>log_min_duration</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
			?</condition><then> <expr><name><name>avopts</name><operator>-&gt;</operator><name>log_min_duration</name></name></expr>
			</then><else>: <expr><name>Log_autovacuum_min_duration</name></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/* these do not have autovacuum-specific settings */</comment>
		<expr_stmt><expr><name>freeze_min_age</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>avopts</name> <operator>&amp;&amp;</operator> <name><name>avopts</name><operator>-&gt;</operator><name>freeze_min_age</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
			?</condition><then> <expr><name><name>avopts</name><operator>-&gt;</operator><name>freeze_min_age</name></name></expr>
			</then><else>: <expr><name>default_freeze_min_age</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name>freeze_table_age</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>avopts</name> <operator>&amp;&amp;</operator> <name><name>avopts</name><operator>-&gt;</operator><name>freeze_table_age</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
			?</condition><then> <expr><name><name>avopts</name><operator>-&gt;</operator><name>freeze_table_age</name></name></expr>
			</then><else>: <expr><name>default_freeze_table_age</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name>multixact_freeze_min_age</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>avopts</name> <operator>&amp;&amp;</operator>
									<name><name>avopts</name><operator>-&gt;</operator><name>multixact_freeze_min_age</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
			?</condition><then> <expr><name><name>avopts</name><operator>-&gt;</operator><name>multixact_freeze_min_age</name></name></expr>
			</then><else>: <expr><name>default_multixact_freeze_min_age</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name>multixact_freeze_table_age</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>avopts</name> <operator>&amp;&amp;</operator>
									  <name><name>avopts</name><operator>-&gt;</operator><name>multixact_freeze_table_age</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
			?</condition><then> <expr><name><name>avopts</name><operator>-&gt;</operator><name>multixact_freeze_table_age</name></name></expr>
			</then><else>: <expr><name>default_multixact_freeze_table_age</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name>tab</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>autovac_table</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relid</name></name> <operator>=</operator> <name>relid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_sharedrel</name></name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>relisshared</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>options</name></name> <operator>=</operator> <name>VACOPT_SKIPTOAST</name> <operator>|</operator>
			<operator>(</operator><ternary><condition><expr><name>dovacuum</name></expr> ?</condition><then> <expr><name>VACOPT_VACUUM</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
			<operator>(</operator><ternary><condition><expr><name>doanalyze</name></expr> ?</condition><then> <expr><name>VACOPT_ANALYZE</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>|</operator>
			<operator>(</operator><ternary><condition><expr><operator>!</operator><name>wraparound</name></expr> ?</condition><then> <expr><name>VACOPT_SKIP_LOCKED</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>index_cleanup</name></name> <operator>=</operator> <name>VACOPT_TERNARY_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>truncate</name></name> <operator>=</operator> <name>VACOPT_TERNARY_DEFAULT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>freeze_min_age</name></name> <operator>=</operator> <name>freeze_min_age</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>freeze_table_age</name></name> <operator>=</operator> <name>freeze_table_age</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>multixact_freeze_min_age</name></name> <operator>=</operator> <name>multixact_freeze_min_age</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>multixact_freeze_table_age</name></name> <operator>=</operator> <name>multixact_freeze_table_age</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>is_wraparound</name></name> <operator>=</operator> <name>wraparound</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>log_min_duration</name></name> <operator>=</operator> <name>log_min_duration</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>auto_stats</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_vacuum_cost_limit</name></name> <operator>=</operator> <name>vac_cost_limit</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_vacuum_cost_delay</name></name> <operator>=</operator> <name>vac_cost_delay</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_nspname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_datname</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If any of the cost delay parameters has been set individually for
		 * this table, disable the balancing algorithm.
		 */</comment>
		<expr_stmt><expr><name><name>tab</name><operator>-&gt;</operator><name>at_dobalance</name></name> <operator>=</operator>
			<operator>!</operator><operator>(</operator><name>avopts</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>avopts</name><operator>-&gt;</operator><name>vacuum_cost_limit</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
						 <name><name>avopts</name><operator>-&gt;</operator><name>vacuum_cost_delay</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>heap_freetuple</name><argument_list>(<argument><expr><name>classTup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>tab</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * relation_needs_vacanalyze
 *
 * Check whether a relation needs to be vacuumed or analyzed; return each into
 * "dovacuum" and "doanalyze", respectively.  Also return whether the vacuum is
 * being forced because of Xid or multixact wraparound.
 *
 * relopts is a pointer to the AutoVacOpts options (either for itself in the
 * case of a plain table, or for either itself or its parent table in the case
 * of a TOAST table), NULL if none; tabentry is the pgstats entry, which can be
 * NULL.
 *
 * A table needs to be vacuumed if the number of dead tuples exceeds a
 * threshold.  This threshold is calculated as
 *
 * threshold = vac_base_thresh + vac_scale_factor * reltuples
 *
 * For analyze, the analysis done is that the number of tuples inserted,
 * deleted and updated since the last analyze exceeds a threshold calculated
 * in the same fashion as above.  Note that the collector actually stores
 * the number of tuples (both live and dead) that there were as of the last
 * analyze.  This is asymmetric to the VACUUM case.
 *
 * We also force vacuum if the table's relfrozenxid is more than freeze_max_age
 * transactions back, and if its relminmxid is more than
 * multixact_freeze_max_age multixacts back.
 *
 * A table whose autovacuum_enabled option is false is
 * automatically skipped (unless we have to vacuum it due to freeze_max_age).
 * Thus autovacuum can be disabled for specific tables. Also, when the stats
 * collector does not have data about a table, it will be skipped.
 *
 * A table whose vac_base_thresh value is &lt; 0 takes the base value from the
 * autovacuum_vacuum_threshold GUC variable.  Similarly, a vac_scale_factor
 * value &lt; 0 is substituted with the value of
 * autovacuum_vacuum_scale_factor GUC variable.  Ditto for analyze.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>relation_needs_vacanalyze</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>,
						  <parameter><decl><type><name>AutoVacOpts</name> <modifier>*</modifier></type><name>relopts</name></decl></parameter>,
						  <parameter><decl><type><name>Form_pg_class</name></type> <name>classForm</name></decl></parameter>,
						  <parameter><decl><type><name>PgStat_StatTabEntry</name> <modifier>*</modifier></type><name>tabentry</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>effective_multixact_freeze_max_age</name></decl></parameter>,
 <comment type="block">/* output params below */</comment>
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>dovacuum</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>doanalyze</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>wraparound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>force_vacuum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>av_enabled</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>reltuples</name></decl>;</decl_stmt>		<comment type="block">/* pg_class.reltuples */</comment>

	<comment type="block">/* constants from reloptions or GUC variables */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>vac_base_thresh</name></decl>,
				<decl><type ref="prev"/><name>anl_base_thresh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>vac_scale_factor</name></decl>,
				<decl><type ref="prev"/><name>anl_scale_factor</name></decl>;</decl_stmt>

	<comment type="block">/* thresholds calculated from above constants */</comment>
	<decl_stmt><decl><type><name>float4</name></type>		<name>vacthresh</name></decl>,
				<decl><type ref="prev"/><name>anlthresh</name></decl>;</decl_stmt>

	<comment type="block">/* number of vacuum (resp. analyze) tuples at this time */</comment>
	<decl_stmt><decl><type><name>float4</name></type>		<name>vactuples</name></decl>,
				<decl><type ref="prev"/><name>anltuples</name></decl>;</decl_stmt>

	<comment type="block">/* freeze parameters */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>freeze_max_age</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>multixact_freeze_max_age</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xidForceLimit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MultiXactId</name></type> <name>multiForceLimit</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't need to hold AutovacuumLock here, since it should be read-only in the worker itself
	 * once the MyWorkerInfo gets set, all the workers only care about its own value.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>MyWorkerInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>classForm</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Determine vacuum/analyze equation parameters.  We have two possible
	 * sources: the passed reloptions (which could be a main table or a toast
	 * table), or the autovacuum GUC variables.
	 */</comment>

	<comment type="block">/* -1 in autovac setting means use plain vacuum_scale_factor */</comment>
	<expr_stmt><expr><name>vac_scale_factor</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>relopts</name> <operator>&amp;&amp;</operator> <name><name>relopts</name><operator>-&gt;</operator><name>vacuum_scale_factor</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
		?</condition><then> <expr><name><name>relopts</name><operator>-&gt;</operator><name>vacuum_scale_factor</name></name></expr>
		</then><else>: <expr><name>autovacuum_vac_scale</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>vac_base_thresh</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>relopts</name> <operator>&amp;&amp;</operator> <name><name>relopts</name><operator>-&gt;</operator><name>vacuum_threshold</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
		?</condition><then> <expr><name><name>relopts</name><operator>-&gt;</operator><name>vacuum_threshold</name></name></expr>
		</then><else>: <expr><name>autovacuum_vac_thresh</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>anl_scale_factor</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>relopts</name> <operator>&amp;&amp;</operator> <name><name>relopts</name><operator>-&gt;</operator><name>analyze_scale_factor</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
		?</condition><then> <expr><name><name>relopts</name><operator>-&gt;</operator><name>analyze_scale_factor</name></name></expr>
		</then><else>: <expr><name>autovacuum_anl_scale</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>anl_base_thresh</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>relopts</name> <operator>&amp;&amp;</operator> <name><name>relopts</name><operator>-&gt;</operator><name>analyze_threshold</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
		?</condition><then> <expr><name><name>relopts</name><operator>-&gt;</operator><name>analyze_threshold</name></name></expr>
		</then><else>: <expr><name>autovacuum_anl_thresh</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>freeze_max_age</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>relopts</name> <operator>&amp;&amp;</operator> <name><name>relopts</name><operator>-&gt;</operator><name>freeze_max_age</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
		?</condition><then> <expr><call><name>Min</name><argument_list>(<argument><expr><name><name>relopts</name><operator>-&gt;</operator><name>freeze_max_age</name></name></expr></argument>, <argument><expr><name>autovacuum_freeze_max_age</name></expr></argument>)</argument_list></call></expr>
		</then><else>: <expr><name>autovacuum_freeze_max_age</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>multixact_freeze_max_age</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>relopts</name> <operator>&amp;&amp;</operator> <name><name>relopts</name><operator>-&gt;</operator><name>multixact_freeze_max_age</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>
		?</condition><then> <expr><call><name>Min</name><argument_list>(<argument><expr><name><name>relopts</name><operator>-&gt;</operator><name>multixact_freeze_max_age</name></name></expr></argument>, <argument><expr><name>effective_multixact_freeze_max_age</name></expr></argument>)</argument_list></call></expr>
		</then><else>: <expr><name>effective_multixact_freeze_max_age</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>av_enabled</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>relopts</name></expr> ?</condition><then> <expr><name><name>relopts</name><operator>-&gt;</operator><name>enabled</name></name></expr> </then><else>: <expr><name>true</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Force vacuum if table is at risk of wraparound */</comment>
	<expr_stmt><expr><name>xidForceLimit</name> <operator>=</operator> <name>recentXid</name> <operator>-</operator> <name>freeze_max_age</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xidForceLimit</name> <operator>&lt;</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>xidForceLimit</name> <operator>-=</operator> <name>FirstNormalTransactionId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>force_vacuum</name> <operator>=</operator> <operator>(</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relfrozenxid</name></name></expr></argument>,
										  <argument><expr><name>xidForceLimit</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>force_vacuum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>multiForceLimit</name> <operator>=</operator> <name>recentMulti</name> <operator>-</operator> <name>multixact_freeze_max_age</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>multiForceLimit</name> <operator>&lt;</operator> <name>FirstMultiXactId</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>multiForceLimit</name> <operator>-=</operator> <name>FirstMultiXactId</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>force_vacuum</name> <operator>=</operator> <call><name>MultiXactIdIsValid</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>MultiXactIdPrecedes</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relminmxid</name></name></expr></argument>, <argument><expr><name>multiForceLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>wraparound</name> <operator>=</operator> <name>force_vacuum</name></expr>;</expr_stmt>

	<comment type="block">/* User disabled it in pg_class.reloptions?  (But ignore if at risk) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>av_enabled</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>force_vacuum</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>doanalyze</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>dovacuum</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we found the table in the stats hash, and autovacuum is currently
	 * enabled, make a threshold-based decision whether to vacuum and/or
	 * analyze.  If autovacuum is currently disabled, we must be here for
	 * anti-wraparound vacuuming only, so don't vacuum (or analyze) anything
	 * that's not being forced.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PointerIsValid</name><argument_list>(<argument><expr><name>tabentry</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>AutoVacuumingActive</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>reltuples</name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>vactuples</name> <operator>=</operator> <name><name>tabentry</name><operator>-&gt;</operator><name>n_dead_tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>anltuples</name> <operator>=</operator> <name><name>tabentry</name><operator>-&gt;</operator><name>changes_since_analyze</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>vacthresh</name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>vac_base_thresh</name> <operator>+</operator> <name>vac_scale_factor</name> <operator>*</operator> <name>reltuples</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>anlthresh</name> <operator>=</operator> <operator>(</operator><name>float4</name><operator>)</operator> <name>anl_base_thresh</name> <operator>+</operator> <name>anl_scale_factor</name> <operator>*</operator> <name>reltuples</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note that we don't need to take special consideration for stat
		 * reset, because if that happens, the last vacuum and analyze counts
		 * will be reset too.
		 */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"%s: vac: %.0f (threshold %.0f), anl: %.0f (threshold %.0f)"</literal></expr></argument>,
			 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>classForm</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>,
			 <argument><expr><name>vactuples</name></expr></argument>, <argument><expr><name>vacthresh</name></expr></argument>, <argument><expr><name>anltuples</name></expr></argument>, <argument><expr><name>anlthresh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Determine if this table needs vacuum or analyze. */</comment>
		<expr_stmt><expr><operator>*</operator><name>dovacuum</name> <operator>=</operator> <name>force_vacuum</name> <operator>||</operator> <operator>(</operator><name>vactuples</name> <operator>&gt;</operator> <name>vacthresh</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>doanalyze</name> <operator>=</operator> <operator>(</operator><name>anltuples</name> <operator>&gt;</operator> <name>anlthresh</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Skip a table not found in stat hash, unless we have to force vacuum
		 * for anti-wrap purposes.  If it's not acted upon, there's no need to
		 * vacuum it.
		 */</comment>
		<expr_stmt><expr><operator>*</operator><name>dovacuum</name> <operator>=</operator> <name>force_vacuum</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>doanalyze</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* ANALYZE refuses to work with pg_statistic */</comment>
	<if_stmt><if>if <condition>(<expr><name>relid</name> <operator>==</operator> <name>StatisticRelationId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>doanalyze</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Only wish to trigger auto-analyze from coordinator */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>doanalyze</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * There are a lot of things to do to enable auto-ANALYZE for partition tables,
	 * see PR10515 for details.
	 * Currently, we just disable auto-ANALYZE for partition tables.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>doanalyze</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>doanalyze</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * GPDB: Autovacuum VACUUM is only enabled for catalog tables. (But ignore
	 * if at risk of wrap around and proceed to vacuum)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsSystemClass</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>classForm</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name>force_vacuum</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>dovacuum</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * autovacuum_do_vac_analyze
 *		Vacuum and/or analyze the specified table
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>autovacuum_do_vac_analyze</name><parameter_list>(<parameter><decl><type><name>autovac_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>, <parameter><decl><type><name>BufferAccessStrategy</name></type> <name>bstrategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeVar</name>   <modifier>*</modifier></type><name>rangevar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VacuumRelation</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>rel_list</name></decl>;</decl_stmt>

	<comment type="block">/* Let pgstat know what we're doing */</comment>
	<expr_stmt><expr><call><name>autovac_report_activity</name><argument_list>(<argument><expr><name>tab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set up one VacuumRelation target, identified by OID, for vacuum() */</comment>
	<expr_stmt><expr><name>rangevar</name> <operator>=</operator> <call><name>makeRangeVar</name><argument_list>(<argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_nspname</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>makeVacuumRelation</name><argument_list>(<argument><expr><name>rangevar</name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relid</name></name></expr></argument>, <argument><expr><name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel_list</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(
		<argument><expr><literal type="string">"auto_vac_worker_after_report_activity"</literal></expr></argument>, <argument><expr><name>DDLNotSpecified</name></expr></argument>,
		<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>vacuum</name><argument_list>(<argument><expr><name>rel_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tab</name><operator>-&gt;</operator><name>at_params</name></name></expr></argument>, <argument><expr><name>bstrategy</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * autovac_report_activity
 *		Report to pgstat what autovacuum is doing
 *
 * We send a SQL string corresponding to what the user would see if the
 * equivalent command was to be issued manually.
 *
 * Note we assume that we are going to report the next command as soon as we're
 * done with the current one, and exit right after the last one, so we don't
 * bother to report "&lt;IDLE&gt;" or some such.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>autovac_report_activity</name><parameter_list>(<parameter><decl><type><name>autovac_table</name> <modifier>*</modifier></type><name>tab</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_AUTOVAC_ACTIV_LEN</name></cpp:macro> <cpp:value>(NAMEDATALEN * 2 + 56)</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>activity</name><index>[<expr><name>MAX_AUTOVAC_ACTIV_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* Report the command and possible options */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_VACUUM</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activity</name></expr></argument>, <argument><expr><name>MAX_AUTOVAC_ACTIV_LEN</name></expr></argument>,
				 <argument><expr><literal type="string">"autovacuum: VACUUM%s"</literal></expr></argument>,
				 <argument><expr><ternary><condition><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>options</name></name> <operator>&amp;</operator> <name>VACOPT_ANALYZE</name></expr> ?</condition><then> <expr><literal type="string">" ANALYZE"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activity</name></expr></argument>, <argument><expr><name>MAX_AUTOVAC_ACTIV_LEN</name></expr></argument>,
				 <argument><expr><literal type="string">"autovacuum: ANALYZE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Report the qualified name of the relation.
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>activity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activity</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>MAX_AUTOVAC_ACTIV_LEN</name> <operator>-</operator> <name>len</name></expr></argument>,
			 <argument><expr><literal type="string">" %s.%s%s"</literal></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_nspname</name></name></expr></argument>, <argument><expr><name><name>tab</name><operator>-&gt;</operator><name>at_relname</name></name></expr></argument>,
			 <argument><expr><ternary><condition><expr><name><name>tab</name><operator>-&gt;</operator><name>at_params</name><operator>.</operator><name>is_wraparound</name></name></expr> ?</condition><then> <expr><literal type="string">" (to prevent wraparound)"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set statement_timestamp() to current time for pg_stat_activity */</comment>
	<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>activity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * autovac_report_workitem
 *		Report to pgstat that autovacuum is processing a work item
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>autovac_report_workitem</name><parameter_list>(<parameter><decl><type><name>AutoVacuumWorkItem</name> <modifier>*</modifier></type><name>workitem</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nspname</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>activity</name><index>[<expr><name>MAX_AUTOVAC_ACTIV_LEN</name> <operator>+</operator> <literal type="number">12</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>blk</name><index>[<expr><literal type="number">12</literal> <operator>+</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>AVW_BRINSummarizeRange</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activity</name></expr></argument>, <argument><expr><name>MAX_AUTOVAC_ACTIV_LEN</name></expr></argument>,
					 <argument><expr><literal type="string">"autovacuum: BRIN summarize"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Report the qualified name of the relation, and the block number if any
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>activity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BlockNumberIsValid</name><argument_list>(<argument><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_blockNumber</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>blk</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>blk</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">" %u"</literal></expr></argument>, <argument><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_blockNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>blk</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>activity</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>MAX_AUTOVAC_ACTIV_LEN</name> <operator>-</operator> <name>len</name></expr></argument>,
			 <argument><expr><literal type="string">" %s.%s%s"</literal></expr></argument>, <argument><expr><name>nspname</name></expr></argument>, <argument><expr><name>relname</name></expr></argument>, <argument><expr><name>blk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Set statement_timestamp() to current time for pg_stat_activity */</comment>
	<expr_stmt><expr><call><name>SetCurrentStatementStartTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_activity</name><argument_list>(<argument><expr><name>STATE_RUNNING</name></expr></argument>, <argument><expr><name>activity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * AutoVacuumingActive
 *		Check GUC vars and report whether the autovacuum process should be
 *		running.
 */</comment>
<function><type><name>bool</name></type>
<name>AutoVacuumingActive</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>autovacuum_start_daemon</name> <operator>||</operator> <operator>!</operator><name>pgstat_track_counts</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Request one work item to the next autovacuum run processing our database.
 * Return false if the request can't be recorded.
 */</comment>
<function><type><name>bool</name></type>
<name>AutoVacuumRequestWork</name><parameter_list>(<parameter><decl><type><name>AutoVacuumWorkItemType</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>,
					  <parameter><decl><type><name>BlockNumber</name></type> <name>blkno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Locate an unused work item and fill it with the given data.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_WORKITEMS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AutoVacuumWorkItem</name> <modifier>*</modifier></type><name>workitem</name> <init>= <expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_workItems</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_used</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_used</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_database</name></name> <operator>=</operator> <name>MyDatabaseId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_relation</name></name> <operator>=</operator> <name>relationId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workitem</name><operator>-&gt;</operator><name>avw_blockNumber</name></name> <operator>=</operator> <name>blkno</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/* done */</comment>
		<break>break;</break>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutovacuumLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * autovac_init
 *		This is called at postmaster initialization.
 *
 * All we do here is annoy the user if he got it wrong.
 */</comment>
<function><type><name>void</name></type>
<name>autovac_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>autovacuum_start_daemon</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>pgstat_track_counts</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"autovacuum not started because of misconfiguration"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Enable the \"track_counts\" option."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IsAutoVacuum functions
 *		Return whether this is either a launcher autovacuum process or a worker
 *		process.
 */</comment>
<function><type><name>bool</name></type>
<name>IsAutoVacuumLauncherProcess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>am_autovacuum_launcher</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsAutoVacuumWorkerProcess</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>am_autovacuum_worker</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AutoVacuumShmemSize
 *		Compute space needed for autovacuum-related shared memory
 */</comment>
<function><type><name>Size</name></type>
<name>AutoVacuumShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Need the fixed struct and the array of WorkerInfoData.
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>AutoVacuumShmemStruct</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>autovacuum_max_workers</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkerInfoData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AutoVacuumShmemInit
 *		Allocate and initialize autovacuum-related shared memory
 */</comment>
<function><type><name>void</name></type>
<name>AutoVacuumShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>AutoVacuumShmem</name> <operator>=</operator> <operator>(</operator><name>AutoVacuumShmemStruct</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"AutoVacuum Data"</literal></expr></argument>,
						<argument><expr><call><name>AutoVacuumShmemSize</name><argument_list>()</argument_list></call></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkerInfo</name></type>	<name>worker</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_launcherpid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_freeWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_runningWorkers</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_startingWorker</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_workItems</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AutoVacuumWorkItem</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>NUM_WORKITEMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>worker</name> <operator>=</operator> <operator>(</operator><name>WorkerInfo</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>AutoVacuumShmem</name> <operator>+</operator>
							   <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AutoVacuumShmemStruct</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* initialize the WorkerInfo free list */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>autovacuum_max_workers</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>AutoVacuumShmem</name><operator>-&gt;</operator><name>av_freeWorkers</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>worker</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>wi_links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * autovac_refresh_stats
 *		Refresh pgstats data for an autovacuum process
 *
 * Cause the next pgstats read operation to obtain fresh data, but throttle
 * such refreshing in the autovacuum launcher.  This is mostly to avoid
 * rereading the pgstats files too many times in quick succession when there
 * are many databases.
 *
 * Note: we avoid throttling in the autovac worker, as it would be
 * counterproductive in the recheck logic.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>autovac_refresh_stats</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>last_read</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TimestampTz</name></type> <name>current_time</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>current_time</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TimestampDifferenceExceeds</name><argument_list>(<argument><expr><name>last_read</name></expr></argument>, <argument><expr><name>current_time</name></expr></argument>,
										<argument><expr><name>STATS_READ_DELAY</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>last_read</name> <operator>=</operator> <name>current_time</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_clear_snapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
