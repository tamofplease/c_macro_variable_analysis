<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/postmaster/checkpointer.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * checkpointer.c
 *
 * The checkpointer is new as of Postgres 9.2.  It handles all checkpoints.
 * Checkpoints are automatically dispatched after a certain amount of time has
 * elapsed since the last one, and it can be signaled to perform requested
 * checkpoints as well.  (The GUC parameter that mandates a checkpoint every
 * so many WAL segments is implemented by having backends signal when they
 * fill WAL segments; the checkpointer itself doesn't watch for the
 * condition.)
 *
 * The checkpointer is started by the postmaster as soon as the startup
 * subprocess finishes, or as soon as recovery begins if we are doing archive
 * recovery.  It remains alive until the postmaster commands it to terminate.
 * Normal termination is by SIGUSR2, which instructs the checkpointer to
 * execute a shutdown checkpoint and then exit(0).  (All backends must be
 * stopped before SIGUSR2 is issued!)  Emergency termination is by SIGQUIT;
 * like any backend, the checkpointer will simply abort and exit on SIGQUIT.
 *
 * If the checkpointer exits unexpectedly, the postmaster treats that the same
 * as a backend crash: shared memory may be corrupted, so remaining backends
 * should be killed by SIGQUIT and then a recovery cycle started.  (Even if
 * shared memory isn't corrupted, we have lost information about which
 * files need to be fsync'd for the next checkpoint, and so a system
 * restart needs to be forced.)
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/postmaster/checkpointer.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/syncrep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/condition_variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/smgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>


<comment type="block">/*----------
 * Shared memory area for communication between checkpointer and backends
 *
 * The ckpt counters allow backends to watch for completion of a checkpoint
 * request they send.  Here's how it works:
 *	* At start of a checkpoint, checkpointer reads (and clears) the request
 *	  flags and increments ckpt_started, while holding ckpt_lck.
 *	* On completion of a checkpoint, checkpointer sets ckpt_done to
 *	  equal ckpt_started.
 *	* On failure of a checkpoint, checkpointer increments ckpt_failed
 *	  and sets ckpt_done to equal ckpt_started.
 *
 * The algorithm for backends is:
 *	1. Record current values of ckpt_failed and ckpt_started, and
 *	   set request flags, while holding ckpt_lck.
 *	2. Send signal to request checkpoint.
 *	3. Sleep until ckpt_started changes.  Now you know a checkpoint has
 *	   begun since you started this algorithm (although *not* that it was
 *	   specifically initiated by your signal), and that it is using your flags.
 *	4. Record new value of ckpt_started.
 *	5. Sleep until ckpt_done &gt;= saved value of ckpt_started.  (Use modulo
 *	   arithmetic here in case counters wrap around.)  Now you know a
 *	   checkpoint has started and completed, but not whether it was
 *	   successful.
 *	6. If ckpt_failed is different from the originally saved value,
 *	   assume request failed; otherwise it was definitely successful.
 *
 * ckpt_flags holds the OR of the checkpoint request flags sent by all
 * requesting backends since the last checkpoint start.  The flags are
 * chosen so that OR'ing is the correct way to combine multiple requests.
 *
 * num_backend_writes is used to count the number of buffer writes performed
 * by user backend processes.  This counter should be wide enough that it
 * can't overflow during a single processing cycle.  num_backend_fsync
 * counts the subset of those writes that also had to do their own fsync,
 * because the checkpointer failed to absorb their request.
 *
 * The requests array holds fsync requests sent by backends and not yet
 * absorbed by the checkpointer.
 *
 * Unlike the checkpoint fields, num_backend_writes, num_backend_fsync, and
 * the requests fields are protected by CheckpointerCommLock.
 *----------
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>SyncRequestType</name></type> <name>type</name></decl>;</decl_stmt>		<comment type="block">/* request type */</comment>
	<decl_stmt><decl><type><name>FileTag</name></type>		<name>ftag</name></decl>;</decl_stmt>			<comment type="block">/* file identifier */</comment>
}</block></struct></type> <name>CheckpointerRequest</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>checkpointer_pid</name></decl>;</decl_stmt>	<comment type="block">/* PID (0 if not started) */</comment>

	<decl_stmt><decl><type><name>slock_t</name></type>		<name>ckpt_lck</name></decl>;</decl_stmt>		<comment type="block">/* protects all the ckpt_* fields */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>ckpt_started</name></decl>;</decl_stmt>	<comment type="block">/* advances when checkpoint starts */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ckpt_done</name></decl>;</decl_stmt>		<comment type="block">/* advances when checkpoint done */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>ckpt_failed</name></decl>;</decl_stmt>	<comment type="block">/* advances when checkpoint fails */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>ckpt_flags</name></decl>;</decl_stmt>		<comment type="block">/* checkpoint flags, as defined in xlog.h */</comment>

	<decl_stmt><decl><type><name>ConditionVariable</name></type> <name>start_cv</name></decl>;</decl_stmt> <comment type="block">/* signaled when ckpt_started advances */</comment>
	<decl_stmt><decl><type><name>ConditionVariable</name></type> <name>done_cv</name></decl>;</decl_stmt>	<comment type="block">/* signaled when ckpt_done advances */</comment>

	<decl_stmt><decl><type><name>uint32</name></type>		<name>num_backend_writes</name></decl>;</decl_stmt> <comment type="block">/* counts user backend buffer writes */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>num_backend_fsync</name></decl>;</decl_stmt>	<comment type="block">/* counts user backend fsync calls */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>num_requests</name></decl>;</decl_stmt>	<comment type="block">/* current # of requests */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_requests</name></decl>;</decl_stmt>	<comment type="block">/* allocated array size */</comment>
	<decl_stmt><decl><type><name>CheckpointerRequest</name></type> <name><name>requests</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>CheckpointerShmemStruct</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>CheckpointerShmemStruct</name> <modifier>*</modifier></type><name>CheckpointerShmem</name></decl>;</decl_stmt>

<comment type="block">/* interval for calling AbsorbSyncRequests in CheckpointWriteDelay */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITES_PER_ABSORB</name></cpp:macro>		<cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/*
 * GUC parameters
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>CheckPointTimeout</name> <init>= <expr><literal type="number">300</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>CheckPointWarning</name> <init>= <expr><literal type="number">30</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>CheckPointCompletionTarget</name> <init>= <expr><literal type="number">0.5</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Flags set by interrupt handlers for later service in the main loop.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>shutdown_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Private state
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>ckpt_active</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* these values are valid when ckpt_active is true: */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pg_time_t</name></type> <name>ckpt_start_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>XLogRecPtr</name></type> <name>ckpt_start_recptr</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>ckpt_cached_elapsed</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>pg_time_t</name></type> <name>last_checkpoint_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>pg_time_t</name></type> <name>last_xlog_switch_time</name></decl>;</decl_stmt>

<comment type="block">/* Prototypes for private functions */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>CheckArchiveTimeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsCheckpointOnSchedule</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>progress</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ImmediateCheckpointRequested</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>CompactCheckpointerRequestQueue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>UpdateSharedMemoryConfig</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Signal handlers */</comment>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chkpt_quickdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ChkptSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReqCheckpointHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>chkpt_sigusr1_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReqShutdownHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Main entry point for checkpointer process
 *
 * This is invoked from AuxiliaryProcessMain, which has already created the
 * basic execution environment, but not enabled signals yet.
 */</comment>
<function><type><name>void</name></type>
<name>CheckpointerMain</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>sigjmp_buf</name></type>	<name>local_sigjmp_buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>checkpointer_context</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>checkpointer_pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Properly accept or ignore signals the postmaster might send us
	 *
	 * Note: we deliberately ignore SIGTERM, because during a standard Unix
	 * system shutdown cycle, init will SIGTERM all processes at once.  We
	 * want to wait for the backends to exit, whereupon the postmaster will
	 * tell us it's okay to shut down (via SIGUSR2).
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>ChkptSigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* set flag to read config file */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>ReqCheckpointHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* request checkpoint */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* ignore SIGTERM */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>chkpt_quickdie</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* hard crash time */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>chkpt_sigusr1_handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>ReqShutdownHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* request shutdown */</comment>

	<comment type="block">/*
	 * Reset some signals that are accepted by postmaster but not here
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We allow SIGQUIT (quickdie) at all times */</comment>
	<expr_stmt><expr><call><name>sigdelset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>, <argument><expr><name>SIGQUIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initialize so that first time-driven event happens at the correct time.
	 */</comment>
	<expr_stmt><expr><name>last_checkpoint_time</name> <operator>=</operator> <name>last_xlog_switch_time</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Create a memory context that we will do all our work in.  We do this so
	 * that we can reset the context during error recovery and thereby avoid
	 * possible memory leaks.  Formerly this code just ran in
	 * TopMemoryContext, but resetting that would be a really bad idea.
	 */</comment>
	<expr_stmt><expr><name>checkpointer_context</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
												 <argument><expr><literal type="string">"Checkpointer"</literal></expr></argument>,
												 <argument><expr><name>ALLOCSET_DEFAULT_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>checkpointer_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If an exception is encountered, processing resumes here.
	 *
	 * See notes in postgres.c about the design of this coding.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>sigsetjmp</name><argument_list>(<argument><expr><name>local_sigjmp_buf</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Since not using PG_TRY, must reset error stack by hand */</comment>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Prevent interrupts while cleaning up */</comment>
		<expr_stmt><expr><call><name>HOLD_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Report the error to the server log */</comment>
		<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * These operations are really just a minimal subset of
		 * AbortTransaction().  We don't have very many resources to worry
		 * about in checkpointer, but we do have LWLocks, buffers, and temp
		 * files.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockReleaseAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AbortBufferIO</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockBuffers</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseAuxProcessResources</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_Buffers</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_SMgr</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_Files</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AtEOXact_HashTables</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Warn any waiting backends that the checkpoint failed. */</comment>
		<if_stmt><if>if <condition>(<expr><name>ckpt_active</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_failed</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_done</name></name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_started</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>done_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>ckpt_active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now return to normal top-level context and clear ErrorContext for
		 * next time.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>checkpointer_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Flush any leaked data in the top-level context */</comment>
		<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>checkpointer_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Now we can allow interrupts again */</comment>
		<expr_stmt><expr><call><name>RESUME_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sleep at least 1 second after any error.  A write error is likely
		 * to be repeated, and we don't want to be filling the error logs as
		 * fast as we can.
		 */</comment>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Close all open files after any error.  This is helpful on Windows,
		 * where holding deleted files open causes various strange errors.
		 * It's not clear we need it elsewhere, but shouldn't hurt.
		 */</comment>
		<expr_stmt><expr><call><name>smgrcloseall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We can now handle ereport(ERROR) */</comment>
	<expr_stmt><expr><name>PG_exception_stack</name> <operator>=</operator> <operator>&amp;</operator><name>local_sigjmp_buf</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Unblock signals (they were blocked when the postmaster forked us)
	 */</comment>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ensure all shared memory values are set correctly for the config. Doing
	 * this here ensures no race conditions from other concurrent updaters.
	 */</comment>
	<expr_stmt><expr><call><name>UpdateSharedMemoryConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Advertise our latch that backends can use to wake us up while we're
	 * sleeping.
	 */</comment>
	<expr_stmt><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>checkpointerLatch</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>MyProc</name><operator>-&gt;</operator><name>procLatch</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Loop forever
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>do_checkpoint</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>flags</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>elapsed_secs</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>cur_timeout</name></decl>;</decl_stmt>

		<comment type="block">/* Clear any already-pending wakeups */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Process any requests or signals received recently.
		 */</comment>
		<expr_stmt><expr><call><name>AbsorbSyncRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Checkpointer is the last process to shut down, so we ask it to
			 * hold the keys for a range of other tasks required most of which
			 * have nothing to do with checkpointing at all.
			 *
			 * For various reasons, some config values can change dynamically
			 * so the primary copy of them is held in shared memory to make
			 * sure all backends see the same value.  We make Checkpointer
			 * responsible for updating the shared memory copy if the
			 * parameter setting changes because of SIGHUP.
			 */</comment>
			<expr_stmt><expr><call><name>UpdateSharedMemoryConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>shutdown_requested</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * From here on, elog(ERROR) should end with exit(1), not send
			 * control back to the sigsetjmp block above
			 */</comment>
			<expr_stmt><expr><name>ExitOnAnyError</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* Close down the database */</comment>
			<expr_stmt><expr><call><name>ShutdownXLOG</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Normal exit from the checkpointer is here */</comment>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* done */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Detect a pending checkpoint request by checking whether the flags
		 * word in shared memory is nonzero.  We shouldn't need to acquire the
		 * ckpt_lck for this.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><specifier>volatile</specifier> <name>CheckpointerShmemStruct</name> <operator>*</operator><operator>)</operator> <name>CheckpointerShmem</name><operator>)</operator><operator>-&gt;</operator><name>ckpt_flags</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>do_checkpoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_requested_checkpoints</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Force a checkpoint if too much time has elapsed since the last one.
		 * Note that we count a timed checkpoint in stats only when this
		 * occurs without an external request, but we set the CAUSE_TIME flag
		 * bit even if there is also an external request.
		 */</comment>
		<expr_stmt><expr><name>now</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>elapsed_secs</name> <operator>=</operator> <name>now</name> <operator>-</operator> <name>last_checkpoint_time</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>elapsed_secs</name> <operator>&gt;=</operator> <name>CheckPointTimeout</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_checkpoint</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_timed_checkpoints</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>do_checkpoint</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>CHECKPOINT_CAUSE_TIME</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Do a checkpoint if requested.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>do_checkpoint</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>ckpt_performed</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>do_restartpoint</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Check if we should perform a checkpoint or a restartpoint. As a
			 * side-effect, RecoveryInProgress() initializes TimeLineID if
			 * it's not set yet.
			 */</comment>
			<expr_stmt><expr><name>do_restartpoint</name> <operator>=</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Atomically fetch the request flags to figure out what kind of a
			 * checkpoint we should perform, and increase the started-counter
			 * to acknowledge that we've started a new checkpoint.
			 */</comment>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_flags</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_flags</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_started</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>start_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The end-of-recovery checkpoint is a real checkpoint that's
			 * performed while we're still in recovery.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_END_OF_RECOVERY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>do_restartpoint</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We will warn if (a) too soon since last checkpoint (whatever
			 * caused it) and (b) somebody set the CHECKPOINT_CAUSE_XLOG flag
			 * since the last checkpoint start.  Note in particular that this
			 * implementation will not generate warnings caused by
			 * CheckPointTimeout &lt; CheckPointWarning.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_restartpoint</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_CAUSE_XLOG</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<name>elapsed_secs</name> <operator>&lt;</operator> <name>CheckPointWarning</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg_plural</name><argument_list>(<argument><expr><literal type="string">"checkpoints are occurring too frequently (%d second apart)"</literal></expr></argument>,
									   <argument><expr><literal type="string">"checkpoints are occurring too frequently (%d seconds apart)"</literal></expr></argument>,
									   <argument><expr><name>elapsed_secs</name></expr></argument>,
									   <argument><expr><name>elapsed_secs</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider increasing the configuration parameter \"max_wal_size\"."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Initialize checkpointer-private variables used during
			 * checkpoint.
			 */</comment>
			<expr_stmt><expr><name>ckpt_active</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>do_restartpoint</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>ckpt_start_recptr</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ckpt_start_recptr</name> <operator>=</operator> <call><name>GetInsertRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>ckpt_start_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>ckpt_cached_elapsed</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Do the checkpoint.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>do_restartpoint</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CreateCheckPoint</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>ckpt_performed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>ckpt_performed</name> <operator>=</operator> <call><name>CreateRestartPoint</name><argument_list>(<argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * After any checkpoint, close all smgr files.  This is so we
			 * won't hang onto smgr references to deleted files indefinitely.
			 */</comment>
			<expr_stmt><expr><call><name>smgrcloseall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Indicate checkpoint completion to any waiting backends.
			 */</comment>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_done</name></name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_started</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ConditionVariableBroadcast</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>done_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>ckpt_performed</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Note we record the checkpoint start time not end time as
				 * last_checkpoint_time.  This is so that time-driven
				 * checkpoints happen at a predictable spacing.
				 */</comment>
				<expr_stmt><expr><name>last_checkpoint_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We were not able to perform the restartpoint (checkpoints
				 * throw an ERROR in case of error).  Most likely because we
				 * have not received any new checkpoint WAL records since the
				 * last restartpoint. Try again in 15 s.
				 */</comment>
				<expr_stmt><expr><name>last_checkpoint_time</name> <operator>=</operator> <name>now</name> <operator>-</operator> <name>CheckPointTimeout</name> <operator>+</operator> <literal type="number">15</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>ckpt_active</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Check for archive_timeout and switch xlog files if necessary. */</comment>
		<expr_stmt><expr><call><name>CheckArchiveTimeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Send off activity statistics to the stats collector.  (The reason
		 * why we re-use bgwriter-related code for this is that the bgwriter
		 * and checkpointer used to be just one process.  It's probably not
		 * worth the trouble to split the stats support into two independent
		 * stats message types.)
		 */</comment>
		<expr_stmt><expr><call><name>pgstat_send_bgwriter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sleep until we are signaled or it's time for another checkpoint or
		 * xlog file switch.
		 */</comment>
		<expr_stmt><expr><name>now</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>elapsed_secs</name> <operator>=</operator> <name>now</name> <operator>-</operator> <name>last_checkpoint_time</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>elapsed_secs</name> <operator>&gt;=</operator> <name>CheckPointTimeout</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>			<comment type="block">/* no sleep for us ... */</comment>
		<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <name>CheckPointTimeout</name> <operator>-</operator> <name>elapsed_secs</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>XLogArchiveTimeout</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>elapsed_secs</name> <operator>=</operator> <name>now</name> <operator>-</operator> <name>last_xlog_switch_time</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>elapsed_secs</name> <operator>&gt;=</operator> <name>XLogArchiveTimeout</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no sleep for us ... */</comment>
			<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>cur_timeout</name></expr></argument>, <argument><expr><name>XLogArchiveTimeout</name> <operator>-</operator> <name>elapsed_secs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>,
						 <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_EXIT_ON_PM_DEATH</name></expr></argument>,
						 <argument><expr><name>cur_timeout</name> <operator>*</operator> <literal type="number">1000L</literal></expr></argument> <comment type="block">/* convert to ms */</comment> ,
						 <argument><expr><name>WAIT_EVENT_CHECKPOINTER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * CheckArchiveTimeout -- check for archive_timeout and switch xlog files
 *
 * This will switch to a new WAL file and force an archive file write if
 * meaningful activity is recorded in the current WAL file. This includes most
 * writes, including just a single checkpoint record, but excludes WAL records
 * that were inserted with the XLOG_MARK_UNIMPORTANT flag being set (like
 * snapshots of running transactions).  Such records, depending on
 * configuration, occur on regular intervals and don't contain important
 * information.  This avoids generating archives with a few unimportant
 * records.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CheckArchiveTimeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>last_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>last_switch_lsn</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>XLogArchiveTimeout</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First we do a quick check using possibly-stale local state. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>now</name> <operator>-</operator> <name>last_xlog_switch_time</name><operator>)</operator> <operator>&lt;</operator> <name>XLogArchiveTimeout</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Update local state ... note that last_xlog_switch_time is the last time
	 * a switch was performed *or requested*.
	 */</comment>
	<expr_stmt><expr><name>last_time</name> <operator>=</operator> <call><name>GetLastSegSwitchData</name><argument_list>(<argument><expr><operator>&amp;</operator><name>last_switch_lsn</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>last_xlog_switch_time</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>last_xlog_switch_time</name></expr></argument>, <argument><expr><name>last_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now we can do the real checks */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>now</name> <operator>-</operator> <name>last_xlog_switch_time</name><operator>)</operator> <operator>&gt;=</operator> <name>XLogArchiveTimeout</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Switch segment only when "important" WAL has been logged since the
		 * last segment switch (last_switch_lsn points to end of segment
		 * switch occurred in).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>GetLastImportantRecPtr</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <name>last_switch_lsn</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>switchpoint</name></decl>;</decl_stmt>

			<comment type="block">/* mark switch as unimportant, avoids triggering checkpoints */</comment>
			<expr_stmt><expr><name>switchpoint</name> <operator>=</operator> <call><name>RequestXLogSwitch</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If the returned pointer points exactly to a segment boundary,
			 * assume nothing happened.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>XLogSegmentOffset</name><argument_list>(<argument><expr><name>switchpoint</name></expr></argument>, <argument><expr><name>wal_segment_size</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"write-ahead log switch forced (archive_timeout=%d)"</literal></expr></argument>,
					 <argument><expr><name>XLogArchiveTimeout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Update state in any case, so we don't retry constantly when the
		 * system is idle.
		 */</comment>
		<expr_stmt><expr><name>last_xlog_switch_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Returns true if an immediate checkpoint request is pending.  (Note that
 * this does not check the *current* checkpoint's IMMEDIATE flag, but whether
 * there is one pending behind it.)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ImmediateCheckpointRequested</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>CheckpointerShmemStruct</name> <modifier>*</modifier></type><name>cps</name> <init>= <expr><name>CheckpointerShmem</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't need to acquire the ckpt_lck in this case because we're only
	 * looking at a single flag bit.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>cps</name><operator>-&gt;</operator><name>ckpt_flags</name></name> <operator>&amp;</operator> <name>CHECKPOINT_IMMEDIATE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CheckpointWriteDelay -- control rate of checkpoint
 *
 * This function is called after each page write performed by BufferSync().
 * It is responsible for throttling BufferSync()'s write rate to hit
 * checkpoint_completion_target.
 *
 * The checkpoint request flags should be passed in; currently the only one
 * examined is CHECKPOINT_IMMEDIATE, which disables delays between writes.
 *
 * 'progress' is an estimate of how much of the work has been done, as a
 * fraction between 0.0 meaning none, and 1.0 meaning all done.
 */</comment>
<function><type><name>void</name></type>
<name>CheckpointWriteDelay</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>progress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>absorb_counter</name> <init>= <expr><name>WRITES_PER_ABSORB</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do nothing if checkpoint is being executed by non-checkpointer process */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AmCheckpointerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Perform the usual duties and take a nap, unless we're behind schedule,
	 * in which case we just try to catch up as quickly as possible.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_IMMEDIATE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>shutdown_requested</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>ImmediateCheckpointRequested</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsCheckpointOnSchedule</name><argument_list>(<argument><expr><name>progress</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* update shmem copies of config variables */</comment>
			<expr_stmt><expr><call><name>UpdateSharedMemoryConfig</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>AbsorbSyncRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>absorb_counter</name> <operator>=</operator> <name>WRITES_PER_ABSORB</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CheckArchiveTimeout</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Report interim activity statistics to the stats collector.
		 */</comment>
		<expr_stmt><expr><call><name>pgstat_send_bgwriter</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * This sleep used to be connected to bgwriter_delay, typically 200ms.
		 * That resulted in more frequent wakeups if not much work to do.
		 * Checkpointer and bgwriter are no longer related so take the Big
		 * Sleep.
		 */</comment>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>--</operator><name>absorb_counter</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Absorb pending fsync requests after each WRITES_PER_ABSORB write
		 * operations even when we don't sleep, to prevent overflow of the
		 * fsync request queue.
		 */</comment>
		<expr_stmt><expr><call><name>AbsorbSyncRequests</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>absorb_counter</name> <operator>=</operator> <name>WRITES_PER_ABSORB</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * IsCheckpointOnSchedule -- are we on schedule to finish this checkpoint
 *		 (or restartpoint) in time?
 *
 * Compares the current progress against the time/segments elapsed since last
 * checkpoint, and returns true if the progress we've made this far is greater
 * than the elapsed time/segments.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsCheckpointOnSchedule</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>progress</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>XLogRecPtr</name></type>	<name>recptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>elapsed_xlogs</name></decl>,
				<decl><type ref="prev"/><name>elapsed_time</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ckpt_active</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Scale progress according to checkpoint_completion_target. */</comment>
	<expr_stmt><expr><name>progress</name> <operator>*=</operator> <name>CheckPointCompletionTarget</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check against the cached value first. Only do the more expensive
	 * calculations once we reach the target previously calculated. Since
	 * neither time or WAL insert pointer moves backwards, a freshly
	 * calculated value can only be greater than or equal to the cached value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&lt;</operator> <name>ckpt_cached_elapsed</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check progress against WAL segments written and CheckPointSegments.
	 *
	 * We compare the current WAL insert location against the location
	 * computed before calling CreateCheckPoint. The code in XLogInsert that
	 * actually triggers a checkpoint when CheckPointSegments is exceeded
	 * compares against RedoRecptr, so this is not completely accurate.
	 * However, it's good enough for our purposes, we're only calculating an
	 * estimate anyway.
	 *
	 * During recovery, we compare last replayed WAL record's location with
	 * the location computed before calling CreateRestartPoint. That maintains
	 * the same pacing as we have during checkpoints in normal operation, but
	 * we might exceed max_wal_size by a fair amount. That's because there can
	 * be a large gap between a checkpoint's redo-pointer and the checkpoint
	 * record itself, and we only start the restartpoint after we've seen the
	 * checkpoint record. (The gap is typically up to CheckPointSegments *
	 * checkpoint_completion_target where checkpoint_completion_target is the
	 * value that was in effect when the WAL was generated).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>RecoveryInProgress</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>GetXLogReplayRecPtr</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>recptr</name> <operator>=</operator> <call><name>GetInsertRecPtr</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>elapsed_xlogs</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>recptr</name> <operator>-</operator> <name>ckpt_start_recptr</name><operator>)</operator><operator>)</operator> <operator>/</operator>
					 <name>wal_segment_size</name><operator>)</operator> <operator>/</operator> <name>CheckPointSegments</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&lt;</operator> <name>elapsed_xlogs</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ckpt_cached_elapsed</name> <operator>=</operator> <name>elapsed_xlogs</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check progress against time elapsed and checkpoint_timeout.
	 */</comment>
	<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>elapsed_time</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>pg_time_t</name><operator>)</operator> <name><name>now</name><operator>.</operator><name>tv_sec</name></name> <operator>-</operator> <name>ckpt_start_time</name><operator>)</operator> <operator>+</operator>
					<name><name>now</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000000.0</literal><operator>)</operator> <operator>/</operator> <name>CheckPointTimeout</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>progress</name> <operator>&lt;</operator> <name>elapsed_time</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ckpt_cached_elapsed</name> <operator>=</operator> <name>elapsed_time</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* It looks like we're on schedule. */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		signal handler routines
 * --------------------------------
 */</comment>

<comment type="block">/*
 * chkpt_quickdie() occurs when signalled SIGQUIT by the postmaster.
 *
 * Some backend has bought the farm,
 * so we need to stop what we're doing and exit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chkpt_quickdie</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We DO NOT want to run proc_exit() or atexit() callbacks -- we're here
	 * because shared memory may be corrupted, so we don't want to try to
	 * clean up our transaction.  Just nail the windows shut and get out of
	 * town.  The callbacks wouldn't be safe to run from a signal handler,
	 * anyway.
	 *
	 * Note we do _exit(2) not _exit(0).  This is to force the postmaster into
	 * a system reset cycle if someone sends a manual SIGQUIT to a random
	 * backend.  This is necessary precisely because we don't clean up our
	 * shared memory state.  (The "dead man switch" mechanism in pmsignal.c
	 * should ensure the postmaster sees this as a crash, too, but no harm in
	 * being doubly sure.)
	 */</comment>
	<expr_stmt><expr><call><name>_exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGHUP: set flag to re-read config file at next convenient time */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ChkptSigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGINT: set flag to run a normal checkpoint right away */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReqCheckpointHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * The signalling process should have set ckpt_flags nonzero, so all we
	 * need do is ensure that our main loop gets kicked out of any wait.
	 */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR1: used for latch wakeups */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>chkpt_sigusr1_handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>latch_sigusr1_handler</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR2: set flag to run a shutdown checkpoint and exit */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReqShutdownHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>shutdown_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		communication with backends
 * --------------------------------
 */</comment>

<comment type="block">/*
 * CheckpointerShmemSize
 *		Compute space needed for checkpointer-related shared memory
 */</comment>
<function><type><name>Size</name></type>
<name>CheckpointerShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Currently, the size of the requests[] array is arbitrarily set equal to
	 * NBuffers.  This may prove too large or small ...
	 */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>CheckpointerShmemStruct</name></expr></argument>, <argument><expr><name>requests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>NBuffers</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointerRequest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CheckpointerShmemInit
 *		Allocate and initialize checkpointer-related shared memory
 */</comment>
<function><type><name>void</name></type>
<name>CheckpointerShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><call><name>CheckpointerShmemSize</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>CheckpointerShmem</name> <operator>=</operator> <operator>(</operator><name>CheckpointerShmemStruct</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Checkpointer Data"</literal></expr></argument>,
						<argument><expr><name>size</name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * First time through, so initialize.  Note that we zero the whole
		 * requests array; this is so that CompactCheckpointerRequestQueue can
		 * assume that any pad bytes in the request structs are zeroes.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>CheckpointerShmem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>max_requests</name></name> <operator>=</operator> <name>NBuffers</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>start_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ConditionVariableInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>done_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RequestCheckpoint
 *		Called in backend processes to request a checkpoint
 *
 * flags is a bitwise OR of the following:
 *	CHECKPOINT_IS_SHUTDOWN: checkpoint is for database shutdown.
 *	CHECKPOINT_END_OF_RECOVERY: checkpoint is for end of WAL recovery.
 *	CHECKPOINT_IMMEDIATE: finish the checkpoint ASAP,
 *		ignoring checkpoint_completion_target parameter.
 *	CHECKPOINT_FORCE: force a checkpoint even if no XLOG activity has occurred
 *		since the last one (implied by CHECKPOINT_IS_SHUTDOWN or
 *		CHECKPOINT_END_OF_RECOVERY).
 *	CHECKPOINT_WAIT: wait for completion before returning (otherwise,
 *		just signal checkpointer to do it, and return).
 *	CHECKPOINT_CAUSE_XLOG: checkpoint is requested due to xlog filling.
 *		(This affects logging, and in particular enables CheckPointWarning.)
 */</comment>
<function><type><name>void</name></type>
<name>RequestCheckpoint</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>ntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>old_failed</name></decl>,
				<decl><type ref="prev"/><name>old_started</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If in a standalone backend, just do it ourselves.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsPostmasterEnvironment</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There's no point in doing slow checkpoints in a standalone backend,
		 * because there's no other backends the checkpoint could disrupt.
		 */</comment>
		<expr_stmt><expr><call><name>CreateCheckPoint</name><argument_list>(<argument><expr><name>flags</name> <operator>|</operator> <name>CHECKPOINT_IMMEDIATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * After any checkpoint, close all smgr files.  This is so we won't
		 * hang onto smgr references to deleted files indefinitely.
		 */</comment>
		<expr_stmt><expr><call><name>smgrcloseall</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Atomically set the request flags, and take a snapshot of the counters.
	 * When we see ckpt_started &gt; old_started, we know the flags we set here
	 * have been seen by checkpointer.
	 *
	 * Note that we OR the flags with any existing flags, to avoid overriding
	 * a "stronger" request by another backend.  The flag senses must be
	 * chosen to make this work!
	 */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>old_failed</name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_failed</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>old_started</name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_started</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_flags</name></name> <operator>|=</operator> <operator>(</operator><name>flags</name> <operator>|</operator> <name>CHECKPOINT_REQUESTED</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Send signal to request checkpoint.  It's possible that the checkpointer
	 * hasn't started yet, or is in process of restarting, so we will retry a
	 * few times if needed.  (Actually, more than a few times, since on slow
	 * or overloaded buildfarm machines, it's been observed that the
	 * checkpointer can take several seconds to start.)  However, if not told
	 * to wait for the checkpoint to occur, we consider failure to send the
	 * signal to be nonfatal and merely LOG it.  The checkpointer should see
	 * the request when it does start, with or without getting a signal.
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_SIGNAL_TRIES</name></cpp:macro> <cpp:value>600</cpp:value></cpp:define>	<comment type="block">/* max wait 60.0 sec */</comment>
	<for>for <control>(<init><expr><name>ntries</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init><condition>;</condition> <incr><expr><name>ntries</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>checkpointer_pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ntries</name> <operator>&gt;=</operator> <name>MAX_SIGNAL_TRIES</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_WAIT</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_WAIT</name><operator>)</operator></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr></argument>,
					 <argument><expr><literal type="string">"could not signal for checkpoint: checkpointer is not running"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>kill</name><argument_list>(<argument><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>checkpointer_pid</name></name></expr></argument>, <argument><expr><name>SIGINT</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>ntries</name> <operator>&gt;=</operator> <name>MAX_SIGNAL_TRIES</name> <operator>||</operator> <operator>!</operator><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_WAIT</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_WAIT</name><operator>)</operator></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr></argument>,
					 <argument><expr><literal type="string">"could not signal for checkpoint: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>				<comment type="block">/* signal sent successfully */</comment>

		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* wait 0.1 sec, then retry */</comment>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If requested, wait for completion.  We detect completion according to
	 * the algorithm given above.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>CHECKPOINT_WAIT</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>new_started</name></decl>,
					<decl><type ref="prev"/><name>new_failed</name></decl>;</decl_stmt>

		<comment type="block">/* Wait for a new checkpoint to start. */</comment>
		<expr_stmt><expr><call><name>ConditionVariablePrepareToSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>start_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_started</name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_started</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>new_started</name> <operator>!=</operator> <name>old_started</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>start_cv</name></name></expr></argument>,
								   <argument><expr><name>WAIT_EVENT_CHECKPOINT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We are waiting for ckpt_done &gt;= new_started, in a modulo sense.
		 */</comment>
		<expr_stmt><expr><call><name>ConditionVariablePrepareToSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>done_cv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>new_done</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_done</name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_done</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>new_failed</name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_failed</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>new_done</name> <operator>-</operator> <name>new_started</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>ConditionVariableSleep</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>done_cv</name></name></expr></argument>,
								   <argument><expr><name>WAIT_EVENT_CHECKPOINT_DONE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>ConditionVariableCancelSleep</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_failed</name> <operator>!=</operator> <name>old_failed</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"checkpoint request failed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consult recent messages in the server log for details."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ForwardSyncRequest
 *		Forward a file-fsync request from a backend to the checkpointer
 *
 * Whenever a backend is compelled to write directly to a relation
 * (which should be seldom, if the background writer is getting its job done),
 * the backend calls this routine to pass over knowledge that the relation
 * is dirty and must be fsync'd before next checkpoint.  We also use this
 * opportunity to count such writes for statistical purposes.
 *
 * To avoid holding the lock for longer than necessary, we normally write
 * to the requests[] queue without checking for duplicates.  The checkpointer
 * will have to eliminate dups internally anyway.  However, if we discover
 * that the queue is full, we make a pass over the entire queue to compact
 * it.  This is somewhat expensive, but the alternative is for the backend
 * to perform its own fsync, which is far more expensive in practice.  It
 * is theoretically possible a backend fsync might still be necessary, if
 * the queue is full and contains no duplicate entries.  In that case, we
 * let the backend know by returning false.
 */</comment>
<function><type><name>bool</name></type>
<name>ForwardSyncRequest</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>FileTag</name> <modifier>*</modifier></type><name>ftag</name></decl></parameter>, <parameter><decl><type><name>SyncRequestType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CheckpointerRequest</name> <modifier>*</modifier></type><name>request</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>too_full</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* probably shouldn't even get here */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>AmCheckpointerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ForwardSyncRequest must not be called in checkpointer"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CheckpointerCommLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Count all backend writes regardless of if they fit in the queue */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AmBackgroundWriterProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_backend_writes</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the checkpointer isn't running or the request queue is full, the
	 * backend will have to perform its own fsync request.  But before forcing
	 * that to happen, we can try to compact the request queue.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>checkpointer_pid</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		<operator>(</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name> <operator>&gt;=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>max_requests</name></name> <operator>&amp;&amp;</operator>
		 <operator>!</operator><call><name>CompactCheckpointerRequestQueue</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Count the subset of writes where backends have to do their own
		 * fsync
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AmBackgroundWriterProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_backend_fsync</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CheckpointerCommLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK, insert request */</comment>
	<expr_stmt><expr><name>request</name> <operator>=</operator> <operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>request</name><operator>-&gt;</operator><name>ftag</name></name> <operator>=</operator> <operator>*</operator><name>ftag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>request</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

	<comment type="block">/* If queue is more than half full, nudge the checkpointer to empty it */</comment>
	<expr_stmt><expr><name>too_full</name> <operator>=</operator> <operator>(</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name> <operator>&gt;=</operator>
				<name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>max_requests</name></name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CheckpointerCommLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ... but not till after we release the lock */</comment>
	<if_stmt><if>if <condition>(<expr><name>too_full</name> <operator>&amp;&amp;</operator> <name><name>ProcGlobal</name><operator>-&gt;</operator><name>checkpointerLatch</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name><name>ProcGlobal</name><operator>-&gt;</operator><name>checkpointerLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CompactCheckpointerRequestQueue
 *		Remove duplicates from the request queue to avoid backend fsyncs.
 *		Returns "true" if any entries were removed.
 *
 * Although a full fsync request queue is not common, it can lead to severe
 * performance problems when it does happen.  So far, this situation has
 * only been observed to occur when the system is under heavy write load,
 * and especially during the "sync" phase of a checkpoint.  Without this
 * logic, each backend begins doing an fsync for every block written, which
 * gets very expensive and can slow down the whole system.
 *
 * Trying to do this every time the queue is full could lose if there
 * aren't any removable entries.  But that should be vanishingly rare in
 * practice: there's one queue entry per shared buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>CompactCheckpointerRequestQueue</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<struct>struct <name>CheckpointerSlotMapping</name>
	<block>{
		<decl_stmt><decl><type><name>CheckpointerRequest</name></type> <name>request</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>slot</name></decl>;</decl_stmt>
	}</block>;</struct>

	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>,
				<decl><type ref="prev"/><name>preserve_count</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_skipped</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>htab</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>skip_slot</name></decl>;</decl_stmt>

	<comment type="block">/* must hold CheckpointerCommLock in exclusive mode */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>CheckpointerCommLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize skip_slot array */</comment>
	<expr_stmt><expr><name>skip_slot</name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize temporary hash table */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointerRequest</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>CheckpointerSlotMapping</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>htab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"CompactCheckpointerRequestQueue"</literal></expr></argument>,
					   <argument><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>,
					   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The basic idea here is that a request can be skipped if it's followed
	 * by a later, identical request.  It might seem more sensible to work
	 * backwards from the end of the queue and check whether a request is
	 * *preceded* by an earlier, identical request, in the hopes of doing less
	 * copying.  But that might change the semantics, if there's an
	 * intervening SYNC_FORGET_REQUEST or SYNC_FILTER_REQUEST, so we do it
	 * this way.  It would be possible to be even smarter if we made the code
	 * below understand the specific semantics of such requests (it could blow
	 * away preceding entries that would end up being canceled anyhow), but
	 * it's not clear that the extra complexity would buy us anything.
	 */</comment>
	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CheckpointerRequest</name> <modifier>*</modifier></type><name>request</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>CheckpointerSlotMapping</name></name> <modifier>*</modifier></type><name>slotmap</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We use the request struct directly as a hashtable key.  This
		 * assumes that any padding bytes in the structs are consistently the
		 * same, which should be okay because we zeroed them in
		 * CheckpointerShmemInit.  Note also that RelFileNode had better
		 * contain no pad bytes.
		 */</comment>
		<expr_stmt><expr><name>request</name> <operator>=</operator> <operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slotmap</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>htab</name></expr></argument>, <argument><expr><name>request</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Duplicate, so mark the previous occurrence as skippable */</comment>
			<expr_stmt><expr><name><name>skip_slot</name><index>[<expr><name><name>slotmap</name><operator>-&gt;</operator><name>slot</name></name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>num_skipped</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Remember slot containing latest occurrence of this request value */</comment>
		<expr_stmt><expr><name><name>slotmap</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Done with the hash table. */</comment>
	<expr_stmt><expr><call><name>hash_destroy</name><argument_list>(<argument><expr><name>htab</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If no duplicates, we're out of luck. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>num_skipped</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>skip_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We found some duplicates; remove them. */</comment>
	<expr_stmt><expr><name>preserve_count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>n</name> <operator>&lt;</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>skip_slot</name><index>[<expr><name>n</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>preserve_count</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>requests</name><index>[<expr><name>n</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"compacted fsync request queue from %d entries to %d entries"</literal></expr></argument>,
					<argument><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name></expr></argument>, <argument><expr><name>preserve_count</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name> <operator>=</operator> <name>preserve_count</name></expr>;</expr_stmt>

	<comment type="block">/* Cleanup. */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>skip_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * AbsorbSyncRequests
 *		Retrieve queued sync requests and pass them to sync mechanism.
 *
 * This is exported because it must be called during CreateCheckPoint;
 * we have to be sure we have accepted all pending requests just before
 * we start fsync'ing.  Since CreateCheckPoint sometimes runs in
 * non-checkpointer processes, do nothing if not checkpointer.
 */</comment>
<function><type><name>void</name></type>
<name>AbsorbSyncRequests</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CheckpointerRequest</name> <modifier>*</modifier></type><name>requests</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CheckpointerRequest</name> <modifier>*</modifier></type><name>request</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AmStartupProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>AmCheckpointerProcess</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"AbsorbFsyncRequests() called in process %d (type %d)"</literal></expr></argument>,
			 <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>MyAuxProcType</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CheckpointerCommLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Transfer stats counts into pending pgstats message */</comment>
	<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_buf_written_backend</name></name> <operator>+=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_backend_writes</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>BgWriterStats</name><operator>.</operator><name>m_buf_fsync_backend</name></name> <operator>+=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_backend_fsync</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_backend_writes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_backend_fsync</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * We try to avoid holding the lock for a long time by copying the request
	 * array, and processing the requests after releasing the lock.
	 *
	 * Once we have cleared the requests from shared memory, we have to PANIC
	 * if we then fail to absorb them (eg, because our hashtable runs out of
	 * memory).  This is because the system cannot run safely if we are unable
	 * to fsync what we have been told to fsync.  Fortunately, the hashtable
	 * is so small that the problem is quite unlikely to arise in practice.
	 */</comment>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>requests</name> <operator>=</operator> <operator>(</operator><name>CheckpointerRequest</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointerRequest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>requests</name></expr></argument>, <argument><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>requests</name></name></expr></argument>, <argument><expr><name>n</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CheckpointerRequest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>START_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>num_requests</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CheckpointerCommLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>request</name> <operator>=</operator> <name>requests</name></expr>;</init> <condition><expr><name>n</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>request</name><operator>++</operator></expr><operator>,</operator> <expr><name>n</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RememberSyncRequest</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>request</name><operator>-&gt;</operator><name>ftag</name></name></expr></argument>, <argument><expr><name><name>request</name><operator>-&gt;</operator><name>type</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>END_CRIT_SECTION</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>requests</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>requests</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update any shared memory configurations based on config parameters
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>UpdateSharedMemoryConfig</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* update global shmem state for sync rep */</comment>
	<expr_stmt><expr><call><name>SyncRepUpdateSyncStandbysDefined</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If full_page_writes has been changed by SIGHUP, we update it in shared
	 * memory and write an XLOG_FPW_CHANGE record.
	 */</comment>
	<expr_stmt><expr><call><name>UpdateFullPageWrites</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>, <argument><expr><literal type="string">"checkpointer updated shared memory configuration values"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FirstCallSinceLastCheckpoint allows a process to take an action once
 * per checkpoint cycle by asynchronously checking for checkpoint completion.
 */</comment>
<function><type><name>bool</name></type>
<name>FirstCallSinceLastCheckpoint</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>ckpt_done</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>new_done</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>FirstCall</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>new_done</name> <operator>=</operator> <name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_done</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>CheckpointerShmem</name><operator>-&gt;</operator><name>ckpt_lck</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>new_done</name> <operator>!=</operator> <name>ckpt_done</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>FirstCall</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>ckpt_done</name> <operator>=</operator> <name>new_done</name></expr>;</expr_stmt>

	<return>return <expr><name>FirstCall</name></expr>;</return>
</block_content>}</block></function>
</unit>
