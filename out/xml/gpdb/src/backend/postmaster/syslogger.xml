<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/postmaster/syslogger.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * syslogger.c
 *
 * The system logger (syslogger) appeared in Postgres 8.0. It catches all
 * stderr output from the postmaster, backends, and other subprocesses
 * by redirecting to a pipe, and writes it to a set of logfiles.
 * It's possible to have size and age limits for the logfile configured
 * in postgresql.conf. If these limits are reached or passed, the
 * current logfile is closed and a new one is created (rotated).
 * The logfiles are stored in a subdirectory (configurable in
 * postgresql.conf), using a user-selectable naming scheme.
 *
 * Author: Andreas Pflug &lt;pgadmin@pse-consulting.de&gt;
 *
 * Copyright (c) 2004-2019, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/postmaster/syslogger.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/file_perm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/pg_list.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fork_process.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BUF_SIZE</name></cpp:macro> <cpp:value>(2 * PIPE_CHUNK_SIZE)</cpp:value></cpp:define>

<comment type="block">/* The maximum bytes for error message */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERROR_MESSAGE_MAX_SIZE</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>

<comment type="block">/*
 * We read() into a temp buffer twice as big as a chunk, so that any fragment
 * left after processing can be moved down to the front and we'll still have
 * room to read a full chunk.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READ_BUF_SIZE</name></cpp:macro> <cpp:value>(2 * PIPE_CHUNK_SIZE)</cpp:value></cpp:define>

<comment type="block">/* Log rotation signal file path, relative to $PGDATA */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOGROTATE_SIGNAL_FILE</name></cpp:macro>	<cpp:value>"logrotate"</cpp:value></cpp:define>


<comment type="block">/*
 * GUC parameters.  Logging_collector cannot be changed after postmaster
 * start, but the rest can change at SIGHUP.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>Logging_collector</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Log_RotationAge</name> <init>= <expr><name>HOURS_PER_DAY</name> <operator>*</operator> <name>MINS_PER_HOUR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Log_RotationSize</name> <init>= <expr><literal type="number">10</literal> <operator>*</operator> <literal type="number">1024</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>Log_directory</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>Log_filename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Log_truncate_on_rotation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>Log_file_mode</name> <init>= <expr><name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>         <name>gp_log_format</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* Text format */</comment>

<comment type="block">/*
 * Globally visible state (used by elog.c)
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>am_syslogger</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>redirection_done</name></decl>;</decl_stmt>

<comment type="block">/*
 * Private state
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>pg_time_t</name></type> <name>next_rotation_time</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>pipe_eof_seen</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>rotation_disabled</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>syslogFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>csvlogFile</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>NON_EXEC_STATIC</name> <name>pg_time_t</name></type> <name>first_syslogger_file_time</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>last_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>last_csv_file_name</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Buffers for saving partial messages from different backends.
 *
 * Keep NBUFFER_LISTS lists of these, with the entry for a given source pid
 * being in the list numbered (pid % NBUFFER_LISTS), so as to cut down on
 * the number of entries we have to examine for any one incoming message.
 * There must never be more than one entry for the same source pid.
 *
 * An inactive buffer is not removed from its list, just held for re-use.
 * An inactive buffer has pid == 0 and undefined contents of data.
 */</comment>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NBUFFER_LISTS</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>
static List *buffer_lists[NBUFFER_LISTS];
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* These must be exported for EXEC_BACKEND case ... annoying */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
<decl_stmt><decl><type><name>int</name></type>			<name><name>syslogPipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><name>HANDLE</name></type>		<name><name>syslogPipe</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>threadHandle</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>CRITICAL_SECTION</name></type> <name>sysloggerSection</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* GPDB: wrapper function to silence unused result warning */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ignore_returned_result</name><parameter_list>(<parameter><decl><type><name>long</name> <name>long</name> <name>int</name></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>result</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>chunk_is_postgres_chunk</name><parameter_list>(<parameter><decl><type><name>PipeProtoHeader</name> <modifier>*</modifier></type><name>hdr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <return>return <expr><name><name>hdr</name><operator>-&gt;</operator><name>zero</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>hdr</name><operator>-&gt;</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>hdr</name><operator>-&gt;</operator><name>thid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>log_format</name></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>log_format</name></name> <operator>==</operator> <literal type="char">'c'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>hdr</name><operator>-&gt;</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>||</operator> <name><name>hdr</name><operator>-&gt;</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'f'</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>syslogger_handle_chunk</name><parameter_list>(<parameter><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>savedchunk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>syslogger_flush_chunks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Flags set by interrupt handlers for later service in the main loop.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>got_SIGHUP</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>sig_atomic_t</name></type> <name>rotation_requested</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<comment type="block">/* Local subroutines */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>pid_t</name></type> <name>syslogger_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>syslogger_parseArgs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><name>NON_EXEC_STATIC</name> <name>void</name></type> <name>SysLoggerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
static void process_pipe_input(char *logbuffer, int *bytes_in_logbuffer);
static void flush_pipe_input(char *logbuffer, int *bytes_in_logbuffer);
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type><name>logfile_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>allow_errors</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name> <name>__stdcall</name></type> <name>pipeThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>logfile_rotate</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>time_based_rotation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>size_based_rotation</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_directory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_filename</name></decl></parameter>,
                           <parameter><decl><type><name>FILE</name> <modifier>*</modifier><modifier>*</modifier></type><name>fh</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>last_log_file_name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>logfile_getname</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_directory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_file_pattern</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_next_rotation_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>update_metainfo_datafile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * GPDB_94_MERGE_FIXME: We might need to refactor the code to make future
 * merge easier.
 */</comment>

<comment type="block">/*
 * GPDB_92_MERGE_FIXME: This is a ugly hack.
 * PG 9.2 changes to use dynamic lists for chunk use. It uses the pid of as
 * index. pid is extracted from the data after pipe read, however our current code
 * is differnt than upstream pg. PG has a temp buffer. It analyzes the buffer
 * to get pid and then allocates a chunk if needed using the pid as an index,
 * and finally copies the buffer to the new chunk. GP code does not do copy
 * so it is impossible (or ugly hacking needed) to get a new chunk from the
 * unknown pid information. GP code is faster of course, however given this
 * code is not hot spot, maybe we should refactor our code to align with pg upstream.
 * GP seems to have special and better logging for 3rd party module output.
 * I'm not sure about other reasons of the different GP implmentation, but
 * We'd better refer pg (9.2 and latest) code and refactor the code after
 * gp code is running.
 *
 * To workaround previous constraint, I temporarily revert to use previous
 * non-pid indexed chunks but keep the pg9.2 code in this file, some of
 * which is commented out. Note other changes in pg 9.2 e.g. latch changes
 * are kept.
 *
 */</comment>
<decl_stmt><decl><type><name>PipeProtoChunk</name></type> <name><name>saved_chunks</name><index>[<expr><name>CHUNK_SLOTS</name></expr>]</index></name></decl>;</decl_stmt>

<comment type="block">/* Get an available chunk */</comment>
<function><type><specifier>static</specifier> <name>PipeProtoChunk</name> <modifier>*</modifier></type>
<name>get_avail_chunk</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CHUNK_SLOTS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>syslogger_flush_chunks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Recheck again. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CHUNK_SLOTS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	List *buffer_list;
	ListCell   *cell;
	PipeProtoChunk *buf;

	buffer_list = buffer_lists[pid % NBUFFER_LISTS];
	foreach(cell, buffer_list)
	{
		buf =  (PipeProtoChunk *) lfirst(cell);

		if (buf-&gt;hdr.pid == 0)
			return buf;
	}

	buf = palloc(sizeof(PipeProtoChunk));
	buf-&gt;hdr.pid = 0;
	buffer_list = lappend(buffer_list, buf);
	buffer_lists[p.pid % NBUFFER_LISTS] = buffer_list;

    return buf;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Main entry point for syslogger process
 * argc/argv parameters are valid only in EXEC_BACKEND case.
 */</comment>
<function><type><name>NON_EXEC_STATIC</name> <name>void</name></type>
<name>SysLoggerMain</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>currentLogDir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>currentLogFilename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>currentLogRotationAge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WaitEventSet</name> <modifier>*</modifier></type><name>wes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>now</name> <operator>=</operator> <name>MyStartTime</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<expr_stmt><expr><call><name>syslogger_parseArgs</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>

	<expr_stmt><expr><name>am_syslogger</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><literal type="string">"master logger process"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>init_ps_display</name><argument_list>(<argument><expr><literal type="string">"logger process"</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If we restarted, our stderr is already redirected into our own input
	 * pipe.  This is of course pretty useless, not to mention that it
	 * interferes with detecting pipe EOF.  Point stderr to /dev/null. This
	 * assumes that all interesting messages generated in the syslogger will
	 * come through elog.c and will be sent to write_syslogger_file.
	 */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>DEVNULL</name></expr></argument>, <argument><expr><name>O_WRONLY</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * The closes might look redundant, but they are not: we want to be
		 * darn sure the pipe gets closed even if the open failed.  We can
		 * survive running with stderr pointing nowhere, but we can't afford
		 * to have extra pipe input descriptors hanging around.
		 *
		 * As we're just trying to reset these to go to DEVNULL, there's not
		 * much point in checking for failure from the close/dup2 calls here,
		 * if they fail then presumably the file descriptors are closed and
		 * any writes will go into the bitbucket anyway.
		 */</comment>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/*
	 * Syslogger's own stderr can't be the syslogPipe, so set it back to text
	 * mode if we didn't just close it. (It was set to binary in
	 * SubPostmasterMain).
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>redirection_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Also close our copy of the write end of the pipe.  This is needed to
	 * ensure we can detect pipe EOF correctly.  (But note that in the restart
	 * case, the postmaster already did this.)
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Properly accept or ignore signals the postmaster might send us
	 *
	 * Note: we ignore all termination signals, and instead exit only when all
	 * upstream processes are gone, to ensure we don't miss any dying gasps of
	 * broken backends...
	 */</comment>

	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGHUP</name></expr></argument>, <argument><expr><name>sigHupHandler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* set flag to read config file */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGINT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGTERM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGQUIT</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGALRM</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGPIPE</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR1</name></expr></argument>, <argument><expr><name>sigUsr1Handler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* request log rotation */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGUSR2</name></expr></argument>, <argument><expr><name>SIG_IGN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset some signals that are accepted by postmaster but not here
	 */</comment>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGCHLD</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>UnBlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Fire up separate data transfer thread */</comment>
	<expr_stmt><expr><call><name>InitializeCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>threadHandle</name> <operator>=</operator> <operator>(</operator><name>HANDLE</name><operator>)</operator> <call><name>_beginthreadex</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>pipeThread</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>threadHandle</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not create syslogger data transfer thread: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

	<comment type="block">/*
	 * Remember active logfiles' name(s).  We recompute 'em from the reference
	 * time because passing down just the pg_time_t is a lot cheaper than
	 * passing a whole file path in the EXEC_BACKEND case.
	 */</comment>
	<expr_stmt><expr><name>last_file_name</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>Log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last_csv_file_name</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><literal type="string">".csv"</literal></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>Log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* remember active logfile parameters */</comment>
	<expr_stmt><expr><name>currentLogDir</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentLogFilename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>Log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>currentLogRotationAge</name> <operator>=</operator> <name>Log_RotationAge</name></expr>;</expr_stmt>
	<comment type="block">/* set next planned rotation time */</comment>
	<expr_stmt><expr><call><name>set_next_rotation_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>update_metainfo_datafile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset whereToSendOutput, as the postmaster will do (but hasn't yet, at
	 * the point where we forked).  This prevents duplicate output of messages
	 * from syslogger itself.
	 */</comment>
	<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up a reusable WaitEventSet object we'll use to wait for our latch,
	 * and (except on Windows) our socket.
	 *
	 * Unlike all other postmaster child processes, we'll ignore postmaster
	 * death because we want to collect final log output from all backends and
	 * then exit last.  We'll do that by running until we see EOF on the
	 * syslog pipe, which implies that all other backends have exited
	 * (including the postmaster).
	 */</comment>
	<expr_stmt><expr><name>wes</name> <operator>=</operator> <call><name>CreateWaitEventSet</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>wes</name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name></expr></argument>, <argument><expr><name>PGINVALID_SOCKET</name></expr></argument>, <argument><expr><name>MyLatch</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><call><name>AddWaitEventToSet</name><argument_list>(<argument><expr><name>wes</name></expr></argument>, <argument><expr><name>WL_SOCKET_READABLE</name></expr></argument>, <argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Reset whereToSendOutput, as the postmaster will do (but hasn't yet, at
	 * the point where we forked).  This prevents duplicate output of messages
	 * from syslogger itself.
	 */</comment>
	<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt>

	<comment type="block">/* main worker loop */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>time_based_rotation</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>size_rotation_for</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>cur_timeout</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>WaitEvent</name></type>	<name>event</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<decl_stmt><decl><type><name>int</name></type>			<name>bytesRead</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<decl_stmt><decl><type><name>bool</name></type>		<name>all_rotations_occurred</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Clear any already-pending wakeups */</comment>
		<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Process any requests or signals received recently.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>got_SIGHUP</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Check if the log directory or filename pattern changed in
			 * postgresql.conf. If so, force rotation to make sure we're
			 * writing the logfiles in the right place.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>currentLogDir</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>currentLogDir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>currentLogDir</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * Also, create new directory if not present; ignore errors
				 */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>Log_filename</name></expr></argument>, <argument><expr><name>currentLogFilename</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>currentLogFilename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>currentLogFilename</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>Log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Force a rotation if CSVLOG output was just turned on or off and
			 * we need to open or close csvlogFile accordingly.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator> <operator>!=</operator>
				<operator>(</operator><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If rotation time parameter changed, reset next rotation time,
			 * but don't immediately force a rotation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>currentLogRotationAge</name> <operator>!=</operator> <name>Log_RotationAge</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>currentLogRotationAge</name> <operator>=</operator> <name>Log_RotationAge</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_next_rotation_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>update_metainfo_datafile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * If we had a rotation-disabling failure, re-enable rotation
			 * attempts after SIGHUP, and force one immediately.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>rotation_disabled</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rotation_disabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Force rewriting last log filename when reloading configuration.
			 * Even if rotation_requested is false, log_destination may have
			 * been changed and we don't want to wait the next file rotation.
			 */</comment>
			<expr_stmt><expr><call><name>update_metainfo_datafile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>Log_RotationAge</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>rotation_disabled</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Do a logfile rotation if it's time */</comment>
			<expr_stmt><expr><name>now</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>now</name> <operator>&gt;=</operator> <name>next_rotation_time</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>time_based_rotation</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rotation_requested</name> <operator>&amp;&amp;</operator> <name>Log_RotationSize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>rotation_disabled</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Do a rotation if file is too big */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>ftell</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>size_rotation_for</name> <operator>|=</operator> <name>LOG_DESTINATION_STDERR</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				<call><name>ftell</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>size_rotation_for</name> <operator>|=</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>all_rotations_occurred</name> <operator>=</operator> <name>rotation_requested</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rotation_requested</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Force rotation when both values are zero. It means the request
			 * was sent by pg_rotate_logfile() or "pg_ctl logrotate".
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>time_based_rotation</name> <operator>&amp;&amp;</operator> <name>size_rotation_for</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>size_rotation_for</name> <operator>=</operator> <name>LOG_DESTINATION_STDERR</name> <operator>|</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>all_rotations_occurred</name> <operator>&amp;=</operator>
				<call><name>logfile_rotate</name><argument_list>(<argument><expr><name>time_based_rotation</name></expr></argument>, <argument><expr><operator>(</operator><name>size_rotation_for</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>Log_filename</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>syslogFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>all_rotations_occurred</name> <operator>&amp;=</operator>
				<call><name>logfile_rotate</name><argument_list>(<argument><expr><name>time_based_rotation</name></expr></argument>, <argument><expr><operator>(</operator><name>size_rotation_for</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr></argument>,
							   <argument><expr><literal type="string">".csv"</literal></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>Log_filename</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>csvlogFile</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last_csv_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * GPDB: only update our rotation timestamp if every log file above was
		 * able to rotate. In upstream, this would have been done as part of
		 * logfile_rotate() itself -- Postgres calls that function once, whereas
		 * we call it (up to) three times.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>all_rotations_occurred</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>set_next_rotation_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>update_metainfo_datafile</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Calculate time till next time-based rotation, so that we don't
		 * sleep longer than that.  We assume the value of "now" obtained
		 * above is still close enough.  Note we can't make this calculation
		 * until after calling logfile_rotate(), since it will advance
		 * next_rotation_time.
		 *
		 * GPDB: logfile_rotate() doesn't advance next_rotation_time; we do that
		 * explicitly above, once all rotations have been successful.
		 *
		 * Also note that we need to beware of overflow in calculation of the
		 * timeout: with large settings of Log_RotationAge, next_rotation_time
		 * could be more than INT_MAX msec in the future.  In that case we'll
		 * wait no more than INT_MAX msec, and try again.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Log_RotationAge</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>rotation_disabled</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>delay</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>delay</name> <operator>=</operator> <name>next_rotation_time</name> <operator>-</operator> <name>now</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>delay</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>delay</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>delay</name> <operator>=</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <name>delay</name> <operator>*</operator> <literal type="number">1000L</literal></expr>;</expr_stmt>	<comment type="block">/* msec */</comment>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>cur_timeout</name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Sleep until there's something to do
		 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>wes</name></expr></argument>, <argument><expr><name>cur_timeout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>event</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							  <argument><expr><name>WAIT_EVENT_SYSLOGGER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>event</name><operator>.</operator><name>events</name></name> <operator>==</operator> <name>WL_SOCKET_READABLE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><call><name>get_avail_chunk</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>readPos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Read data to fill the buffer up to PIPE_CHUNK_SIZE bytes */</comment>
		<label><name>next_chunkloop</name>:</label>
			<if_stmt><if>if <condition>(<expr><name>bytesRead</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PipeProtoHeader</name></expr></argument>)</argument_list></sizeof></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We always try to make sure that the buffer has at least sizeof(PipeProtoHeader)
				 * bytes if we have read several bytes in the previous read. This handles the case
				 * when a valid chunk has to be read in two read calls, and the first read only
				 * picks up less than sizeof(PipeProtoHeader) bytes.
				 *
				 * However, this read may force some 3rd party error messages (less than
				 * sizeof(PipeProtoHeader) bytes) to sits in the buffer until the next message
				 * comes in. Thus you may experience some delays for small 3rd party error messages
				 * showing up in the logfile. Hopefully, this is very rare.
				 */</comment>
				<expr_stmt><expr><name>readPos</name> <operator>=</operator> <name>bytesRead</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>bytesRead</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>chunk</name> <operator>+</operator> <name>readPos</name></expr></argument>, <argument><expr><name>PIPE_CHUNK_SIZE</name> <operator>-</operator> <name>readPos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>bytesRead</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Zero bytes read when select() is saying read-ready means
				 * EOF on the pipe: that is, there are no longer any processes
				 * with the pipe write end open.  Therefore, the postmaster
				 * and all backends are shut down, and we are done.
				 */</comment>
				<expr_stmt><expr><name>pipe_eof_seen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

				<comment type="block">/* if there's any data left then force it out now */</comment>
				<expr_stmt><expr><call><name>syslogger_flush_chunks</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>bytesRead</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>EINTR</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Syslogger could not read from logger pipe: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>bytesRead</name> <operator>+</operator> <name>readPos</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PipeProtoHeader</name></expr></argument>)</argument_list></sizeof> <operator>&amp;&amp;</operator>
					<call><name>chunk_is_postgres_chunk</name><argument_list>(<argument><expr><operator>(</operator><name>PipeProtoHeader</name> <operator>*</operator><operator>)</operator><name>chunk</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>chunk_size</name> <init>= <expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>PipeProtoHeader</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>needBytes</name> <init>= <expr><name>chunk_size</name> <operator>-</operator> <operator>(</operator><name>bytesRead</name> <operator>+</operator> <name>readPos</name><operator>)</operator></expr></init></decl>;</decl_stmt>

					<comment type="block">/*
					 * Finish reading a chunk if the bytes we have read so far
					 * is not sufficient.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>needBytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>bytesRead</name> <operator>=</operator>	<call><name>read</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
											 <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>chunk</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>bytesRead</name> <operator>+</operator> <name>readPos</name><operator>)</operator></expr></argument>,
											 <argument><expr><name>needBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bytesRead</name> <operator>==</operator> <name>needBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>syslogger_handle_chunk</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/*
					 * Copy the remaining bytes to the beginning of a new unused chunk
					 * buffer if we have read too much.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>needBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>int</name></type>			<name>moreBytes</name> <init>= <expr><name>bytesRead</name> <operator>+</operator> <name>readPos</name> <operator>-</operator> <name>chunk_size</name></expr></init></decl>;</decl_stmt>
						<decl_stmt><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>new_chunk</name> <init>= <expr><call><name>get_avail_chunk</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>moreBytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>new_chunk</name></expr></argument>, <argument><expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>chunk</name><operator>)</operator> <operator>+</operator> <name>chunk_size</name></expr></argument>, <argument><expr><name>moreBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>chunk</name> <operator>=</operator> <name>new_chunk</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>bytesRead</name> <operator>=</operator> <name>moreBytes</name></expr>;</expr_stmt>
						<expr_stmt><expr><name>readPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

						<goto>goto <name>next_chunkloop</name>;</goto>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* go back to the main loop */</comment>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * This is a 3rd party error. We may read parts of the standard
					 * error message along with the 3rd party error. So here, we
					 * scan the data byte by byte until we find a byte that is 0.
					 */</comment>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>msgEnd</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>chunk</name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>chunkEnd</name> <init>= <expr><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>chunk</name><operator>)</operator> <operator>+</operator> <operator>(</operator><name>bytesRead</name> <operator>+</operator> <name>readPos</name><operator>)</operator></expr></init></decl>;</decl_stmt>

					<while>while <condition>(<expr><operator>*</operator><name>msgEnd</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>msgEnd</name> <operator>&lt;</operator> <name>chunkEnd</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>msgEnd</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

					<if_stmt><if>if <condition>(<expr><name>msgEnd</name> <operator>&gt;=</operator> <name>chunkEnd</name></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name></type>		<name>lastChar</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>

						<comment type="block">/*
						 * We didn't find a byte '0', so the whole message
						 * is one 3rd party error message.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>bytesRead</name> <operator>+</operator> <name>readPos</name> <operator>&gt;=</operator> <name>PIPE_CHUNK_SIZE</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name>msgEnd</name> <operator>--</operator></expr>;</expr_stmt>
							<expr_stmt><expr><name>lastChar</name> <operator>=</operator> <operator>*</operator><name>msgEnd</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/* Add a '\0' terminator */</comment>
						<expr_stmt><expr><operator>*</operator><name>msgEnd</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"3rd party error log:\n%s%c"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>chunk</name></expr></argument>, <argument><expr><name>lastChar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/* remember to free this chunk */</comment>
						<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>msgEnd</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * If a 3rd party error does not start with byte '0',
						 * write the message.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>msgEnd</name> <operator>!=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>chunk</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"3rd party error log:\n%s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* A 3rd party error starts with bytes '0', ignore this bytes. */</comment>
							<expr_stmt><expr><name>msgEnd</name><operator>++</operator></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>

						<if_stmt><if>if <condition>(<expr><name>chunkEnd</name> <operator>-</operator> <name>msgEnd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* We copy the rest of bytes to the beginning of the chunk buffer. */</comment>
							<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name>chunk</name></expr></argument>, <argument><expr><name>msgEnd</name></expr></argument>, <argument><expr><name>chunkEnd</name> <operator>-</operator> <name>msgEnd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name>bytesRead</name> <operator>=</operator> <name>chunkEnd</name> <operator>-</operator> <name>msgEnd</name></expr>;</expr_stmt>
							<expr_stmt><expr><name>readPos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

							<goto>goto <name>next_chunkloop</name>;</goto>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>

		<comment type="block">/*
		 * On Windows we leave it to a separate thread to transfer data and
		 * detect pipe EOF.  The main thread just wakes up to handle SIGHUP
		 * and rotation conditions.
		 *
		 * Server code isn't generally thread-safe, so we ensure that only one
		 * of the threads is active at a time by entering the critical section
		 * whenever we're not sleeping.
		 */</comment>
		<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>WaitEventSetWait</name><argument_list>(<argument><expr><name>wes</name></expr></argument>, <argument><expr><name>cur_timeout</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>event</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
								<argument><expr><name>WAIT_EVENT_SYSLOGGER_MAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

		<if_stmt><if>if <condition>(<expr><name>pipe_eof_seen</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * seeing this message on the real stderr is annoying - so we make
			 * it DEBUG1 to suppress in normal use.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"logger shutting down"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Normal exit from the syslogger is here.  Note that we
			 * deliberately do not close syslogFile before exiting; this is to
			 * allow for the possibility of elog messages being generated
			 * inside proc_exit.  Regular exit() will take care of flushing
			 * and closing stdio channels.
			 */</comment>
			<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Postmaster subroutine to start a syslogger subprocess.
 */</comment>
<function><type><name>int</name></type>
<name>SysLogger_Start</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pid_t</name></type>		<name>sysloggerPid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>Logging_collector</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If first time through, create the pipe which will receive stderr
	 * output.
	 *
	 * If the syslogger crashes and needs to be restarted, we continue to use
	 * the same pipe (indeed must do so, since extant backends will be writing
	 * into that pipe).
	 *
	 * This means the postmaster must continue to hold the read end of the
	 * pipe open, so we can pass it down to the reincarnated syslogger. This
	 * is a bit klugy but we have little choice.
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pipe</name><argument_list>(<argument><expr><name>syslogPipe</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_socket_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create pipe for syslog: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SECURITY_ATTRIBUTES</name></type> <name>sa</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>nLength</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SECURITY_ATTRIBUTES</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sa</name><operator>.</operator><name>bInheritHandle</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CreatePipe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sa</name></expr></argument>, <argument><expr><literal type="number">32768</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create pipe for syslog: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Create log directory if not present; ignore errors
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>MakePGDirectory</name><argument_list>(<argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The initial logfile is created right in the postmaster, to verify that
	 * the Log_directory is writable.  We save the reference time so that the
	 * syslogger child process can recompute this file name.
	 *
	 * It might look a bit strange to re-do this during a syslogger restart,
	 * but we must do so since the postmaster closed syslogFile after the
	 * previous fork (and remembering that old file wouldn't be right anyway).
	 * Note we always append here, we won't overwrite any existing file.  This
	 * is consistent with the normal rules, because by definition this is not
	 * a time-based rotation.
	 */</comment>
	<expr_stmt><expr><name>first_syslogger_file_time</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>Log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>syslogFile</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise for the initial CSV log file, if that's enabled.  (Note that
	 * we open syslogFile even when only CSV output is nominally enabled,
	 * since some code paths will write to syslogFile anyway.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>first_syslogger_file_time</name></expr></argument>, <argument><expr><literal type="string">".csv"</literal></expr></argument>, <argument><expr><name>Log_directory</name></expr></argument>, <argument><expr><name>Log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
	<switch>switch <condition>(<expr><operator>(</operator><name>sysloggerPid</name> <operator>=</operator> <call><name>syslogger_forkexec</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<switch>switch <condition>(<expr><operator>(</operator><name>sysloggerPid</name> <operator>=</operator> <call><name>fork_process</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fork system logger: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<comment type="block">/* in postmaster child ... */</comment>
			<expr_stmt><expr><call><name>InitPostmasterChild</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Close the postmaster's sockets */</comment>
			<expr_stmt><expr><call><name>ClosePostmasterPorts</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Drop our connection to postmaster's shared memory, as well */</comment>
			<expr_stmt><expr><call><name>dsm_detach_all</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PGSharedMemoryDetach</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* do the work */</comment>
			<expr_stmt><expr><call><name>SysLoggerMain</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<default>default:</default>
			<comment type="block">/* success, in postmaster */</comment>

			<comment type="block">/* now we redirect stderr, if not done already */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>redirection_done</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
				<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

				<comment type="block">/*
				 * Leave a breadcrumb trail when redirecting, in case the user
				 * forgets that redirection is active and looks only at the
				 * original stderr target file.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"redirecting log output to logging collector process"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Future log output will appear in directory \"%s\"."</literal></expr></argument>,
								 <argument><expr><name>Log_directory</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not redirect stdout: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not redirect stderr: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* Now we are done with the write end of the pipe. */</comment>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

				<comment type="block">/*
				 * open the pipe in binary mode and make sure stderr is binary
				 * after it's been dup'ed into, to avoid disturbing the pipe
				 * chunking protocol.
				 */</comment>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>_open_osfhandle</name><argument_list>(<argument><expr><operator>(</operator><name>intptr_t</name><operator>)</operator> <name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name>_O_APPEND</name> <operator>|</operator> <name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>dup2</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not redirect stderr: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_BINARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Now we are done with the write end of the pipe.
				 * CloseHandle() must not be called because the preceding
				 * close() closes the underlying handle.
				 */</comment>
				<expr_stmt><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name>redirection_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* postmaster will never write the file(s); close 'em */</comment>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>syslogFile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><operator>(</operator><name>int</name><operator>)</operator> <name>sysloggerPid</name></expr>;</return>
	</block_content>}</block></switch></block_content></block></switch>

	<comment type="block">/* we should never reach here */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 * syslogger_forkexec() -
 *
 * Format up the arglist for, then fork and exec, a syslogger process
 */</comment>
<function><type><specifier>static</specifier> <name>pid_t</name></type>
<name>syslogger_forkexec</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>av</name><index>[<expr><literal type="number">10</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ac</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>filenobuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>alertFilenobuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>csvfilenobuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <literal type="string">"--forklog"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>			<comment type="block">/* filled in by postmaster_forkexec */</comment>

	<comment type="block">/* static variables (those not passed by write_backend_variables) */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name>syslogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filenobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filenobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
				 <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>filenobuf</name></expr></argument>, <argument><expr><literal type="string">"-1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<if_stmt><if>if <condition>(<expr><name>syslogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filenobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>filenobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>_get_osfhandle</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>filenobuf</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>filenobuf</name></expr>;</expr_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
				 <argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>, <argument><expr><literal type="string">"-1"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<if_stmt><if>if <condition>(<expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <call><name>_get_osfhandle</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>csvfilenobuf</name></expr></argument>, <argument><expr><literal type="string">"0"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>csvfilenobuf</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>av</name><index>[<expr><name>ac</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ac</name> <operator>&lt;</operator> <call><name>lengthof</name><argument_list>(<argument><expr><name>av</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>postmaster_forkexec</name><argument_list>(<argument><expr><name>ac</name></expr></argument>, <argument><expr><name>av</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * syslogger_parseArgs() -
 *
 * Extract data from the arglist for exec'ed syslogger process
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>syslogger_parseArgs</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>         <name>alertFd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>argc</name> <operator>==</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>argv</name> <operator>+=</operator> <literal type="number">3</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Re-open the error output files that were opened by SysLogger_Start().
	 *
	 * We expect this will always succeed, which is too optimistic, but if it
	 * fails there's not a lot we can do to report the problem anyway.  As
	 * coded, we'll just crash on a null pointer dereference after failure...
	 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>syslogFile</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>							<comment type="block">/* WIN32 */</comment>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>_open_osfhandle</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>_O_APPEND</name> <operator>|</operator> <name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>syslogFile</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>atoi</name><argument_list>(<argument><expr><operator>*</operator><name>argv</name><operator>++</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>_open_osfhandle</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>_O_APPEND</name> <operator>|</operator> <name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>csvlogFile</name> <operator>=</operator> <call><name>fdopen</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>

<comment type="block">/*
 * Write a given timestamp to the log file.
 */</comment>
<function><type><name>void</name></type>
<name>syslogger_append_timestamp</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>stamp_time</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amsyslogger</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>append_comma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <if_stmt><if>if<condition>(<expr><name>stamp_time</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>char</name></type> <name><name>strbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

        <expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
                <comment type="block">/* Win32 timezone names are too long so don't print them */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
                <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S %Z"</literal></expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
                <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S"</literal></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
                <argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>strbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>append_comma</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write the current timestamp with milliseconds to the syslogger file or
 * stderr.
 *
 * It is not safe to call strftime since it is not async-safe, and it
 * is expensive to call strftime to get timezone everytime, we use
 * pg_strftime, but stick on a fixed timezone (default_timezone)
 * instead a settable timezone as PostgreSQL does, since we want all
 * log messages to have the same time format. See MPP-2591.
 */</comment>
<function><type><name>void</name></type>
<name>syslogger_append_current_timestamp</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>amsyslogger</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>pg_time_t</name></type>	<name>stamp_time</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>strbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name><name>msbuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

    <expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>stamp_time</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <name><name>tv</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
            <comment type="block">/* leave room for milliseconds... */</comment>
            <comment type="block">/* Win32 timezone names are too long so don't print them */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
            <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S        %Z"</literal></expr></argument>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
            <argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S        "</literal></expr></argument>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
            <argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* 'paste' milliseconds into place... */</comment>
    <expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>msbuf</name></expr></argument>, <argument><expr><literal type="string">".%06d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>tv</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name>strbuf</name> <operator>+</operator> <literal type="number">19</literal></expr></argument>, <argument><expr><name>msbuf</name></expr></argument>, <argument><expr><literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>strbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>strbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * We use the PostgreSQL defaults for CSV, i.e. quote = escape = '"'
 * If it's NULL, append nothing.
 */</comment>
<function><type><name>int</name></type> <name>syslogger_write_str</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amsyslogger</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>csv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* avoid confusing an empty string with NULL */</comment>
    <if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

    <while>while <condition>(<expr><name>cnt</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
    <block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>csv</name> <operator>&amp;&amp;</operator> <name><name>data</name><index>[<expr><name>cnt</name></expr>]</index></name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name>data</name><operator>+</operator><name>cnt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>data</name><operator>+</operator><name>cnt</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <expr_stmt><expr><name>cnt</name><operator>+=</operator><literal type="number">1</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <return>return <expr><name>cnt</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a string, ended with '\0', in a specific chunk to the log.
 *
 * If csv is true, this function puts double-quotes around the string.
 * If both csv and quote_empty_string are true, this function puts
 * double-quotes around an empty string.
 * If append_comma is true, this function appends a comma after the string.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>syslogger_write_str_from_chunk</name><parameter_list>(<parameter><decl><type><name>CSVChunkStr</name> <modifier>*</modifier></type><name>chunkstr</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>csv</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>quote_empty_string</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>append_comma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>wlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>is_empty_string</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>-</operator> <operator>(</operator><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/* Check if the string is an empty string */</comment>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>is_empty_string</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>next_chunk</name> <init>= <expr><operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>next_chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>next_chunk</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>is_empty_string</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>is_empty_string</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

    <if_stmt><if>if<condition>(<expr><name>csv</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>is_empty_string</name> <operator>||</operator> <name>quote_empty_string</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <while>while<condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>bool</name></type> <name>done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><name>wlen</name> <operator>=</operator> <call><name>syslogger_write_str</name><argument_list>(<argument><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Write OK, don't forget to account for the trailing 0 */</comment>
        <if_stmt><if>if<condition>(<expr><name>wlen</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
        <block>{<block_content> 
            <expr_stmt><expr><name>done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
            <expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
        </block_content>}</block></if>
        <else>else<block type="pseudo"><block_content>
            <expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>wlen</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

        <if_stmt><if>if<condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name></name> <operator>==</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name></expr>)</condition>
        <block>{<block_content>
            <comment type="block">/* switch to next chunk */</comment>
            <if_stmt><if>if<condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
            <block>{<block_content>
                <expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name></expr>]</index></name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
                <expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>-</operator> <operator>(</operator><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>
            </block_content>}</block></if>
            <else>else
            <block>{<block_content>
                <expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
                <expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
            </block_content>}</block></else></if_stmt>
        </block_content>}</block></if></if_stmt>

        <if_stmt><if>if<condition>(<expr><name>done</name></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
    </block_content>}</block></while>

    <if_stmt><if>if<condition>(<expr><name>csv</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>is_empty_string</name> <operator>||</operator> <name>quote_empty_string</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <if_stmt><if>if <condition>(<expr><name>append_comma</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>syslogger_write_int32</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>test0</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>i</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amsyslogger</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>append_comma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">1024</literal></expr>]</index></name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name>test0</name> <operator>||</operator> <name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>sprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s%d"</literal></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>append_comma</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setErrorDataFromSegvChunk
 *   Fill in the given error data with the chunk that contains the message
 * sent in a SEGV/BUS/ILL handler.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>fillinErrorDataFromSegvChunk</name><parameter_list>(<parameter><decl><type><name>GpErrorData</name> <modifier>*</modifier></type><name>errorData</name></decl></parameter>, <parameter><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunk</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		   <name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>is_segv_msg</name></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator>
		   <name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GpSegvErrorData</name> <modifier>*</modifier></type><name>segvData</name> <init>= <expr><operator>(</operator><name>GpSegvErrorData</name> <operator>*</operator><operator>)</operator><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>session_start_time</name></name> <operator>=</operator> <name><name>segvData</name><operator>-&gt;</operator><name>session_start_time</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>omit_location</name></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>

	<comment type="block">/* This field is always true now. We should remove this eventually. */</comment>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>gp_is_primary</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>gp_session_id</name></name> <operator>=</operator> <name><name>segvData</name><operator>-&gt;</operator><name>gp_session_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>gp_command_count</name></name> <operator>=</operator> <name><name>segvData</name><operator>-&gt;</operator><name>gp_command_count</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>gp_segment_id</name></name> <operator>=</operator> <name><name>segvData</name><operator>-&gt;</operator><name>gp_segment_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>slice_id</name></name> <operator>=</operator> <name><name>segvData</name><operator>-&gt;</operator><name>slice_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>error_cursor_pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>internal_query_pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>error_fileline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>top_trans_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>dist_trans_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>local_trans_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>subtrans_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>username</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>databasename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>remote_host</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>remote_port</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_severity</name></name> <operator>=</operator> <literal type="string">"PANIC"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>sql_state</name></name> <operator>=</operator> <literal type="string">"XX000"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_message</name></name> <operator>=</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>ERROR_MESSAGE_MAX_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>signalName</name> <init>= <expr><call><name>SegvBusIllName</name><argument_list>(<argument><expr><name><name>segvData</name><operator>-&gt;</operator><name>signal_num</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>signalName</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>, <argument><expr><name>ERROR_MESSAGE_MAX_SIZE</name></expr></argument>,
			 <argument><expr><literal type="string">"Unexpected internal error: %s received signal %s"</literal></expr></argument>,
			 <argument><expr><ternary><condition><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr> ?</condition><then> <expr><literal type="string">"Master process"</literal></expr> </then><else>: <expr><literal type="string">"Segment process"</literal></expr></else></ternary></expr></argument>,
			 <argument><expr><name>signalName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_detail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_hint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>internal_query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>debug_query_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_func_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_filename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>stacktrace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>segvData</name><operator>-&gt;</operator><name>frame_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>stackAddressArray</name> <init>= <expr><operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpSegvErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>stackAddresses</name> <init>= <expr><name>stackAddressArray</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>stacktrace</name></name> <operator>=</operator> <call><name>gp_stacktrace</name><argument_list>(<argument><expr><name>stackAddresses</name></expr></argument>, <argument><expr><name><name>segvData</name><operator>-&gt;</operator><name>frame_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * freeErrorDataFields
 *   Free the palloc'ed fields inside GpErrorData.
 *
 * This is the counterpart for fillinErrorDataFromSegvChunk. Currently, only error message and
 * stacktrace need to be freed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>freeErrorDataFields</name><parameter_list>(<parameter><decl><type><name>GpErrorData</name> <modifier>*</modifier></type><name>errorData</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>errorData</name><operator>-&gt;</operator><name>stacktrace</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>stacktrace</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * syslogger_write_str_with_comma
 *   Write the given string to the log. A comma is appended after the given string.
 *
 * If csv is true, double quotes are added around the string.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>syslogger_write_str_with_comma</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amsyslogger</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>csv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quote_empty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_empty</name> <init>= <expr><operator>(</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>csv</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>is_empty</name> <operator>||</operator> <name>quote_empty</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>syslogger_write_str</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>csv</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>is_empty</name> <operator>||</operator> <name>quote_empty</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * syslogger_write_str_end
 *   Write the given string to the log. No comma is appended after the given string.
 *
 * If csv is true, double quotes are added around the string.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>syslogger_write_str_end</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amsyslogger</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>csv</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>quote_empty</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type> <name>is_empty</name> <init>= <expr><operator>(</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>csv</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>is_empty</name> <operator>||</operator> <name>quote_empty</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>syslogger_write_str</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>csv</name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>is_empty</name> <operator>||</operator> <name>quote_empty</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * syslogger_write_errordata
 *   Write the GpErrorData to the log.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>syslogger_write_errordata</name><parameter_list>(<parameter><decl><type><name>PipeProtoHeader</name> <modifier>*</modifier></type><name>chunkHeader</name></decl></parameter>, <parameter><decl><type><name>GpErrorData</name> <modifier>*</modifier></type><name>errorData</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>csv</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>syslogger_append_current_timestamp</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* username */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>username</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* databasename */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>databasename</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* Process id, thread id */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>, <argument><expr><name><name>chunkHeader</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"th"</literal></expr></argument>, <argument><expr><name><name>chunkHeader</name><operator>-&gt;</operator><name>thid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* Remote host */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Remote port */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* session start timestamp */</comment>
	<expr_stmt><expr><call><name>syslogger_append_timestamp</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>session_start_time</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* Transaction id */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>top_trans_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* GPDB specific options. */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"con"</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>gp_session_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"cmd"</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>gp_command_count</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>gp_is_primary</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr>?</condition><then> <expr><literal type="string">"seg"</literal></expr> </then><else>: <expr><literal type="string">"mir"</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>gp_segment_id</name></name></expr></argument>,
						  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>slice_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"dx"</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>dist_trans_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>local_trans_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"sx"</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>subtrans_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	
	<comment type="block">/* error severity */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_severity</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* sql state code */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>sql_state</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* errmsg */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_message</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* errdetail */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_detail</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* errhint */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_hint</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* internal query */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>internal_query</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* internal query pos */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>internal_query_pos</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* err ctxt */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_context</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* user query */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>debug_query_string</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* cursor pos */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>error_cursor_pos</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<comment type="block">/* func name */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_func_name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* file name */</comment>
	<expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>error_filename</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* line number */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>fix_fields</name><operator>.</operator><name>error_fileline</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* stack trace */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>errorData</name><operator>-&gt;</operator><name>stacktrace</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>csv</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		
		<expr_stmt><expr><call><name>syslogger_write_str</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>stacktrace</name></name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>errorData</name><operator>-&gt;</operator><name>stacktrace</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>csv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>csv</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/* EOL */</comment>
	<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name>LOG_EOL</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>LOG_EOL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * syslogger_log_segv_chunk
 *   Write the chunk for the message sent inside a SEGV/BUS/ILL handler to the log.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>syslogger_log_segv_chunk</name><parameter_list>(<parameter><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>is_segv_msg</name></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>&amp;&amp;</operator> <name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>==</operator> <name>FIXED_THREAD_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Reset the thread id */</comment>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>GpErrorData</name></type> <name>errorData</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fillinErrorDataFromSegvChunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorData</name></expr></argument>, <argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>syslogger_write_errordata</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>errorData</name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>log_format</name></name> <operator>==</operator> <literal type="char">'c'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>freeErrorDataFields</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* mark chunk as unused */</comment>
	<expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>size_t</name></type>
<name>pg_strnlen</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>maxlen</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>maxlen</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<return>return <expr><name>p</name> <operator>-</operator> <name>str</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>move_to_next_chunk</name><parameter_list>(<parameter><decl><type><name>CSVChunkStr</name> <modifier>*</modifier></type> <name>chunkstr</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>PipeProtoChunk</name> <modifier>*</modifier></type> <name>saved_chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunkstr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>saved_chunks</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name></name> <operator>&gt;=</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* switch to next chunk */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* no more chunks */</comment>
				<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_str_from_chunk</name><parameter_list>(<parameter><decl><type><name>CSVChunkStr</name> <modifier>*</modifier></type><name>chunkstr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PipeProtoChunk</name> <modifier>*</modifier></type><name>saved_chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>wlen</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>out</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunkstr</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>saved_chunks</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>move_to_next_chunk</name><argument_list>(<argument><expr><name>chunkstr</name></expr></argument>, <argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>-</operator> <operator>(</operator><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Check if the string is an empty string */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>p</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>move_to_next_chunk</name><argument_list>(<argument><expr><name>chunkstr</name></expr></argument>, <argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>PipeProtoChunk</name> <modifier>*</modifier></type><name>next_chunk</name> <init>=
				<expr><operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>next_chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>next_chunk</name><operator>-&gt;</operator><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>move_to_next_chunk</name><argument_list>(<argument><expr><name>chunkstr</name></expr></argument>, <argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>strdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>wlen</name> <operator>=</operator> <call><name>pg_strnlen</name><argument_list>(<argument><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>wlen</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// String all contained in this chunk</comment>
		<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// include the null byte</comment>
		<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// skip to start of next string.</comment>
		<return>return <expr><name>out</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>out</name><index>[<expr><name>wlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>wlen</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>move_to_next_chunk</name><argument_list>(<argument><expr><name>chunkstr</name></expr></argument>, <argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>-</operator> <operator>(</operator><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>-</operator> <name><name>chunkstr</name><operator>-&gt;</operator><name>chunk</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>wlen</name> <operator>=</operator> <call><name>pg_strnlen</name><argument_list>(<argument><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Write OK, don't forget to account for the trailing 0 */</comment>
		<if_stmt><if>if <condition>(<expr><name>wlen</name> <operator>&lt;</operator> <name>len</name></expr>)</condition>
		<block>{<block_content>
			<comment type="line">// Remainder of String all contained in this chunk</comment>
			<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// include the null byte</comment>

			<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>wlen</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="line">// skip to start of next string.</comment>
			<return>return <expr><name>out</name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>newlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>out</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>wlen</name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>out</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name>newlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>out</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name></expr></argument>, <argument><expr><name>wlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>out</name><index>[<expr><name>newlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>chunkstr</name><operator>-&gt;</operator><name>p</name></name> <operator>+=</operator> <name>wlen</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>out</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type> <name>syslogger_log_chunk_list</name><parameter_list>(<parameter><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>GpErrorDataFixFields</name> <modifier>*</modifier></type><name>pfixed</name> <init>= <expr><operator>(</operator><name>GpErrorDataFixFields</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>log_format</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
    <block>{<block_content>
        <decl_stmt><decl><type><name>CSVChunkStr</name></type> <name>chunkstr</name> <init>= <expr><block>{ <expr><name>chunk</name></expr>, <expr><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name></expr> }</block></expr></init></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>syslogger_write_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if>
    <else>else
    <block>{<block_content>
        <decl_stmt><decl><type><name>CSVChunkStr</name></type> <name>chunkstr</name> <init>= <expr><block>{ <expr><name>chunk</name></expr>, <expr><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> sizeof<operator>(</operator><name>GpErrorDataFixFields</name><operator>)</operator></expr> }</block></expr></init></decl>;</decl_stmt>
	    <decl_stmt><decl><type><name>GpErrorData</name></type> <name>errorData</name></decl>;</decl_stmt>
        <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>errorData</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>errorData</name><operator>.</operator><name>fix_fields</name></name></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>fix_fields</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>username</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>databasename</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>remote_host</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>remote_port</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_severity</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>sql_state</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_message</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_detail</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_hint</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>internal_query</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_context</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>debug_query_string</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_func_name</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_filename</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>stacktrace</name></name> <operator>=</operator> <call><name>get_str_from_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>chunkstr</name></expr></argument>,<argument><expr><name>saved_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/*
         * timestamp_with_milliseconds 
         */</comment>
        <expr_stmt><expr><call><name>syslogger_append_current_timestamp</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* username */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>username</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* databasename */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>databasename</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Process id, thread id */</comment>
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>pid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"th"</literal></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>thid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Remote host */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>remote_host</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* Remote port */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>remote_port</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* session start timestamp */</comment>
        <expr_stmt><expr><call><name>syslogger_append_timestamp</name><argument_list>(<argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>session_start_time</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* Transaction id */</comment>
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>top_trans_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* GPDB specific options. */</comment>
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"con"</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>gp_session_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"cmd"</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>gp_command_count</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pfixed</name><operator>-&gt;</operator><name>gp_is_primary</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr>?</condition><then> <expr><literal type="string">"seg"</literal></expr> </then><else>: <expr><literal type="string">"mir"</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>gp_segment_id</name></name></expr></argument>,
							  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>slice_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"dx"</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>dist_trans_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>local_trans_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"sx"</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>subtrans_id</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 

        <comment type="block">/* error severity */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_severity</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* sql state code */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>sql_state</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* errmsg */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_message</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* errdetail */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_detail</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* errhint */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_hint</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* internal query */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>internal_query</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* internal query pos */</comment>
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>internal_query_pos</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* err ctxt */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_context</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* user query */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>debug_query_string</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* cursor pos */</comment>
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>error_cursor_pos</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
        <comment type="block">/* func name */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_func_name</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* file name */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_with_comma</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_filename</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* line number */</comment>
        <expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>pfixed</name><operator>-&gt;</operator><name>error_fileline</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <comment type="block">/* stack trace */</comment>
        <expr_stmt><expr><call><name>syslogger_write_str_end</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>stacktrace</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* EOL */</comment>
        <expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name>LOG_EOL</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>LOG_EOL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>stacktrace</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>stacktrace</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>errorData</name><operator>.</operator><name>error_filename</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_filename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>errorData</name><operator>.</operator><name>error_func_name</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_func_name</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>debug_query_string</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>debug_query_string</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_context</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>internal_query</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>internal_query</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_hint</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_hint</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_detail</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_detail</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>error_message</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_message</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>sql_state</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>sql_state</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><name><name>errorData</name><operator>.</operator><name>error_severity</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>error_severity</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>remote_port</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>remote_port</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>remote_host</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>remote_host</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>databasename</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>databasename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>errorData</name><operator>.</operator><name>username</name></name></expr></argument> )</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name><name>errorData</name><operator>.</operator><name>username</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <comment type="block">/* Free the chunks */</comment>
    <while>while<condition>(<expr><name>true</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
        <if_stmt><if>if<condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
            <break>break;</break></block_content></block></if></if_stmt>
        <expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name></expr>]</index></name></expr>;</expr_stmt>
    </block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>syslogger_flush_chunks</name><parameter_list>()</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type> <name>chunk</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>CHUNK_SLOTS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal>
                <operator>&amp;&amp;</operator> <name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>chunk_no</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
        <block>{<block_content>
            <expr_stmt><expr><name>chunk</name> <operator>=</operator> <operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
            <expr_stmt><expr><call><name>syslogger_log_chunk_list</name><argument_list>(<argument><expr><name>chunk</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* make sure we free everything */</comment>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>CHUNK_SLOTS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <expr_stmt><expr><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
    </block_content>}</block></for>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	int			i;

	<comment type="block">/* Dump any incomplete protocol messages */</comment>
	for (i = 0; i &lt; NBUFFER_LISTS; i++)
	{
		List	   *list = buffer_lists[i];
		ListCell   *cell;

		foreach(cell, list)
		{
			PipeProtoChunk *buf = (PipeProtoChunk *) lfirst(cell);
			StringInfo	str = &amp;(buf-&gt;data);

			if(buf-&gt;hdr.pid != 0 &amp;&amp; buf-&gt;hdr.chunk_no == 0)
				syslogger_log_chunk_list(buf);

			buf-&gt;hdr.pid = 0;
		}
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>syslogger_handle_chunk</name><parameter_list>(<parameter><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>chunk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 
    <decl_stmt><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> 

    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>log_format</name></name> <operator>==</operator> <literal type="char">'c'</literal> <operator>||</operator> <name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>log_format</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
          
    <comment type="block">/* I am the last, so chain no one */</comment>
    <expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> 

    <comment type="block">/* find interesting things */</comment>
    <for>for<control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>CHUNK_SLOTS</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
    <block>{<block_content>
        <if_stmt><if>if<condition>(<expr><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>==</operator> <name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>&amp;&amp;</operator> 
                <name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>==</operator> <name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>&amp;&amp;</operator> 
                <name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>log_line_number</name></name> <operator>==</operator> <name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>log_line_number</name></name></expr>)</condition>
        <block>{<block_content>
            <if_stmt><if>if<condition>(<expr><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>chunk_no</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>first</name> <operator>=</operator> <operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

            <if_stmt><if>if<condition>(<expr><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>hdr</name><operator>.</operator><name>chunk_no</name></name> <operator>==</operator> <name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>chunk_no</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
                <expr_stmt><expr><name>prev</name> <operator>=</operator> <operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* Chain me */</comment>
    <if_stmt><if>if<condition>(<expr><name>prev</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>=</operator> <name>chunk</name> <operator>-</operator> <operator>&amp;</operator><name><name>saved_chunks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if<condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>chunk_no</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
    <block>{<block_content>
        <comment type="block">/* A chunk without prev, drop it on the floor */</comment>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Out of order or dangling chunks from pid %d"</literal></expr></argument>, <argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

        <comment type="block">/* remember to free this chunk */</comment>
        <expr_stmt><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

        <comment type="block">/* Out of order chunk, if we have something before this, output */</comment>
        <if_stmt><if>if<condition>(<expr><name>first</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><call><name>syslogger_log_chunk_list</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

        <return>return;</return>
    </block_content>}</block></if></if_stmt>

    <if_stmt><if>if<condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>is_segv_msg</name></name> <operator>==</operator> <literal type="char">'t'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>syslogger_log_segv_chunk</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>syslogger_log_chunk_list</name><argument_list>(<argument><expr><name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/* --------------------------------
 *		pipe protocol handling
 * --------------------------------
 */</comment>

<comment type="block">/*
 * Process data received through the syslogger pipe.
 *
 * This routine interprets the log pipe protocol which sends log messages as
 * (hopefully atomic) chunks - such chunks are detected and reassembled here.
 *
 * The protocol has a header that starts with two nul bytes, then has a 16 bit
 * length, the pid of the sending process, and a flag to indicate if it is
 * the last chunk in a message. Incomplete chunks are saved until we read some
 * more, and non-final chunks are accumulated until we get the final chunk.
 *
 * All of this is to avoid 2 problems:
 * . partial messages being written to logfiles (messes rotation), and
 * . messages from different backends being interleaved (messages garbled).
 *
 * Any non-protocol messages are written out directly. These should only come
 * from non-PostgreSQL sources, however (e.g. third party libraries writing to
 * stderr).
 *
 * logbuffer is the data input buffer, and *bytes_in_logbuffer is the number
 * of bytes present.  On exit, any not-yet-eaten data is left-justified in
 * logbuffer, and *bytes_in_logbuffer is updated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>process_pipe_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>logbuffer</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bytes_in_logbuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cursor</name> <init>= <expr><name>logbuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><operator>*</operator><name>bytes_in_logbuffer</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>dest</name> <init>= <expr><name>LOG_DESTINATION_STDERR</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* While we have enough for a header, process data... */</comment>
	<while>while <condition>(<expr><name>count</name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>offsetof</name><argument_list>(<argument><expr><name>PipeProtoHeader</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PipeProtoHeader</name></type> <name>p</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>chunklen</name></decl>;</decl_stmt>

		<comment type="block">/* Do we have a valid header? */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PipeProtoHeader</name></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>p</name><operator>.</operator><name>nuls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>.</operator><name>nuls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
			<name><name>p</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>p</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <name>PIPE_MAX_PAYLOAD</name> <operator>&amp;&amp;</operator>
			<name><name>p</name><operator>.</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>p</name><operator>.</operator><name>thid</name></name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'t'</literal> <operator>||</operator> <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'f'</literal> <operator>||</operator>
			 <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'T'</literal> <operator>||</operator> <name><name>p</name><operator>.</operator><name>is_last</name></name> <operator>==</operator> <literal type="char">'F'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>buffer_list</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>cell</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>save_buffer</name> <modifier>*</modifier></type><name>existing_slot</name> <init>= <expr><name>NULL</name></expr></init></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>free_slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>StringInfo</name></type>	<name>str</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>chunklen</name> <operator>=</operator> <name>PIPE_HEADER_SIZE</name> <operator>+</operator> <name><name>p</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>

			<comment type="block">/* Fall out of loop if we don't have the whole chunk yet */</comment>
			<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&lt;</operator> <name>chunklen</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>dest</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>p</name><operator>.</operator><name>log_format</name></name> <operator>==</operator> <literal type="char">'c'</literal> <operator>||</operator> <name><name>p</name><operator>.</operator><name>log_format</name></name> <operator>==</operator> <literal type="char">'f'</literal><operator>)</operator></expr> ?</condition><then>
			 	<expr><name>LOG_DESTINATION_CSVLOG</name></expr> </then><else>: <expr><name>LOG_DESTINATION_STDERR</name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/* Finished processing this chunk */</comment>
			<expr_stmt><expr><name>cursor</name> <operator>+=</operator> <name>chunklen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name> <operator>-=</operator> <name>chunklen</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Process non-protocol data */</comment>

			<comment type="block">/*
			 * Look for the start of a protocol header.  If found, dump data
			 * up to there and repeat the loop.  Otherwise, dump it all and
			 * fall out of the loop.  (Note: we want to dump it all if at all
			 * possible, so as to avoid dividing non-protocol messages across
			 * logfiles.  We expect that in many scenarios, a non-protocol
			 * message will arrive all in one read(), and we want to respect
			 * the read() boundary if possible.)
			 */</comment>
			<for>for <control>(<init><expr><name>chunklen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>chunklen</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><name>chunklen</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>cursor</name><index>[<expr><name>chunklen</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<comment type="block">/* fall back on the stderr log as the destination */</comment>
			<expr_stmt><expr><call><name>write_syslogger_file</name><argument_list>(<argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>chunklen</name></expr></argument> <comment type="block">/*, LOG_DESTINATION_STDERR*/</comment>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>cursor</name> <operator>+=</operator> <name>chunklen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name> <operator>-=</operator> <name>chunklen</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* We don't have a full chunk, so left-align what remains in the buffer */</comment>
	<if_stmt><if>if <condition>(<expr><name>count</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>cursor</name> <operator>!=</operator> <name>logbuffer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><name>cursor</name></expr></argument>, <argument><expr><name>count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>bytes_in_logbuffer</name> <operator>=</operator> <name>count</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Force out any buffered data
 *
 * This is currently used only at syslogger shutdown, but could perhaps be
 * useful at other times, so it is careful to leave things in a clean state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>flush_pipe_input</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>logbuffer</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>bytes_in_logbuffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>syslogger_flush_chunks</name><argument_list>()</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_binary_to_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fh</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fileSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>fwrite</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fileSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Try to report any failure.  We mustn't use ereport because it would
	 * just recurse right back here, but write_stderr is OK: it will write
	 * either to the postmaster's original stderr, or to /dev/null, but never
	 * to our input pipe which would result in a different sort of looping.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rc</name> <operator>!=</operator> <name>count</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"could not write to log file: %s\n"</literal></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/* --------------------------------
 *		logfile routines
 * --------------------------------
 */</comment>

<comment type="block">/*
 * Write binary data to the currently open logfile
 *
 * On Windows the data arriving in the pipe already has CR/LF newlines,
 * so we must send it to the file without further translation.
 */</comment>
<function><type><name>void</name></type> <name>write_syslogger_file_binary</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we're told to write to csvlogFile, but it's not open, dump the data
	 * to syslogFile (which is always open) instead.  This can happen if CSV
	 * output is enabled after postmaster start and we've been unable to open
	 * csvlogFile.  There are also race conditions during a parameter change
	 * whereby backends might send us CSV output before we open csvlogFile or
	 * after we close it.  Writing CSV-formatted output to the regular log
	 * file isn't great, but it beats dropping log output on the floor.
	 *
	 * Think not to improve this by trying to open csvlogFile on-the-fly.  Any
	 * failure in that would lead to recursion.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>destination</name> <operator>==</operator> <name>LOG_DESTINATION_STDERR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_binary_to_file</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>count</name></expr></argument>, <argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>destination</name> <operator>&amp;=</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_binary_to_file</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>count</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>csvlogFile</name></expr> </then><else>: <expr><name>syslogFile</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * Write text to the currently open logfile
 *
 * This is exported so that elog.c can call it when am_syslogger is true.
 * This allows the syslogger process to record elog messages of its own,
 * even though its stderr does not point at the syslog pipe.
 */</comment>
<function><type><name>void</name></type> <name>write_syslogger_file</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>count</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>destination</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>,<argument><expr><name>count</name></expr></argument>, <argument><expr><name>destination</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

<comment type="block">/*
 * Worker thread to transfer data from the pipe to the current logfile.
 *
 * We need this because on Windows, WaitforMultipleObjects does not work on
 * unnamed pipes: it always reports "signaled", so the blocking ReadFile won't
 * allow for SIGHUP; and select is for sockets only.
 */</comment>
<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name> <name>__stdcall</name></type>
<name>pipeThread</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>logbuffer</name><index>[<expr><name>READ_BUF_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>bytes_in_logbuffer</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DWORD</name></type>		<name>bytesRead</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BOOL</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ReadFile</name><argument_list>(<argument><expr><name><name>syslogPipe</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
						  <argument><expr><name>logbuffer</name> <operator>+</operator> <name>bytes_in_logbuffer</name></expr></argument>,
						  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>logbuffer</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>bytes_in_logbuffer</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>bytesRead</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Enter critical section before doing anything that might touch
		 * global state shared by the main thread. Anything that uses
		 * palloc()/pfree() in particular are not safe outside the critical
		 * section.
		 */</comment>
		<expr_stmt><expr><call><name>EnterCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>DWORD</name></type>		<name>error</name> <init>= <expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>error</name> <operator>==</operator> <name>ERROR_HANDLE_EOF</name> <operator>||</operator>
				<name>error</name> <operator>==</operator> <name>ERROR_BROKEN_PIPE</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>_dosmaperr</name><argument_list>(<argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from logger pipe: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>bytesRead</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bytes_in_logbuffer</name> <operator>+=</operator> <name>bytesRead</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>process_pipe_input</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_in_logbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we've filled the current logfile, nudge the main thread to do a
		 * log rotation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>Log_RotationSize</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>ftell</name><argument_list>(<argument><expr><name>syslogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal> <operator>||</operator>
				<operator>(</operator><name>csvlogFile</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <call><name>ftell</name><argument_list>(<argument><expr><name>csvlogFile</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>Log_RotationSize</name> <operator>*</operator> <literal type="number">1024L</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* We exit the above loop only upon detecting pipe EOF */</comment>
	<expr_stmt><expr><name>pipe_eof_seen</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* if there's any data left then force it out now */</comment>
	<expr_stmt><expr><call><name>flush_pipe_input</name><argument_list>(<argument><expr><name>logbuffer</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_in_logbuffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set the latch to waken the main thread, which will quit */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LeaveCriticalSection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sysloggerSection</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>_endthread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

<comment type="block">/*
 * Open a new logfile with proper permissions and buffering options.
 *
 * If allow_errors is true, we just log any open failure and return NULL
 * (with errno still correct for the fopen failure).
 * Otherwise, errors are treated as fatal.
 */</comment>
<function><type><specifier>static</specifier> <name>FILE</name> <modifier>*</modifier></type>
<name>logfile_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>mode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>allow_errors</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mode_t</name></type>		<name>oumask</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note we do not let Log_file_mode disable IWUSR, since we certainly want
	 * to be able to write the files ourselves.
	 */</comment>
	<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><operator>(</operator><name>mode_t</name><operator>)</operator> <operator>(</operator><operator>(</operator><operator>~</operator><operator>(</operator><name>Log_file_mode</name> <operator>|</operator> <name>S_IWUSR</name><operator>)</operator><operator>)</operator> <operator>&amp;</operator> <operator>(</operator><name>S_IRWXU</name> <operator>|</operator> <name>S_IRWXG</name> <operator>|</operator> <name>S_IRWXO</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<comment type="block">/* use CRLF line endings on Windows */</comment>
		<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>allow_errors</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>FATAL</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open log file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>fh</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * perform logfile rotation.
 *
 * In GPDB, this has been modified significantly from the upstream version:
 *
 * - In PostgreSQL, one call to logfile_rotate performs rotation for both the
 *   normal and the CSV log. In GPDB, this must be called separately for both,
 *   and also for the GPDB specific 'alert' log
 * - In PostgreSQL, this resets 'rotation_requested' flag. In GPDB, the caller
 *   has to do it.
 * - In PostgreSQL, this calls set_next_rotation_time(). In GPDB, the caller
 *   has to do it once all calls to this function return true (i.e. after all
 *   rotations have been successfully completed for the current timestamp), to
 *   avoid having the filename timestamp advance multiple times per rotation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>logfile_rotate</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>time_based_rotation</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>size_based_rotation</name></decl></parameter>,
			   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>,
               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_directory</name></decl></parameter>, 
               <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_filename</name></decl></parameter>, 
               <parameter><decl><type><name>FILE</name> <modifier>*</modifier><modifier>*</modifier></type><name>fh_p</name></decl></parameter>,
               <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>last_log_file_name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>csvfilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>fntime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name> <init>= <expr><operator>*</operator><name>fh_p</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * When doing a time-based rotation, invent the new logfile name based on
	 * the planned rotation time, not current time, to avoid "slippage" in the
	 * file name when we don't do the rotation immediately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>time_based_rotation</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fntime</name> <operator>=</operator> <name>next_rotation_time</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>fntime</name> <operator>=</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>fntime</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>, <argument><expr><name>log_directory</name></expr></argument>, <argument><expr><name>log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>csvfilename</name> <operator>=</operator> <call><name>logfile_getname</name><argument_list>(<argument><expr><name>fntime</name></expr></argument>, <argument><expr><literal type="string">".csv"</literal></expr></argument>, <argument><expr><name>log_directory</name></expr></argument>, <argument><expr><name>log_filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Decide whether to overwrite or append.  We can overwrite if (a)
	 * Log_truncate_on_rotation is set, (b) the rotation was triggered by
	 * elapsed time and not something else, and (c) the computed file name is
	 * different from what we were previously logging into.
	 *
	 * Note: last_file_name should never be NULL here, but if it is, append.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>time_based_rotation</name> <operator>||</operator> <name>size_based_rotation</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Log_truncate_on_rotation</name> <operator>&amp;&amp;</operator> <name>time_based_rotation</name> <operator>&amp;&amp;</operator>
			<operator>*</operator><name>last_log_file_name</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><operator>*</operator><name>last_log_file_name</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>logfile_open</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fh</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * ENFILE/EMFILE are not too surprising on a busy system; just
			 * keep using the old file till we manage to get a new one.
			 * Otherwise, assume something's wrong with Log_directory and stop
			 * trying to create files.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENFILE</name> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EMFILE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"disabling automatic rotation (use SIGHUP to re-enable)"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rotation_disabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>fh_p</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><operator>*</operator><name>fh_p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>fh_p</name> <operator>=</operator> <name>fh</name></expr>;</expr_stmt>

		<comment type="block">/* instead of pfree'ing filename, remember it for next time */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>*</operator><name>last_log_file_name</name><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>*</operator><name>last_log_file_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>last_log_file_name</name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<comment type="block">/* GPDB_94_MERGE_FIXME: We earlier removed the code below. Why not keep them
 * even we might not call them (I'm not sure though)? Note the API for this
 * function is different. pg upstream has size_rotation_for however gpdb does
 * not have.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	<comment type="block">/*
	 * Same as above, but for csv file.  Note that if LOG_DESTINATION_CSVLOG
	 * was just turned on, we might have to open csvlogFile here though it was
	 * not open before.  In such a case we'll append not overwrite (since
	 * last_csv_file_name will be NULL); that is consistent with the normal
	 * rules since it's not a time-based rotation.
	 */</comment>
	if ((Log_destination &amp; LOG_DESTINATION_CSVLOG) &amp;&amp;
		(csvlogFile == NULL ||
		 time_based_rotation || (size_rotation_for &amp; LOG_DESTINATION_CSVLOG)))
	{
		if (Log_truncate_on_rotation &amp;&amp; time_based_rotation &amp;&amp;
			last_csv_file_name != NULL &amp;&amp;
			strcmp(csvfilename, last_csv_file_name) != 0)
			fh = logfile_open(csvfilename, "w", true);
		else
			fh = logfile_open(csvfilename, "a", true);

		if (!fh)
		{
			<comment type="block">/*
			 * ENFILE/EMFILE are not too surprising on a busy system; just
			 * keep using the old file till we manage to get a new one.
			 * Otherwise, assume something's wrong with Log_directory and stop
			 * trying to create files.
			 */</comment>
			if (errno != ENFILE &amp;&amp; errno != EMFILE)
			{
				ereport(LOG,
						(errmsg("disabling automatic rotation (use SIGHUP to re-enable)")));
				rotation_disabled = true;
			}

			if (filename)
				pfree(filename);
			if (csvfilename)
				pfree(csvfilename);
			return;
		}

		if (csvlogFile != NULL)
			fclose(csvlogFile);
		csvlogFile = fh;

		<comment type="block">/* instead of pfree'ing filename, remember it for next time */</comment>
		if (last_csv_file_name != NULL)
			pfree(last_csv_file_name);
		last_csv_file_name = csvfilename;
		csvfilename = NULL;
	}
	else if (!(Log_destination &amp; LOG_DESTINATION_CSVLOG) &amp;&amp;
			 csvlogFile != NULL)
	{
		<comment type="block">/* CSVLOG was just turned off, so close the old file */</comment>
		fclose(csvlogFile);
		csvlogFile = NULL;
		if (last_csv_file_name != NULL)
			pfree(last_csv_file_name);
		last_csv_file_name = NULL;
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * construct logfile name using timestamp information
 *
 * In Postgres, if suffix isn't NULL, append it to the name, replacing any ".log"
 * that may be in the pattern.
 *
 * In GPDB, parameter suffix is not used. A separate refactor is needed for the API change.
 *
 * Result is palloc'd.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>logfile_getname</name><parameter_list>(<parameter><decl><type><name>pg_time_t</name></type> <name>timestamp</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_directory</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>log_file_pattern</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp_suffix</name></decl>;</decl_stmt>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CSV_SUFFIX</name></cpp:macro> <cpp:value>".csv"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LOG_SUFFIX</name></cpp:macro> <cpp:value>".log"</cpp:value></cpp:define>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXPGPATH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><name>MAXPGPATH</name></expr></argument>, <argument><expr><literal type="string">"%s/"</literal></expr></argument>, <argument><expr><name>log_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* treat Log_filename as a strftime pattern */</comment>
	<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>filename</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>MAXPGPATH</name> <operator>-</operator> <name>len</name></expr></argument>, <argument><expr><name>log_file_pattern</name></expr></argument>,
				<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>timestamp</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the logging format is 'TEXT' and the filename ends with ".csv",
	 * replace ".csv" with ".log".
	 *
	 * If the logging format is 'CSV' and the filename does not end with ".csv",
	 * replace the last four characters in the filename with ".cvs".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CSV_SUFFIX</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmp_suffix</name> <operator>=</operator> <name>filename</name> <operator>+</operator> <operator>(</operator><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>CSV_SUFFIX</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Point the tmp_suffix to the end of string if the length of
		 * the filename is less than ".csv".
		 */</comment>
		<expr_stmt><expr><name>tmp_suffix</name> <operator>=</operator> <name>filename</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Only change .csv to .log if gp_log_format is TEXT, otherwise leave it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_log_format</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tmp_suffix</name></expr></argument>, <argument><expr><name>CSV_SUFFIX</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp_suffix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LOG_SUFFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>LOG_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_log_format</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tmp_suffix</name></expr></argument>, <argument><expr><name>CSV_SUFFIX</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmp_suffix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>CSV_SUFFIX</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>CSV_SUFFIX</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>filename</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine the next planned rotation time, and store in next_rotation_time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_next_rotation_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>now</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rotinterval</name></decl>;</decl_stmt>

	<comment type="block">/* nothing to do if time-based rotation is disabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_RotationAge</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The requirements here are to choose the next time &gt; now that is a
	 * "multiple" of the log rotation interval.  "Multiple" can be interpreted
	 * fairly loosely.  In this version we align to log_timezone rather than
	 * GMT.
	 */</comment>
	<expr_stmt><expr><name>rotinterval</name> <operator>=</operator> <name>Log_RotationAge</name> <operator>*</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>	<comment type="block">/* convert to seconds */</comment>
	<expr_stmt><expr><name>now</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>now</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>now</name> <operator>+=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>now</name> <operator>-=</operator> <name>now</name> <operator>%</operator> <name>rotinterval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>now</name> <operator>+=</operator> <name>rotinterval</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>now</name> <operator>-=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>next_rotation_time</name> <operator>=</operator> <name>now</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Store the name of the file(s) where the log collector, when enabled, writes
 * log messages.  Useful for finding the name(s) of the current log file(s)
 * when there is time-based logfile rotation.  Filenames are stored in a
 * temporary file and which is renamed into the final destination for
 * atomicity.  The file is opened with the same permissions as what gets
 * created in the data directory and has proper buffering options.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>update_metainfo_datafile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fh</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mode_t</name></type>		<name>oumask</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>unlink</name><argument_list>(<argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not remove file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* use the same permissions as the data directory for the new file */</comment>
	<expr_stmt><expr><name>oumask</name> <operator>=</operator> <call><name>umask</name><argument_list>(<argument><expr><name>pg_mode_mask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fh</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>umask</name><argument_list>(<argument><expr><name>oumask</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fh</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setvbuf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>PG_IOLBF</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<comment type="block">/* use CRLF line endings on Windows */</comment>
		<expr_stmt><expr><call><name>_setmode</name><argument_list>(<argument><expr><call><name>_fileno</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>_O_TEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>last_file_name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><literal type="string">"stderr %s\n"</literal></expr></argument>, <argument><expr><name>last_file_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>last_csv_file_name</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fh</name></expr></argument>, <argument><expr><literal type="string">"csvlog %s\n"</literal></expr></argument>, <argument><expr><name>last_csv_file_name</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>fh</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>rename</name><argument_list>(<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>, <argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not rename file \"%s\" to \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>LOG_METAINFO_DATAFILE_TMP</name></expr></argument>, <argument><expr><name>LOG_METAINFO_DATAFILE</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* --------------------------------
 *		signal handler routines
 * --------------------------------
 */</comment>

<comment type="block">/*
 * Check to see if a log rotation request has arrived.  Should be
 * called by postmaster after receiving SIGUSR1.
 */</comment>
<function><type><name>bool</name></type>
<name>CheckLogrotateSignal</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>LOGROTATE_SIGNAL_FILE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the file signaling a log rotation request.
 */</comment>
<function><type><name>void</name></type>
<name>RemoveLogrotateSignalFiles</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>unlink</name><argument_list>(<argument><expr><name>LOGROTATE_SIGNAL_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGHUP: set flag to reload config file */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigHupHandler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>got_SIGHUP</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* SIGUSR1: set flag to rotate logfile */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sigUsr1Handler</name><parameter_list>(<parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>rotation_requested</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><name>MyLatch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>save_errno</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
