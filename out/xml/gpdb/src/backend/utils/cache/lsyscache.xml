<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/cache/lsyscache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * lsyscache.c
 *	  Convenience routines for common queries in the system catalog cache.
 *
 * Portions Copyright (c) 2007-2009, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/cache/lsyscache.c
 *
 * NOTES
 *	  Eventually, the index information should go through here, too.
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/nbtree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"bootstrap/bootstrap.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amop.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_amproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_language.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opclass.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_range.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_transform.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablecmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>			<comment type="block">/* for sort_op_can_sort() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbhash.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/heap.h"</cpp:file></cpp:include>                   <comment type="block">/* SystemAttributeDefinition() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_aggregate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_inherits.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_trigger.h"</cpp:file></cpp:include>

<comment type="block">/* Hook for plugins to get control in get_attavgwidth() */</comment>
<decl_stmt><decl><type><name>get_attavgwidth_hook_type</name></type> <name>get_attavgwidth_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*				---------- AMOP CACHES ----------						 */</comment>

<comment type="block">/*
 * op_in_opfamily
 *
 *		Return t iff operator 'opno' is in operator family 'opfamily'.
 *
 * This function only considers search operators, not ordering operators.
 */</comment>
<function><type><name>bool</name></type>
<name>op_in_opfamily</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchSysCacheExists3</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>AMOP_SEARCH</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_opfamily_strategy
 *
 *		Get the operator's strategy number within the specified opfamily,
 *		or 0 if it's not a member of the opfamily.
 *
 * This function only considers search operators, not ordering operators.
 */</comment>
<function><type><name>int</name></type>
<name>get_op_opfamily_strategy</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amop_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>AMOP_SEARCH</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>amop_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_opfamily_sortfamily
 *
 *		If the operator is an ordering operator within the specified opfamily,
 *		return its amopsortfamily OID; else return InvalidOid.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_op_opfamily_sortfamily</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amop_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><name>AMOP_ORDER</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>amop_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amopsortfamily</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_opfamily_properties
 *
 *		Get the operator's strategy number and declared input data types
 *		within the specified opfamily.
 *
 * Caller should already have verified that opno is a member of opfamily,
 * therefore we raise an error if the tuple is not found.
 */</comment>
<function><type><name>void</name></type>
<name>get_op_opfamily_properties</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>ordering_op</name></decl></parameter>,
						   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>lefttype</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>righttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amop_tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>CharGetDatum</name><argument_list>(<argument><expr><ternary><condition><expr><name>ordering_op</name></expr> ?</condition><then> <expr><name>AMOP_ORDER</name></expr> </then><else>: <expr><name>AMOP_SEARCH</name></expr></else></ternary></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u is not a member of opfamily %u"</literal></expr></argument>,
			 <argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>amop_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>lefttype</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>righttype</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_opfamily_member
 *		Get the OID of the operator that implements the specified strategy
 *		with the specified datatypes for the specified opfamily.
 *
 * Returns InvalidOid if there is no pg_amop entry for the given keys.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opfamily_member</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>righttype</name></decl></parameter>,
					<parameter><decl><type><name>int16</name></type> <name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amop_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache4</name><argument_list>(<argument><expr><name>AMOPSTRATEGY</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>lefttype</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>righttype</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>strategy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>amop_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amop_tup</name><operator>-&gt;</operator><name>amopopr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_ordering_op_properties
 *		Given the OID of an ordering operator (a btree "&lt;" or "&gt;" operator),
 *		determine its opfamily, its declared input datatype, and its
 *		strategy number (BTLessStrategyNumber or BTGreaterStrategyNumber).
 *
 * Returns true if successful, false if no matching pg_amop entry exists.
 * (This indicates that the operator is not a valid ordering operator.)
 *
 * Note: the operator could be registered in multiple families, for example
 * if someone were to build a "reverse sort" opfamily.  This would result in
 * uncertainty as to whether "ORDER BY USING op" would default to NULLS FIRST
 * or NULLS LAST, as well as inefficient planning due to failure to match up
 * pathkeys that should be the same.  So we want a determinate result here.
 * Because of the way the syscache search works, we'll use the interpretation
 * associated with the opfamily with smallest OID, which is probably
 * determinate enough.  Since there is no longer any particularly good reason
 * to build reverse-sort opfamilies, it doesn't seem worth expending any
 * additional effort on ensuring consistency.
 */</comment>
<function><type><name>bool</name></type>
<name>get_ordering_op_properties</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
						   <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opfamily</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opcintype</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>strategy</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* ensure outputs are initialized on failure */</comment>
	<expr_stmt><expr><operator>*</operator><name>opfamily</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>opcintype</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Search pg_amop to see if the target operator is registered as the "&lt;"
	 * or "&gt;" operator of any btree opfamily.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* must be btree */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>BTLessStrategyNumber</name> <operator>||</operator>
			<name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>BTGreaterStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found it ... should have consistent input types */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name> <operator>==</operator> <name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Found a suitable opfamily, return info */</comment>
				<expr_stmt><expr><operator>*</operator><name>opfamily</name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>opcintype</name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>strategy</name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_compare_function_for_ordering_op
 *		Get the OID of the datatype-specific btree comparison function
 *		associated with an ordering operator (a "&lt;" or "&gt;" operator).
 *
 * *cmpfunc receives the comparison function OID.
 * *reverse is set FALSE if the operator is "&lt;", TRUE if it's "&gt;"
 * (indicating the comparison result must be negated before use).
 *
 * Returns TRUE if successful, FALSE if no btree function can be found.
 * (This indicates that the operator is not a valid ordering operator.)
 */</comment>
<function><type><name>bool</name></type>
<name>get_compare_function_for_ordering_op</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>cmpfunc</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opcintype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>strategy</name></decl>;</decl_stmt>

	<comment type="block">/* Find the operator in pg_amop */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcintype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found a suitable opfamily, get matching support function */</comment>
		<expr_stmt><expr><operator>*</operator><name>cmpfunc</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
									 <argument><expr><name>opcintype</name></expr></argument>,
									 <argument><expr><name>opcintype</name></expr></argument>,
									 <argument><expr><name>BTORDER_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>cmpfunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* should not happen */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d(%u,%u) in opfamily %u"</literal></expr></argument>,
				 <argument><expr><name>BTORDER_PROC</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opcintype</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>reverse</name> <operator>=</operator> <operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name><operator>)</operator></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* ensure outputs are set on failure */</comment>
	<expr_stmt><expr><operator>*</operator><name>cmpfunc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>reverse</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_equality_op_for_ordering_op
 *		Get the OID of the datatype-specific btree equality operator
 *		associated with an ordering operator (a "&lt;" or "&gt;" operator).
 *
 * If "reverse" isn't NULL, also set *reverse to false if the operator is "&lt;",
 * true if it's "&gt;"
 *
 * Returns InvalidOid if no matching equality operator can be found.
 * (This indicates that the operator is not a valid ordering operator.)
 */</comment>
<function><type><name>Oid</name></type>
<name>get_equality_op_for_ordering_op</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>reverse</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opcintype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>strategy</name></decl>;</decl_stmt>

	<comment type="block">/* Find the operator in pg_amop */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_ordering_op_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>opfamily</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opcintype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>strategy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Found a suitable opfamily, get matching equality operator */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
									 <argument><expr><name>opcintype</name></expr></argument>,
									 <argument><expr><name>opcintype</name></expr></argument>,
									 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>reverse</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>reverse</name> <operator>=</operator> <operator>(</operator><name>strategy</name> <operator>==</operator> <name>BTGreaterStrategyNumber</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_ordering_op_for_equality_op
 *		Get the OID of a datatype-specific btree ordering operator
 *		associated with an equality operator.  (If there are multiple
 *		possibilities, assume any one will do.)
 *
 * This function is used when we have to sort data before unique-ifying,
 * and don't much care which sorting op is used as long as it's compatible
 * with the intended equality operator.  Since we need a sorting operator,
 * it should be single-data-type even if the given operator is cross-type.
 * The caller specifies whether to find an op for the LHS or RHS data type.
 *
 * Returns InvalidOid if no matching ordering operator can be found.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_ordering_op_for_equality_op</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_lhs_type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search pg_amop to see if the target operator is registered as the "="
	 * operator of any btree opfamily.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* must be btree */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Found a suitable opfamily, get matching ordering operator */</comment>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>typid</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>typid</name> <operator>=</operator> <ternary><condition><expr><name>use_lhs_type</name></expr> ?</condition><then> <expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr> </then><else>: <expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
										 <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>,
										 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<comment type="block">/* failure probably shouldn't happen, but keep looking if so */</comment>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_mergejoin_opfamilies
 *		Given a putatively mergejoinable operator, return a list of the OIDs
 *		of the btree opfamilies in which it represents equality.
 *
 * It is possible (though at present unusual) for an operator to be equality
 * in more than one opfamily, hence the result is a list.  This also lets us
 * return NIL if the operator is not found in any opfamilies.
 *
 * The planner currently uses simple equal() tests to compare the lists
 * returned by this function, which makes the list order relevant, though
 * strictly speaking it should not be.  Because of the way syscache list
 * searches are handled, in normal operation the result will be sorted by OID
 * so everything works fine.  If running with system index usage disabled,
 * the result ordering is unspecified and hence the planner might fail to
 * recognize optimization opportunities ... but that's hardly a scenario in
 * which performance is good anyway, so there's no point in expending code
 * or cycles here to guarantee the ordering in that case.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_mergejoin_opfamilies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search pg_amop to see if the target operator is registered as the "="
	 * operator of any btree opfamily.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* must be btree equality */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>BTREE_AM_OID</name> <operator>&amp;&amp;</operator>
			<name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_compatible_hash_operators
 *		Get the OID(s) of hash equality operator(s) compatible with the given
 *		operator, but operating on its LHS and/or RHS datatype.
 *
 * An operator for the LHS type is sought and returned into *lhs_opno if
 * lhs_opno isn't NULL.  Similarly, an operator for the RHS type is sought
 * and returned into *rhs_opno if rhs_opno isn't NULL.
 *
 * If the given operator is not cross-type, the results should be the same
 * operator, but in cross-type situations they will be different.
 *
 * Returns true if able to find the requested operator(s), false if not.
 * (This indicates that the operator should not have been marked oprcanhash.)
 */</comment>
<function><type><name>bool</name></type>
<name>get_compatible_hash_operators</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
							  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>lhs_opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rhs_opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_compatible_hash_operators_and_family</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>lhs_opno</name></expr></argument>, <argument><expr><name>rhs_opno</name></expr></argument>,
													<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extended version of get_compatible_hash_operators, which also returns
 * the operator family that the returned operators belong to.
 */</comment>
<function><type><name>bool</name></type>
<name>get_compatible_hash_operators_and_family</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
										 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>lhs_opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>rhs_opno</name></decl></parameter>,
										 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opfamily</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>this_opfamily</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Ensure output args are initialized on failure */</comment>
	<if_stmt><if>if <condition>(<expr><name>lhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lhs_opno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>rhs_opno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>opfamily</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>opfamily</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Search pg_amop to see if the target operator is registered as the "="
	 * operator of any hash opfamily.  If the operator is registered in
	 * multiple opfamilies, assume we can use any one.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>this_opfamily</name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>HASH_AM_OID</name> <operator>&amp;&amp;</operator>
			<name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No extra lookup needed if given operator is single-type */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name> <operator>==</operator> <name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>lhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>lhs_opno</name> <operator>=</operator> <name>opno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>rhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>rhs_opno</name> <operator>=</operator> <name>opno</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Get the matching single-type operator(s).  Failure probably
			 * shouldn't happen --- it implies a bogus opfamily --- but
			 * continue looking if so.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>lhs_opno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>lhs_opno</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
												<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
												<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
												<argument><expr><name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>lhs_opno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<comment type="block">/* Matching LHS found, done if caller doesn't want RHS */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rhs_opno</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>rhs_opno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>rhs_opno</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
												<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
												<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
												<argument><expr><name>HTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>rhs_opno</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Forget any LHS operator from this opfamily */</comment>
					<if_stmt><if>if <condition>(<expr><name>lhs_opno</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>lhs_opno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Matching RHS found, so done */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&amp;&amp;</operator> <name>opfamily</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>opfamily</name> <operator>=</operator> <name>this_opfamily</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>get_compatible_hash_opfamily</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search pg_amop to see if the target operator is registered as the "="
	 * operator of any hash opfamily.  If the operator is registered in
	 * multiple opfamilies, assume we can use any one.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>HASH_AM_OID</name> <operator>&amp;&amp;</operator>
			<name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>get_compatible_legacy_hash_opfamily</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search pg_amop to see if the target operator is registered as the "="
	 * operator of any hash opfamily.  If the operator is registered in
	 * multiple opfamilies, assume we can use any one.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>HASH_AM_OID</name> <operator>&amp;&amp;</operator>
			<name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type> <name>hashfunc</name> <init>= <expr><call><name>cdb_hashproc_in_opfamily</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>, <argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>isLegacyCdbHashFunction</name><argument_list>(<argument><expr><name>hashfunc</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_hash_functions
 *		Get the OID(s) of the standard hash support function(s) compatible with
 *		the given operator, operating on its LHS and/or RHS datatype as required.
 *
 * A function for the LHS type is sought and returned into *lhs_procno if
 * lhs_procno isn't NULL.  Similarly, a function for the RHS type is sought
 * and returned into *rhs_procno if rhs_procno isn't NULL.
 *
 * If the given operator is not cross-type, the results should be the same
 * function, but in cross-type situations they will be different.
 *
 * Returns true if able to find the requested function(s), false if not.
 * (This indicates that the operator should not have been marked oprcanhash.)
 */</comment>
<function><type><name>bool</name></type>
<name>get_op_hash_functions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>,
					  <parameter><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>lhs_procno</name></decl></parameter>, <parameter><decl><type><name>RegProcedure</name> <modifier>*</modifier></type><name>rhs_procno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure output args are initialized on failure */</comment>
	<if_stmt><if>if <condition>(<expr><name>lhs_procno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>lhs_procno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>rhs_procno</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>rhs_procno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Search pg_amop to see if the target operator is registered as the "="
	 * operator of any hash opfamily.  If the operator is registered in
	 * multiple opfamilies, assume we can use any one.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>aform</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>HASH_AM_OID</name> <operator>&amp;&amp;</operator>
			<name><name>aform</name><operator>-&gt;</operator><name>amopstrategy</name></name> <operator>==</operator> <name>HTEqualStrategyNumber</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Get the matching support function(s).  Failure probably
			 * shouldn't happen --- it implies a bogus opfamily --- but
			 * continue looking if so.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>lhs_procno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>lhs_procno</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
												<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
												<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr></argument>,
												<argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>lhs_procno</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<comment type="block">/* Matching LHS found, done if caller doesn't want RHS */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>rhs_procno</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Only one lookup needed if given operator is single-type */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>aform</name><operator>-&gt;</operator><name>amoplefttype</name></name> <operator>==</operator> <name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name>rhs_procno</name> <operator>=</operator> <operator>*</operator><name>lhs_procno</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>rhs_procno</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>rhs_procno</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>,
												<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
												<argument><expr><name><name>aform</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr></argument>,
												<argument><expr><name>HASHSTANDARD_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><operator>*</operator><name>rhs_procno</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Forget any LHS function from this opfamily */</comment>
					<if_stmt><if>if <condition>(<expr><name>lhs_procno</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>lhs_procno</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* Matching RHS found, so done */</comment>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_btree_interpretation
 *		Given an operator's OID, find out which btree opfamilies it belongs to,
 *		and what properties it has within each one.  The results are returned
 *		as a palloc'd list of OpBtreeInterpretation structs.
 *
 * In addition to the normal btree operators, we consider a &lt;&gt; operator to be
 * a "member" of an opfamily if its negator is an equality operator of the
 * opfamily.  ROWCOMPARE_NE is returned as the strategy number for this case.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_op_btree_interpretation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OpBtreeInterpretation</name> <modifier>*</modifier></type><name>thisresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find all the pg_amop entries containing the operator.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>op_tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>op_form</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>op_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>op_strategy</name></decl>;</decl_stmt>

		<comment type="block">/* must be btree */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>op_form</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Get the operator's btree strategy number */</comment>
		<expr_stmt><expr><name>op_strategy</name> <operator>=</operator> <operator>(</operator><name>StrategyNumber</name><operator>)</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op_strategy</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op_strategy</name> <operator>&lt;=</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>thisresult</name> <operator>=</operator> <operator>(</operator><name>OpBtreeInterpretation</name> <operator>*</operator><operator>)</operator>
			<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpBtreeInterpretation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>opfamily_id</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amopfamily</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>op_strategy</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>oplefttype</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>oprighttype</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>thisresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we didn't find any btree opfamily containing the operator, perhaps
	 * it is a &lt;&gt; operator.  See if it has a negator that is in an opfamily.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>op_negator</name> <init>= <expr><call><name>get_negator</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>op_negator</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>,
										  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>op_negator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>op_tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>op_form</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>op_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>StrategyNumber</name></type> <name>op_strategy</name></decl>;</decl_stmt>

				<comment type="block">/* must be btree */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>op_form</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* Get the operator's btree strategy number */</comment>
				<expr_stmt><expr><name>op_strategy</name> <operator>=</operator> <operator>(</operator><name>StrategyNumber</name><operator>)</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amopstrategy</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op_strategy</name> <operator>&gt;=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>op_strategy</name> <operator>&lt;=</operator> <literal type="number">5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Only consider negators that are = */</comment>
				<if_stmt><if>if <condition>(<expr><name>op_strategy</name> <operator>!=</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>

				<comment type="block">/* OK, report it with "strategy" ROWCOMPARE_NE */</comment>
				<expr_stmt><expr><name>thisresult</name> <operator>=</operator> <operator>(</operator><name>OpBtreeInterpretation</name> <operator>*</operator><operator>)</operator>
					<call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OpBtreeInterpretation</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>opfamily_id</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amopfamily</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>strategy</name></name> <operator>=</operator> <name>ROWCOMPARE_NE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>oplefttype</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amoplefttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>thisresult</name><operator>-&gt;</operator><name>oprighttype</name></name> <operator>=</operator> <name><name>op_form</name><operator>-&gt;</operator><name>amoprighttype</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>thisresult</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * equality_ops_are_compatible
 *		Return true if the two given equality operators have compatible
 *		semantics.
 *
 * This is trivially true if they are the same operator.  Otherwise,
 * we look to see if they can be found in the same btree or hash opfamily.
 * Either finding allows us to assume that they have compatible notions
 * of equality.  (The reason we need to do these pushups is that one might
 * be a cross-type operator; for instance int24eq vs int4eq.)
 */</comment>
<function><type><name>bool</name></type>
<name>equality_ops_are_compatible</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno1</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opno2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Easy if they're the same operator */</comment>
	<if_stmt><if>if <condition>(<expr><name>opno1</name> <operator>==</operator> <name>opno2</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We search through all the pg_amop entries for opno1.
	 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>op_tuple</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>op_form</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>op_tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* must be btree or hash */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>op_form</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>BTREE_AM_OID</name> <operator>||</operator>
			<name><name>op_form</name><operator>-&gt;</operator><name>amopmethod</name></name> <operator>==</operator> <name>HASH_AM_OID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>op_in_opfamily</name><argument_list>(<argument><expr><name>opno2</name></expr></argument>, <argument><expr><name><name>op_form</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*				---------- AMPROC CACHES ----------						 */</comment>

<comment type="block">/*
 * get_opfamily_proc
 *		Get the OID of the specified support function
 *		for the specified opfamily and datatypes.
 *
 * Returns InvalidOid if there is no pg_amproc entry for the given keys.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opfamily_proc</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>righttype</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>procnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_amproc</name></type> <name>amproc_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache4</name><argument_list>(<argument><expr><name>AMPROCNUM</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>lefttype</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>righttype</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>procnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>amproc_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_amproc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amproc_tup</name><operator>-&gt;</operator><name>amproc</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*				---------- ATTRIBUTE CACHES ----------					 */</comment>

<comment type="block">/*
 * get_attname
 *		Given the relation id and the attribute number, return the "attname"
 *		field from the attribute relation as a palloc'ed string.
 *
 * If no such attribute exists and missing_ok is true, NULL is returned;
 * otherwise a not-intended-for-user-consumption error is thrown.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_attname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>att_tup</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
			 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_attnum
 *
 *		Given the relation id and the attribute name,
 *		return the "attnum" field from the attribute relation.
 *
 *		Returns InvalidAttrNumber if the attr doesn't exist (or is dropped).
 */</comment>
<function><type><name>AttrNumber</name></type>
<name>get_attnum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCacheAttName</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attnum</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidAttrNumber</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_attgenerated
 *
 *		Given the relation id and the attribute name,
 *		return the "attgenerated" field from the attribute relation.
 *
 *		Errors if not found.
 *
 *		Since not generated is represented by '\0', this can also be used as a
 *		Boolean test.
 */</comment>
<function><type><name>char</name></type>
<name>get_attgenerated</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
			 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attgenerated</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_atttype
 *
 *		Given the relation OID and the attribute number with the relation,
 *		return the attribute type OID.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_atttype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name> <init>= <expr><operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_atttypetypmodcoll
 *
 *		A three-fer: given the relation id and the attribute number,
 *		fetch atttypid, atttypmod, and attcollation in a single cache lookup.
 *
 * Unlike the otherwise-similar get_atttype, this routine
 * raises an error if it can't obtain the information.
 */</comment>
<function><type><name>void</name></type>
<name>get_atttypetypmodcoll</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>,
					  <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typmod</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att_tup</name></decl>;</decl_stmt>

	<comment type="block">/* CDB: Get type for sysattr even if relid is no good (e.g. SubqueryScan) */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>attnum</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>attnum</name></expr></argument> &gt;</argument_list></name> <name>FirstLowInvalidHeapAttributeNumber</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>FormData_pg_attribute</name> <modifier>*</modifier></type><name>sysatt_tup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sysatt_tup</name> <operator>=</operator> <call><name>SystemAttributeDefinition</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typid</name> <operator>=</operator> <name><name>sysatt_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <name><name>sysatt_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>collid</name> <operator>=</operator> <name><name>sysatt_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>ATTNUM</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for attribute %d of relation %u"</literal></expr></argument>,
			 <argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>att_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_attribute</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>typid</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>atttypmod</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>collid</name> <operator>=</operator> <name><name>att_tup</name><operator>-&gt;</operator><name>attcollation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*				---------- COLLATION CACHE ----------					 */</comment>

<comment type="block">/*
 * get_collation_name
 *		Returns the name of a given pg_collation entry.
 *
 * Returns a palloc'd copy of the string, or NULL if no such collation.
 *
 * NOTE: since collation name is not unique, be wary of code that uses this
 * for anything except preparing error messages.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_collation_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>colloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>colltup</name> <init>= <expr><operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>colltup</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>get_collation_isdeterministic</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>colloid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>colltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>colloid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>colltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>colltup</name><operator>-&gt;</operator><name>collisdeterministic</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*				---------- CONSTRAINT CACHE ----------					 */</comment>

<comment type="block">/*
 * get_constraint_name
 *		Returns the name of a given pg_constraint entry.
 *
 * Returns a palloc'd copy of the string, or NULL if no such constraint.
 *
 * NOTE: since constraint name is not unique, be wary of code that uses this
 * for anything except preparing error messages.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_constraint_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>conoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>conoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>contup</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>contup</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*				---------- LANGUAGE CACHE ----------					 */</comment>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_language_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>langoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>LANGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>langoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_language</name></type> <name>lantup</name> <init>= <expr><operator>(</operator><name>Form_pg_language</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>lantup</name><operator>-&gt;</operator><name>lanname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for language %u"</literal></expr></argument>,
			 <argument><expr><name>langoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*				---------- OPCLASS CACHE ----------						 */</comment>

<comment type="block">/*
 * get_opclass_family
 *
 *		Returns the OID of the operator family the opclass belongs to.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opclass_family</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>cla_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>cla_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_opclass_input_type
 *
 *		Returns the OID of the datatype the opclass indexes.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_opclass_input_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>cla_tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for opclass %u"</literal></expr></argument>, <argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>cla_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_opclass_opfamily_and_input_type
 *
 *		Returns the OID of the operator family the opclass belongs to,
 *				the OID of the datatype the opclass indexes
 */</comment>
<function><type><name>bool</name></type>
<name>get_opclass_opfamily_and_input_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opclass</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opfamily</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>opcintype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_opclass</name></type> <name>cla_tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CLAOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opclass</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cla_tup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_opclass</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>opfamily</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcfamily</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>opcintype</name> <operator>=</operator> <name><name>cla_tup</name><operator>-&gt;</operator><name>opcintype</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*				---------- OPERATOR CACHE ----------					 */</comment>

<comment type="block">/*
 * get_opcode
 *
 *		Returns the regproc id of the routine used to implement an
 *		operator given the operator oid.
 */</comment>
<function><type><name>RegProcedure</name></type>
<name>get_opcode</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprcode</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_opname
 *	  returns the name of the operator with the given opno
 *
 * Note: returns a palloc'd copy of the string, or NULL if no such operator.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_opname</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>optup</name><operator>-&gt;</operator><name>oprname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_op_rettype
 *		Given operator oid, return the operator's result type.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_op_rettype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprresult</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * op_input_types
 *
 *		Returns the left and right input datatypes for an operator
 *		(InvalidOid if not relevant).
 */</comment>
<function><type><name>void</name></type>
<name>op_input_types</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>lefttype</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>righttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* shouldn't happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for operator %u"</literal></expr></argument>, <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>optup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>lefttype</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprleft</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>righttype</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprright</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * op_mergejoinable
 *
 * Returns true if the operator is potentially mergejoinable.  (The planner
 * will fail to find any mergejoin plans unless there are suitable btree
 * opfamily entries for this operator and associated sortops.  The pg_operator
 * flag is just a hint to tell the planner whether to bother looking.)
 *
 * In some cases (currently only array_eq and record_eq), mergejoinability
 * depends on the specific input data type the operator is invoked for, so
 * that must be passed as well. We currently assume that only one input's type
 * is needed to check this --- by convention, pass the left input's data type.
 */</comment>
<function><type><name>bool</name></type>
<name>op_mergejoinable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For array_eq or record_eq, we can sort if the element or field types
	 * are all sortable.  We could implement all the checks for that here, but
	 * the typcache already does that and caches the results too, so let's
	 * rely on the typcache.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>opno</name> <operator>==</operator> <name>ARRAY_EQ_OP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>inputtype</name></expr></argument>, <argument><expr><name>TYPECACHE_CMP_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name> <operator>==</operator> <name>F_BTARRAYCMP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>opno</name> <operator>==</operator> <name>RECORD_EQ_OP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>inputtype</name></expr></argument>, <argument><expr><name>TYPECACHE_CMP_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>cmp_proc</name></name> <operator>==</operator> <name>F_BTRECORDCMP</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* For all other operators, rely on pg_operator.oprcanmerge */</comment>
		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprcanmerge</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * op_hashjoinable
 *
 * Returns true if the operator is hashjoinable.  (There must be a suitable
 * hash opfamily entry for this operator if it is so marked.)
 *
 * In some cases (currently only array_eq), hashjoinability depends on the
 * specific input data type the operator is invoked for, so that must be
 * passed as well.  We currently assume that only one input's type is needed
 * to check this --- by convention, pass the left input's data type.
 */</comment>
<function><type><name>bool</name></type>
<name>op_hashjoinable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>inputtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>

	<comment type="block">/* As in op_mergejoinable, let the typcache handle the hard cases */</comment>
	<comment type="block">/* Eventually we'll need a similar case for record_eq ... */</comment>
	<if_stmt><if>if <condition>(<expr><name>opno</name> <operator>==</operator> <name>ARRAY_EQ_OP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>inputtype</name></expr></argument>, <argument><expr><name>TYPECACHE_HASH_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typentry</name><operator>-&gt;</operator><name>hash_proc</name></name> <operator>==</operator> <name>F_HASH_ARRAY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* For all other operators, rely on pg_operator.oprcanhash */</comment>
		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprcanhash</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * op_strict
 *
 * Get the proisstrict flag for the operator's underlying function.
 */</comment>
<function><type><name>bool</name></type>
<name>op_strict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>funcid</name> <init>= <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>funcid</name> <operator>==</operator> <operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u does not exist"</literal></expr></argument>, <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>func_strict</name><argument_list>(<argument><expr><operator>(</operator><name>Oid</name><operator>)</operator> <name>funcid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * op_volatile
 *
 * Get the provolatile flag for the operator's underlying function.
 */</comment>
<function><type><name>char</name></type>
<name>op_volatile</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>funcid</name> <init>= <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>funcid</name> <operator>==</operator> <operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"operator %u does not exist"</literal></expr></argument>, <argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>func_volatile</name><argument_list>(<argument><expr><operator>(</operator><name>Oid</name><operator>)</operator> <name>funcid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_commutator
 *
 *		Returns the corresponding commutator of an operator.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_commutator</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprcom</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_negator
 *
 *		Returns the corresponding negator of an operator.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_negator</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprnegate</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_oprrest
 *
 *		Returns procedure id for computing selectivity of an operator.
 */</comment>
<function><type><name>RegProcedure</name></type>
<name>get_oprrest</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprrest</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_oprjoin
 *
 *		Returns procedure id for computing selectivity of a join.
 */</comment>
<function><type><name>RegProcedure</name></type>
<name>get_oprjoin</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_operator</name></type> <name>optup</name> <init>= <expr><operator>(</operator><name>Form_pg_operator</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>optup</name><operator>-&gt;</operator><name>oprjoin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*				---------- TRIGGER CACHE ----------					 */</comment>


<comment type="block">/* Does table have update triggers? */</comment>
<function><type><name>bool</name></type>
<name>has_update_triggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>relation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Assume the caller already holds a suitable lock. */</comment>
	<expr_stmt><expr><name>relation</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relhastriggers</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>	<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RelationBuildTriggers</name><argument_list>(<argument><expr><name>relation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>numtriggers</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name>found</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Trigger</name></type> <name>trigger</name> <init>= <expr><name><name>relation</name><operator>-&gt;</operator><name>trigdesc</name><operator>-&gt;</operator><name>triggers</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>trigger_enabled</name><argument_list>(<argument><expr><name><name>trigger</name><operator>.</operator><name>tgoid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>(</operator><call><name>get_trigger_type</name><argument_list>(<argument><expr><name><name>trigger</name><operator>.</operator><name>tgoid</name></name></expr></argument>)</argument_list></call> <operator>&amp;</operator> <name>TRIGGER_TYPE_UPDATE</name><operator>)</operator> <operator>==</operator> <name>TRIGGER_TYPE_UPDATE</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* GPDB_96_MERGE_FIXME: Why is this not allowed? */</comment>
		<if_stmt><if>if <condition>(<expr><name>found</name> <operator>||</operator> <call><name>child_triggers</name><argument_list>(<argument><expr><name><name>relation</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>TRIGGER_TYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relation</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_trigger_type
 *		Given trigger id, return the trigger's type
 */</comment>
<function><type><name>int32</name></type>
<name>get_trigger_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>result</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type>	<name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>triggerid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>TriggerOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for trigger %u"</literal></expr></argument>, <argument><expr><name>triggerid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>tgtype</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * trigger_enabled
 *		Given trigger id, return the trigger's enabled flag
 */</comment>
<function><type><name>bool</name></type>
<name>trigger_enabled</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>triggerid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type>	<name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>triggerid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>TriggerOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for trigger %u"</literal></expr></argument>, <argument><expr><name>triggerid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name></type> <name>tgenabled</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_trigger</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>tgenabled</name></expr></init></decl>;</decl_stmt>
	<switch>switch <condition>(<expr><name>tgenabled</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TRIGGER_FIRES_ON_ORIGIN</name></expr>:</case>
			<comment type="block">/* fallthrough */</comment>
			<comment type="block">/*
			 * FIXME: we should probably return false when
			 * SessionReplicationRole isn't SESSION_REPLICATION_ROLE_ORIGIN,
			 * but does that means we'll also have to flush ORCA's metadata
			 * cache on every assignment of session_replication_role?
			 */</comment>
		<case>case <expr><name>TRIGGER_FIRES_ALWAYS</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TRIGGER_FIRES_ON_REPLICA</name></expr>:</case>
		<case>case <expr><name>TRIGGER_DISABLED</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Unknown trigger type: %c"</literal></expr></argument>, <argument><expr><name>tgenabled</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*				---------- FUNCTION CACHE ----------					 */</comment>

<comment type="block">/*
 * get_func_name
 *	  returns the name of the function with the given funcid
 *
 * Note: returns a palloc'd copy of the string, or NULL if no such function.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_func_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>functup</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>functup</name><operator>-&gt;</operator><name>proname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_type_name
 *	  returns the name of the type with the given oid
 *
 * Note: returns a palloc'd copy of the string, or NULL if no such type.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_type_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>typtup</name><operator>-&gt;</operator><name>typname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_namespace
 *
 *		Returns the pg_namespace OID associated with a given function.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_func_namespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>functup</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>functup</name><operator>-&gt;</operator><name>pronamespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*				---------- RELATION CACHE ----------					 */</comment>
 
<comment type="block">/*
 * get_func_rettype
 *		Given procedure id, return the function's result type.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_func_rettype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>prorettype</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_agg_transtype
 *		Given aggregate id, return the aggregate transition function's result type.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_agg_transtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>aggid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>aggid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>, <argument><expr><name>aggid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>aggtranstype</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_ordered_agg
 *		Given aggregate id, check if it is an ordered aggregate
 */</comment>
<function><type><name>bool</name></type>
<name>is_agg_ordered</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>aggid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>aggTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>aggkind</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>aggTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>aggid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>, <argument><expr><name>aggid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>aggkind</name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>aggTuple</name></expr></argument>,
										   <argument><expr><name>Anum_pg_aggregate_aggkind</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>AGGKIND_IS_ORDERED_SET</name><argument_list>(<argument><expr><name>aggkind</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * is_agg_partial_capable
 *		Given aggregate id, check if it can be used in 2-phase aggregation.
 *
 * It must have a combine function, and if the transition type is 'internal',
 * also serial/deserial functions.
 */</comment>
<function><type><name>bool</name></type>
<name>is_agg_partial_capable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>aggid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>aggTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_aggregate</name></type> <name>aggform</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>aggTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>,
							   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>aggid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for aggregate %u"</literal></expr></argument>, <argument><expr><name>aggid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>aggform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_aggregate</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggcombinefn</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggtranstype</name></name> <operator>==</operator> <name>INTERNALOID</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>aggform</name><operator>-&gt;</operator><name>aggserialfn</name></name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator>
			<name><name>aggform</name><operator>-&gt;</operator><name>aggdeserialfn</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>aggTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_tablespace
 *
 *		Returns the pg_tablespace OID associated with a given relation.
 *
 * Note: InvalidOid might mean either that we couldn't find the relation,
 * or that it is in the database's default tablespace.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_rel_tablespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>reltablespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * get_func_nargs
 *		Given procedure id, return the number of arguments.
 */</comment>
<function><type><name>int</name></type>
<name>get_func_nargs</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>pronargs</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_signature
 *		Given procedure id, return the function's argument and result types.
 *		(The return value is the result type.)
 *
 * The arguments are returned as a palloc'd array.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_func_signature</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier><modifier>*</modifier></type><name>argtypes</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>nargs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procstruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>procstruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>prorettype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>nargs</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>pronargs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>nargs</name> <operator>==</operator> <name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>dim1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>argtypes</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>*</operator><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>argtypes</name></expr></argument>, <argument><expr><name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><operator>*</operator><name>nargs</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pfree_ptr_array
 * 		Free an array of pointers, after freeing each individual element
 */</comment>
<function><type><name>void</name></type>
<name>pfree_ptr_array</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptrarray</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nelements</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>ptrarray</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nelements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name><name>ptrarray</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>ptrarray</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>ptrarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_output_arg_types
 *		Given procedure id, return the function's output argument types
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_func_output_arg_types</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>argtypes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>argnames</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argmodes</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>l_argtypes</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>numargs</name> <operator>=</operator> <call><name>get_func_arg_info</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argtypes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argnames</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name>argmodes</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree_ptr_array</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>numargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>!=</operator> <name>argtypes</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>argtype</name> <init>= <expr><name><name>argtypes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>argmode</name> <init>= <expr><name><name>argmodes</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>PROARGMODE_INOUT</name> <operator>==</operator> <name>argmode</name> <operator>||</operator> <name>PROARGMODE_OUT</name> <operator>==</operator> <name>argmode</name> <operator>||</operator> <name>PROARGMODE_TABLE</name> <operator>==</operator> <name>argmode</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>l_argtypes</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>l_argtypes</name></expr></argument>, <argument><expr><name>argtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>pfree_ptr_array</name><argument_list>(<argument><expr><name>argnames</name></expr></argument>, <argument><expr><name>numargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>argmodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>l_argtypes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_arg_types
 *		Given procedure id, return all the function's argument types
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_func_arg_types</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>procstruct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name> <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>procstruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>args</name> <operator>=</operator> <operator>&amp;</operator><name><name>procstruct</name><operator>-&gt;</operator><name>proargtypes</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>args</name><operator>-&gt;</operator><name>dim1</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>args</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_variadictype
 *		Given procedure id, return the function's provariadic field.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_func_variadictype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>provariadic</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_retset
 *		Given procedure id, return the function's proretset flag.
 */</comment>
<function><type><name>bool</name></type>
<name>get_func_retset</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proretset</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * func_strict
 *		Given procedure id, return the function's proisstrict flag.
 */</comment>
<function><type><name>bool</name></type>
<name>func_strict</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proisstrict</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * func_volatile
 *		Given procedure id, return the function's provolatile flag.
 */</comment>
<function><type><name>char</name></type>
<name>func_volatile</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>provolatile</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * func_parallel
 *		Given procedure id, return the function's proparallel flag.
 */</comment>
<function><type><name>char</name></type>
<name>func_parallel</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proparallel</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_prokind
 *	   Given procedure id, return the routine kind.
 */</comment>
<function><type><name>char</name></type>
<name>get_func_prokind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>prokind</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_leakproof
 *	   Given procedure id, return the function's leakproof field.
 */</comment>
<function><type><name>bool</name></type>
<name>get_func_leakproof</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>proleakproof</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_func_support
 *
 *		Returns the support function OID associated with a given function,
 *		or InvalidOid if there is none.
 */</comment>
<function><type><name>RegProcedure</name></type>
<name>get_func_support</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>functup</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RegProcedure</name></type> <name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>functup</name><operator>-&gt;</operator><name>prosupport</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>RegProcedure</name><operator>)</operator> <name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * func_data_access
 *		Given procedure id, return the function's data access flag.
 */</comment>
<function><type><name>char</name></type>
<name>func_data_access</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(
		<argument><expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>Anum_pg_proc_prodataaccess</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * func_exec_location
 *		Given procedure id, return the function's proexeclocation field
 */</comment>
<function><type><name>char</name></type>
<name>func_exec_location</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>funcid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for function %u"</literal></expr></argument>, <argument><expr><name>funcid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(
		<argument><expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>, <argument><expr><name>Anum_pg_proc_proexeclocation</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*				---------- RELATION CACHE ----------					 */</comment>

<comment type="block">/*
 * get_relname_relid
 *		Given name and namespace of a relation, look up the OID.
 *
 * Returns InvalidOid if there is no such relation.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_relname_relid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>relname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>relnamespace</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>GetSysCacheOid2</name><argument_list>(<argument><expr><name>RELNAMENSP</name></expr></argument>, <argument><expr><name>Anum_pg_class_oid</name></expr></argument>,
						   <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>relname</name></expr></argument>)</argument_list></call></expr></argument>,
						   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relnamespace</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<comment type="block">/*
 * get_relnatts
 *
 *		Returns the number of attributes for a given relation.
 */</comment>
<function><type><name>int</name></type>
<name>get_relnatts</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relnatts</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidAttrNumber</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * get_rel_name
 *		Returns the name of a given relation.
 *
 * Returns a palloc'd copy of the string, or NULL if no such relation.
 *
 * NOTE: since relation name is not unique, be wary of code that uses this
 * for anything except preparing error messages.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_rel_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>reltup</name><operator>-&gt;</operator><name>relname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_namespace
 *
 *		Returns the pg_namespace OID associated with a given relation.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_rel_namespace</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relnamespace</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_type_id
 *
 *		Returns the pg_type OID associated with a given relation.
 *
 * Note: not all pg_class entries have associated pg_type OIDs; so be
 * careful to check for InvalidOid result.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_rel_type_id</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>reltype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_relkind
 *
 *		Returns the relkind associated with a given relation.
 */</comment>
<function><type><name>char</name></type>
<name>get_rel_relkind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="char">'\0'</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_relispartition
 *
 *		Returns the relispartition flag associated with a given relation.
 */</comment>
<function><type><name>bool</name></type>
<name>get_rel_relispartition</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relispartition</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_rel_persistence
 *
 *		Returns the relpersistence associated with a given relation.
 */</comment>
<function><type><name>char</name></type>
<name>get_rel_persistence</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>reltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>reltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>reltup</name><operator>-&gt;</operator><name>relpersistence</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*				---------- TRANSFORM CACHE ----------						 */</comment>

<function><type><name>Oid</name></type>
<name>get_transform_fromsql</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>langid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>trftypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>trftypes</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>TRFTYPELANG</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>langid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_transform</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>trffromsql</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>funcid</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>Oid</name></type>
<name>get_transform_tosql</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>langid</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>trftypes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>list_member_oid</name><argument_list>(<argument><expr><name>trftypes</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache2</name><argument_list>(<argument><expr><name>TRFTYPELANG</name></expr></argument>, <argument><expr><name>typid</name></expr></argument>, <argument><expr><name>langid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>funcid</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>funcid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_transform</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>trftosql</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>funcid</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*				---------- TYPE CACHE ----------						 */</comment>

<comment type="block">/*
 * get_typisdefined
 *
 *		Given the type OID, determine whether the type is defined
 *		(if not, it's only a shell).
 */</comment>
<function><type><name>bool</name></type>
<name>get_typisdefined</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typlen
 *
 *		Given the type OID, return the length of the type.
 */</comment>
<function><type><name>int16</name></type>
<name>get_typlen</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typbyval
 *
 *		Given the type OID, determine whether the type is returned by value or
 *		not.  Returns true if by value, false if by reference.
 */</comment>
<function><type><name>bool</name></type>
<name>get_typbyval</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typlenbyval
 *
 *		A two-fer: given the type OID, return both typlen and typbyval.
 *
 *		Since both pieces of info are needed to know how to copy a Datum,
 *		many places need both.  Might as well get them with one cache lookup
 *		instead of two.  Also, this routine raises an error instead of
 *		returning a bogus value when given a bad type OID.
 */</comment>
<function><type><name>void</name></type>
<name>get_typlenbyval</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typbyval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typtup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typlen</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typbyval</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typlenbyvalalign
 *
 *		A three-fer: given the type OID, return typlen, typbyval, typalign.
 */</comment>
<function><type><name>void</name></type>
<name>get_typlenbyvalalign</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typbyval</name></decl></parameter>,
					 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typtup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typlen</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typbyval</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typalign</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeIOParam
 *		Given a pg_type row, select the type OID to pass to I/O functions
 *
 * Formerly, all I/O functions were passed pg_type.typelem as their second
 * parameter, but we now have a more complex rule about what to pass.
 * This knowledge is intended to be centralized here --- direct references
 * to typelem elsewhere in the code are wrong, if they are associated with
 * I/O calls and not with actual subscripting operations!  (But see
 * bootstrap.c's boot_get_type_io_data() if you need to change this.)
 *
 * As of PostgreSQL 8.1, output functions receive only the value itself
 * and not any auxiliary parameters, so the name of this routine is now
 * a bit of a misnomer ... it should be getTypeInputParam.
 */</comment>
<function><type><name>Oid</name></type>
<name>getTypeIOParam</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>typeTuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeStruct</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Array types get their typelem as parameter; everybody else gets their
	 * own type OID as parameter.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typelem</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>typeStruct</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name><name>typeStruct</name><operator>-&gt;</operator><name>oid</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_type_io_data
 *
 *		A six-fer:	given the type OID, return typlen, typbyval, typalign,
 *					typdelim, typioparam, and IO function OID. The IO function
 *					returned is controlled by IOFuncSelector
 */</comment>
<function><type><name>void</name></type>
<name>get_type_io_data</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>,
				 <parameter><decl><type><name>IOFuncSelector</name></type> <name>which_func</name></decl></parameter>,
				 <parameter><decl><type><name>int16</name> <modifier>*</modifier></type><name>typlen</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typbyval</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typalign</name></decl></parameter>,
				 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typdelim</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typioparam</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>func</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeStruct</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * In bootstrap mode, pass it off to bootstrap.c.  This hack allows us to
	 * use array_in and array_out during bootstrap.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typinput</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>typoutput</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>boot_get_type_io_data</name><argument_list>(<argument><expr><name>typid</name></expr></argument>,
							  <argument><expr><name>typlen</name></expr></argument>,
							  <argument><expr><name>typbyval</name></expr></argument>,
							  <argument><expr><name>typalign</name></expr></argument>,
							  <argument><expr><name>typdelim</name></expr></argument>,
							  <argument><expr><name>typioparam</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>typinput</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>typoutput</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>which_func</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>IOFunc_input</name></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>typinput</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IOFunc_output</name></expr>:</case>
				<expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name>typoutput</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"binary I/O not supported during bootstrap"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typeStruct</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>typlen</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typlen</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typbyval</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typbyval</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typalign</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typdelim</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typdelim</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typioparam</name> <operator>=</operator> <call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>which_func</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>IOFunc_input</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typinput</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IOFunc_output</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typoutput</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IOFunc_receive</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typreceive</name></name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>IOFunc_send</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>func</name> <operator>=</operator> <name><name>typeStruct</name><operator>-&gt;</operator><name>typsend</name></name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<function><type><name>char</name></type>
<name>get_typalign</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typalign</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="char">'i'</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><name>char</name></type>
<name>get_typstorage</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typstorage</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="char">'p'</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typdefault
 *	  Given a type OID, return the type's default value, if any.
 *
 *	  The result is a palloc'd expression node tree, or NULL if there
 *	  is no defined default for the datatype.
 *
 * NB: caller should be prepared to coerce result to correct datatype;
 * the returned expression tree might produce something of the wrong type.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>get_typdefault</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isNull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>type</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * typdefault and typdefaultbin are potentially null, so don't try to
	 * access 'em as struct fields. Must do it the hard way with
	 * SysCacheGetAttr.
	 */</comment>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
							<argument><expr><name>typeTuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_type_typdefaultbin</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We have an expression default */</comment>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Perhaps we have a plain literal default */</comment>
		<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>,
								<argument><expr><name>typeTuple</name></expr></argument>,
								<argument><expr><name>Anum_pg_type_typdefault</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>isNull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isNull</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>strDefaultVal</name></decl>;</decl_stmt>

			<comment type="block">/* Convert text datum to C string */</comment>
			<expr_stmt><expr><name>strDefaultVal</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Convert C string to a value of the given type */</comment>
			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>OidInputFunctionCall</name><argument_list>(<argument><expr><name><name>type</name><operator>-&gt;</operator><name>typinput</name></name></expr></argument>, <argument><expr><name>strDefaultVal</name></expr></argument>,
										 <argument><expr><call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Build a Const node containing the value */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name>typid</name></expr></argument>,
									  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>type</name><operator>-&gt;</operator><name>typcollation</name></name></expr></argument>,
									  <argument><expr><name><name>type</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
									  <argument><expr><name>datum</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>,
									  <argument><expr><name><name>type</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>strDefaultVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No default */</comment>
			<expr_stmt><expr><name>expr</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>expr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getBaseType
 *		If the given type is a domain, return its base type;
 *		otherwise return the type's own OID.
 */</comment>
<function><type><name>Oid</name></type>
<name>getBaseType</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>getBaseTypeAndTypmod</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getBaseTypeAndTypmod
 *		If the given type is a domain, return its base type and typmod;
 *		otherwise return the type's own OID, and leave *typmod unchanged.
 *
 * Note that the "applied typmod" should be -1 for every domain level
 * above the bottommost; therefore, if the passed-in typid is indeed
 * a domain, *typmod should be -1.
 */</comment>
<function><type><name>Oid</name></type>
<name>getBaseTypeAndTypmod</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We loop to find the bottom base type in a stack of domains.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Not a domain, so done */</comment>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>typmod</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>typid</name> <operator>=</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typbasetype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>typmod</name> <operator>=</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typtypmod</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>typid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_typavgwidth
 *
 *	  Given a type OID and a typmod value (pass -1 if typmod is unknown),
 *	  estimate the average width of values of the type.  This is used by
 *	  the planner, which doesn't require absolutely correct results;
 *	  it's OK (and expected) to guess if we don't know for sure.
 */</comment>
<function><type><name>int32</name></type>
<name>get_typavgwidth</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>typmod</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>typlen</name> <init>= <expr><call><name>get_typlen</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>maxwidth</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Easy if it's a fixed-width type
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>typlen</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * type_maximum_size knows the encoding of typmod for some datatypes;
	 * don't duplicate that knowledge here.
	 */</comment>
	<expr_stmt><expr><name>maxwidth</name> <operator>=</operator> <call><name>type_maximum_size</name><argument_list>(<argument><expr><name>typid</name></expr></argument>, <argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>maxwidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For BPCHAR, the max width is also the only width.  Otherwise we
		 * need to guess about the typical data width given the max. A sliding
		 * scale for percentage of max width seems reasonable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>BPCHAROID</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>maxwidth</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>maxwidth</name> <operator>&lt;=</operator> <literal type="number">32</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>maxwidth</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* assume full width */</comment>
		<if_stmt><if>if <condition>(<expr><name>maxwidth</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">32</literal> <operator>+</operator> <operator>(</operator><name>maxwidth</name> <operator>-</operator> <literal type="number">32</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* assume 50% */</comment>

		<comment type="block">/*
		 * Beyond 1000, assume we're looking at something like
		 * "varchar(10000)" where the limit isn't actually reached often, and
		 * use a fixed estimate.
		 */</comment>
		<return>return <expr><literal type="number">32</literal> <operator>+</operator> <operator>(</operator><literal type="number">1000</literal> <operator>-</operator> <literal type="number">32</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Oops, we have no idea ... wild guess time.
	 */</comment>
	<return>return <expr><literal type="number">32</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_typtype
 *
 *		Given the type OID, find if it is a basic type, a complex type, etc.
 *		It returns the null char if the cache lookup fails...
 */</comment>
<function><type><name>char</name></type>
<name>get_typtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="char">'\0'</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * type_is_rowtype
 *
 *		Convenience function to determine whether a type OID represents
 *		a "rowtype" type --- either RECORD or a named composite type
 *		(including a domain over a named composite type).
 */</comment>
<function><type><name>bool</name></type>
<name>type_is_rowtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>typid</name> <operator>==</operator> <name>RECORDOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* easy case */</comment>
	<switch>switch <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TYPTYPE_COMPOSITE</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<case>case <expr><name>TYPTYPE_DOMAIN</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>get_typtype</name><argument_list>(<argument><expr><call><name>getBaseType</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_COMPOSITE</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * type_is_enum
 *	  Returns true if the given type is an enum type.
 */</comment>
<function><type><name>bool</name></type>
<name>type_is_enum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>get_typtype</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_ENUM</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * type_is_range
 *	  Returns true if the given type is a range type.
 */</comment>
<function><type><name>bool</name></type>
<name>type_is_range</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>get_typtype</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TYPTYPE_RANGE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_type_category_preferred
 *
 *		Given the type OID, fetch its category and preferred-type status.
 *		Throws error on failure.
 */</comment>
<function><type><name>void</name></type>
<name>get_type_category_preferred</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>typcategory</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typispreferred</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>typtup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typcategory</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typcategory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typispreferred</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typispreferred</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typ_typrelid
 *
 *		Given the type OID, get the typrelid (InvalidOid if not a complex
 *		type).
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typ_typrelid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_element_type
 *
 *		Given the type OID, get the typelem (InvalidOid if not an array type).
 *
 * NB: this only considers varlena arrays to be true arrays; InvalidOid is
 * returned if the input is a fixed-length array type.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_element_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>typtup</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_array_type
 *
 *		Given the type OID, get the corresponding "true" array type.
 *		Returns InvalidOid if no array type can be found.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_array_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>typarray</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_promoted_array_type
 *
 *		The "promoted" type is what you'd get from an ARRAY(SELECT ...)
 *		construct, that is, either the corresponding "true" array type
 *		if the input is a scalar type that has such an array type,
 *		or the same type if the input is already a "true" array type.
 *		Returns InvalidOid if neither rule is satisfied.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_promoted_array_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>array_type</name> <init>= <expr><call><name>get_array_type</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>array_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>array_type</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>typid</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_base_element_type
 *		Given the type OID, get the typelem, looking "through" any domain
 *		to its underlying array type.
 *
 * This is equivalent to get_element_type(getBaseType(typid)), but avoids
 * an extra cache lookup.  Note that it fails to provide any information
 * about the typmod of the array.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_base_element_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We loop to find the bottom base type in a stack of domains.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typTup</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>typTup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typtype</name></name> <operator>!=</operator> <name>TYPTYPE_DOMAIN</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Not a domain, so stop descending */</comment>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

			<comment type="block">/* This test must match get_element_type */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>typTup</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typelem</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>typid</name> <operator>=</operator> <name><name>typTup</name><operator>-&gt;</operator><name>typbasetype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Like get_element_type, silently return InvalidOid for bogus input */</comment>
	<return>return <expr><name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeInputInfo
 *
 *		Get info needed for converting values of a type to internal form
 */</comment>
<function><type><name>void</name></type>
<name>getTypeInputInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typInput</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typIOParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>pt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is only a shell"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>typinput</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no input function available for type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>typInput</name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>typinput</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typIOParam</name> <operator>=</operator> <call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeOutputInfo
 *
 *		Get info needed for printing values of a type
 */</comment>
<function><type><name>void</name></type>
<name>getTypeOutputInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typOutput</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typIsVarlena</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>pt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is only a shell"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>typoutput</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no output function available for type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>typOutput</name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>typoutput</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typIsVarlena</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typbyval</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeBinaryInputInfo
 *
 *		Get info needed for binary input of values of a type
 */</comment>
<function><type><name>void</name></type>
<name>getTypeBinaryInputInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typReceive</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typIOParam</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>pt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is only a shell"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>typreceive</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no binary input function available for type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>typReceive</name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>typreceive</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typIOParam</name> <operator>=</operator> <call><name>getTypeIOParam</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * getTypeBinaryOutputInfo
 *
 *		Get info needed for binary output of values of a type
 */</comment>
<function><type><name>void</name></type>
<name>getTypeBinaryOutputInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>typSend</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>typIsVarlena</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>pt</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>pt</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typisdefined</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"type %s is only a shell"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>pt</name><operator>-&gt;</operator><name>typsend</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_FUNCTION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no binary output function available for type %s"</literal></expr></argument>,
						<argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>typSend</name> <operator>=</operator> <name><name>pt</name><operator>-&gt;</operator><name>typsend</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>typIsVarlena</name> <operator>=</operator> <operator>(</operator><operator>!</operator><name><name>pt</name><operator>-&gt;</operator><name>typbyval</name></name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>pt</name><operator>-&gt;</operator><name>typlen</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_typmodin
 *
 *		Given the type OID, return the type's typmodin procedure, if any.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typmodin</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typmodin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
<comment type="block">/*
 * get_typmodout
 *
 *		Given the type OID, return the type's typmodout procedure, if any.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typmodout</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typmodout</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* NOT_USED */</comment>

<comment type="block">/*
 * get_typcollation
 *
 *		Given the type OID, return the type's typcollation attribute.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_typcollation</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typtup</name> <init>= <expr><operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>typtup</name><operator>-&gt;</operator><name>typcollation</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * type_is_collatable
 *
 *		Return whether the type cares about collations
 */</comment>
<function><type><name>bool</name></type>
<name>type_is_collatable</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_typcollation</name><argument_list>(<argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*				---------- STATISTICS CACHE ----------					 */</comment>

<comment type="block">/*
 * get_attavgwidth
 *
 *	  Given the table and attribute number of a column, get the average
 *	  width of entries in the column.  Return zero if no data available.
 *
 * Currently this is only consulted for individual tables, not for inheritance
 * trees, so we don't need an "inh" parameter.
 *
 * Calling a hook at this point looks somewhat strange, but is required
 * because the optimizer calls this function without any other way for
 * plug-ins to control the result.
 */</comment>
<function><type><name>int32</name></type>
<name>get_attavgwidth</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>stawidth</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>get_attavgwidth_hook</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stawidth</name> <operator>=</operator> <call>(<modifier>*</modifier><name>get_attavgwidth_hook</name>) <argument_list>(<argument><expr><name>relid</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>stawidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>stawidth</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
						 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stawidth</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>stawidth</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>stawidth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>stawidth</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_attnullfrac
 *
 *	  Given the table and attribute number of a column, get the null
 *	  fraction of entries in the column.  Return zero if no data.
 */</comment>
<function><type><name>float4</name></type>
<name>get_attnullfrac</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>stanullfrac</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stanullfrac</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>stanullfrac</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>stanullfrac</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>stanullfrac</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><literal type="number">0.0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_attstatsslot
 *
 *		Extract the contents of a "slot" of a pg_statistic tuple.
 *		Returns true if requested slot type was found, else false.
 *
 * Unlike other routines in this file, this takes a pointer to an
 * already-looked-up tuple in the pg_statistic cache.  We do this since
 * most callers will want to extract more than one value from the cache
 * entry, and we don't want to repeat the cache lookup unnecessarily.
 * Also, this API allows this routine to be used with statistics tuples
 * that have been provided by a stats hook and didn't really come from
 * pg_statistic.
 *
 * sslot: pointer to output area (typically, a local variable in the caller).
 * statstuple: pg_statistic tuple to be examined.
 * reqkind: STAKIND code for desired statistics slot kind.
 * reqop: STAOP value wanted, or InvalidOid if don't care.
 * flags: bitmask of ATTSTATSSLOT_VALUES and/or ATTSTATSSLOT_NUMBERS.
 *
 * If a matching slot is found, true is returned, and *sslot is filled thus:
 * staop: receives the actual STAOP value.
 * stacoll: receives the actual STACOLL value.
 * valuetype: receives actual datatype of the elements of stavalues.
 * values: receives pointer to an array of the slot's stavalues.
 * nvalues: receives number of stavalues.
 * numbers: receives pointer to an array of the slot's stanumbers (as float4).
 * nnumbers: receives number of stanumbers.
 *
 * valuetype/values/nvalues are InvalidOid/NULL/0 if ATTSTATSSLOT_VALUES
 * wasn't specified.  Likewise, numbers/nnumbers are NULL/0 if
 * ATTSTATSSLOT_NUMBERS wasn't specified.
 *
 * If no matching slot is found, false is returned, and *sslot is zeroed.
 *
 * Note that the current API doesn't allow for searching for a slot with
 * a particular collation.  If we ever actually support recording more than
 * one collation, we'll have to extend the API, but for now simple is good.
 *
 * The data referred to by the fields of sslot is locally palloc'd and
 * is independent of the original pg_statistic tuple.  When the caller
 * is done with it, call free_attstatsslot to release the palloc'd data.
 *
 * If it's desirable to call free_attstatsslot when get_attstatsslot might
 * not have been called, memset'ing sslot to zeroes will allow that.
 */</comment>
<function><type><name>bool</name></type>
<name>get_attstatsslot</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>statstuple</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>reqkind</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>reqop</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name> <init>= <expr><operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>statstuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>statarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>arrayelemtype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>narrayelem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>typeTuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_type</name></type> <name>typeForm</name></decl>;</decl_stmt>

	<comment type="block">/* initialize *sslot properly */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>sslot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AttStatsSlot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>STATISTIC_NUM_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>stakind1</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>==</operator> <name>reqkind</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>reqop</name> <operator>==</operator> <name>InvalidOid</name> <operator>||</operator> <operator>(</operator><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>staop1</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index> <operator>==</operator> <name>reqop</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>STATISTIC_NUM_SLOTS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* not there */</comment>

	<expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>staop</name></name> <operator>=</operator> <operator>(</operator><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>staop1</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>stacoll</name></name> <operator>=</operator> <operator>(</operator><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>stacoll1</name></name><operator>)</operator><index>[<expr><name>i</name></expr>]</index></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX Hopefully-temporary hack: if stacoll isn't set, inject the default
	 * collation.  This won't matter for non-collation-aware datatypes.  For
	 * those that are, this covers cases where stacoll has not been set.  In
	 * the short term we need this because some code paths involving type NAME
	 * do not pass any collation to prefix_selectivity and related functions.
	 * Even when that's been fixed, it's likely that some add-on typanalyze
	 * functions won't get the word right away about filling stacoll during
	 * ANALYZE, so we'll probably need this for awhile.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>-&gt;</operator><name>stacoll</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>stacoll</name></name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ATTSTATSSLOT_VALUES</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>, <argument><expr><name>statstuple</name></expr></argument>,
							  <argument><expr><name>Anum_pg_statistic_stavalues1</name> <operator>+</operator> <name>i</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stavalues is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Detoast the array if needed, and in any case make a copy that's
		 * under control of this AttStatsSlot.
		 */</comment>
		<expr_stmt><expr><name>statarray</name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Extract the actual array element type, and pass it back in case the
		 * caller needs it.
		 */</comment>
		<expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>valuetype</name></name> <operator>=</operator> <name>arrayelemtype</name> <operator>=</operator> <call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Need info about element type */</comment>
		<expr_stmt><expr><name>typeTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>arrayelemtype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for type %u"</literal></expr></argument>, <argument><expr><name>arrayelemtype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>typeForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_type</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Deconstruct array into Datum elements; NULLs not expected */</comment>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>,
						  <argument><expr><name>arrayelemtype</name></expr></argument>,
						  <argument><expr><name><name>typeForm</name><operator>-&gt;</operator><name>typlen</name></name></expr></argument>,
						  <argument><expr><name><name>typeForm</name><operator>-&gt;</operator><name>typbyval</name></name></expr></argument>,
						  <argument><expr><name><name>typeForm</name><operator>-&gt;</operator><name>typalign</name></name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>sslot</name><operator>-&gt;</operator><name>values</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>sslot</name><operator>-&gt;</operator><name>nvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If the element type is pass-by-reference, we now have a bunch of
		 * Datums that are pointers into the statarray, so we need to keep
		 * that until free_attstatsslot.  Otherwise, all the useful info is in
		 * sslot-&gt;values[], so we can free the array object immediately.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>typeForm</name><operator>-&gt;</operator><name>typbyval</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>values_arr</name></name> <operator>=</operator> <name>statarray</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>typeTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>, <argument><expr><name>statstuple</name></expr></argument>,
							  <argument><expr><name>Anum_pg_statistic_stanumbers1</name> <operator>+</operator> <name>i</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stanumbers is null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Detoast the array if needed, and in any case make a copy that's
		 * under control of this AttStatsSlot.
		 */</comment>
		<expr_stmt><expr><name>statarray</name> <operator>=</operator> <call><name>DatumGetArrayTypePCopy</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>narrayelem</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal> <operator>||</operator> <name>narrayelem</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator>
			<call><name>ARR_HASNULL</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>FLOAT4OID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"stanumbers is not a 1-D float4 array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Give caller a pointer directly into the statarray */</comment>
		<expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>numbers</name></name> <operator>=</operator> <operator>(</operator><name>float4</name> <operator>*</operator><operator>)</operator> <call><name>ARR_DATA_PTR</name><argument_list>(<argument><expr><name>statarray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>nnumbers</name></name> <operator>=</operator> <name>narrayelem</name></expr>;</expr_stmt>

		<comment type="block">/* We'll free the statarray in free_attstatsslot */</comment>
		<expr_stmt><expr><name><name>sslot</name><operator>-&gt;</operator><name>numbers_arr</name></name> <operator>=</operator> <name>statarray</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * free_attstatsslot
 *		Free data allocated by get_attstatsslot
 */</comment>
<function><type><name>void</name></type>
<name>free_attstatsslot</name><parameter_list>(<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* The values[] array was separately palloc'd by deconstruct_array */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>-&gt;</operator><name>values</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sslot</name><operator>-&gt;</operator><name>values</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* The numbers[] array points into numbers_arr, do not pfree it */</comment>
	<comment type="block">/* Free the detoasted array objects, if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>-&gt;</operator><name>values_arr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sslot</name><operator>-&gt;</operator><name>values_arr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>-&gt;</operator><name>numbers_arr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>sslot</name><operator>-&gt;</operator><name>numbers_arr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_att_stats
 *		Get attribute statistics. Return a copy of the HeapTuple object, or NULL
 *		if no stats found for attribute
 * 
 */</comment>
<function><type><name>HeapTuple</name></type>
<name>get_att_stats</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>, <parameter><decl><type><name>AttrNumber</name></type> <name>attrnum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type> <name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is used by ORCA, and ORCA doesn't know that there are two different kinds of stats,
	 * the inherited stats and the non-inherited. Use the inherited stats, i.e. stats that
	 * cover all the child tables, too, if available.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SearchSysCacheCopy3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attrnum</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>SearchSysCacheCopy3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
									 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attrnum</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*				---------- PG_NAMESPACE CACHE ----------				 */</comment>

<comment type="block">/*
 * get_namespace_name
 *		Returns the name of a given namespace
 *
 * Returns a palloc'd copy of the string, or NULL if no such namespace.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_namespace_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>NAMESPACEOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_namespace</name></type> <name>nsptup</name> <init>= <expr><operator>(</operator><name>Form_pg_namespace</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>nsptup</name><operator>-&gt;</operator><name>nspname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_namespace_name_or_temp
 *		As above, but if it is this backend's temporary namespace, return
 *		"pg_temp" instead.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_namespace_name_or_temp</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>nspid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>isTempNamespace</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"pg_temp"</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name>nspid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*				---------- PG_RANGE CACHE ----------				 */</comment>

<comment type="block">/*
 * get_range_subtype
 *		Returns the subtype of a given range type
 *
 * Returns InvalidOid if the type is not a range type.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_range_subtype</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>rangeOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RANGETYPE</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>rangeOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_range</name></type> <name>rngtup</name> <init>= <expr><operator>(</operator><name>Form_pg_range</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>rngtup</name><operator>-&gt;</operator><name>rngsubtype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * relation_exists
 *	  Is there a relation with the given oid
 */</comment>
<function><type><name>bool</name></type>
<name>relation_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchSysCacheExists</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * index_exists
 *	  Is there an index with the given oid
 */</comment>
<function><type><name>bool</name></type>
<name>index_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchSysCacheExists</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * type_exists
 *	  Is there a type with the given oid
 */</comment>
<function><type><name>bool</name></type>
<name>type_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchSysCacheExists</name><argument_list>(<argument><expr><name>TYPEOID</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * operator_exists
 *	  Is there an operator with the given oid
 */</comment>
<function><type><name>bool</name></type>
<name>operator_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchSysCacheExists</name><argument_list>(<argument><expr><name>OPEROID</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * function_exists
 *	  Is there a function with the given oid
 */</comment>
<function><type><name>bool</name></type>
<name>function_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchSysCacheExists</name><argument_list>(<argument><expr><name>PROCOID</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * aggregate_exists
 *	  Is there an aggregate with the given oid
 */</comment>
<function><type><name>bool</name></type>
<name>aggregate_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchSysCacheExists</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><name>oid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="line">// Get oid of aggregate with given name and argument type</comment>
<function><type><name>Oid</name></type>
<name>get_aggregate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>aggname</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oidType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oidResult</name></decl>;</decl_stmt>

	<comment type="line">// lookup pg_proc for functions with the given name and arg type</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>PROCNAMEARGSNSP</name></expr></argument>,
								  <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>aggname</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>oidResult</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>htup</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_proc</name></type> <name>proctuple</name> <init>= <expr><operator>(</operator><name>Form_pg_proc</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> <name>oidProc</name> <init>= <expr><name><name>proctuple</name><operator>-&gt;</operator><name>oid</name></name></expr></init></decl>;</decl_stmt>

		<comment type="line">// skip functions with the wrong number of type of arguments</comment>
		<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <name><name>proctuple</name><operator>-&gt;</operator><name>pronargs</name></name> <operator>||</operator> <name>oidType</name> <operator>!=</operator> <name><name>proctuple</name><operator>-&gt;</operator><name>proargtypes</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>SearchSysCacheExists</name><argument_list>(<argument><expr><name>AGGFNOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oidProc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>oidResult</name> <operator>=</operator> <name>oidProc</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>oidResult</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * trigger_exists
 *	  Is there a trigger with the given oid
 */</comment>
<function><type><name>bool</name></type>
<name>trigger_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type>	<name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>, <argument><expr><name>Anum_pg_trigger_oid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TriggerRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>TriggerOidIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_relation_keys
 *	  Return a list of relation keys
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_relation_keys</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>keys</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<comment type="line">// lookup unique constraints for relation from the catalog table</comment>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>skey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Relation</name></type> <name>rel</name> <init>= <expr><call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>skey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>, <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>skey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>contuple</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// skip non-unique constraints</comment>
		<if_stmt><if>if <condition>(<expr><name>CONSTRAINT_UNIQUE</name> <operator>!=</operator> <name><name>contuple</name><operator>-&gt;</operator><name>contype</name></name> <operator>&amp;&amp;</operator>
			<name>CONSTRAINT_PRIMARY</name> <operator>!=</operator> <name><name>contuple</name><operator>-&gt;</operator><name>contype</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
			
		<comment type="line">// store key set in an array</comment>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		
		<decl_stmt><decl><type><name>bool</name></type> <name>null</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type> <name>dat</name> <init>= 
				<expr><call><name>heap_getattr</name><argument_list>(<argument><expr><name>htup</name></expr></argument>, <argument><expr><name>Anum_pg_constraint_conkey</name></expr></argument>, <argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>null</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		
		<decl_stmt><decl><type><name>Datum</name> <modifier>*</modifier></type><name>dats</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>numKeys</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="line">// extract key elements</comment>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>dat</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>INT2OID</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="char">'s'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>dats</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numKeys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numKeys</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int16</name></type> <name>key_elem</name> <init>=  <expr><call><name>DatumGetInt16</name><argument_list>(<argument><expr><name><name>dats</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>key</name> <operator>=</operator> <call><name>lappend_int</name><argument_list>(<argument><expr><name>key</name></expr></argument>, <argument><expr><name>key_elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
		
		<expr_stmt><expr><name>keys</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>keys</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>keys</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * check_constraint_exists
 *	  Is there a check constraint with the given oid
 */</comment>
<function><type><name>bool</name></type>
<name>check_constraint_exists</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oidCheckconstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>SearchSysCacheExists1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oidCheckconstraint</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_check_constraint_relid
 *		Given check constraint id, return the check constraint's relation oid
 */</comment>
<function><type><name>Oid</name></type>
<name>get_check_constraint_relid</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oidCheckconstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oidCheckconstraint</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>contup</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>contup</name><operator>-&gt;</operator><name>conrelid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * get_check_constraint_oids
 *	 Extract all check constraint oid for a given relation.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_check_constraint_oids</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oidRel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>plConstraints</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>conrel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * lookup constraints for relation from the catalog table
	 *
	 * SELECT * FROM pg_constraint WHERE conrelid = :1
	 */</comment>
	<expr_stmt><expr><name>conrel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ConstraintRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_constraint_conrelid</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oidRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>ConstraintRelidTypidNameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>contuple</name> <init>= <expr><operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="line">// only consider check constraints</comment>
		<if_stmt><if>if <condition>(<expr><name>CONSTRAINT_CHECK</name> <operator>!=</operator> <name><name>contuple</name><operator>-&gt;</operator><name>contype</name></name> <operator>||</operator> <operator>!</operator><name><name>contuple</name><operator>-&gt;</operator><name>convalidated</name></name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>plConstraints</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>plConstraints</name></expr></argument>, <argument><expr><name><name>contuple</name><operator>-&gt;</operator><name>oid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>conrel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>plConstraints</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_check_constraint_name
 *        returns the name of the check constraint with the given oidConstraint.
 *
 * Note: returns a palloc'd copy of the string, or NULL if no such constraint.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>get_check_constraint_name</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oidCheckconstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>get_constraint_name</name><argument_list>(<argument><expr><name>oidCheckconstraint</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_check_constraint_expr_tree
 *        returns the expression node tree representing the check constraint
 *        with the given oidConstraint.
 *
 * Note: returns a palloc'd expression node tree, or NULL if no such constraint.
 */</comment>
<function><type><name>Node</name> <modifier>*</modifier></type>
<name>get_check_constraint_expr_tree</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oidCheckconstraint</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
						<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oidCheckconstraint</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>conbin</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>conbin</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><name>tp</name></expr></argument>,
								 <argument><expr><name>Anum_pg_constraint_conbin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>stringToNode</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>conbin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_cast_func
 *        finds the cast function between the given source and destination type,
 *        and records its oid and properties in the output parameters.
 *        Returns true if a cast exists, false otherwise.
 */</comment>
<function><type><name>bool</name></type>
<name>get_cast_func</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oidSrc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oidDest</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>is_binary_coercible</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>oidCastFunc</name></decl></parameter>, <parameter><decl><type><name>CoercionPathType</name> <modifier>*</modifier></type><name>pathtype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>oidSrc</name></expr></argument>, <argument><expr><name>oidDest</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>is_binary_coercible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>oidCastFunc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><operator>*</operator><name>is_binary_coercible</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>pathtype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>oidDest</name></expr></argument>, <argument><expr><name>oidSrc</name></expr></argument>, <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>, <argument><expr><name>oidCastFunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pathtype</name> <operator>==</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>is_binary_coercible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_NONE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_comparison_type
 *      Retrieve comparison type  
 */</comment>
<function><type><name>CmpType</name></type>
<name>get_comparison_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oidOp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OpBtreeInterpretation</name> <modifier>*</modifier></type><name>opBti</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opBtis</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opBtis</name> <operator>=</operator> <call><name>get_op_btree_interpretation</name><argument_list>(<argument><expr><name>oidOp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>opBtis</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* The operator does not belong to any B-tree operator family */</comment>
		<return>return <expr><name>CmptOther</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * XXX: Arbitrarily use the first found operator family. Usually
	 * there is only one, but e.g. if someone has created a reverse ordering
	 * family that sorts in descending order, it is ambiguous whether a
	 * &lt; operator stands for the less than operator of the ascending opfamily,
	 * or the greater than operator for the descending opfamily.
	 */</comment>
	<expr_stmt><expr><name>opBti</name> <operator>=</operator> <operator>(</operator><name>OpBtreeInterpretation</name><operator>*</operator><operator>)</operator><call><name>linitial</name><argument_list>(<argument><expr><name>opBtis</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch<condition>(<expr><name><name>opBti</name><operator>-&gt;</operator><name>strategy</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
			<return>return <expr><name>CmptLT</name></expr>;</return>
		<case>case <expr><name>BTLessEqualStrategyNumber</name></expr>:</case>
			<return>return <expr><name>CmptLEq</name></expr>;</return>
		<case>case <expr><name>BTEqualStrategyNumber</name></expr>:</case>
			<return>return <expr><name>CmptEq</name></expr>;</return>
		<case>case <expr><name>BTGreaterEqualStrategyNumber</name></expr>:</case>
			<return>return <expr><name>CmptGEq</name></expr>;</return>
		<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
			<return>return <expr><name>CmptGT</name></expr>;</return>
		<case>case <expr><name>ROWCOMPARE_NE</name></expr>:</case>
			<return>return <expr><name>CmptNEq</name></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown B-tree strategy: %d"</literal></expr></argument>, <argument><expr><name><name>opBti</name><operator>-&gt;</operator><name>strategy</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>CmptOther</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * get_comparison_operator
 *      Retrieve comparison operator between given types  
 */</comment>
<function><type><name>Oid</name></type>
<name>get_comparison_operator</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oidLeft</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>oidRight</name></decl></parameter>, <parameter><decl><type><name>CmpType</name></type> <name>cmpt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>		<name>opstrat</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>ht</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>result</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pg_amop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankey</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>

	<switch>switch<condition>(<expr><name>cmpt</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CmptLT</name></expr>:</case>
			<expr_stmt><expr><name>opstrat</name> <operator>=</operator> <name>BTLessStrategyNumber</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CmptLEq</name></expr>:</case>
			<expr_stmt><expr><name>opstrat</name> <operator>=</operator> <name>BTLessEqualStrategyNumber</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CmptEq</name></expr>:</case>
			<expr_stmt><expr><name>opstrat</name> <operator>=</operator> <name>BTEqualStrategyNumber</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CmptGEq</name></expr>:</case>
			<expr_stmt><expr><name>opstrat</name> <operator>=</operator> <name>BTGreaterEqualStrategyNumber</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>CmptGT</name></expr>:</case>
			<expr_stmt><expr><name>opstrat</name> <operator>=</operator> <name>BTGreaterStrategyNumber</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<return>return <expr><name>InvalidOid</name></expr>;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><name>pg_amop</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>AccessMethodOperatorRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SELECT * FROM pg_amop
	 * WHERE amoplefttype = :1 and amoprighttype = :2 and amopmethod = :3 and amopstrategy = :4
	 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_amop_amoplefttype</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oidLeft</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_amop_amoprighttype</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oidRight</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_amop_amopmethod</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>BTREE_AM_OID</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankey</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>,
				<argument><expr><name>Anum_pg_amop_amopstrategy</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_INT2EQ</name></expr></argument>,
				<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>opstrat</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX: There is no index for this, so this is slow! */</comment>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>pg_amop</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* XXX: There can be multiple results. Arbitrarily use the first one */</comment>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>ht</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amoptup</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>ht</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>amoptup</name><operator>-&gt;</operator><name>amopopr</name></name></expr>;</expr_stmt>
		<break>break;</break>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>pg_amop</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * has_subclass_slow
 *
 * Performs the exhaustive check whether a relation has a subclass. This is 
 * different from has_subclass(), in that the latter can return true if a relation.
 * *might* have a subclass. See comments in has_subclass() for more details.
 */</comment>
<function><type><name>bool</name></type>
<name>has_subclass_slow</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ScanKeyData</name></type>	<name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_subclass</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>InheritsRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>, <argument><expr><name>Anum_pg_inherits_inhparent</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
				<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relationId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* no index on inhparent */</comment>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_operator_opfamilies
 *		Get the oid of operator families the given operator belongs to
 *
 * ORCA calls this.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_operator_opfamilies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opfam_oids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CatCList</name>   <modifier>*</modifier></type><name>catlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>opfam_oids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>

	<comment type="block">/* SELECT * FROM pg_amop WHERE amopopr = :1 */</comment>
	<expr_stmt><expr><name>catlist</name> <operator>=</operator> <call><name>SearchSysCacheList1</name><argument_list>(<argument><expr><name>AMOPOPID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>opno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>catlist</name><operator>-&gt;</operator><name>n_members</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name> <init>= <expr><operator>&amp;</operator><name><name>catlist</name><operator>-&gt;</operator><name>members</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>tuple</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_amop</name></type> <name>amop_tuple</name> <init>= <expr><operator>(</operator><name>Form_pg_amop</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>opfam_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opfam_oids</name></expr></argument>, <argument><expr><name><name>amop_tuple</name><operator>-&gt;</operator><name>amopfamily</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCacheList</name><argument_list>(<argument><expr><name>catlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>opfam_oids</name></expr>;</return>
</block_content>}</block></function> 

<comment type="block">/*
 * get_index_opfamilies
 *		Get the oid of operator families for the index keys
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_index_opfamilies</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oidIndex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>htup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opfam_oids</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indnkeyatts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>indclassDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>htup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>,
						   <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>oidIndex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Index %u not found"</literal></expr></argument>, <argument><expr><name>oidIndex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <comment type="block">/*
     * use SysCacheGetAttr() to retrieve number of index attributes, and the oid
	 * vector of indclass
     */</comment>
	<expr_stmt><expr><name>indnkeyatts</name> <operator>=</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>, <argument><expr><name>Anum_pg_index_indnkeyatts</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>indclassDatum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>htup</name></expr></argument>, <argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
    <expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>indclassDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opfam_oids</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>indnkeyatts</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>oidOpClass</name> <init>= <expr><name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type> 		<name>opfam</name> <init>= <expr><call><name>get_opclass_family</name><argument_list>(<argument><expr><name>oidOpClass</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>opfam_oids</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>opfam_oids</name></expr></argument>, <argument><expr><name>opfam</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>htup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>opfam_oids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  relation_policy
 *  Return the distribution policy of a table. 
 */</comment>
<function><type><name>GpPolicy</name> <modifier>*</modifier></type>
<name>relation_policy</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* not a partitioned table */</comment>
	<return>return <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  child_distribution_mismatch
 *  Return true if the table is partitioned and one of its children has a
 *  different distribution policy. The only allowed mismatch is for the parent
 *  to be hash distributed, and its child part to be randomly distributed.
 */</comment>
<function><type><name>bool</name></type>
<name>child_distribution_mismatch</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not a partitioned table */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>rootPolicy</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>rootPolicy</name> <operator>&amp;&amp;</operator> <literal type="string">"Partitioned tables cannot be master-only"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* replicated table can't have child */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>rootPolicy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsRandomPartitioned</name><argument_list>(<argument><expr><name>rootPolicy</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* root partition policy already marked as Random, no mismatch possible as
		 * all children must be random as well */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>child_oids</name> <init>= <expr><call><name>find_all_inheritors</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name> <argument_list>(<argument>lc</argument>, <argument>child_oids</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>oidChild</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type> <name>relChild</name> <init>= <expr><call><name>RelationIdGetRelation</name><argument_list>(<argument><expr><name>oidChild</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>relChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>GpPolicy</name> <modifier>*</modifier></type><name>childPolicy</name> <init>= <expr><name><name>relChild</name><operator>-&gt;</operator><name>rd_cdbpolicy</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>GpPolicyIsReplicated</name><argument_list>(<argument><expr><name>childPolicy</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>GpPolicyIsRandomPartitioned</name><argument_list>(<argument><expr><name>childPolicy</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* child partition is Random, and parent is not */</comment>
			<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>RelationClose</name><argument_list>(<argument><expr><name>relChild</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>child_oids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* all children match the root's distribution policy */</comment>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  child_triggers
 *  Return true if the table is partitioned and any of the child partitions
 *  have a trigger of the given type.
 */</comment>
<function><type><name>bool</name></type>
<name>child_triggers</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relationId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>triggerType</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<comment type="block">/* GPDB_12_MERGE_FIXME */</comment>
	<return>return <expr><name>false</name></expr>;</return>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><literal type="number">0</literal></expr></cpp:if>
	Assert(InvalidOid != relationId);
	if (PART_STATUS_NONE == rel_part_status(relationId))
	{
		<comment type="block">/* not a partitioned table */</comment>
		return false;
	}

	List *childOids = find_all_inheritors(relationId, NoLock, NULL);
	ListCell *lc;

	bool found = false;
	foreach (lc, childOids)
	{
		Oid oidChild = lfirst_oid(lc);
		Relation relChild = RelationIdGetRelation(oidChild);
		Assert(NULL != relChild);

		if (relChild-&gt;rd_rel-&gt;relhastriggers &amp;&amp; NULL == relChild-&gt;trigdesc)
		{
			RelationBuildTriggers(relChild);
			if (NULL == relChild-&gt;trigdesc)
			{
				relChild-&gt;rd_rel-&gt;relhastriggers = false;
			}
		}

		if (relChild-&gt;rd_rel-&gt;relhastriggers)
		{
			for (int i = 0; i &lt; relChild-&gt;trigdesc-&gt;numtriggers &amp;&amp; !found; i++)
			{
				Trigger trigger = relChild-&gt;trigdesc-&gt;triggers[i];
				found = trigger_enabled(trigger.tgoid) &amp;&amp;
						(get_trigger_type(trigger.tgoid) &amp; triggerType) == triggerType;
			}
		}

		RelationClose(relChild);
		if (found)
		{
			break;
		}
	}

	list_free(childOids);
	
	<comment type="block">/* no child triggers matching the given type */</comment>
	return found;
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*				---------- PG_INDEX CACHE ----------				 */</comment>

<comment type="block">/*
 * get_index_column_opclass
 *
 *		Given the index OID and column number,
 *		return opclass of the index column
 *			or InvalidOid if the index was not found.
 */</comment>
<function><type><name>Oid</name></type>
<name>get_index_column_opclass</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>index_oid</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>attno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_index</name> <name>rd_index</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>oidvector</name>  <modifier>*</modifier></type><name>indclass</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opclass</name></decl>;</decl_stmt>

	<comment type="block">/* First we need to know the column's opclass. */</comment>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>index_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>rd_index</name> <operator>=</operator> <operator>(</operator><name>Form_pg_index</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* caller is supposed to guarantee this */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>attno</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>attno</name> <operator>&lt;=</operator> <name><name>rd_index</name><operator>-&gt;</operator><name>indnatts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>INDEXRELID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>,
							<argument><expr><name>Anum_pg_index_indclass</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>indclass</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>oidvector</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>datum</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>opclass</name> <operator>=</operator> <name><name>indclass</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>attno</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>opclass</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GPDB_12_MERGE_FIXME: only used by ORCA. Fix the callers to check
 * Relation-&gt;relkind == RELKIND_PARTITIONED_TABLE instead. They should
 * have the relcache entry at hand anyway.
 */</comment>
<function><type><name>bool</name></type>
<name>relation_is_partitioned</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>PARTRELID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>index_is_partitioned</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>relid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>   <name>tuple</name></decl>;</decl_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for relation %u"</literal></expr></argument>, <argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>pg_class_tuple</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>pg_class_tuple</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>List</name> <modifier>*</modifier></type>
<name>relation_get_leaf_partitions</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>descendants</name> <init>= <expr><call><name>find_all_inheritors</name><argument_list>(<argument><expr><name>oid</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>leaves</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>descendants</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>Oid</name></type> <name>descendant</name> <init>= <expr><call><name>lfirst_oid</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>descendant</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name> <operator>&amp;&amp;</operator>
			<call><name>get_rel_relkind</name><argument_list>(<argument><expr><name>descendant</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RELKIND_PARTITIONED_INDEX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>leaves</name> <operator>=</operator> <call><name>lappend_oid</name><argument_list>(<argument><expr><name>leaves</name></expr></argument>, <argument><expr><name>descendant</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<return>return <expr><name>leaves</name></expr>;</return>
</block_content>}</block></function>
</unit>
