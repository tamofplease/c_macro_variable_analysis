<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/cache/ts_cache.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ts_cache.c
 *	  Tsearch related object caches.
 *
 * Tsearch performance is very sensitive to performance of parsers,
 * dictionaries and mapping, so lookups should be cached as much
 * as possible.
 *
 * Once a backend has created a cache entry for a particular TS object OID,
 * the cache entry will exist for the life of the backend; hence it is
 * safe to hold onto a pointer to the cache entry while doing things that
 * might result in recognizing a cache invalidation.  Beware however that
 * subsidiary information might be deleted and reallocated somewhere else
 * if a cache inval and reval happens!	This does not look like it will be
 * a big problem as long as parser and dictionary methods do not attempt
 * any database access.
 *
 *
 * Copyright (c) 2006-2019, PostgreSQL Global Development Group
 *
 * IDENTIFICATION
 *	  src/backend/utils/cache/ts_cache.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_config_map.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_dict.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_ts_template.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/defrem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/catcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/regproc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * MAXTOKENTYPE/MAXDICTSPERTT are arbitrary limits on the workspace size
 * used in lookup_ts_config_cache().  We could avoid hardwiring a limit
 * by making the workspace dynamically enlargeable, but it seems unlikely
 * to be worth the trouble.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXTOKENTYPE</name></cpp:macro>	<cpp:value>256</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXDICTSPERTT</name></cpp:macro>	<cpp:value>100</cpp:value></cpp:define>


<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>TSParserCacheHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TSParserCacheEntry</name> <modifier>*</modifier></type><name>lastUsedParser</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>TSDictionaryCacheHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TSDictionaryCacheEntry</name> <modifier>*</modifier></type><name>lastUsedDictionary</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>TSConfigCacheHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TSConfigCacheEntry</name> <modifier>*</modifier></type><name>lastUsedConfig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * GUC default_text_search_config, and a cache of the current config's OID
 */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>TSCurrentConfig</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>TSCurrentConfigCache</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * We use this syscache callback to detect when a visible change to a TS
 * catalog entry has been made, by either our own backend or another one.
 *
 * In principle we could just flush the specific cache entry that changed,
 * but given that TS configuration changes are probably infrequent, it
 * doesn't seem worth the trouble to determine that; we just flush all the
 * entries of the related hash table.
 *
 * We can use the same function for all TS caches by passing the hash
 * table address as the "arg".
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateTSCacheCallBack</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>hash</name> <init>= <expr><operator>(</operator><name>HTAB</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSAnyCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <operator>(</operator><name>TSAnyCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isvalid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Also invalidate the current-config cache if it's pg_ts_config */</comment>
	<if_stmt><if>if <condition>(<expr><name>hash</name> <operator>==</operator> <name>TSConfigCacheHash</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>TSCurrentConfigCache</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch parser cache entry
 */</comment>
<function><type><name>TSParserCacheEntry</name> <modifier>*</modifier></type>
<name>lookup_ts_parser_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>prsId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSParserCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>TSParserCacheHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the hash table */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSParserCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>TSParserCacheHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Tsearch parser cache"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush cache on pg_ts_parser changes */</comment>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>TSPARSEROID</name></expr></argument>, <argument><expr><name>InvalidateTSCacheCallBack</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>TSParserCacheHash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also make sure CacheMemoryContext exists */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check single-entry cache */</comment>
	<if_stmt><if>if <condition>(<expr><name>lastUsedParser</name> <operator>&amp;&amp;</operator> <name><name>lastUsedParser</name><operator>-&gt;</operator><name>prsId</name></name> <operator>==</operator> <name>prsId</name> <operator>&amp;&amp;</operator>
		<name><name>lastUsedParser</name><operator>-&gt;</operator><name>isvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>lastUsedParser</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Try to look up an existing entry */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TSParserCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>TSParserCacheHash</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>prsId</name></expr></argument>,
											   <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isvalid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we didn't find one, we want to make one. But first look up the
		 * object to be sure the OID is real.
		 */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_ts_parser</name></type> <name>prs</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSPARSEROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>prsId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for text search parser %u"</literal></expr></argument>,
				 <argument><expr><name>prsId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>prs</name> <operator>=</operator> <operator>(</operator><name>Form_pg_ts_parser</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sanity checks
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prs</name><operator>-&gt;</operator><name>prsstart</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"text search parser %u has no prsstart method"</literal></expr></argument>, <argument><expr><name>prsId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prs</name><operator>-&gt;</operator><name>prstoken</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"text search parser %u has no prstoken method"</literal></expr></argument>, <argument><expr><name>prsId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>prs</name><operator>-&gt;</operator><name>prsend</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"text search parser %u has no prsend method"</literal></expr></argument>, <argument><expr><name>prsId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<comment type="block">/* Now make the cache entry */</comment>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TSParserCacheEntry</name> <operator>*</operator><operator>)</operator>
				<call><name>hash_search</name><argument_list>(<argument><expr><name>TSParserCacheHash</name></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>prsId</name></expr></argument>,
							<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* it wasn't there a moment ago */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TSParserCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>prsId</name></name> <operator>=</operator> <name>prsId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>startOid</name></name> <operator>=</operator> <name><name>prs</name><operator>-&gt;</operator><name>prsstart</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>tokenOid</name></name> <operator>=</operator> <name><name>prs</name><operator>-&gt;</operator><name>prstoken</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>endOid</name></name> <operator>=</operator> <name><name>prs</name><operator>-&gt;</operator><name>prsend</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>headlineOid</name></name> <operator>=</operator> <name><name>prs</name><operator>-&gt;</operator><name>prsheadline</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>lextypeOid</name></name> <operator>=</operator> <name><name>prs</name><operator>-&gt;</operator><name>prslextype</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>startOid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>prsstart</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tokenOid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>prstoken</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>endOid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>prsend</name></name></expr></argument>, <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>headlineOid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>headlineOid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>prsheadline</name></name></expr></argument>,
						  <argument><expr><name>CacheMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lastUsedParser</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch dictionary cache entry
 */</comment>
<function><type><name>TSDictionaryCacheEntry</name> <modifier>*</modifier></type>
<name>lookup_ts_dictionary_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>dictId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSDictionaryCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>TSDictionaryCacheHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the hash table */</comment>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSDictionaryCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>TSDictionaryCacheHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Tsearch dictionary cache"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush cache on pg_ts_dict and pg_ts_template changes */</comment>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>TSDICTOID</name></expr></argument>, <argument><expr><name>InvalidateTSCacheCallBack</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>TSDictionaryCacheHash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>TSTEMPLATEOID</name></expr></argument>, <argument><expr><name>InvalidateTSCacheCallBack</name></expr></argument>,
									  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>TSDictionaryCacheHash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Also make sure CacheMemoryContext exists */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check single-entry cache */</comment>
	<if_stmt><if>if <condition>(<expr><name>lastUsedDictionary</name> <operator>&amp;&amp;</operator> <name><name>lastUsedDictionary</name><operator>-&gt;</operator><name>dictId</name></name> <operator>==</operator> <name>dictId</name> <operator>&amp;&amp;</operator>
		<name><name>lastUsedDictionary</name><operator>-&gt;</operator><name>isvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>lastUsedDictionary</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Try to look up an existing entry */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TSDictionaryCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>TSDictionaryCacheHash</name></expr></argument>,
												   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dictId</name></expr></argument>,
												   <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isvalid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we didn't find one, we want to make one. But first look up the
		 * object to be sure the OID is real.
		 */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tpdict</name></decl>,
					<decl><type ref="prev"/><name>tptmpl</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_ts_dict</name></type> <name>dict</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_ts_template</name></type> <name>template</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>saveCtx</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tpdict</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSDICTOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>dictId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tpdict</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for text search dictionary %u"</literal></expr></argument>,
				 <argument><expr><name>dictId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>dict</name> <operator>=</operator> <operator>(</operator><name>Form_pg_ts_dict</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tpdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sanity checks
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>dicttemplate</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"text search dictionary %u has no template"</literal></expr></argument>, <argument><expr><name>dictId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Retrieve dictionary's template
		 */</comment>
		<expr_stmt><expr><name>tptmpl</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSTEMPLATEOID</name></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>dicttemplate</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tptmpl</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for text search template %u"</literal></expr></argument>,
				 <argument><expr><name><name>dict</name><operator>-&gt;</operator><name>dicttemplate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>template</name> <operator>=</operator> <operator>(</operator><name>Form_pg_ts_template</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tptmpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sanity checks
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>template</name><operator>-&gt;</operator><name>tmpllexize</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"text search template %u has no lexize method"</literal></expr></argument>,
				 <argument><expr><name><name>template</name><operator>-&gt;</operator><name>tmpllexize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<comment type="block">/* Now make the cache entry */</comment>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TSDictionaryCacheEntry</name> <operator>*</operator><operator>)</operator>
				<call><name>hash_search</name><argument_list>(<argument><expr><name>TSDictionaryCacheHash</name></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>dictId</name></expr></argument>,
							<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* it wasn't there a moment ago */</comment>

			<comment type="block">/* Create private memory context the first time through */</comment>
			<expr_stmt><expr><name>saveCtx</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
											<argument><expr><literal type="string">"TS dictionary"</literal></expr></argument>,
											<argument><expr><name>ALLOCSET_SMALL_SIZES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name>saveCtx</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>dictname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Clear the existing entry's private context */</comment>
			<expr_stmt><expr><name>saveCtx</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>dictCtx</name></name></expr>;</expr_stmt>
			<comment type="block">/* Don't let context's ident pointer dangle while we reset it */</comment>
			<expr_stmt><expr><call><name>MemoryContextSetIdentifier</name><argument_list>(<argument><expr><name>saveCtx</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>saveCtx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>MemoryContextCopyAndSetIdentifier</name><argument_list>(<argument><expr><name>saveCtx</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>dict</name><operator>-&gt;</operator><name>dictname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TSDictionaryCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>dictId</name></name> <operator>=</operator> <name>dictId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>dictCtx</name></name> <operator>=</operator> <name>saveCtx</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>lexizeOid</name></name> <operator>=</operator> <name><name>template</name><operator>-&gt;</operator><name>tmpllexize</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>template</name><operator>-&gt;</operator><name>tmplinit</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>dictoptions</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>opt</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Init method runs in dictionary's private memory context, and we
			 * make sure the options are stored there too
			 */</comment>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dictCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>opt</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>TSDICTOID</name></expr></argument>, <argument><expr><name>tpdict</name></expr></argument>,
								  <argument><expr><name>Anum_pg_ts_dict_dictinitoption</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dictoptions</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>dictoptions</name> <operator>=</operator> <call><name>deserialize_deflist</name><argument_list>(<argument><expr><name>opt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>dictData</name></name> <operator>=</operator>
				<call><name>DatumGetPointer</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name><name>template</name><operator>-&gt;</operator><name>tmplinit</name></name></expr></argument>,
												 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>dictoptions</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tptmpl</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tpdict</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>lexizeOid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>lexize</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>dictCtx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lastUsedDictionary</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize config cache and prepare callbacks.  This is split out of
 * lookup_ts_config_cache because we need to activate the callback before
 * caching TSCurrentConfigCache, too.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_ts_config_cache</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSConfigCacheEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>TSConfigCacheHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Tsearch configuration cache"</literal></expr></argument>, <argument><expr><literal type="number">16</literal></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Flush cache on pg_ts_config and pg_ts_config_map changes */</comment>
	<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>TSCONFIGOID</name></expr></argument>, <argument><expr><name>InvalidateTSCacheCallBack</name></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>TSConfigCacheHash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>TSCONFIGMAP</name></expr></argument>, <argument><expr><name>InvalidateTSCacheCallBack</name></expr></argument>,
								  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>TSConfigCacheHash</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also make sure CacheMemoryContext exists */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CacheMemoryContext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CreateCacheMemoryContext</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch configuration cache entry
 */</comment>
<function><type><name>TSConfigCacheEntry</name> <modifier>*</modifier></type>
<name>lookup_ts_config_cache</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>cfgId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSConfigCacheEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>TSConfigCacheHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the hash table */</comment>
		<expr_stmt><expr><call><name>init_ts_config_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Check single-entry cache */</comment>
	<if_stmt><if>if <condition>(<expr><name>lastUsedConfig</name> <operator>&amp;&amp;</operator> <name><name>lastUsedConfig</name><operator>-&gt;</operator><name>cfgId</name></name> <operator>==</operator> <name>cfgId</name> <operator>&amp;&amp;</operator>
		<name><name>lastUsedConfig</name><operator>-&gt;</operator><name>isvalid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>lastUsedConfig</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Try to look up an existing entry */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TSConfigCacheEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>TSConfigCacheHash</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cfgId</name></expr></argument>,
											   <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>isvalid</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we didn't find one, we want to make one. But first look up the
		 * object to be sure the OID is real.
		 */</comment>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_ts_config</name></type> <name>cfg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>maprel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Relation</name></type>	<name>mapidx</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>mapskey</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>mapscan</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>maptup</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListDictionary</name></type> <name><name>maplists</name><index>[<expr><name>MAXTOKENTYPE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>mapdicts</name><index>[<expr><name>MAXDICTSPERTT</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>maxtokentype</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ndicts</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSCONFIGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>cfgId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for text search configuration %u"</literal></expr></argument>,
				 <argument><expr><name>cfgId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cfg</name> <operator>=</operator> <operator>(</operator><name>Form_pg_ts_config</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sanity checks
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>cfg</name><operator>-&gt;</operator><name>cfgparser</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"text search configuration %u has no parser"</literal></expr></argument>, <argument><expr><name>cfgId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<comment type="block">/* Now make the cache entry */</comment>
			<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>TSConfigCacheEntry</name> <operator>*</operator><operator>)</operator>
				<call><name>hash_search</name><argument_list>(<argument><expr><name>TSConfigCacheHash</name></expr></argument>,
							<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>cfgId</name></expr></argument>,
							<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* it wasn't there a moment ago */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Cleanup old contents */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>map</name></name></expr>)</condition>
			<block>{<block_content>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>lenmap</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
					<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dictIds</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>map</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>dictIds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>map</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>entry</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TSConfigCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>cfgId</name></name> <operator>=</operator> <name>cfgId</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>prsId</name></name> <operator>=</operator> <name><name>cfg</name><operator>-&gt;</operator><name>cfgparser</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Scan pg_ts_config_map to gather dictionary list for each token type
		 *
		 * Because the index is on (mapcfg, maptokentype, mapseqno), we will
		 * see the entries in maptokentype order, and in mapseqno order for
		 * each token type, even though we didn't explicitly ask for that.
		 */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>maplists</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>maplists</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>maxtokentype</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndicts</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mapskey</name></expr></argument>,
					<argument><expr><name>Anum_pg_ts_config_map_mapcfg</name></expr></argument>,
					<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_OIDEQ</name></expr></argument>,
					<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>cfgId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>maprel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>TSConfigMapRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mapidx</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name>TSConfigMapIndexId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>mapscan</name> <operator>=</operator> <call><name>systable_beginscan_ordered</name><argument_list>(<argument><expr><name>maprel</name></expr></argument>, <argument><expr><name>mapidx</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>mapskey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><operator>(</operator><name>maptup</name> <operator>=</operator> <call><name>systable_getnext_ordered</name><argument_list>(<argument><expr><name>mapscan</name></expr></argument>, <argument><expr><name>ForwardScanDirection</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Form_pg_ts_config_map</name></type> <name>cfgmap</name> <init>= <expr><operator>(</operator><name>Form_pg_ts_config_map</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>maptup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>toktype</name> <init>= <expr><name><name>cfgmap</name><operator>-&gt;</operator><name>maptokentype</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>toktype</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>toktype</name> <operator>&gt;</operator> <name>MAXTOKENTYPE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"maptokentype value %d is out of range"</literal></expr></argument>, <argument><expr><name>toktype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>toktype</name> <operator>&lt;</operator> <name>maxtokentype</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"maptokentype entries are out of order"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>toktype</name> <operator>&gt;</operator> <name>maxtokentype</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* starting a new token type, but first save the prior data */</comment>
				<if_stmt><if>if <condition>(<expr><name>ndicts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>maplists</name><index>[<expr><name>maxtokentype</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>ndicts</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>maplists</name><index>[<expr><name>maxtokentype</name></expr>]</index></name><operator>.</operator><name>dictIds</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
						<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
										   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>maplists</name><index>[<expr><name>maxtokentype</name></expr>]</index></name><operator>.</operator><name>dictIds</name></expr></argument>, <argument><expr><name>mapdicts</name></expr></argument>,
						   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>maxtokentype</name> <operator>=</operator> <name>toktype</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>mapdicts</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>cfgmap</name><operator>-&gt;</operator><name>mapdict</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>ndicts</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* continuing data for current token type */</comment>
				<if_stmt><if>if <condition>(<expr><name>ndicts</name> <operator>&gt;=</operator> <name>MAXDICTSPERTT</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too many pg_ts_config_map entries for one token type"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>mapdicts</name><index>[<expr><name>ndicts</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>cfgmap</name><operator>-&gt;</operator><name>mapdict</name></name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<expr_stmt><expr><call><name>systable_endscan_ordered</name><argument_list>(<argument><expr><name>mapscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>mapidx</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>maprel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ndicts</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* save the last token type's dictionaries */</comment>
			<expr_stmt><expr><name><name>maplists</name><index>[<expr><name>maxtokentype</name></expr>]</index></name><operator>.</operator><name>len</name> <operator>=</operator> <name>ndicts</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>maplists</name><index>[<expr><name>maxtokentype</name></expr>]</index></name><operator>.</operator><name>dictIds</name> <operator>=</operator> <operator>(</operator><name>Oid</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>maplists</name><index>[<expr><name>maxtokentype</name></expr>]</index></name><operator>.</operator><name>dictIds</name></expr></argument>, <argument><expr><name>mapdicts</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>ndicts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* and save the overall map */</comment>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>lenmap</name></name> <operator>=</operator> <name>maxtokentype</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>map</name></name> <operator>=</operator> <operator>(</operator><name>ListDictionary</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>CacheMemoryContext</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListDictionary</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>entry</name><operator>-&gt;</operator><name>lenmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>map</name></name></expr></argument>, <argument><expr><name>maplists</name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ListDictionary</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>entry</name><operator>-&gt;</operator><name>lenmap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>isvalid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>lastUsedConfig</name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*---------------------------------------------------
 * GUC variable "default_text_search_config"
 *---------------------------------------------------
 */</comment>

<function><type><name>Oid</name></type>
<name>getTSCurrentConfig</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>emitError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* if we have a cached value, return it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>TSCurrentConfigCache</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>TSCurrentConfigCache</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* fail if GUC hasn't been set up yet */</comment>
	<if_stmt><if>if <condition>(<expr><name>TSCurrentConfig</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>TSCurrentConfig</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>emitError</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"text search configuration isn't set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>TSConfigCacheHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First time through: initialize the tsconfig inval callback */</comment>
		<expr_stmt><expr><call><name>init_ts_config_cache</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Look up the config */</comment>
	<expr_stmt><expr><name>TSCurrentConfigCache</name> <operator>=</operator>
		<call><name>get_ts_config_oid</name><argument_list>(<argument><expr><call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><name>TSCurrentConfig</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><operator>!</operator><name>emitError</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>TSCurrentConfigCache</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GUC check_hook for default_text_search_config */</comment>
<function><type><name>bool</name></type>
<name>check_TSCurrentConfig</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we aren't inside a transaction, or connected to a database, we
	 * cannot do the catalog accesses necessary to verify the config name.
	 * Must accept it on faith.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsTransactionState</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>MyDatabaseId</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>cfgId</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_ts_config</name></type> <name>cfg</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cfgId</name> <operator>=</operator> <call><name>get_ts_config_oid</name><argument_list>(<argument><expr><call><name>stringToQualifiedNameList</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * When source == PGC_S_TEST, don't throw a hard error for a
		 * nonexistent configuration, only a NOTICE.  See comments in guc.h.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>cfgId</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_TEST</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"text search configuration \"%s\" does not exist"</literal></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Modify the actually stored value to be fully qualified, to ensure
		 * later changes of search_path don't affect it.
		 */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>TSCONFIGOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>cfgId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for text search configuration %u"</literal></expr></argument>,
				 <argument><expr><name>cfgId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>cfg</name> <operator>=</operator> <operator>(</operator><name>Form_pg_ts_config</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>quote_qualified_identifier</name><argument_list>(<argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>cfg</name><operator>-&gt;</operator><name>cfgnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>,
										 <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>cfg</name><operator>-&gt;</operator><name>cfgname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* GUC wants it malloc'd not palloc'd */</comment>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>newval</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GUC assign_hook for default_text_search_config */</comment>
<function><type><name>void</name></type>
<name>assign_TSCurrentConfig</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Just reset the cache to force a lookup on first use */</comment>
	<expr_stmt><expr><name>TSCurrentConfigCache</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
