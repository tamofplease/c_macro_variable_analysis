<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/misc/fstream/fstream.c"><cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/* exclude transformation features on windows for now */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GPFXDIST</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*#include "c.h"*/</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_WINSOCKAPI_</name></cpp:macro></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;windows.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;winsock2.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ws2tcpip.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;postgres.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;commands/copy.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fstream/fstream.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;glob.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gpfxdist.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FILE_ERROR_SZ</name></cpp:macro> <cpp:value>200</cpp:value></cpp:define>
<function_decl><type><name>char</name><modifier>*</modifier></type> <name>format_error</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>c1</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>c2</name></decl></parameter>)</parameter_list>;</function_decl>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type> 	<name>gl_pathc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type>	<name>gl_pathv</name></decl>;</decl_stmt>
}</block></struct></type> <name>glob_and_copy_t</name>;</typedef>

<struct>struct <name>fstream_t</name>
<block>{
	<decl_stmt><decl><type><name>glob_and_copy_t</name></type> <name>glob</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>gfile_t</name></type> 		<name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 			<name>fidx</name></decl>;</decl_stmt> <comment type="block">/* current index in ffd[] */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type> 		<name>foff</name></decl>;</decl_stmt> <comment type="block">/* current offset in ffd[fidx] */</comment>
	<decl_stmt><decl><type><name>int64_t</name></type> 		<name>line_number</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type> 		<name>compressed_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64_t</name></type> 		<name>compressed_position</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 			<name>skip_header_line</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> 			<name>buffer</name></decl>;</decl_stmt>			 <comment type="block">/* buffer to store data read from file */</comment>
	<decl_stmt><decl><type><name>int</name></type> 			<name>buffer_cur_size</name></decl>;</decl_stmt> <comment type="block">/* number of bytes in buffer currently */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>		<name>ferror</name></decl>;</decl_stmt> 		 <comment type="block">/* error string */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>fstream_options</name></name></type> <name>options</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Returns a pointer to the end of the last delimiter occurrence,
 * or the start pointer if delimiter doesn't appear.
 *
 * delimiter_length MUST be &gt; 0
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>find_last_eol_delim</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>size</name></decl></parameter>,
								  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delimiter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>delimiter_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <name>delimiter_length</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>start</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>start</name> <operator>+</operator> <name>size</name> <operator>-</operator> <name>delimiter_length</name></expr>;</init> <condition><expr><name>start</name> <operator>&lt;=</operator> <name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>, <argument><expr><name>delimiter_length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>p</name> <operator>+</operator> <name>delimiter_length</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>start</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns a pointer to the end of the first delimiter occurrence,
 * or the end pointer if delimiter doesn't appear.
 *
 * delimiter_length MUST be &gt; 0
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>find_first_eol_delim</name> <parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>delimiter</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>delimiter_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>search_limit</name> <init>= <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>end</name> <operator>-</operator> <name>delimiter_length</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>end</name> <operator>-</operator> <name>start</name> <operator>&lt;=</operator> <name>delimiter_length</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>end</name></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init> <condition><expr><name>start</name> <operator>&lt;=</operator> <name>search_limit</name></expr>;</condition> <incr><expr><name>start</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>start</name></expr></argument>, <argument><expr><name>delimiter</name></expr></argument>, <argument><expr><name>delimiter_length</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>start</name> <operator>+</operator> <name>delimiter_length</name> <operator>-</operator> <literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>end</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * glob_and_copy
 *
 * Given a pattern, glob it and populate pglob with the results that match it.
 * For example, if 'pattern' equals '/somedir/&lt;asterisk&gt;.txt' and the filesystem has
 * 2 .txt files inside of somedir, namely 1.txt and 2.txt, then the result is:
 * g.gl_pathc = 2
 * g.gl_pathv[0] =  '/somedir/1.txt'
 * g.gl_pathv[1] =  '/somedir/2.txt'
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>glob_and_copy</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><function_decl><type><name>int</name></type>(<modifier>*</modifier><name>errfunc</name>)<parameter_list>(
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>epath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eerno</name></decl></parameter>)</parameter_list></function_decl></parameter>, <parameter><decl><type><name>glob_and_copy_t</name> <modifier>*</modifier></type><name>pglob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>glob_t</name></type> 	<name>g</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>i</name> <init>= <expr><call><name>glob</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>, <argument><expr><name>errfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>g</name></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>i</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>gfile_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>a</name> <operator>*</operator> <operator>(</operator><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathc</name></name> <operator>+</operator> <name><name>g</name><operator>.</operator><name>gl_pathc</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>a</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <name>GLOB_NOSPACE</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>pglob</name><operator>-&gt;</operator><name>gl_pathc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>a</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name><name>pglob</name><operator>-&gt;</operator><name>gl_pathv</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			<if_stmt><if>if <condition>(<expr><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathv</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathv</name></name> <operator>=</operator> <name>a</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>a</name> <operator>+=</operator> <name><name>pglob</name><operator>-&gt;</operator><name>gl_pathc</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>g</name><operator>.</operator><name>gl_pathc</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type><name>b</name> <init>= <expr><name><name>g</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><operator>*</operator><name>a</name> <operator>=</operator> <call><name>gfile_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>i</name> <operator>=</operator> <name>GLOB_NOSPACE</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><operator>*</operator><name>a</name><operator>++</operator></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathc</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>globfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * glob_and_copyfree
 *
 * free memory allocated in pglob.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>glob_and_copyfree</name><parameter_list>(<parameter><decl><type><name>glob_and_copy_t</name> <modifier>*</modifier></type><name>pglob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathv</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pglob</name><operator>-&gt;</operator><name>gl_pathc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathv</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pglob</name><operator>-&gt;</operator><name>gl_pathv</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name>fstream_get_error</name><parameter_list>(<parameter><decl><type><name>fstream_t</name><modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * scan_csv_records
 *
 * Scan the data in [p, q) according to the csv parsing rules. Return as many
 * complete csv records as possible. However, if 'one' was passed in, return the
 * first complete record only.
 *
 * We need this function for gpfdist because until 'text' format we can't just
 * peek at the line newline in the buffer and send the whole data chunk to the
 * server. That is because it may be inside a quote. We have to carefully parse
 * the data from the start in order to find the last unquoted newline.
 *
 */</comment>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>scan_csv_records_crlf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>q</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>one</name></decl></parameter>, <parameter><decl><type><name>fstream_t</name><modifier>*</modifier></type> <name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> 	<name>in_quote</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>last_was_esc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>qc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>quote</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>xc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>escape</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>	<name>last_record_loc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>ch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>lastch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>q</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>lastch</name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>in_quote</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last_was_esc</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>qc</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <name>xc</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>last_was_esc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>last_was_esc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <name>lastch</name> <operator>==</operator> <literal type="char">'\r'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_record_loc</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>line_number</name></name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>one</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <name>qc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>last_record_loc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>scan_csv_records_cr_or_lf</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>one</name></decl></parameter>, <parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> 	<name>in_quote</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>last_was_esc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>qc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>quote</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 	<name>xc</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>escape</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>	<name>last_record_loc</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>p</name> <operator>&lt;</operator> <name>q</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>ch</name> <init>= <expr><operator>*</operator><name>p</name><operator>++</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>in_quote</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>last_was_esc</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <name>qc</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <name>xc</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>last_was_esc</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>last_was_esc</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <name>nc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_record_loc</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>line_number</name></name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>one</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>==</operator> <name>qc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>in_quote</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>last_record_loc</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name><modifier>*</modifier></type>
<name>scan_csv_records</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>q</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>one</name></decl></parameter>, <parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch<condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>eol_type</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>EOL_CRNL</name></expr>:</case>
		   <return>return <expr><call><name>scan_csv_records_crlf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>EOL_CR</name></expr>:</case>
		   <return>return <expr><call><name>scan_csv_records_cr_or_lf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>EOL_NL</name></expr>:</case>
		<default>default:</default>
		   <return>return <expr><call><name>scan_csv_records_cr_or_lf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>one</name></expr></argument>, <argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>
<comment type="block">/* close the file stream */</comment>
<function><type><name>void</name></type> <name>fstream_close</name><parameter_list>(<parameter><decl><type><name>fstream_t</name><modifier>*</modifier></type> <name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
	<comment type="block">/*
	 * remove temporary file we created to hold the file paths
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>transform</name></name> <operator>&amp;&amp;</operator> <name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>transform</name><operator>-&gt;</operator><name>tempfilename</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>apr_file_remove</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>transform</name><operator>-&gt;</operator><name>tempfilename</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>transform</name><operator>-&gt;</operator><name>mp</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>transform</name><operator>-&gt;</operator><name>tempfilename</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if<condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>glob_and_copyfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gfile_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>fpath_all_directories</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>glob_and_copy_t</name> <modifier>*</modifier></type><name>glob</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>glob</name><operator>-&gt;</operator><name>gl_pathc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	<modifier>*</modifier></type><name>a</name> <init>= <expr><name><name>glob</name><operator>-&gt;</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>a</name> <operator>||</operator> <name><name>a</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>expand_directories</name><parameter_list>(<parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>glob_and_copy_t</name></type> <name>g</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 			<name>i</name></decl>, <decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name>g</name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>a</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>b</name> <init>= <expr><call><name>gfile_malloc</name><argument_list>(<argument><expr><literal type="number">2</literal> <operator>*</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>, <decl><type ref="prev"><modifier>*</modifier></type><name>c</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>b</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>glob_and_copyfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<for>for <control>(<init><expr><name>c</name> <operator>=</operator> <name>b</name></expr> ;</init> <condition><expr><operator>*</operator><name>a</name></expr> ;</condition> <incr><expr><name>a</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>a</name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator> <operator>*</operator><name>a</name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator> <operator>*</operator><name>a</name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>c</name><operator>++</operator> <operator>=</operator> <literal type="char">'\\'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>c</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>a</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><operator>*</operator><name>c</name><operator>++</operator> <operator>=</operator> <literal type="char">'*'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>c</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>j</name> <operator>=</operator> <call><name>glob_and_copy</name><argument_list>(<argument><expr><name>b</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>j</name> <operator>==</operator> <name>GLOB_NOMATCH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream %s is empty directory"</literal></expr></argument>,
					<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>j</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream glob failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>glob_and_copyfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name>g</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>glob_and_copyfree</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name></name> <operator>=</operator> <name>g</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>glob_path</name><parameter_list>(<parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>path2</name> <init>= <expr><call><name>gfile_malloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>path2</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>path</name> <operator>=</operator> <call><name>strcpy</name><argument_list>(<argument><expr><name>path2</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>	<name>p</name></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>*</operator><name>path</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>path</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>p</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>path</name> <operator>&amp;&amp;</operator>
			<call><name>glob_and_copy</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>GLOB_MARK</name> <operator>|</operator> <name>GLOB_NOCHECK</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream glob failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>path</name></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name>path2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
<comment type="block">/*
 * adjust fs-&gt;glob so that it contains a single item which is a
 * properly allocated copy of the specified filename.  assumes fs-&gt;glob
 * contains at least one name.  
 */</comment>

<function><type><specifier>static</specifier> <name>int</name></type> <name>glob_adjust</name><parameter_list>(<parameter><decl><type><name>fstream_t</name><modifier>*</modifier></type> <name>fs</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>response_code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>response_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>tlen</name>    <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>tname</name> <init>= <expr><call><name>gfile_malloc</name><argument_list>(<argument><expr><name>tlen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tname</name></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">500</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"fstream out of memory allocating copy of temporary file name"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>response_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>tname</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>tname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * fstream_open
 *
 * Allocate a new file stream given a path (a url). in case of wildcards,
 * expand them here. we end up with a final list of files and include them
 * in our filestream that we return.
 *
 * In case of errors we set the proper http response code to send to the client.
 */</comment>
<function><type><name>fstream_t</name><modifier>*</modifier></type>
<name>fstream_open</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>fstream_options</name></name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
			 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>response_code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>response_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fstream_t</name><modifier>*</modifier></type> <name>fs</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">500</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"Internal Server Error"</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <operator>(</operator><name>fs</name> <operator>=</operator> <call><name>gfile_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>fs</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <operator>*</operator><name>options</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>gfile_malloc</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>bufsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * get a list of all files that were requested to be read and include them
	 * in our fstream. This includes any wildcard pattern matching.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>glob_path</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fstream_close</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the list of files in our filestrem includes a directory name, expand
	 * the directory and add all the files inside of it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>fpath_all_directories</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>glob</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>expand_directories</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>fstream_close</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * check if we don't have any matching files
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream bad path: %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fstream_close</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">404</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"No matching file(s) found"</literal></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name> <operator>!=</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>options</name><operator>-&gt;</operator><name>forwrite</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream open for write found more than one file (%d)"</literal></expr></argument>,
										<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">404</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"More than 1 file found for writing. Unsupported operation."</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fstream_close</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
	<comment type="block">/*
	 * when the subprocess transformation wants to handle iteration over the files
	 * we write the paths to a temporary file and replace the fs-&gt;glob items with
	 * just a single entry referencing the path to the temporary file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>options</name><operator>-&gt;</operator><name>transform</name></name> <operator>&amp;&amp;</operator> <name><name>options</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>pass_paths</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>apr_pool_t</name><modifier>*</modifier></type>  <name>mp</name> <init>= <expr><name><name>options</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>mp</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>apr_file_t</name><modifier>*</modifier></type>  <name>f</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>  <name>tempdir</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>        <name>tempfilename</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>apr_status_t</name></type> <name>rv</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_temp_dir_get</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tempdir</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>APR_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">500</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"failed to get temporary directory for paths file"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>response_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fstream_close</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

	    <expr_stmt><expr><name>tempfilename</name> <operator>=</operator> <call><name>apr_pstrcat</name><argument_list>(<argument><expr><name>mp</name></expr></argument>, <argument><expr><name>tempdir</name></expr></argument>, <argument><expr><literal type="string">"/pathsXXXXXX"</literal></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_file_mktemp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>f</name></expr></argument>, <argument><expr><name>tempfilename</name></expr></argument>, <argument><expr><name>APR_CREATE</name><operator>|</operator><name>APR_WRITE</name><operator>|</operator><name>APR_EXCL</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>APR_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">500</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"failed to open temporary paths file"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>response_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fstream_close</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>options</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>tempfilename</name></name> <operator>=</operator> <name>tempfilename</name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>filename</name>      <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>apr_size_t</name></type> <name>expected</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
			
			<if_stmt><if>if <condition>(<expr><call><name>apr_file_printf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%s\n"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>expected</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">500</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"failed to fully write path to temporary paths file"</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>response_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fstream_close</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>glob_adjust</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>tempfilename</name></expr></argument>, <argument><expr><name>response_code</name></expr></argument>, <argument><expr><name>response_string</name></expr></argument>)</argument_list></call></expr>)</condition> 
		<block>{<block_content>
			<expr_stmt><expr><call><name>fstream_close</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * if writing - check write access rights for the one file.
	 * if reading - check read access right for all files, and 
	 * then close them, leaving the first file open.
	 * 
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * CR-2173 - the fstream code allows the upper level logic to treat a
		 * collection of input sources as a single stream.  One problem it has
		 * to handle is the possibility that some of the underlying sources may
		 * not be readable.  Here we're trying to detect potential problems in
		 * advance by checking that we can open and close each source in our
		 * list in reverse order.
		 *
		 * However in the case of subprocess transformations, we don't want to 
		 * start and stop each transformation in this manner.  The check that 
		 * each transformation's underlying input source can be read is still 
		 * useful so we do those until we get to the first source, at which 
		 * point we proceed to just setup the tranformation for it.
		 */</comment>
		<decl_stmt><decl><type><name><name>struct</name> <name>gpfxdist_t</name></name><modifier>*</modifier></type> <name>transform</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><name><name>options</name><operator>-&gt;</operator><name>transform</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gfile_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>gfile_open</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>gfile_open_flags</name><argument_list>(<argument><expr><name><name>options</name><operator>-&gt;</operator><name>forwrite</name></name></expr></argument>, <argument><expr><name><name>options</name><operator>-&gt;</operator><name>usesync</name></name></expr></argument>)</argument_list></call></expr></argument>,
					   <argument><expr><name>response_code</name></expr></argument>, <argument><expr><name>response_string</name></expr></argument>, <argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream unable to open file %s"</literal></expr></argument>,
					<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fstream_close</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>+=</operator> <call><name>gfile_get_compressed_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>line_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>skip_header_line</name></name> <operator>=</operator> <name><name>options</name><operator>-&gt;</operator><name>header</name></name></expr>;</expr_stmt>

	<return>return <expr><name>fs</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Updates the currently used filename and line number and offset. Since we
 * may be reading from more than 1 file, we need to be up to date all the time.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type> <name>updateCurFileState</name><parameter_list>(<parameter><decl><type><name>fstream_t</name><modifier>*</modifier></type> <name>fs</name></decl></parameter>,
							   <parameter><decl><type><name><name>struct</name> <name>fstream_filename_and_offset</name></name><modifier>*</modifier></type> <name>fo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>fo</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fo</name><operator>-&gt;</operator><name>foff</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>foff</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fo</name><operator>-&gt;</operator><name>line_number</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>line_number</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>fo</name><operator>-&gt;</operator><name>fname</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name></expr>]</index></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>fo</name><operator>-&gt;</operator><name>fname</name></name></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fo</name><operator>-&gt;</operator><name>fname</name><index>[<expr><sizeof>sizeof <name><name>fo</name><operator>-&gt;</operator><name>fname</name></name></sizeof> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * nextFile
 *
 * open the next source file, if any.
 *
 * return 1 if could not open the next file.
 * return 0 otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> <name>nextFile</name><parameter_list>(<parameter><decl><type><name>fstream_t</name><modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>response_code</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	<modifier>*</modifier></type><name>response_string</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>gpfxdist_t</name></name><modifier>*</modifier></type> <name>transform</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>transform</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>compressed_position</name></name> <operator>+=</operator> <call><name>gfile_get_compressed_size</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gfile_close</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>foff</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>line_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name> <operator>&lt;</operator> <name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>skip_header_line</name></name> <operator>=</operator> <name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>header</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>gfile_open</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>GFILE_OPEN_FOR_READ</name></expr></argument>, 
					   <argument><expr><operator>&amp;</operator><name>response_code</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>response_string</name></expr></argument>, <argument><expr><name>transform</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"fstream unable to open file %s"</literal></expr></argument>,
											<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name> <operator>=</operator> <literal type="string">"unable to open file"</literal></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * format_error
 * enables addition of string parameters to the const char* error message in fstream_t
 * while enabling the calling functions not to worry about freeing memory - which is 
 * the present behaviour
 */</comment>
<function><type><name>char</name><modifier>*</modifier></type> <name>format_error</name><parameter_list>(<parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>c1</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>c2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>len1</name></decl>, <decl><type ref="prev"/><name>len2</name></decl>;</decl_stmt>
	
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>err_msg</name><index>[<expr><name>FILE_ERROR_SZ</name></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>err_msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>FILE_ERROR_SZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>len1</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>c1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len2</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>c2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>( <expr><operator>(</operator><name>len1</name> <operator>+</operator> <name>len2</name><operator>)</operator> <operator>&gt;</operator> <name>FILE_ERROR_SZ</name></expr> )</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"cannot read file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="string">"cannot read file"</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>targ</name> <init>= <expr><name>err_msg</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>targ</name></expr></argument>, <argument><expr><name>c1</name></expr></argument>, <argument><expr><name>len1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>targ</name> <operator>+=</operator> <name>len1</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>targ</name></expr></argument>, <argument><expr><name>c2</name></expr></argument>, <argument><expr><name>len2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err_msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><name>err_msg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * fstream_read
 *
 * Read 'size' bytes of data from the filestream into 'buffer'.
 * If 'read_whole_lines' is specified then read up to the last logical row
 * in the source buffer. 'fo' keeps the state (name, offset, etc) of the current
 * filestream file we are reading from.
 */</comment>
<function><type><name>int</name></type> <name>fstream_read</name><parameter_list>(<parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>,
				 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>,
				 <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>,
				 <parameter><decl><type><name><name>struct</name> <name>fstream_filename_and_offset</name></name> <modifier>*</modifier></type><name>fo</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>read_whole_lines</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line_delim_str</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line_delim_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>buffer_capacity</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>bufsize</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>err_buf</name><index>[<expr><name>FILE_ERROR_SZ</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytesread</name></decl>;</decl_stmt> 		<comment type="block">/* num bytes read from filestream */</comment>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>bytesread2</name></decl>;</decl_stmt>		<comment type="block">/* same, but when reading a second round */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>size</name> <operator>||</operator> <name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If data source has a header, we consume it now and in order to
		 * move on to real data that follows it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>skip_header_line</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> 	<name>p</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> 	<name>q</name> <init>= <expr><name>p</name> <operator>+</operator> <name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>size_t</name></type> 	<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		    <expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name> <operator>&lt;</operator> <name>buffer_capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * read data from the source file and fill up the file stream buffer
			 */</comment>
			<expr_stmt><expr><name>len</name> <operator>=</operator> <name>buffer_capacity</name> <operator>-</operator> <name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>bytesread</name> <operator>=</operator> <call><name>gfile_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>bytesread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name> <operator>=</operator> <call><name>format_error</name><argument_list>(<argument><expr><literal type="string">"cannot read file - "</literal></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* update the buffer size according to new byte count we just read */</comment>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name> <operator>+=</operator> <name>bytesread</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>q</name> <operator>+=</operator> <name>bytesread</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>is_csv</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* csv header */</comment>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>scan_csv_records</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>line_delim_length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* text header with defined EOL */</comment>
					<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>find_first_eol_delim</name> <argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>q</name></expr></argument>, <argument><expr><name>line_delim_str</name></expr></argument>, <argument><expr><name>line_delim_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* text header with \n as delimiter (by default) */</comment>
					<for>for <control>(<init>;</init> <condition><expr><name>p</name> <operator>&lt;</operator> <name>q</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						<empty_stmt>;</empty_stmt></block_content></block></for>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>p</name> <operator>&lt;</operator> <name>q</name><operator>)</operator></expr> ?</condition><then> <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>line_number</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name> <operator>==</operator> <name>buffer_capacity</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(
							<argument><expr><literal type="string">"fstream ERROR: header too long in file %s"</literal></expr></argument>,
							<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
					<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name> <operator>=</operator> <literal type="string">"line too long in file"</literal></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <name>q</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * update the filestream buffer offset to past last line read and
			 * copy the end of the buffer (past header data) to the beginning.
			 * we now bypassed the header data and can continue to real data.
			 */</comment>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>foff</name></name> <operator>+=</operator> <name>p</name> <operator>-</operator> <name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name> <operator>=</operator> <name>q</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>skip_header_line</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If we need to read all the data up to the last *complete* logical
		 * line in the data buffer (like gpfdist for example) - we choose this
		 * path. We grab the bigger chunk we can get that includes whole lines.
		 * Otherwise, if we just want the whole buffer we skip.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>read_whole_lines</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	<modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ssize_t</name></type> <name>total_bytes</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name></expr></init></decl>;</decl_stmt>
			
			<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name>size</name> <operator>&gt;=</operator> <name>buffer_capacity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>total_bytes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * source buffer is not empty. copy the data from the beginning
				 * up to the current length before moving on to reading more
				 */</comment>
				<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>updateCurFileState</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>fo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>total_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* read more data from source file into destination buffer */</comment>
			<expr_stmt><expr><name>bytesread2</name> <operator>=</operator> <call><name>gfile_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>dest</name> <operator>+</operator> <name>total_bytes</name></expr></argument>, <argument><expr><name>size</name> <operator>-</operator> <name>total_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>bytesread2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name> <operator>=</operator> <call><name>format_error</name><argument_list>(<argument><expr><literal type="string">"cannot read file - "</literal></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>bytesread2</name> <operator>&lt;</operator> <name>size</name> <operator>-</operator> <name>total_bytes</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We didn't read as much as we asked for. Check why.
				 * We could be done reading data, we may need to move
				 * on the reading the next data file (if any).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>total_bytes</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>bytesread2</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>nextFile</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* found next file but failed to open */</comment>
						<continue>continue;</continue>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><call><name>updateCurFileState</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>fo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * try to open the next file if any, and return the number of
				 * bytes read to buffer earlier, if next file was found but
				 * could not open return -1
				 */</comment>
				<return>return <expr><ternary><condition><expr><call><name>nextFile</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><name>total_bytes</name> <operator>+</operator> <name>bytesread2</name></expr></else></ternary></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>updateCurFileState</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>fo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Now that we have enough data in our filestream buffer, get a 
			 * chunk of whole rows and copy it into our dest buffer to be sent
			 * out later.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>options</name><operator>.</operator><name>is_csv</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* CSV: go slow, scan byte-by-byte for record boundary */</comment>
				<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>scan_csv_records</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>+</operator> <name>size</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * TEXT: go fast, scan for end of line delimiter (\n by default) for
				 * record boundary.
				 * find the last end of line delimiter from the back
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>line_delim_length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>find_last_eol_delim</name><argument_list>(<argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>line_delim_str</name></expr></argument>, <argument><expr><name>line_delim_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>+</operator> <name>size</name></expr>;</init> <condition><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>&lt;=</operator> <operator>--</operator><name>p</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
						<empty_stmt>;</empty_stmt></block_content></block></for>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>p</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>&lt;=</operator> <name>p</name></expr> ?</condition><then> <expr><name>p</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>line_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * could we not find even one complete row in this buffer? error.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name> <operator>||</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>+</operator> <name>size</name> <operator>&gt;=</operator> <name>p</name> <operator>+</operator> <name>buffer_capacity</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>err_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>err_buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"line too long in file %s near (%ld bytes)"</literal></expr></argument>,
						 <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>fs</name><operator>-&gt;</operator><name>foff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>err_buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>err_buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"line too long in file %s near (%lld bytes)"</literal></expr></argument>,
						 <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator> <name><name>fs</name><operator>-&gt;</operator><name>foff</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name> <operator>=</operator> <name>err_buf</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>err_buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* copy the result chunk of data into our buffer and we're done */</comment>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name> <operator>+</operator> <name>size</name> <operator>-</operator> <name>p</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>p</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>foff</name></name> <operator>+=</operator> <name>p</name> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name></expr>;</expr_stmt>

			<return>return <expr><name>p</name> <operator>-</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>dest</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * if we're here it means that we just want chunks of data and don't
		 * care if it includes whole rows or not (for example, backend url_read
		 * code - a segdb that reads all the data that gpfdist sent to it,
		 * buffer by buffer and then parses the lines internally).
		 */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ssize_t</name></type> <name>total_bytes</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name></expr></init></decl>;</decl_stmt>
			
			<expr_stmt><expr><call><name>updateCurFileState</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>fo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>total_bytes</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>total_bytes</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name>total_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name> <operator>-=</operator> <name>total_bytes</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name>total_bytes</name></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>buffer_cur_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>foff</name></name> <operator>+=</operator> <name>total_bytes</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>line_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<return>return <expr><name>total_bytes</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>bytesread</name> <operator>=</operator> <call><name>gfile_read</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>bytesread</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name> <operator>=</operator> <call><name>format_error</name><argument_list>(<argument><expr><literal type="string">"cannot read file - "</literal></expr></argument>, <argument><expr><name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathv</name><index>[<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>bytesread</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>updateCurFileState</name><argument_list>(<argument><expr><name>fs</name></expr></argument>, <argument><expr><name>fo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>foff</name></name> <operator>+=</operator> <name>bytesread</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>line_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<return>return <expr><name>bytesread</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>nextFile</name><argument_list>(<argument><expr><name>fs</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><name>int</name></type> <name>fstream_write</name><parameter_list>(<parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>,
				  <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>size</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>write_whole_lines</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>line_delim_str</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>line_delim_length</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>byteswritten</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we need to write all the data up to the last *complete* logical
	 * line in the data buffer (like gpfdist for example) - we choose this
	 * path (we don't want to write partial lines to the output file). 
	 * We grab the bigger chunk we can get that includes whole lines.
	 * Otherwise, if we just want the whole buffer we skip.
	 */</comment>	
	<if_stmt><if>if <condition>(<expr><name>write_whole_lines</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type> <name>last_delim</name></decl>;</decl_stmt>

	   <comment type="block">/*
		* scan for EOL Delimiter (\n by default) for record boundary
		* find the last EOL Delimiter from the back
		*/</comment>
		<if_stmt><if>if <condition>(<expr><name>line_delim_length</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>last_delim</name> <operator>=</operator> <call><name>find_last_eol_delim</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>line_delim_str</name></expr></argument>, <argument><expr><name>line_delim_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<for>for <control>(<init><expr><name>last_delim</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buf</name> <operator>+</operator> <name>size</name></expr>;</init> <condition><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buf</name> <operator>&lt;=</operator> <operator>--</operator><name>last_delim</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>last_delim</name> <operator>!=</operator> <literal type="char">'\n'</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
				<empty_stmt>;</empty_stmt></block_content></block></for>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>last_delim</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>buf</name> <operator>&lt;=</operator> <name>last_delim</name></expr> ?</condition><then> <expr><name>last_delim</name> <operator>+</operator> <literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>last_delim</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name> <operator>=</operator> <literal type="string">"no complete data row found for writing"</literal></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
				
		<comment type="block">/* TODO: need to do this more carefully for CSV, like in the read case */</comment>
		
                <expr_stmt><expr><name>size</name> <operator>=</operator> <name>last_delim</name> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>buf</name></expr>;</expr_stmt>
		<comment type="block">/* caller should move leftover data to start of buffer */</comment>
        </block_content>}</block></if></if_stmt>

	<comment type="block">/* write data to destination file */</comment>
	<expr_stmt><expr><name>byteswritten</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>gfile_write</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>buf</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>byteswritten</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
                <expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"cannot write into file, byteswritten=%d, size=%d, errno=%d, errmsg=%s"</literal></expr></argument>, 
                        <argument><expr><name>byteswritten</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><name>errno</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fs</name><operator>-&gt;</operator><name>ferror</name></name> <operator>=</operator> <literal type="string">"cannot write into file"</literal></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>byteswritten</name></expr>;</return>
	
</block_content>}</block></function>
<function><type><name>int</name></type> <name>fstream_eof</name><parameter_list>(<parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name> <operator>==</operator> <name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64_t</name></type> <name>fstream_get_compressed_size</name><parameter_list>(<parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>compressed_size</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int64_t</name></type> <name>fstream_get_compressed_position</name><parameter_list>(<parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64_t</name></type> <name>p</name> <init>= <expr><name><name>fs</name><operator>-&gt;</operator><name>compressed_position</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fs</name><operator>-&gt;</operator><name>fidx</name></name> <operator>!=</operator> <name><name>fs</name><operator>-&gt;</operator><name>glob</name><operator>.</operator><name>gl_pathc</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>gfile_get_compressed_position</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fs</name><operator>-&gt;</operator><name>fd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool_t</name></type> <name>fstream_is_win_pipe</name><parameter_list>(<parameter><decl><type><name>fstream_t</name> <modifier>*</modifier></type><name>fs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>fs</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>is_win_pipe</name></name></expr>;</return>
</block_content>}</block></function>

</unit>
