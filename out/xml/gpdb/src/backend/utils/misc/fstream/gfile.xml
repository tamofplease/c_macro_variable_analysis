<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/misc/fstream/gfile.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"c.h"</cpp:file></cpp:include>


<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>FRONTEND</name></cpp:ifndef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/* exclude transformation features on windows for now */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>GPFXDIST</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_CONFIG_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;config.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NDEBUG</name></cpp:ifdef>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>NDEBUG</name></cpp:undef>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fstream/gfile.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;gpfxdist.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;errno.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>   <comment type="block">/* for flock */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;io.h&gt;</cpp:file></cpp:include>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>snprintf</name></cpp:macro> <cpp:value>_snprintf</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>O_BINARY</name></cpp:macro> <cpp:value>0</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>S_IRUSR</name></cpp:ifndef>					<comment type="block">/* XXX [TRH] should be in a header */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IRUSR</name></cpp:macro>		 <cpp:value>S_IREAD</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IWUSR</name></cpp:macro>		 <cpp:value>S_IWRITE</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IXUSR</name></cpp:macro>		 <cpp:value>S_IEXEC</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> 

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COMPRESSION_BUFFER_SIZE</name></cpp:macro>		<cpp:value>(1&lt;&lt;14)</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISDIR</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFDIR</name></cpp:macro>  <cpp:value>_S_IFDIR</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISDIR</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFDIR)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>S_ISFIFO</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_IFIFO</name></cpp:macro> <cpp:value>_S_IFIFO</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_ISFIFO</name><parameter_list>(<parameter><type><name>m</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(((m) &amp; S_IFMT) == S_IFIFO)</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>strcasecmp</name></cpp:macro> <cpp:value>stricmp</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>nothing_close</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>read_and_retry</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<do>do<block type="pseudo"><block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>read</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>
	while <condition>(<expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_position</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>write_and_retry</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ssize_t</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<do>do<block type="pseudo"><block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>
	while <condition>(<expr><name>i</name><operator>&lt;</operator><literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name><operator>==</operator><name>EINTR</name></expr>)</condition>;</do>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_position</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>closewinpipe</name><parameter_list>(<parameter><decl><type><name>gfile_t</name><modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>is_win_pipe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr_stmt><expr><call><name>CloseHandle</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>pipefd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>readwinpipe</name><parameter_list>(<parameter><decl><type><name>gfile_t</name><modifier>*</modifier></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>is_win_pipe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<do>do<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReadFile</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>pipefd</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>(</operator><name>PDWORD</name><operator>)</operator><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>
	while <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_position</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>writewinpipe</name><parameter_list>(<parameter><decl><type><name>gfile_t</name><modifier>*</modifier></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>is_win_pipe</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<do>do<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>WriteFile</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>pipefd</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>(</operator><name>PDWORD</name><operator>)</operator><operator>&amp;</operator><name>i</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block>
	while <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_position</name></name> <operator>+=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>i</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBBZ2</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>bz_alloc</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>gfile_malloc</name><argument_list>(<argument><expr><name>b</name> <operator>*</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>bz_free</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>,<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<struct>struct <name>bzlib_stuff</name>
<block>{
	<decl_stmt><decl><type><name>bz_stream</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>in_size</name></decl>, <decl><type ref="prev"/><name>out_size</name></decl>, <decl><type ref="prev"/><name>eof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>in</name><index>[<expr><name>COMPRESSION_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>out</name><index>[<expr><name>COMPRESSION_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>ssize_t</name></type> 
<name>bz_file_read</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>bzlib_stuff</name></name> <modifier>*</modifier></type><name>z</name> <init>= <expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name></name></expr></init></decl>;</decl_stmt>
	
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>e</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_out</name></name> <operator>-</operator> <name><name>z</name><operator>-&gt;</operator><name>out</name></name> <operator>-</operator> <name><name>z</name><operator>-&gt;</operator><name>out_size</name></name></expr></init></decl>;</decl_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>z</name><operator>-&gt;</operator><name>eof</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>z</name><operator>-&gt;</operator><name>out</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>out_size</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>out_size</name></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
			
			<return>return <expr><name>s</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>out_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>z</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>
		
		<while>while <condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>in_size</name></name> <operator>&lt;</operator> <sizeof>sizeof <name><name>z</name><operator>-&gt;</operator><name>in</name></name></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>read_and_retry</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>z</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>in_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>z</name><operator>-&gt;</operator><name>in</name></name></sizeof>
					<operator>-</operator> <name><name>z</name><operator>-&gt;</operator><name>in_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>in_size</name></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
		</block_content>}</block></while>
		
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>s</name> <operator>=</operator> <name><name>z</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>in_size</name></name> <operator>-</operator> <name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <sizeof>sizeof <name><name>z</name><operator>-&gt;</operator><name>out</name></name></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>BZ2_bzDecompress</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>BZ_STREAM_END</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>e</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_out</name></name> <operator>==</operator> <sizeof>sizeof <name><name>z</name><operator>-&gt;</operator><name>out</name></name></sizeof> <operator>&amp;&amp;</operator> <name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>==</operator> <name>s</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name> <operator>==</operator> <name><name>z</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>in_size</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name><name>z</name><operator>-&gt;</operator><name>in</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>in_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>bz_file_close</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><call><name>BZ2_bzDecompressEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> <name>bz_file_open</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name></name> <operator>=</operator> <call><name>gfile_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"Out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>bzalloc</name></name> <operator>=</operator> <name>bz_alloc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>bzfree</name></name> <operator>=</operator> <name>bz_free</name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><call><name>BZ2_bzDecompressInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"BZ2_bzDecompressInit failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>bz</name><operator>-&gt;</operator><name>in</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>read</name></name> <operator>=</operator> <name>bz_file_read</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>close</name></name> <operator>=</operator> <name>bz_file_close</name></expr>;</expr_stmt>
	
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifdef>
<comment type="block">/* GZ */</comment>
<struct>struct <name>zlib_stuff</name>
<block>{
	<decl_stmt><decl><type><name>z_stream</name></type> <name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>in_size</name></decl>, <decl><type ref="prev"/><name>out_size</name></decl>, <decl><type ref="prev"/><name>eof</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Byte</name></type> <name><name>in</name><index>[<expr><name>COMPRESSION_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Byte</name></type> <name><name>out</name><index>[<expr><name>COMPRESSION_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>gz_file_read</name><parameter_list>(<parameter><decl><type><name>gfile_t</name><modifier>*</modifier></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>zlib_stuff</name></name><modifier>*</modifier></type> <name>z</name> <init>= <expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
	
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>	<name>e</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>	<name>flush</name> <init>= <expr><name>Z_NO_FLUSH</name></expr></init></decl>;</decl_stmt>
		
		<comment type="block">/*
		 * 'out' is our output buffer.
		 * 'next_out' is a pointer to the next byte in 'out'
		 * 'out_size' is num bytes currently in 'out'
		 * 
		 * if s is &gt;0 we have data in 'out' that we didn't write
		 * yet, write it and return.  
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_out</name></name> <operator>-</operator> <operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>out</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>out_size</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>z</name><operator>-&gt;</operator><name>eof</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>z</name><operator>-&gt;</operator><name>out</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>out_size</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>out_size</name></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
			<return>return <expr><name>s</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		
		<comment type="block">/* ok, wrote all 'out' data. reset back to beginning of 'out' */</comment>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>out_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>z</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>
		
		<comment type="block">/*
		 * Fill up our input buffer from the input file.
		 */</comment>
		<while>while <condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>in_size</name></name> <operator>&lt;</operator> <sizeof>sizeof <name><name>z</name><operator>-&gt;</operator><name>in</name></name></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>read_and_retry</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>z</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>in_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>z</name><operator>-&gt;</operator><name>in</name></name></sizeof> <operator>-</operator> <name><name>z</name><operator>-&gt;</operator><name>in_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no more data to read */</comment>
				
				<if_stmt><if>if <condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>in_size</name></name> <operator>==</operator> <name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>flush</name> <operator>=</operator> <name>Z_FINISH</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* read error */</comment>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
				
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>in_size</name></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
		</block_content>}</block></while>
		
		<comment type="block">/* number of bytes available at next_in */</comment>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>in_size</name></name><operator>)</operator> <operator>-</operator> <name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name></expr>;</expr_stmt>
		
		<comment type="block">/* remaining free space at next_out */</comment> 
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <sizeof>sizeof <name><name>z</name><operator>-&gt;</operator><name>out</name></name></sizeof></expr>;</expr_stmt>
		
		<comment type="block">/* decompress */</comment> 
		<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>inflate</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>e</name> <operator>==</operator> <name>Z_STREAM_END</name> <operator>&amp;&amp;</operator> <name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we're done decompressing all we have */</comment>
			<if_stmt><if>if <condition>(<expr><name>flush</name> <operator>==</operator> <name>Z_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>eof</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if<condition>(<expr><name>e</name> <operator>==</operator> <name>Z_STREAM_END</name> <operator>&amp;&amp;</operator> <name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* 
			 * we're done decompressing a chunk, but there's more
			 * input. we need to reset state. see MPP-8012 for info 
			 */</comment>
			<if_stmt><if>if<condition>(<expr><call><name>inflateReset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>z</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>e</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>			
		</block_content>}</block></if></if_stmt>
		
		<comment type="block">/* if no more data available for decompression reset input buf */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name> <operator>==</operator> <operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>in</name></name> <operator>+</operator> <name><name>z</name><operator>-&gt;</operator><name>in_size</name></name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name><name>z</name><operator>-&gt;</operator><name>in</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>in_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>gz_file_write_one_chunk</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>do_flush</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * 0 - means we are ok
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>have</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>zlib_stuff</name></name><modifier>*</modifier></type> <name>z</name> <init>= <expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
	
	<do>do 
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>ret1</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_out</name></name> <operator>=</operator> <name>COMPRESSION_BUFFER_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>z</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret1</name> <operator>=</operator> <call><name>deflate</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>s</name></name><operator>)</operator></expr></argument>, <argument><expr><name>do_flush</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* no bad return value */</comment>
		<if_stmt><if>if <condition>(<expr><name>ret1</name> <operator>==</operator> <name>Z_STREAM_ERROR</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"the gz file is unrepaired, stop writing"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>have</name> <operator>=</operator> <name>COMPRESSION_BUFFER_SIZE</name> <operator>-</operator> <name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_out</name></name></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>( <expr><call><name>write_and_retry</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>z</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><name>have</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>have</name></expr> )</condition> 
		<block>{<block_content>
			<comment type="block">/*
			 * presently gfile_close calls gz_file_close only for the on_write case so we don't need
			 * to handle inflateEnd here
			 */</comment>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"failed to write, the stream ends"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator><call><name>deflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>z</name><operator>-&gt;</operator><name>s</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		
	</block_content>}</block> while <condition>(<expr><name>COMPRESSION_BUFFER_SIZE</name> <operator>==</operator> <name>have</name></expr>)</condition>;</do>	
	<comment type="block">/*
	 * if the deflate engine filled all the output buffer, it may have more data, so we must try again
	 */</comment>
	
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>gz_file_write</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	
	
	<decl_stmt><decl><type><name>size_t</name></type> <name>left_to_compress</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>one_iter_compress</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>zlib_stuff</name></name><modifier>*</modifier></type> <name>z</name> <init>= <expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name></expr></init></decl>;</decl_stmt>
		
	<do>do
	<block>{<block_content>
		<comment type="block">/*
		 * we do not wish that the size of the input buffer to the deflate engine, will be greater
		 * than the recomended COMPRESSION_BUFFER_SIZE.
		 */</comment>
		<expr_stmt><expr><name>one_iter_compress</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>left_to_compress</name> <operator>&gt;</operator> <name>COMPRESSION_BUFFER_SIZE</name><operator>)</operator></expr> ?</condition><then> <expr><name>COMPRESSION_BUFFER_SIZE</name></expr> </then><else>: <expr><name>left_to_compress</name></expr></else></ternary></expr>;</expr_stmt>
			
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>avail_in</name></name> <operator>=</operator> <name>one_iter_compress</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <operator>(</operator><name>Byte</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>Byte</name><operator>*</operator><operator>)</operator><name>ptr</name> <operator>+</operator> <operator>(</operator><name>size</name> <operator>-</operator> <name>left_to_compress</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>gz_file_write_one_chunk</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>Z_NO_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <name>ret</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>ret</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
				
		<expr_stmt><expr><name>left_to_compress</name> <operator>-=</operator> <name>one_iter_compress</name></expr>;</expr_stmt> 
	</block_content>}</block> while<condition>( <expr><name>left_to_compress</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>;</do>

		
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>gz_file_close</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>e</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	
	<if_stmt><if>if <condition>( <expr><name><name>fd</name><operator>-&gt;</operator><name>is_write</name></name> <operator>==</operator> <name>TRUE</name></expr> )</condition> <comment type="block">/* writing, or in other words compressing */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>gz_file_write_one_chunk</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>Z_FINISH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <name>e</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>e</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>deflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else <comment type="block">/* reading, that is inflating */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>e</name> <operator>=</operator> <call><name>inflateEnd</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>s</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	
	<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>e</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>voidpf</name></type>
<name>z_alloc</name><parameter_list>(<parameter><decl><type><name>voidpf</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>uInt</name></type> <name>b</name></decl></parameter>, <parameter><decl><type><name>uInt</name></type> <name>c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>gfile_malloc</name><argument_list>(<argument><expr><name>b</name> <operator>*</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type> <name>z_free</name><parameter_list>(<parameter><decl><type><name>voidpf</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>voidpf</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>gz_file_open</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name> <operator>=</operator> <call><name>gfile_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"Out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>zalloc</name></name> <operator>=</operator> <name>z_alloc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>zfree</name></name> <operator>=</operator> <name>z_free</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>opaque</name></name> <operator>=</operator> <name>Z_NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_out</name></name> <operator>=</operator> <name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>out</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>s</name><operator>.</operator><name>next_in</name></name> <operator>=</operator> <name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>in</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>read</name></name> <operator>=</operator> <name>gz_file_read</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>write</name></name> <operator>=</operator> <name>gz_file_write</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>close</name></name> <operator>=</operator> <name>gz_file_close</name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>( <expr><name><name>fd</name><operator>-&gt;</operator><name>is_write</name></name> <operator>==</operator> <name>FALSE</name></expr> )</condition><comment type="block">/* for read */</comment>  
	<block>{<block_content>
		<comment type="block">/*
		 * reading a compressed file
		 */</comment>		
		<if_stmt><if>if <condition>(<expr><call><name>inflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>s</name></name></expr></argument>,<argument><expr><literal type="number">31</literal></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"inflateInit2 failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else 
	<block>{<block_content>
		<comment type="block">/*
		 * writing a compressed file
		 */</comment>
		<if_stmt><if>if <condition>( <expr><name>Z_OK</name> <operator>!=</operator>
			 <call><name>deflateInit2</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>z</name><operator>-&gt;</operator><name>s</name></name></expr></argument>, <argument><expr><name>Z_DEFAULT_COMPRESSION</name></expr></argument>, <argument><expr><name>Z_DEFLATED</name></expr></argument>, <argument><expr><literal type="number">31</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>, <argument><expr><name>Z_DEFAULT_STRATEGY</name></expr></argument>)</argument_list></call></expr> )</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"deflateInit2 failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>			
		</block_content>}</block></if></if_stmt>
		 
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ZSTD</name></cpp:ifdef>

<comment type="block">/* The value range of the level could be found at zstd.h at different versions.
 * Although the level in ZSTD_initCStream() has the same meaning in different
 * versions, the macro ZSTD_CLEVEL_DEFAULT may not be defined before 1.3.7.
 * So we borrow the macro from zstd.h at 1.3.7 in case it is not defined */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>ZSTD_CLEVEL_DEFAULT</name></cpp:ifndef>
<cpp:define>#  <cpp:directive>define</cpp:directive> <cpp:macro><name>ZSTD_CLEVEL_DEFAULT</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<struct>struct <name>zstdlib_stuff</name>
<block>{
	<decl_stmt><decl><type><name>ZSTD_inBuffer</name></type> <name>in</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ZSTD_outBuffer</name></type> <name>out</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>in_size</name></decl>, <decl><type ref="prev"/><name>out_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>cstream</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ZSTD_DStream</name><modifier>*</modifier></type> <name>dstream</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>in_buffer</name><index>[<expr><name>COMPRESSION_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name></type> <name><name>out_buffer</name><index>[<expr><name>COMPRESSION_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>
<comment type="block">/* Defined in later version 1.4.8 of zstd.h */</comment>
<enum>enum <name>compress_mode</name>
<block>{
	<decl><name>ZSTD_CONTINUE_FLUSH</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
	<decl><name>ZSTD_FLUSH_FLUSH</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>,
	<decl><name>ZSTD_END_FLUSH</name> <init>= <expr><literal type="number">2</literal></expr></init></decl>,
}</block>;</enum>
<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>zstd_file_read</name><parameter_list>(<parameter><decl><type><name>gfile_t</name><modifier>*</modifier></type> <name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name><modifier>*</modifier></type> <name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>zstdlib_stuff</name></name><modifier>*</modifier></type> <name>zstd</name> <init>= <expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name></name></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>size_t</name></type>	<name>ret</name></decl>;</decl_stmt>
		<comment type="block">/*
		 * 'out-&gt;dst' is our output buffer.
		 * 'pos' is a size_t value equal to the next pos in 'out_buffer'
		 * 'out_size' is num bytes currently read out of 'out_buffer'
		 *
		 * if s is &gt;0 we have data in 'out.dst' that we didn't write
		 * yet, write it and return.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type> <name>s</name> <init>= <expr><name><name>zstd</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>pos</name></name> <operator>-</operator> <name><name>zstd</name><operator>-&gt;</operator><name>out_size</name></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>zstd</name><operator>-&gt;</operator><name>out_buffer</name></name> <operator>+</operator> <name><name>zstd</name><operator>-&gt;</operator><name>out_size</name></name></expr></argument>, <argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>out_size</name></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
			<return>return <expr><name>s</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* ok, wrote all 'out' data. reset back to beginning of 'out_buffer' */</comment>
		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>out_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Fill up our input buffer from the input file.
		 */</comment>
		<while>while <condition>(<expr><name><name>zstd</name><operator>-&gt;</operator><name>in_size</name></name> <operator>&lt;</operator> <sizeof>sizeof <name><name>zstd</name><operator>-&gt;</operator><name>in_buffer</name></name></sizeof></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>read_and_retry</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>zstd</name><operator>-&gt;</operator><name>in_buffer</name></name> <operator>+</operator> <name><name>zstd</name><operator>-&gt;</operator><name>in_size</name></name></expr></argument>, <argument><expr><sizeof>sizeof <name><name>zstd</name><operator>-&gt;</operator><name>in_buffer</name></name></sizeof> <operator>-</operator> <name><name>zstd</name><operator>-&gt;</operator><name>in_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* read error */</comment>
				<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"ZSTD read_and_retry failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if<condition>(<expr><name>s</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>in_size</name></name> <operator>+=</operator> <name>s</name></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/* size of bytes at next decompression */</comment>
		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name><name>zstd</name><operator>-&gt;</operator><name>in_size</name></name></expr>;</expr_stmt>

		<comment type="block">/* remaining free space at next decompression */</comment>
		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>size</name></name> <operator>=</operator> <sizeof>sizeof <name><name>zstd</name><operator>-&gt;</operator><name>out_buffer</name></name></sizeof></expr>;</expr_stmt>

		<comment type="block">/* decompress */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No more data to be decompressed and out_buffer is empty */</comment>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>ZSTD_decompressStream</name><argument_list>(<argument><expr><name><name>zstd</name><operator>-&gt;</operator><name>dstream</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zstd</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zstd</name><operator>-&gt;</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>ret</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"ZSTD_decompressStream failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* if no more data available for decompression reset input buf */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>pos</name></name> <operator>==</operator> <name><name>zstd</name><operator>-&gt;</operator><name>in_size</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>in_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<comment type="block">/* In later version we can use ZSTD_compressStream2 with mode parameter,
 * but in order to coordinate with earlier version, we use the following two functions instead */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>size_t</name></type> <name>zstd_compression_with_mode</name><parameter_list>(<parameter><decl><type><name>ZSTD_CStream</name><modifier>*</modifier></type> <name>zcs</name></decl></parameter>, <parameter><decl><type><name>ZSTD_outBuffer</name><modifier>*</modifier></type> <name>output</name></decl></parameter>, <parameter><decl><type><name>ZSTD_inBuffer</name><modifier>*</modifier></type> <name>input</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>mode</name> <operator>!=</operator> <name>ZSTD_END_FLUSH</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>ZSTD_compressStream</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>output</name></expr></argument>, <argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><call><name>ZSTD_endStream</name><argument_list>(<argument><expr><name>zcs</name></expr></argument>, <argument><expr><name>output</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>zstd_file_write_one_chunk</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * 0 - means we are ok
	 */</comment>
	<decl_stmt><decl><type><name>size_t</name></type> <name>remain</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>have</name></decl>, <decl><type ref="prev"/><name>finished</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>zstdlib_stuff</name></name><modifier>*</modifier></type> <name>zstd</name> <init>= <expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name></name></expr></init></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>COMPRESSION_BUFFER_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <name><name>zstd</name><operator>-&gt;</operator><name>out_buffer</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>remain</name> <operator>=</operator> <call><name>zstd_compression_with_mode</name><argument_list>(<argument><expr><name><name>zstd</name><operator>-&gt;</operator><name>cstream</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zstd</name><operator>-&gt;</operator><name>out</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>zstd</name><operator>-&gt;</operator><name>in</name></name></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    <comment type="block">/* no bad return value */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><name>remain</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"zstd_compression_with_mode failed mode:%d"</literal></expr></argument>, <argument><expr><name>mode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>have</name> <operator>=</operator> <name><name>zstd</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>pos</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>( <expr><call><name>write_and_retry</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>zstd</name><operator>-&gt;</operator><name>out_buffer</name></name></expr></argument>, <argument><expr><name>have</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>have</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"ZSTD write_and_retry failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>finished</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>mode</name> <operator>==</operator> <name>ZSTD_END_FLUSH</name><operator>)</operator></expr> ?</condition><then> <expr><operator>(</operator><name>remain</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> </then><else>: <expr><operator>(</operator><name><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>pos</name></name> <operator>==</operator> <name><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>size</name></name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><operator>!</operator><name>finished</name></expr>)</condition>;</do>
	<comment type="block">/*
	 * if the ZSTD_compressStream or ZSTD_endStream engine filled all the output buffer, it may have more data, so we must try again
	 */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>zstd_file_write</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>left_to_compress</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>one_iter_compress</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>zstdlib_stuff</name></name><modifier>*</modifier></type> <name>zstd</name> <init>= <expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name></name></expr></init></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<comment type="block">/*
		 * we do not wish that the size of the input buffer to the ZSTD_compressStream engine, will be greater
		 * than the recommended COMPRESSION_BUFFER_SIZE.
		 */</comment>
		<expr_stmt><expr><name>one_iter_compress</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>left_to_compress</name> <operator>&gt;</operator> <name>COMPRESSION_BUFFER_SIZE</name><operator>)</operator></expr> ?</condition><then> <expr><name>COMPRESSION_BUFFER_SIZE</name></expr> </then><else>: <expr><name>left_to_compress</name></expr></else></ternary></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>size</name></name> <operator>=</operator> <name>one_iter_compress</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>src</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><operator>(</operator><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator><name>ptr</name> <operator>+</operator> <operator>(</operator><name>size</name> <operator>-</operator> <name>left_to_compress</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>zstd_file_write_one_chunk</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ZSTD_CONTINUE_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <name>ret</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>ret</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>left_to_compress</name> <operator>-=</operator> <name>one_iter_compress</name></expr>;</expr_stmt>
	</block_content>}</block> while<condition>( <expr><name>left_to_compress</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> )</condition>;</do>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>zstd_file_close</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>( <expr><name><name>fd</name><operator>-&gt;</operator><name>is_write</name></name> <operator>==</operator> <name>FALSE</name></expr> )</condition> <comment type="block">/* writing, or in other words compressing */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ZSTD_freeDStream</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>dstream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* flush any remaining data _and_ close current frame */</comment>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>zstd_file_write_one_chunk</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ZSTD_END_FLUSH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>!=</operator> <name>ret</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><name>ret</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ZSTD_freeCStream</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>cstream</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>gfile_free</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>zstd_file_open</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name></name> <operator>=</operator> <call><name>gfile_malloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"Out of memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof <name/></sizeof>*<name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>in</name><operator>.</operator><name>src</name></name> <operator>=</operator> <name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>in_buffer</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>out</name><operator>.</operator><name>dst</name></name> <operator>=</operator> <name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>out_buffer</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>read</name></name> <operator>=</operator> <name>zstd_file_read</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>write</name></name> <operator>=</operator> <name>zstd_file_write</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>close</name></name> <operator>=</operator> <name>zstd_file_close</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>( <expr><name><name>fd</name><operator>-&gt;</operator><name>is_write</name></name> <operator>==</operator> <name>FALSE</name></expr> )</condition><comment type="block">/* for read */</comment>
	<block>{<block_content>
		<comment type="block">/*
		 * reading a compressed file
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>dstream</name></name> <operator>=</operator> <call><name>ZSTD_createDStream</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"ZSTD_createDStream failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_initDStream</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>dstream</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"ZSTD_initDStream failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * writing a compressed file
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>cstream</name></name> <operator>=</operator> <call><name>ZSTD_createCStream</name><argument_list>()</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"ZSTD_createCStream() failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if<condition>(<expr><call><name>ZSTD_isError</name><argument_list>(<argument><expr><call><name>ZSTD_initCStream</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>zstd</name><operator>-&gt;</operator><name>cstream</name></name></expr></argument>, <argument><expr><name>ZSTD_CLEVEL_DEFAULT</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"ZSTD_initCStream failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
<comment type="block">/*
 * subprocess support
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>subprocess_open_errfn</name><parameter_list>(<parameter><decl><type><name>apr_pool_t</name> <modifier>*</modifier></type><name>pool</name></decl></parameter>, <parameter><decl><type><name>apr_status_t</name></type> <name>status</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>desc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>errbuf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><literal type="string">"subprocess: %s: %s\n"</literal></expr></argument>, <argument><expr><name>desc</name></expr></argument>, <argument><expr><call><name>apr_strerror</name><argument_list>(<argument><expr><name>status</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>subprocess_open_failed</name><parameter_list>(<parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>response_code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>response_string</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name>reason</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>response_code</name>   <operator>=</operator> <literal type="number">500</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <name>reason</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name>response_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type> 
<name>subprocess_open</name><parameter_list>(<parameter><decl><type><name>gfile_t</name><modifier>*</modifier></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fpath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>for_write</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>rcode</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>rstring</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>apr_pool_t</name><modifier>*</modifier></type>     <name>mp</name>     <init>= <expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>mp</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier></type>           <name>cmd</name>    <init>= <expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>cmd</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>apr_procattr_t</name><modifier>*</modifier></type> <name>pattr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type>          <name>tokens</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>apr_status_t</name></type>    <name>rv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>apr_file_t</name><modifier>*</modifier></type>     <name>errfile</name></decl>;</decl_stmt>

	<comment type="block">/* tokenize command string */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_tokenize_to_argv</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tokens</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>APR_SUCCESS</name></expr>)</condition> 
	<block>{<block_content>
		<return>return <expr><call><name>subprocess_open_failed</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><name>rstring</name></expr></argument>, <argument><expr><literal type="string">"subprocess_open: apr_tokenize_to_argv failed"</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* replace %FILENAME% with path to input or output file */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>
		<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>tokens</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control> 
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><literal type="string">"%FILENAME%"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>fpath</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>

	<comment type="block">/* setup apr subprocess attribute structure */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_procattr_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pattr</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>APR_SUCCESS</name></expr>)</condition> 
	<block>{<block_content>
		<return>return <expr><call><name>subprocess_open_failed</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><name>rstring</name></expr></argument>, <argument><expr><literal type="string">"subprocess_open: apr_procattr_create failed"</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* setup child stdin/stdout depending on the direction of transformation */</comment>
	<if_stmt><if>if <condition>(<expr><name>for_write</name></expr>)</condition> 
	<block>{<block_content>
		<comment type="block">/* writable external table, so child will be reading from standard input */</comment>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_procattr_io_set</name><argument_list>(<argument><expr><name>pattr</name></expr></argument>, <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>, <argument><expr><name>APR_NO_PIPE</name></expr></argument>, <argument><expr><name>APR_NO_PIPE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>APR_SUCCESS</name></expr>)</condition> 
		<block>{<block_content>
			<return>return <expr><call><name>subprocess_open_failed</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><name>rstring</name></expr></argument>, <argument><expr><literal type="string">"subprocess_open: apr_procattr_io_set (full,no,no) failed"</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>for_write</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if> 
	<else>else 
	<block>{<block_content>
		<comment type="block">/* readable external table, so child will be writing to standard output */</comment>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_procattr_io_set</name><argument_list>(<argument><expr><name>pattr</name></expr></argument>, <argument><expr><name>APR_NO_PIPE</name></expr></argument>, <argument><expr><name>APR_FULL_BLOCK</name></expr></argument>, <argument><expr><name>APR_NO_PIPE</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>APR_SUCCESS</name></expr>)</condition> 
		<block>{<block_content>
			<return>return <expr><call><name>subprocess_open_failed</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><name>rstring</name></expr></argument>, <argument><expr><literal type="string">"subprocess_open: apr_procattr_io_set (no,full,no) failed"</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>for_write</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* setup child stderr */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>errfile</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* redirect stderr to a file to be sent to server when we're finished */</comment>

		<expr_stmt><expr><name>errfile</name> <operator>=</operator> <name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>errfile</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_procattr_child_err_set</name><argument_list>(<argument><expr><name>pattr</name></expr></argument>, <argument><expr><name>errfile</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator>  <name>APR_SUCCESS</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><call><name>subprocess_open_failed</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><name>rstring</name></expr></argument>, <argument><expr><literal type="string">"subprocess_open: apr_procattr_child_err_set failed"</literal></expr></argument>)</argument_list></call></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt> 

	<comment type="block">/* more APR complexity: setup error handler for when child doesn't spawn properly */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_procattr_child_errfn_set</name><argument_list>(<argument><expr><name>pattr</name></expr></argument>, <argument><expr><name>subprocess_open_errfn</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>APR_SUCCESS</name></expr>)</condition> 
	<block>{<block_content>
		<return>return <expr><call><name>subprocess_open_failed</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><name>rstring</name></expr></argument>, <argument><expr><literal type="string">"subprocess_open: apr_procattr_child_errfn_set failed"</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* don't run the child via an operating system shell */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_procattr_cmdtype_set</name><argument_list>(<argument><expr><name>pattr</name></expr></argument>, <argument><expr><name>APR_PROGRAM_ENV</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>APR_SUCCESS</name></expr>)</condition> 
	<block>{<block_content>
		<return>return <expr><call><name>subprocess_open_failed</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><name>rstring</name></expr></argument>, <argument><expr><literal type="string">"subprocess_open: apr_procattr_cmdtype_set failed"</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* finally... start the child process */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>rv</name> <operator>=</operator> <call><name>apr_proc_create</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><name><name>tokens</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name><operator>*</operator> <specifier>const</specifier><operator>*</operator><operator>)</operator><name>tokens</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>pattr</name></expr></argument>, <argument><expr><name>mp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>APR_SUCCESS</name></expr>)</condition> 
	<block>{<block_content>
		<return>return <expr><call><name>subprocess_open_failed</name><argument_list>(<argument><expr><name>rcode</name></expr></argument>, <argument><expr><name>rstring</name></expr></argument>, <argument><expr><literal type="string">"subprocess_open: apr_proc_create failed"</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>ssize_t</name></type> 
<name>read_subprocess</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>apr_size_t</name></type>      <name>nbytes</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>apr_status_t</name></type>    <name>rv</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>apr_file_read</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>proc</name><operator>.</operator><name>out</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>APR_SUCCESS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>nbytes</name></expr>;</return></block_content></block></if></if_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>rv</name> <operator>==</operator> <name>APR_EOF</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>ssize_t</name></type>
<name>write_subprocess</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>apr_size_t</name></type>      <name>nbytes</name> <init>= <expr><name>size</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>apr_file_write</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>proc</name><operator>.</operator><name>in</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nbytes</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>close_subprocess</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>             <name>st</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>apr_exit_why_e</name></type>  <name>why</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>apr_status_t</name></type>    <name>rv</name></decl>;</decl_stmt>
    
	<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>for_write</name></name></expr>)</condition><block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>proc</name><operator>.</operator><name>in</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
	    <expr_stmt><expr><call><name>apr_file_close</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>proc</name><operator>.</operator><name>out</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
        
	<expr_stmt><expr><name>rv</name> <operator>=</operator> <call><name>apr_proc_wait</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>fd</name><operator>-&gt;</operator><name>transform</name><operator>-&gt;</operator><name>proc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>why</name></expr></argument>, <argument><expr><name>APR_WAIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>APR_STATUS_IS_CHILD_DONE</name><argument_list>(<argument><expr><name>rv</name></expr></argument>)</argument_list></call></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"close_subprocess: done: why = %d, exit status = %d"</literal></expr></argument>, <argument><expr><name>why</name></expr></argument>, <argument><expr><name>st</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>st</name></expr>;</return>
	</block_content>}</block></if> 
	<else>else 
	<block>{<block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"close_subprocess: notdone"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function><type><specifier>static</specifier> <name>int</name></type> <name>close_filefd</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FRONTEND</name></cpp:ifdef>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>CloseTransientFile</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block>
	while <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * public interface
 */</comment>

<function><type><name>int</name></type> 
<name>gfile_open_flags</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>writing</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>usesync</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>writing</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>usesync</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>GFILE_OPEN_FOR_WRITE_SYNC</name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>GFILE_OPEN_FOR_WRITE_NOSYNC</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>GFILE_OPEN_FOR_READ</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type> <name>gfile_open</name><parameter_list>(<parameter><decl><type><name>gfile_t</name><modifier>*</modifier></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>fpath</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><name>int</name><modifier>*</modifier></type> <name>response_code</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier><modifier>*</modifier></type> <name>response_string</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>gpfxdist_t</name></name><modifier>*</modifier></type> <name>transform</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>s</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool_t</name></type> <name>is_win_pipe</name> <init>= <expr><name>FALSE</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><name><name>struct</name> 		<name>stat</name></name></type> <name>sta</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sta</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sta</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>fd</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * check for subprocess and/or named pipe
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* is this a windows named pipe, of the form \\&lt;host&gt;\... */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fpath</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <name><name>fpath</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>is_win_pipe</name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"looks like a windows pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_win_pipe</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Try and open it as a windows named pipe */</comment>
		<decl_stmt><decl><type><name>HANDLE</name></type> <name>pipe</name> <init>= <expr><call><name>CreateFile</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, 
								 <argument><expr><operator>(</operator><ternary><condition><expr><name>flags</name> <operator>!=</operator> <name>GFILE_OPEN_FOR_READ</name></expr> ?</condition><then> <expr><name>GENERIC_WRITE</name></expr> </then><else>: <expr><name>GENERIC_READ</name></expr></else></ternary><operator>)</operator></expr></argument>,
								 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* no sharing */</comment>
								 <argument><expr><name>NULL</name></expr></argument>, <comment type="block">/* default security */</comment>
								 <argument><expr><name>OPEN_EXISTING</name></expr></argument>, <comment type="block">/* file must exist */</comment>
								 <argument><expr><literal type="number">0</literal></expr></argument>, <comment type="block">/* default attributes */</comment>
								 <argument><expr><name>NULL</name></expr></argument> <comment type="block">/* no template */</comment>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"trying to connect to pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pipe</name> <operator>!=</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>is_win_pipe</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>pipefd</name></name> <operator>=</operator> <name>pipe</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"connected to pipe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>LPSTR</name></type> <name>msg</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>FormatMessage</name><argument_list>(<argument><expr><name>FORMAT_MESSAGE_ALLOCATE_BUFFER</name> <operator>|</operator>
						  <name>FORMAT_MESSAGE_FROM_SYSTEM</name></expr></argument>,
				   		  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><call><name>GetLastError</name><argument_list>()</argument_list></call></expr></argument>,
						  <argument><expr><call><name>MAKELANGID</name><argument_list>(<argument><expr><name>LANG_ENGLISH</name></expr></argument>, <argument><expr><name>SUBLANG_DEFAULT</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><operator>(</operator><name>LPSTR</name><operator>)</operator> <operator>&amp;</operator> <name>msg</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"could not create pipe: %s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>GetLastError</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>ERROR_PIPE_BUSY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">500</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"could not connect to pipe"</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">501</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"pipe is busy, close the pipe and try again"</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>	<comment type="block">/* not win32 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
	<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name></name> <operator>=</operator> <name>transform</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* caller wants a subprocess. nothing to do here just yet. */</comment>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"looks like a subprocess"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fd</name><operator>-&gt;</operator><name>is_win_pipe</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>==</operator> <name>GFILE_OPEN_FOR_READ</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sta</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name>errno</name> <operator>==</operator> <name>EOVERFLOW</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					* ENGINF-176
					* 
					* Some platforms don't support stat'ing of "large files"
					* accurately (files over 2GB) - SPARC for example. In these
					* cases the storage size of st_size is too small and the
					* file size will overflow. Therefore, we look for cases where
					* overflow had occurred, and resume operation. At least we
					* know that the file does exist and that's the main goal of
					* stat'ing here anyway. we set the size to 0, similarly to
					* the winpipe path, so that negative sizes won't be used.
					* 
					* TODO: there may be side effects to setting the size to 0,
					* need to double check.
					* 
					* TODO: this hack could possibly now be removed after enabling
					* largefiles via the build process with compiler flags.
					*/</comment>
					<expr_stmt><expr><name><name>sta</name><operator>.</operator><name>st_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"gfile stat %s failure: %s"</literal></expr></argument>, <argument><expr><name>fpath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">404</literal></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"file not found"</literal></expr>;</expr_stmt>
					<return>return <expr><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>S_ISDIR</name><argument_list>(<argument><expr><name><name>sta</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"gfile %s is a directory"</literal></expr></argument>, <argument><expr><name>fpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">403</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"Reading a directory is forbidden."</literal></expr>;</expr_stmt>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_size</name></name> <operator>=</operator> <name><name>sta</name><operator>.</operator><name>st_size</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>	<comment type="block">/* ifdef win32 */</comment>

	<if_stmt><if>if <condition>(<expr><name>NULL</name> <operator>==</operator> <name><name>fd</name><operator>-&gt;</operator><name>transform</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>fd</name><operator>-&gt;</operator><name>is_win_pipe</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>syncFlag</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>openFlags</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>mode_t</name></type> <name>openMode</name></decl>;</decl_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
		<comment type="block">/*
		 * MPP-13817 (support opening files without O_SYNC)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GFILE_OPEN_FOR_WRITE_SYNC</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * caller explicitly requested O_SYNC
			 */</comment>
			<expr_stmt><expr><name>syncFlag</name> <operator>=</operator> <name>O_SYNC</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><call><name>stat</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sta</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <call><name>S_ISFIFO</name><argument_list>(<argument><expr><name><name>sta</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * use O_SYNC since we're writing to another process via a pipe
			 */</comment>
			<expr_stmt><expr><name>syncFlag</name> <operator>=</operator> <name>O_SYNC</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>GFILE_OPEN_FOR_READ</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>openFlags</name> <operator>=</operator> <name>O_WRONLY</name> <operator>|</operator> <name>O_CREAT</name> <operator>|</operator> <name>O_BINARY</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>syncFlag</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>openMode</name> <operator>=</operator> <name>S_IRUSR</name> <operator>|</operator> <name>S_IWUSR</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>openFlags</name> <operator>=</operator> <name>O_RDONLY</name> <operator>|</operator> <name>O_BINARY</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>openMode</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<do>do
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FRONTEND</name></cpp:ifdef>
			<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>fpath</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>, <argument><expr><name>openMode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name> <operator>=</operator> <call><name>OpenTransientFile</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>fpath</name></expr></argument>, <argument><expr><name>openFlags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		</block_content>}</block>
		while <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>

		<if_stmt><if>if <condition>(<expr><operator>-</operator><literal type="number">1</literal> <operator>==</operator> <name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"gfile open (for %s) failed %s: %s"</literal></expr></argument>,
										<argument><expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>==</operator> <name>GFILE_OPEN_FOR_READ</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"read"</literal></expr> </then><else>:
											<expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name>flags</name> <operator>==</operator> <name>GFILE_OPEN_FOR_WRITE_SYNC</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"write (sync)"</literal></expr> </then><else>: <expr><literal type="string">"write"</literal></expr></else></ternary><operator>)</operator></expr></else></ternary><operator>)</operator></expr></argument>,
										<argument><expr><name>fpath</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">404</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof <name>buf</name></sizeof></expr></argument>, <argument><expr><literal type="string">"file open failure %s: %s"</literal></expr></argument>, <argument><expr><name>fpath</name></expr></argument>,
					<argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <name>buf</name></expr>;</expr_stmt>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call></expr></cpp:if>
		<comment type="block">/* Restrict only one reader session for each PIPE */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>S_ISFIFO</name><argument_list>(<argument><expr><name><name>sta</name><operator>.</operator><name>st_mode</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>flags</name> <operator>==</operator> <name>GFILE_OPEN_FOR_READ</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>flock</name> <argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name></expr></argument>, <argument><expr><name>LOCK_EX</name> <operator>|</operator> <name>LOCK_NB</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>held_pipe_lock</name></name> <operator>=</operator> <name>FALSE</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"gfile %s is a pipe"</literal></expr></argument>, <argument><expr><name>fpath</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">404</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"Multiple reader to a pipe is forbidden."</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>close_filefd</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
				<return>return <expr><literal type="number">1</literal></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>held_pipe_lock</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * prepare to use the appropriate i/o routines 
	 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>read</name></name>  <operator>=</operator> <name>read_subprocess</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>write</name></name> <operator>=</operator> <name>write_subprocess</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>close</name></name> <operator>=</operator> <name>close_subprocess</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>is_win_pipe</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>read</name></name> <operator>=</operator> <name>readwinpipe</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>write</name></name> <operator>=</operator> <name>writewinpipe</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>close</name></name> <operator>=</operator> <name>closewinpipe</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>read</name></name> <operator>=</operator> <name>read_and_retry</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>write</name></name> <operator>=</operator> <name>write_and_retry</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>close</name></name> <operator>=</operator> <name>nothing_close</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * delegate remaining setup work to an appropriate open routine
	 * or return an error if we can't handle the type
	 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name></name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>subprocess_open</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>fpath</name></expr></argument>, <argument><expr><operator>(</operator><name>flags</name> <operator>!=</operator> <name>GFILE_OPEN_FOR_READ</name><operator>)</operator></expr></argument>, <argument><expr><name>response_code</name></expr></argument>, <argument><expr><name>response_string</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else 
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	if <condition>(<expr><name>s</name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">".gz"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBZ</name></cpp:ifndef>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">".gz not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<comment type="block">/*
		 * flag used by function gfile close
		 */</comment>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name>GZ_COMPRESSION</name></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>GFILE_OPEN_FOR_READ</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>is_write</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>gz_file_open</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>s</name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">".bz2"</literal></expr></argument>)</argument_list></call><operator>==</operator><literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_LIBBZ2</name></cpp:ifndef>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">".bz2 not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name>BZ_COMPRESSION</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>GFILE_OPEN_FOR_READ</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">".bz2 not yet supported for writable tables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><call><name>bz_file_open</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>s</name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">".zst"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_ZSTD</name></cpp:ifndef>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">".zst not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>compression</name></name> <operator>=</operator> <name>ZSTD_COMPRESSION</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>!=</operator> <name>GFILE_OPEN_FOR_READ</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>is_write</name></name> <operator>=</operator> <name>TRUE</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><call><name>zstd_file_open</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>s</name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">".z"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"gfile compression .z file is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>s</name> <operator>&amp;&amp;</operator> <call><name>strcasecmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>,<argument><expr><literal type="string">".zip"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>gfile_printf_then_putc_newline</name><argument_list>(<argument><expr><literal type="string">"gfile compression zip is not supported"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>response_code</name> <operator>=</operator> <literal type="number">415</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>response_string</name> <operator>=</operator> <literal type="string">"Unsupported File Type"</literal></expr>;</expr_stmt>

	<return>return <expr><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>gfile_close</name><parameter_list>(<parameter><decl><type><name>gfile_t</name><modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ret</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>close</name></name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>GPFXDIST</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>transform</name></name></expr>)</condition>
        <block>{<block_content>
			<expr_stmt><expr><call><name><name>fd</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if> 
        <else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<comment type="block">/*
			* for the compressed data implementation we need to call the "close" callback. Other implementations
			* didn't use to call this callback here and it will remain so.
			*/</comment>
			<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>compression</name></name> <operator>==</operator> <name>GZ_COMPRESSION</name> <operator>||</operator> <name><name>fd</name><operator>-&gt;</operator><name>compression</name></name> <operator>==</operator> <name>ZSTD_COMPRESSION</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name><name>fd</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>is_win_pipe</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name><name>fd</name><operator>-&gt;</operator><name>close</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if<condition>(<expr><name><name>fd</name><operator>-&gt;</operator><name>held_pipe_lock</name></name></expr>)</condition>
				<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
					<expr_stmt><expr><call><name>flock</name> <argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name></expr></argument>, <argument><expr><name>LOCK_UN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>ret</name> <operator>=</operator> <call><name>close_filefd</name><argument_list>(<argument><expr><name><name>fd</name><operator>-&gt;</operator><name>fd</name><operator>.</operator><name>filefd</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ret</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt> 
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>read</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fd</name><operator>-&gt;</operator><name>close</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type> 
<name>gfile_read</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>olen</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
	
	<while>while <condition>(<expr><name>len</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>i</name> <init>= <expr><call><name><name>fd</name><operator>-&gt;</operator><name>read</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	
	<return>return <expr><name>olen</name> <operator>-</operator> <name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>ssize_t</name></type> 
<name>gfile_write</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type> <name>olen</name> <init>= <expr><name>len</name></expr></init></decl>;</decl_stmt>
	
	<while>while <condition>(<expr><name>len</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ssize_t</name></type> <name>i</name> <init>= <expr><call><name><name>fd</name><operator>-&gt;</operator><name>write</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>i</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>char</name><operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>i</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>i</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	
	<return>return <expr><name>olen</name> <operator>-</operator> <name>len</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>off_t</name></type> <name>gfile_get_compressed_size</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_size</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>off_t</name></type> <name>gfile_get_compressed_position</name><parameter_list>(<parameter><decl><type><name>gfile_t</name> <modifier>*</modifier></type><name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>fd</name><operator>-&gt;</operator><name>compressed_position</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
