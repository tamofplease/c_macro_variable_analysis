<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/misc/guc.c"><comment type="block">/*--------------------------------------------------------------------
 * guc.c
 *
 * Support for grand unified configuration scheme, including SET
 * command, configuration file, and command line options.
 * See src/backend/utils/misc/README for more information.
 *
 *
 * Portions Copyright (c) 2005-2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Copyright (c) 2000-2019, PostgreSQL Global Development Group
 * Written by Peter Eisentraut &lt;peter_e@gmx.net&gt;.
 *
 * IDENTIFICATION
 *	  src/backend/utils/misc/guc.c
 *
 *--------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_POLL_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;poll.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syslog.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/commit_ts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog_internal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/namespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/async.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/prepare.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/user.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/vacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/variable.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/string.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"jit/jit.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/auth.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planmain.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_expr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/scansup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgworker_internals.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/fts.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/walwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/logicallauncher.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/slot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/syncrep.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walreceiver.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"replication/walsender.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm_impl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/standby.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/large_object.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/predicate.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_cache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/bytea.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/float.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_lsn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/plancache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/tzparser.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/xml.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_KRB_SRVTAB</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_KRB_SRVTAB</name></cpp:macro> <cpp:value>""</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIG_FILENAME</name></cpp:macro> <cpp:value>"postgresql.conf"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>HBA_FILENAME</name></cpp:macro>	<cpp:value>"pg_hba.conf"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IDENT_FILENAME</name></cpp:macro>	<cpp:value>"pg_ident.conf"</cpp:value></cpp:define>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIG_EXEC_PARAMS</name></cpp:macro> <cpp:value>"global/config_exec_params"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CONFIG_EXEC_PARAMS_NEW</name></cpp:macro> <cpp:value>"global/config_exec_params.new"</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Precision with which REAL type guc values are to be printed for GUC
 * serialization.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>REALTYPE_PRECISION</name></cpp:macro> <cpp:value>17</cpp:value></cpp:define>

<comment type="block">/* XXX these should appear in other modules' header files */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>Log_disconnections</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>	<name>CommitDelay</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>int</name></type>	<name>CommitSiblings</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>default_tablespace</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>temp_tablespaces</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>ignore_checksum_failure</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>synchronize_seqscans</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>SSLCipherSuites</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SYNCSCAN</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>trace_syncscan</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_BOUNDED_SORT</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>optimize_bounded_sort</name></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>GUC_check_errcode_value</name></decl>;</decl_stmt>

<comment type="block">/* global variables for check hook support */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>GUC_check_errmsg_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>GUC_check_errdetail_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>GUC_check_errhint_string</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_serialize</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>maxbytes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list> pg_attribute_printf<parameter_list>(</parameter_list>3<operator>,</operator> 4</function_decl>)<empty_stmt>;</empty_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_config_sourcefile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>,
								  <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_bool_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
								 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_int_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
								<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_real_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
								 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_string_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>,
								   <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>call_enum_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>,
								 <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_log_destination</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_log_destination</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_wal_consistency_checking</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
										   <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_wal_consistency_checking</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>syslog_facility</name> <init>= <expr><name>LOG_LOCAL0</name></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>syslog_facility</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_syslog_facility</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_syslog_ident</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_session_replication_role</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_temp_buffers</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_bonjour</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_ssl</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_stage_log_stats</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_log_stats</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_canonical_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_timezone_abbreviations</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_timezone_abbreviations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_archive_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_tcp_keepalives_idle</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_tcp_keepalives_interval</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_tcp_keepalives_count</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_tcp_user_timeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_tcp_keepalives_idle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_tcp_keepalives_interval</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_tcp_keepalives_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_tcp_user_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_maxconnections</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_max_worker_processes</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_autovacuum_max_workers</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_max_wal_senders</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_autovacuum_work_mem</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_effective_io_concurrency</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_client_connection_check_interval</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_effective_io_concurrency</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_pgstat_temp_directory</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_application_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_application_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_cluster_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_unix_socket_permissions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_log_file_mode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>show_data_directory_mode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_recovery_target_timeline</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_recovery_target_timeline</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_recovery_target</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_recovery_target</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_recovery_target_xid</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_recovery_target_xid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_recovery_target_time</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_recovery_target_time</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_recovery_target_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_recovery_target_name</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_recovery_target_lsn</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>assign_recovery_target_lsn</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_primary_slot_name</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_default_with_oids</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>defunct_int</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>	<name>defunct_bool</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>defunct_double</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* Private functions in guc-file.l that need to be called from guc.c */</comment>
<function_decl><type><specifier>static</specifier> <name>ConfigVariable</name> <modifier>*</modifier></type><name>ProcessConfigFileInternal</name><parameter_list>(<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
												 <parameter><decl><type><name>bool</name></type> <name>applySettings</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Options for enum values defined in this module.
 *
 * NOTE! Option values may not contain double quotes!
 */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>bytea_output_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"escape"</literal></expr>, <expr><name>BYTEA_OUTPUT_ESCAPE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"hex"</literal></expr>, <expr><name>BYTEA_OUTPUT_HEX</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * We have different sets for client and server message level options because
 * they sort slightly different (see "log" level), and because "fatal"/"panic"
 * aren't sensible for client_min_messages.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>client_message_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"debug5"</literal></expr>, <expr><name>DEBUG5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug4"</literal></expr>, <expr><name>DEBUG4</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug3"</literal></expr>, <expr><name>DEBUG3</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug2"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug1"</literal></expr>, <expr><name>DEBUG1</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"log"</literal></expr>, <expr><name>LOG</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"info"</literal></expr>, <expr><name>INFO</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"notice"</literal></expr>, <expr><name>NOTICE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"warning"</literal></expr>, <expr><name>WARNING</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"error"</literal></expr>, <expr><name>ERROR</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>server_message_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug5"</literal></expr>, <expr><name>DEBUG5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug4"</literal></expr>, <expr><name>DEBUG4</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug3"</literal></expr>, <expr><name>DEBUG3</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug2"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug1"</literal></expr>, <expr><name>DEBUG1</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"debug"</literal></expr>, <expr><name>DEBUG2</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"info"</literal></expr>, <expr><name>INFO</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"notice"</literal></expr>, <expr><name>NOTICE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"warning"</literal></expr>, <expr><name>WARNING</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"error"</literal></expr>, <expr><name>ERROR</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"log"</literal></expr>, <expr><name>LOG</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"fatal"</literal></expr>, <expr><name>FATAL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"panic"</literal></expr>, <expr><name>PANIC</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>intervalstyle_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"postgres"</literal></expr>, <expr><name>INTSTYLE_POSTGRES</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"postgres_verbose"</literal></expr>, <expr><name>INTSTYLE_POSTGRES_VERBOSE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"sql_standard"</literal></expr>, <expr><name>INTSTYLE_SQL_STANDARD</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"iso_8601"</literal></expr>, <expr><name>INTSTYLE_ISO_8601</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>log_error_verbosity_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"terse"</literal></expr>, <expr><name>PGERROR_TERSE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"default"</literal></expr>, <expr><name>PGERROR_DEFAULT</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"verbose"</literal></expr>, <expr><name>PGERROR_VERBOSE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>log_statement_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"none"</literal></expr>, <expr><name>LOGSTMT_NONE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ddl"</literal></expr>, <expr><name>LOGSTMT_DDL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"mod"</literal></expr>, <expr><name>LOGSTMT_MOD</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>LOGSTMT_ALL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>isolation_level_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"serializable"</literal></expr>, <expr><name>XACT_SERIALIZABLE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"repeatable read"</literal></expr>, <expr><name>XACT_REPEATABLE_READ</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"read committed"</literal></expr>, <expr><name>XACT_READ_COMMITTED</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"read uncommitted"</literal></expr>, <expr><name>XACT_READ_UNCOMMITTED</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>session_replication_role_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"origin"</literal></expr>, <expr><name>SESSION_REPLICATION_ROLE_ORIGIN</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"replica"</literal></expr>, <expr><name>SESSION_REPLICATION_ROLE_REPLICA</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local"</literal></expr>, <expr><name>SESSION_REPLICATION_ROLE_LOCAL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>syslog_facility_options</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"local0"</literal></expr>, <expr><name>LOG_LOCAL0</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local1"</literal></expr>, <expr><name>LOG_LOCAL1</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local2"</literal></expr>, <expr><name>LOG_LOCAL2</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local3"</literal></expr>, <expr><name>LOG_LOCAL3</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local4"</literal></expr>, <expr><name>LOG_LOCAL4</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local5"</literal></expr>, <expr><name>LOG_LOCAL5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local6"</literal></expr>, <expr><name>LOG_LOCAL6</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"local7"</literal></expr>, <expr><name>LOG_LOCAL7</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr><block>{<expr><literal type="string">"none"</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>track_function_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"none"</literal></expr>, <expr><name>TRACK_FUNC_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"pl"</literal></expr>, <expr><name>TRACK_FUNC_PL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"all"</literal></expr>, <expr><name>TRACK_FUNC_ALL</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>xmlbinary_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"base64"</literal></expr>, <expr><name>XMLBINARY_BASE64</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"hex"</literal></expr>, <expr><name>XMLBINARY_HEX</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>xmloption_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"content"</literal></expr>, <expr><name>XMLOPTION_CONTENT</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"document"</literal></expr>, <expr><name>XMLOPTION_DOCUMENT</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Although only "on", "off", and "safe_encoding" are documented, we
 * accept all the likely variants of "on" and "off".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>backslash_quote_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"safe_encoding"</literal></expr>, <expr><name>BACKSLASH_QUOTE_SAFE_ENCODING</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>BACKSLASH_QUOTE_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>BACKSLASH_QUOTE_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>BACKSLASH_QUOTE_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>BACKSLASH_QUOTE_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>BACKSLASH_QUOTE_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>BACKSLASH_QUOTE_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>BACKSLASH_QUOTE_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>BACKSLASH_QUOTE_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Although only "on", "off", and "partition" are documented, we
 * accept all the likely variants of "on" and "off".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>constraint_exclusion_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"partition"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_PARTITION</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>CONSTRAINT_EXCLUSION_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Although only "on", "off", "remote_apply", "remote_write", and "local" are
 * documented, we accept all the likely variants of "on" and "off".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>synchronous_commit_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"local"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_LOCAL_FLUSH</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"remote_write"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_REMOTE_WRITE</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"remote_apply"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_REMOTE_APPLY</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>SYNCHRONOUS_COMMIT_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Although only "on", "off", "try" are documented, we accept all the likely
 * variants of "on" and "off".
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>huge_pages_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>HUGE_PAGES_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>HUGE_PAGES_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"try"</literal></expr>, <expr><name>HUGE_PAGES_TRY</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>HUGE_PAGES_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>HUGE_PAGES_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>HUGE_PAGES_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>HUGE_PAGES_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>HUGE_PAGES_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>HUGE_PAGES_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>force_parallel_mode_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"off"</literal></expr>, <expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>FORCE_PARALLEL_ON</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"regress"</literal></expr>, <expr><name>FORCE_PARALLEL_REGRESS</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>FORCE_PARALLEL_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"false"</literal></expr>, <expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>FORCE_PARALLEL_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"no"</literal></expr>, <expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>FORCE_PARALLEL_ON</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>plan_cache_mode_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"auto"</literal></expr>, <expr><name>PLAN_CACHE_MODE_AUTO</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"force_generic_plan"</literal></expr>, <expr><name>PLAN_CACHE_MODE_FORCE_GENERIC_PLAN</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"force_custom_plan"</literal></expr>, <expr><name>PLAN_CACHE_MODE_FORCE_CUSTOM_PLAN</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * password_encryption used to be a boolean, so accept all the likely
 * variants of "on", too. "off" used to store passwords in plaintext,
 * but we don't support that anymore.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>password_encryption_options</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"md5"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"scram-sha-256"</literal></expr>, <expr><name>PASSWORD_TYPE_SCRAM_SHA_256</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"on"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"true"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yes"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"1"</literal></expr>, <expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>true</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>ssl_protocol_versions_info</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">""</literal></expr>, <expr><name>PG_TLS_ANY</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TLSv1"</literal></expr>, <expr><name>PG_TLS1_VERSION</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TLSv1.1"</literal></expr>, <expr><name>PG_TLS1_1_VERSION</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TLSv1.2"</literal></expr>, <expr><name>PG_TLS1_2_VERSION</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TLSv1.3"</literal></expr>, <expr><name>PG_TLS1_3_VERSION</name></expr>, <expr><name>false</name></expr>}</block></expr>,
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>shared_memory_options</name><index>[]</index></name> <init>= <expr><block>{
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<expr><block>{<expr><literal type="string">"sysv"</literal></expr>, <expr><name>SHMEM_TYPE_SYSV</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifndef>
	<expr><block>{<expr><literal type="string">"mmap"</literal></expr>, <expr><name>SHMEM_TYPE_MMAP</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<expr><block>{<expr><literal type="string">"windows"</literal></expr>, <expr><name>SHMEM_TYPE_WINDOWS</name></expr>, <expr><name>false</name></expr>}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Options for enum values stored in other modules
 */</comment>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>wal_level_options</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>archive_mode_options</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>recovery_target_action_options</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>sync_method_options</name><index>[]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>extern</specifier> <specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name></type> <name><name>dynamic_shared_memory_options</name><index>[]</index></name></decl>;</decl_stmt>

<comment type="block">/*
 * GUC option variables that are exported from this module
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_duration</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_print_plan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_print_parse</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_print_rewritten</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>Debug_pretty_print</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>log_parser_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_planner_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_executor_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_statement_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* this is sort of all three above
											 * together */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>log_btree_build_stats</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>event_source</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>bool</name></type>		<name>row_security</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>check_function_bodies</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * This GUC exists solely for backward compatibility, check its definition for
 * details.
 */</comment>
<decl_stmt><decl><type><name>bool</name></type>		<name>default_with_oids</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>session_auth_is_superuser</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>log_min_error_statement</name> <init>= <expr><name>ERROR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>log_min_messages</name> <init>= <expr><name>WARNING</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>client_min_messages</name> <init>= <expr><name>NOTICE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>log_min_duration_statement</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>log_temp_files</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>log_statement_sample_rate</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>double</name></type>		<name>log_xact_sample_rate</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>trace_recovery_messages</name> <init>= <expr><name>LOG</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>temp_file_limit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>num_temp_buffers</name> <init>= <expr><literal type="number">1024</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cluster_name</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ConfigFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>HbaFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>IdentFileName</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>external_pid_file</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>pgstat_temp_directory</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>application_name</name></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name></type>			<name>tcp_keepalives_idle</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>tcp_keepalives_interval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>tcp_keepalives_count</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>			<name>tcp_user_timeout</name></decl>;</decl_stmt>

<comment type="block">/*
 * SSL renegotiation was been removed in PostgreSQL 9.5, but we tolerate it
 * being set to zero (meaning never renegotiate) for backward compatibility.
 * This avoids breaking compatibility with clients that have never supported
 * renegotiation and therefore always try to zero it.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>ssl_renegotiation_limit</name></decl>;</decl_stmt>

<comment type="block">/*
 * This really belongs in pg_shmem.c, but is defined here so that it doesn't
 * need to be duplicated in all the different implementations of pg_shmem.c.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>huge_pages</name></decl>;</decl_stmt>

<comment type="block">/*
 * These variables are all dummies that don't do anything, except in some
 * cases provide the value for SHOW to display.  The real state is elsewhere
 * and is kept in sync by assign_hooks.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>syslog_ident_str</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>double</name></type> <name>phony_random_seed</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>client_encoding_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>datestyle_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>locale_collate</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>locale_ctype</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>server_encoding_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>server_version_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>server_version_num</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>timezone_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>log_timezone_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>timezone_abbreviations_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>data_directory</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>session_authorization_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_function_args</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_index_keys</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>max_identifier_length</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>block_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>segment_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>wal_block_size</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>data_checksums</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>integer_datetimes</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>assert_enabled</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recovery_target_timeline_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recovery_target_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recovery_target_xid_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recovery_target_name_string</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>recovery_target_lsn_string</name></decl>;</decl_stmt>


<comment type="block">/* should be static, but commands/variable.c needs to get at this */</comment>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>role_string</name></decl>;</decl_stmt>


<comment type="block">/*
 * Displayable names for context types (enum GucContext)
 *
 * Note: these strings are deliberately not localized.
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>GucContext_Names</name><index>[]</index></name> <init>=
<expr><block>{
	 <comment type="block">/* PGC_INTERNAL */</comment> <expr><literal type="string">"internal"</literal></expr>,
	 <comment type="block">/* PGC_POSTMASTER */</comment> <expr><literal type="string">"postmaster"</literal></expr>,
	 <comment type="block">/* PGC_SIGHUP */</comment> <expr><literal type="string">"sighup"</literal></expr>,
	 <comment type="block">/* PGC_SU_BACKEND */</comment> <expr><literal type="string">"superuser-backend"</literal></expr>,
	 <comment type="block">/* PGC_BACKEND */</comment> <expr><literal type="string">"backend"</literal></expr>,
	 <comment type="block">/* PGC_SUSET */</comment> <expr><literal type="string">"superuser"</literal></expr>,
	 <comment type="block">/* PGC_USERSET */</comment> <expr><literal type="string">"user"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Displayable names for source types (enum GucSource)
 *
 * Note: these strings are deliberately not localized.
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>GucSource_Names</name><index>[]</index></name> <init>=
<expr><block>{
	 <comment type="block">/* PGC_S_DEFAULT */</comment> <expr><literal type="string">"default"</literal></expr>,
	 <comment type="block">/* PGC_S_DYNAMIC_DEFAULT */</comment> <expr><literal type="string">"default"</literal></expr>,
	 <comment type="block">/* PGC_S_ENV_VAR */</comment> <expr><literal type="string">"environment variable"</literal></expr>,
	 <comment type="block">/* PGC_S_FILE */</comment> <expr><literal type="string">"configuration file"</literal></expr>,
	 <comment type="block">/* PGC_S_ARGV */</comment> <expr><literal type="string">"command line"</literal></expr>,
	 <comment type="block">/* PGC_S_GLOBAL */</comment> <expr><literal type="string">"global"</literal></expr>,
	 <comment type="block">/* PGC_S_DATABASE */</comment> <expr><literal type="string">"database"</literal></expr>,
	 <comment type="block">/* PGC_S_USER */</comment> <expr><literal type="string">"user"</literal></expr>,
	 <comment type="block">/* PGC_S_DATABASE_USER */</comment> <expr><literal type="string">"database user"</literal></expr>,
	 <comment type="block">/* PGC_S_CLIENT */</comment> <expr><literal type="string">"client"</literal></expr>,
	 <comment type="block">/* PGC_S_RESGROUP */</comment> <expr><literal type="string">"resource group"</literal></expr>,
	 <comment type="block">/* PGC_S_OVERRIDE */</comment> <expr><literal type="string">"override"</literal></expr>,
	 <comment type="block">/* PGC_S_INTERACTIVE */</comment> <expr><literal type="string">"interactive"</literal></expr>,
	 <comment type="block">/* PGC_S_TEST */</comment> <expr><literal type="string">"test"</literal></expr>,
	 <comment type="block">/* PGC_S_SESSION */</comment> <expr><literal type="string">"session"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Displayable names for the groupings defined in enum config_group
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>config_group_names</name><index>[]</index></name> <init>=
<expr><block>{
	<comment type="block">/* UNGROUPED */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Ungrouped"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* FILE_LOCATIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"File Locations"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CONN_AUTH */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Connections and Authentication"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CONN_AUTH_SETTINGS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Connections and Authentication / Connection Settings"</literal></expr></argument>)</argument_list></call></expr>,
    <comment type="block">/* CONN_AUTH_AUTH */</comment>
    <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Connections and Authentication / Authentication"</literal></expr></argument>)</argument_list></call></expr>,
    <comment type="block">/* CONN_AUTH_SSL */</comment>
    <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Connections and Authentication / SSL"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* EXTERNAL_TABLES */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"External Tables"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* APPENDONLY_TABLES */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Append-Only Tables"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_MEM */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Memory"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_DISK */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Disk"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_KERNEL */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Kernel Resources"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_VACUUM_DELAY */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Cost-Based Vacuum Delay"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_BGWRITER */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Background Writer"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_ASYNCHRONOUS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Asynchronous Behavior"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* RESOURCES_MGM */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Resource Usage / Resources Management"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL_SETTINGS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log / Settings"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL_CHECKPOINTS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log / Checkpoints"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL_ARCHIVING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log / Archiving"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL_ARCHIVE_RECOVERY */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log / Archive Recovery"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* WAL_RECOVERY_TARGET */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write-Ahead Log / Recovery Target"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION_SENDING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication / Sending Servers"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION_MASTER */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication / Master Server"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION_STANDBY */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication / Standby Servers"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* REPLICATION_SUBSCRIBERS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Replication / Subscribers"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* QUERY_TUNING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Query Tuning"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* QUERY_TUNING_METHOD */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Query Tuning / Planner Method Configuration"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* QUERY_TUNING_COST */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Query Tuning / Planner Cost Constants"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* QUERY_TUNING_OTHER */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Query Tuning / Other Planner Options"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOGGING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reporting and Logging"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOGGING_WHERE */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reporting and Logging / Where to Log"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOGGING_WHEN */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reporting and Logging / When to Log"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOGGING_WHAT */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reporting and Logging / What to Log"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* PROCESS_TITLE */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Process Title"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* STATS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Statistics"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* STATS_ANALYZE */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Statistics / ANALYZE Database Contents"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* STATS_MONITORING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Statistics / Monitoring"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* STATS_COLLECTOR */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Statistics / Query and Index Statistics Collector"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* AUTOVACUUM */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Autovacuum"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN_STATEMENT */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults / Statement Behavior"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN_LOCALE */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults / Locale and Formatting"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN_PRELOAD */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults / Shared Library Preloading"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CLIENT_CONN_OTHER */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Client Connection Defaults / Other Defaults"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* LOCK_MANAGEMENT */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lock Management"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* COMPAT_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version and Platform Compatibility"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* COMPAT_OPTIONS_PREVIOUS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version and Platform Compatibility / Previous PostgreSQL Versions"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* COMPAT_OPTIONS_CLIENT */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version and Platform Compatibility / Other Platforms and Clients"</literal></expr></argument>)</argument_list></call></expr>,
    <comment type="block">/* COMPAT_OPTIONS_IGNORED */</comment>
    <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Version and Platform Compatibility / Ignored"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* ERROR_HANDLING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Error Handling"</literal></expr></argument>)</argument_list></call></expr>,
    <comment type="block">/* GP_ARRAY_CONFIGURATION */</comment>
    <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><name>PACKAGE_NAME</name> <literal type="string">" / Array Configuration"</literal></expr></argument>)</argument_list></call></expr>,
    <comment type="block">/* GP_ARRAY_TUNING */</comment>
    <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><name>PACKAGE_NAME</name> <literal type="string">" / Array Tuning"</literal></expr></argument>)</argument_list></call></expr>,
    <comment type="block">/* GP_WORKER_IDENTITY */</comment>
    <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><name>PACKAGE_NAME</name> <literal type="string">" / Worker Process Identity"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* GP_ERROR_HANDLING */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"GPDB Error Handling"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* PRESET_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Preset Options"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* CUSTOM_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Customized Options"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* DEVELOPER_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Developer Options"</literal></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* DEPRECATED_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Deprecated Options"</literal></expr></argument>)</argument_list></call></expr>,
	<comment type="block">/* DEFUNCT_OPTIONS */</comment>
	<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Defunct Options"</literal></expr></argument>)</argument_list></call></expr>,

	<comment type="block">/* help_config wants this array to be null-terminated */</comment>
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Displayable names for GUC variable types (enum config_type)
 *
 * Note: these strings are deliberately not localized.
 */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>config_type_names</name><index>[]</index></name> <init>=
<expr><block>{
	 <comment type="block">/* PGC_BOOL */</comment> <expr><literal type="string">"bool"</literal></expr>,
	 <comment type="block">/* PGC_INT */</comment> <expr><literal type="string">"integer"</literal></expr>,
	 <comment type="block">/* PGC_REAL */</comment> <expr><literal type="string">"real"</literal></expr>,
	 <comment type="block">/* PGC_STRING */</comment> <expr><literal type="string">"string"</literal></expr>,
	 <comment type="block">/* PGC_ENUM */</comment> <expr><literal type="string">"enum"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Unit conversion tables.
 *
 * There are two tables, one for memory units, and another for time units.
 * For each supported conversion from one unit to another, we have an entry
 * in the table.
 *
 * To keep things simple, and to avoid possible roundoff error,
 * conversions are never chained.  There needs to be a direct conversion
 * between all units (of the same type).
 *
 * The conversions for each base unit must be kept in order from greatest to
 * smallest human-friendly unit; convert_xxx_from_base_unit() rely on that.
 * (The order of the base-unit groups does not matter.)
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_UNIT_LEN</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>	<comment type="block">/* length of longest recognized unit string */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>char</name></type>		<name><name>unit</name><index>[<expr><name>MAX_UNIT_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* unit, as a string, like "kB" or
										 * "min" */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>base_unit</name></decl>;</decl_stmt>		<comment type="block">/* GUC_UNIT_XXX */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>multiplier</name></decl>;</decl_stmt>		<comment type="block">/* Factor for converting unit -&gt; base_unit */</comment>
}</block></struct></type> <name>unit_conversion</name>;</typedef>

<comment type="block">/* Ensure that the constants in the tables don't overflow or underflow */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name><name>BLCKSZ</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1024</literal> <operator>||</operator> <name>BLCKSZ</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> BLCKSZ must be between 1KB and 1MB</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name><name>XLOG_BLCKSZ</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1024</literal> <operator>||</operator> <name>XLOG_BLCKSZ</name></expr></argument> &gt;</argument_list></name> <argument_list>(<argument><expr><literal type="number">1024</literal><operator>*</operator><literal type="number">1024</literal></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:error>#<cpp:directive>error</cpp:directive> XLOG_BLCKSZ must be between 1KB and 1MB</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>memory_units_hint</name> <init>= <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Valid units for this parameter are \"B\", \"kB\", \"MB\", \"GB\", and \"TB\"."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unit_conversion</name></type> <name><name>memory_unit_conversion_table</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_BYTE</name></expr>, <expr><literal type="number">1.0</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><literal type="number">1.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_KB</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <literal type="number">1024.0</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><literal type="number">1.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <literal type="number">1024.0</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_MB</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal><operator>)</operator></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><operator>(</operator><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><operator>(</operator><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><literal type="number">1024.0</literal> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_BLOCKS</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <name>BLCKSZ</name></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"TB"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><operator>(</operator><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"GB"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><operator>(</operator><literal type="number">1024.0</literal> <operator>*</operator> <literal type="number">1024.0</literal><operator>)</operator> <operator>/</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MB"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><literal type="number">1024.0</literal> <operator>/</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"kB"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><name>GUC_UNIT_XBLOCKS</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <name>XLOG_BLCKSZ</name></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">""</literal></expr>}</block></expr>						<comment type="block">/* end of table marker */</comment>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>time_units_hint</name> <init>= <expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Valid units for this parameter are \"us\", \"ms\", \"s\", \"min\", \"h\", and \"d\"."</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>unit_conversion</name></type> <name><name>time_unit_conversion_table</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1000</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">24</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"h"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1000</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"min"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1000</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"s"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1000</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ms"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"us"</literal></expr>, <expr><name>GUC_UNIT_MS</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <literal type="number">1000</literal></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal> <operator>*</operator> <literal type="number">24</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"h"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"min"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"s"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ms"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <literal type="number">1000</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"us"</literal></expr>, <expr><name>GUC_UNIT_S</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">24</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"h"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"min"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><literal type="number">1</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"s"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <literal type="number">60</literal></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ms"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><literal type="number">1000</literal> <operator>*</operator> <literal type="number">60</literal><operator>)</operator></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"us"</literal></expr>, <expr><name>GUC_UNIT_MIN</name></expr>, <expr><literal type="number">1.0</literal> <operator>/</operator> <operator>(</operator><literal type="number">1000</literal> <operator>*</operator> <literal type="number">1000</literal> <operator>*</operator> <literal type="number">60</literal><operator>)</operator></expr>}</block></expr>,

	<expr><block>{<expr><literal type="string">""</literal></expr>}</block></expr>						<comment type="block">/* end of table marker */</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Contents of GUC tables
 *
 * See src/backend/utils/misc/README for design notes.
 *
 * TO ADD AN OPTION:
 *
 * 1. Declare a global variable of type bool, int, double, or char*
 *	  and make use of it.
 *
 * 2. Decide at what times it's safe to set the option. See guc.h for
 *	  details.
 *
 * 3. Decide on a name, a default value, upper and lower bounds (if
 *	  applicable), etc.
 *
 * 4. Add a record below.
 *
 * 5. Add it to src/backend/utils/misc/postgresql.conf.sample, if
 *	  appropriate.
 *
 * 6. Don't forget to document the option (at least in config.sgml).
 *
 * 7. If it's a new GUC_LIST_QUOTE option, you must add it to
 *	  variable_is_guc_list_quote() in src/bin/pg_dump/dumputils.c.
 *
 * 8. In gpdb, the guc is force explicit declare whether it needs to sync value
 * 	  between master and primary. Add guc name into either sync_guc_names_array
 * 	  or unsync_guc_names_array.
 */</comment>


<comment type="block" format="doxygen">/******** option records follow ********/</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_bool</name></name></type> <name><name>ConfigureNamesBool</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_seqscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of sequential-scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_seqscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_indexscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of index-scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_indexscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_indexonlyscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of index-only-scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_indexonlyscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_bitmapscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of bitmap-scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_bitmapscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_tidscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of TID scan plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_tidscan</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_sort"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of explicit sort steps."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_sort</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_hashagg"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of hashed aggregation plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_hashagg</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_hashagg_disk"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of hashed aggregation plans that are expected to exceed work_mem."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_hashagg_disk</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_groupingsets_hash_disk"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of hashed aggregation plans for groupingsets when the total size of the hash tables is expected to exceed work_mem."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_groupingsets_hash_disk</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_material"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of materialization."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_material</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_nestloop"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of nested-loop join plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_nestloop</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_mergejoin"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of merge join plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_mergejoin</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_hashjoin"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of hash join plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_hashjoin</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_gathermerge"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of gather merge plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_gathermerge</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_partitionwise_join"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables partitionwise join."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_partitionwise_join</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_partitionwise_aggregate"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables partitionwise aggregation and grouping."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_partitionwise_aggregate</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_parallel_append"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of parallel append plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_parallel_append</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_parallel_hash"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner's use of parallel hash plans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_parallel_hash</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"enable_partition_pruning"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable plan-time and run-time partition pruning."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allows the query planner and executor to compare partition "</literal>
						 <literal type="string">"bounds to conditions in the query to determine which "</literal>
						 <literal type="string">"partitions must be scanned."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_partition_pruning</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Unused. Syntax check only for PostgreSQL compatibility."</literal></expr></argument>)</argument_list></call></expr>,
            <expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>defunct_bool</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Not for general use --- used by SET SESSION AUTHORIZATION */</comment>
		<expr><block>{<expr><literal type="string">"is_superuser"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows whether the current user is a superuser."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>session_auth_is_superuser</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"bonjour"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables advertising the server via Bonjour."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enable_bonjour</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_bonjour</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_commit_timestamp"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects transaction commit time."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>track_commit_timestamp</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables SSL connections."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>EnableSSL</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_ssl</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_passphrase_command_supports_reload"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Also use ssl_passphrase_command during server reload."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_passphrase_command_supports_reload</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_prefer_server_ciphers"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Give priority to server ciphersuite order."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SSLPreferServerCiphers</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"fsync"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Forces synchronization of updates to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The server will use the fsync() system call in several places to make "</literal>
						 <literal type="string">"sure that updates are physically written to disk. This insures "</literal>
						 <literal type="string">"that a database cluster will recover to a consistent state after "</literal>
						 <literal type="string">"an operating system or hardware crash."</literal></expr></argument>)</argument_list></call></expr>,
		  <expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>enableFsync</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"ignore_checksum_failure"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Continues processing after a checksum failure."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Detection of a checksum failure normally causes PostgreSQL to "</literal>
						 <literal type="string">"report an error, aborting the current transaction. Setting "</literal>
						 <literal type="string">"ignore_checksum_failure to true causes the system to ignore the failure "</literal>
						 <literal type="string">"(but still report a warning), and continue processing. This "</literal>
						 <literal type="string">"behavior could cause crashes or other serious problems. Only "</literal>
						 <literal type="string">"has an effect if checksums are enabled."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ignore_checksum_failure</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"zero_damaged_pages"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Continues processing past damaged page headers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Detection of a damaged page header normally causes PostgreSQL to "</literal>
						 <literal type="string">"report an error, aborting the current transaction. Setting "</literal>
						 <literal type="string">"zero_damaged_pages to true causes the system to instead report a "</literal>
						 <literal type="string">"warning, zero out the damaged page, and continue processing. This "</literal>
						 <literal type="string">"behavior will destroy data, namely all the rows on the damaged page."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>zero_damaged_pages</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"full_page_writes"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes full pages to WAL when first modified after a checkpoint."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A page write in process during an operating system crash might be "</literal>
						 <literal type="string">"only partially written to disk.  During recovery, the row changes "</literal>
						 <literal type="string">"stored in WAL are not enough to recover.  This option writes "</literal>
						 <literal type="string">"pages when first modified after a checkpoint to WAL so full recovery "</literal>
						 <literal type="string">"is possible."</literal></expr></argument>)</argument_list></call></expr>,
			 <expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>fullPageWrites</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_log_hints"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes full pages to WAL when first modified after a checkpoint, even for a non-critical modifications."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_log_hints</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_compression"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Compresses full-page writes written in WAL file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_compression</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_init_zero"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes zeroes to new WAL files before first use."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_init_zero</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_recycle"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Recycles WAL files by renaming them."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_recycle</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_checkpoints"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each checkpoint."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_checkpoints</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_connections"</literal></expr>, <expr><name>PGC_SU_BACKEND</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each successful connection."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_connections</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_disconnections"</literal></expr>, <expr><name>PGC_SU_BACKEND</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs end of a session, including duration."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_disconnections</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_replication_commands"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each replication command."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_replication_commands</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_assertions"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows whether the running server has assertion checks enabled."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>assert_enabled</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<expr><name>true</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><name>false</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"exit_on_error"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>ERROR_HANDLING_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Terminate session on any error."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ExitOnAnyError</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"restart_after_crash"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>ERROR_HANDLING_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Reinitialize server after backend crash."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>restart_after_crash</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_duration"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs the duration of each completed SQL statement."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_duration</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_print_parse"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each query's parse tree."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_print_parse</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_print_rewritten"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each query's rewritten parse tree."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_print_rewritten</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_print_plan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs each query's execution plan."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_print_plan</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_pretty_print"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Indents parse and plan tree displays."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_pretty_print</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_parser_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_MONITORING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes parser performance statistics to the server log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_parser_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_stage_log_stats</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_planner_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_MONITORING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes planner performance statistics to the server log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_planner_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_stage_log_stats</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_executor_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_MONITORING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes executor performance statistics to the server log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_executor_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_stage_log_stats</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_statement_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_MONITORING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes cumulative performance statistics to the server log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_statement_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_log_stats</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>BTREE_BUILD_STATS</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_btree_build_stats"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs system resource usage statistics (memory and CPU) on various B-tree operations."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_btree_build_stats</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_activities"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects information about executing commands."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Enables the collection of information on the currently "</literal>
						 <literal type="string">"executing command of each session, along with "</literal>
						 <literal type="string">"the time at which that command began execution."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_track_activities</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_counts"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects statistics on database activity."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_track_counts</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_io_timing"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects timing statistics for database I/O activity."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>track_io_timing</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"update_process_title"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>PROCESS_TITLE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Updates the process title to show the active SQL command."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Enables updating of the process title every time a new SQL command is received by the server."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>update_process_title</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<expr><name>false</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><name>true</name></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Starts the autovacuum subprocess."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_start_daemon</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_notify"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Generates debugging output for LISTEN and NOTIFY."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_notify</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_locks"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emits information about lock usage."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_locks</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_userlocks"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emits information about user lock usage."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_userlocks</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_lwlocks"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emits information about lightweight lock usage."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_lwlocks</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"debug_deadlocks"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Dumps information about all current locks when a deadlock timeout occurs."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Debug_deadlocks</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_lock_waits"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs long lock waits."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_lock_waits</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_hostname"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Logs the host name in the connection logs."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"By default, connection logs only show the IP address "</literal>
						 <literal type="string">"of the connecting host. If you want them to show the host name you "</literal>
						 <literal type="string">"can turn this on, but depending on your host name resolution "</literal>
						 <literal type="string">"setup it might impose a non-negligible performance penalty."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_hostname</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"transform_null_equals"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_CLIENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Treats \"expr=NULL\" as \"expr IS NULL\"."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"When turned on, expressions of the form expr = NULL "</literal>
						 <literal type="string">"(or NULL = expr) are treated as expr IS NULL, that is, they "</literal>
						 <literal type="string">"return true if expr evaluates to the null value, and false "</literal>
						 <literal type="string">"otherwise. The correct behavior of expr = NULL is to always "</literal>
						 <literal type="string">"return null (unknown)."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Transform_null_equals</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"db_user_namespace"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables per-database user names."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Db_user_namespace</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_transaction_read_only"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the default read-only status of new transactions."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>DefaultXactReadOnly</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"transaction_read_only"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the current transaction's read-only status."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XactReadOnly</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_transaction_read_only</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_transaction_deferrable"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the default deferrable status of new transactions."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>DefaultXactDeferrable</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"transaction_deferrable"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Whether to defer a read-only serializable transaction until it can be executed with no possible serialization failures."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XactDeferrable</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_transaction_deferrable</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"row_security"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable row security."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"When enabled, row security will be applied to all users."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>row_security</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"check_function_bodies"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Check function bodies during CREATE FUNCTION."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>check_function_bodies</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"array_nulls"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable input of NULL elements in arrays."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"When turned on, unquoted NULL in an array input "</literal>
						 <literal type="string">"value means a null value; "</literal>
						 <literal type="string">"otherwise it is taken literally."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Array_nulls</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * WITH OIDS support, and consequently default_with_oids, was removed in
	 * PostgreSQL 12, but we tolerate the parameter being set to false to
	 * avoid unnecessarily breaking older dump files.
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_with_oids"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"WITH OIDS is no longer supported; this can only be false."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>default_with_oids</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>check_default_with_oids</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"logging_collector"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Start a subprocess to capture stderr output and/or csvlogs into log files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Logging_collector</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_truncate_on_rotation"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Truncate existing log files of same name during log rotation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_truncate_on_rotation</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_sort"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emit information about resource usage in sorting."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>trace_sort</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>TRACE_SYNCSCAN</name></cpp:ifdef>
	<comment type="block">/* this is undocumented because not exposed in a standard build */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_syncscan"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Generate debugging output for synchronized scanning."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>trace_syncscan</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_BOUNDED_SORT</name></cpp:ifdef>
	<comment type="block">/* this is undocumented because not exposed in a standard build */</comment>
	<expr><block>{
		<expr><block>{
			<expr><literal type="string">"optimize_bounded_sort"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_METHOD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable bounded sorting using heap sort."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>optimize_bounded_sort</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WAL_DEBUG</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_debug"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emit WAL-related debugging output."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLOG_DEBUG</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"integer_datetimes"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Datetimes are integer based."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>integer_datetimes</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"krb_caseins_users"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets whether Kerberos and GSSAPI user names should be treated as case-insensitive."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pg_krb_caseins_users</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"escape_string_warning"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Warn about backslash escapes in ordinary string literals."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>escape_string_warning</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"standard_conforming_strings"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Causes '...' strings to treat backslashes literally."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>standard_conforming_strings</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"synchronize_seqscans"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enable synchronized sequential scans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>synchronize_seqscans</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_target_inclusive"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_RECOVERY_TARGET</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets whether to include or exclude transaction with recovery target."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recoveryTargetInclusive</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"hot_standby"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allows connections and queries during recovery."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>EnableHotStandby</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"hot_standby_feedback"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allows feedback from a hot standby to the primary that will avoid query conflicts."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>hot_standby_feedback</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"allow_system_table_mods"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CUSTOM_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allows modifications of the structure of system tables."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>allowSystemTableMods</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ignore_system_indexes"</literal></expr>, <expr><name>PGC_BACKEND</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Disables reading from system indexes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"It does not prevent updating the indexes, so it is safe "</literal>
						 <literal type="string">"to use.  The worst consequence is slowness."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>IgnoreSystemIndexes</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lo_compat_privileges"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables backward compatibility mode for privilege checks on large objects."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Skips privilege checks when reading or modifying large objects, "</literal>
						 <literal type="string">"for compatibility with PostgreSQL releases prior to 9.0."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>lo_compat_privileges</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"operator_precedence_warning"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Emit a warning for constructs that changed meaning since PostgreSQL 9.4."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>operator_precedence_warning</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"quote_all_identifiers"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"When generating SQL fragments, quote all identifiers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>quote_all_identifiers</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"data_checksums"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows whether data checksums are turned on for this cluster."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>data_checksums</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"syslog_sequence_numbers"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Add sequence number to syslog messages to avoid duplicate suppression."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>syslog_sequence_numbers</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"syslog_split_messages"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Split messages sent to syslog by lines and to fit into 1024 bytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>syslog_split_messages</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"parallel_leader_participation"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Controls whether Gather and Gather Merge also run subplans."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Should gather nodes also run subplans, or just gather tuples?"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>parallel_leader_participation</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allow JIT compilation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_enabled</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_debugging_support"</literal></expr>, <expr><name>PGC_SU_BACKEND</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Register JIT compiled function with debugger."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_debugging_support</name></expr>,
		<expr><name>false</name></expr>,

		<comment type="block">/*
		 * This is not guaranteed to be available, but given it's a developer
		 * oriented option, it doesn't seem worth adding code checking
		 * availability.
		 */</comment>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_dump_bitcode"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write out LLVM bitcode to facilitate JIT debugging."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_dump_bitcode</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_expressions"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allow JIT compilation of expressions."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_expressions</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_profiling_support"</literal></expr>, <expr><name>PGC_SU_BACKEND</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Register JIT compiled function with perf profiler."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_profiling_support</name></expr>,
		<expr><name>false</name></expr>,

		<comment type="block">/*
		 * This is not guaranteed to be available, but given it's a developer
		 * oriented option, it doesn't seem worth adding code checking
		 * availability.
		 */</comment>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_tuple_deforming"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allow JIT compilation of tuple deforming."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_tuple_deforming</name></expr>,
		<expr><name>true</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"data_sync_retry"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>ERROR_HANDLING_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Whether to continue running after a failure to sync data files."</literal></expr></argument>)</argument_list></call></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>data_sync_retry</name></expr>,
		<expr><name>false</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><name>false</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_int</name></name></type> <name><name>ConfigureNamesInt</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{<expr><literal type="string">"archive_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_ARCHIVING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Forces a switch to the next WAL file if a "</literal>
						 <literal type="string">"new file has not been started within N seconds."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLogArchiveTimeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"post_auth_delay"</literal></expr>, <expr><name>PGC_BACKEND</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Waits N seconds on connection startup after authentication."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This allows attaching a debugger to the process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PostAuthDelay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_statistics_target"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>STATS_ANALYZE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the default statistics target."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"This applies to table columns that have not had a "</literal>
						 <literal type="string">"column-specific target set via ALTER TABLE SET STATISTICS."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>default_statistics_target</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"from_collapse_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the FROM-list size beyond which subqueries "</literal>
						 <literal type="string">"are not collapsed."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The planner will merge subqueries into upper "</literal>
						 <literal type="string">"queries if the resulting FROM list would have no more than "</literal>
						 <literal type="string">"this many items."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>from_collapse_limit</name></expr>,
		<expr><literal type="number">20</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"join_collapse_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the FROM-list size beyond which JOIN "</literal>
						 <literal type="string">"constructs are not flattened."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The planner will flatten explicit JOIN "</literal>
						 <literal type="string">"constructs into lists of FROM items whenever a "</literal>
						 <literal type="string">"list of no more than this many items would result."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>join_collapse_limit</name></expr>,
		<expr><literal type="number">20</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_threshold"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Unused. Syntax check only for PostgreSQL compatibility."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>defunct_int</name></expr>,
		<expr><literal type="number">12</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_effort"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Unused. Syntax check only for PostgreSQL compatibility."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>defunct_int</name></expr>,
		<comment type="line">//DEFAULT_GEQO_EFFORT, MIN_GEQO_EFFORT, MAX_GEQO_EFFORT,</comment>
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_pool_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Unused. Syntax check only for PostgreSQL compatibility."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>defunct_int</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_generations"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Unused. Syntax check only for PostgreSQL compatibility."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>defunct_int</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* This is PGC_SUSET to prevent hiding from log_lock_waits. */</comment>
		<expr><block>{<expr><literal type="string">"deadlock_timeout"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time to wait on a lock before checking for deadlock."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>DeadlockTimeout</name></expr>,
		<expr><literal type="number">1000</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_standby_archive_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum delay before canceling queries when a hot standby server is processing archived WAL data."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_standby_archive_delay</name></expr>,
		<expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_standby_streaming_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum delay before canceling queries when a hot standby server is processing streamed WAL data."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_standby_streaming_delay</name></expr>,
		<expr><literal type="number">30</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_min_apply_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum delay for applying changes during recovery."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recovery_min_apply_delay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_receiver_status_interval"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum interval between WAL receiver status reports to the sending server."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_receiver_status_interval</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_receiver_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum wait time to receive data from the sending server."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_receiver_timeout</name></expr>,
		<expr><literal type="number">60</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_connections"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of concurrent connections."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>MaxConnections</name></expr>,
		<expr><literal type="number">200</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>check_maxconnections</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* see max_connections */</comment>
		<expr><block>{<expr><literal type="string">"superuser_reserved_connections"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of connection slots reserved for "</literal>
						<literal type="string">"superusers (including reserved FTS connection for primaries)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ReservedBackends</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><name>RESERVED_FTS_CONNECTIONS</name></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * We sometimes multiply the number of shared buffers by two without
	 * checking for overflow, so we mustn't allow more than INT_MAX / 2.
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"shared_buffers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of shared memory buffers used by the server."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>NBuffers</name></expr>,
		<expr><literal type="number">4096</literal></expr>, <expr><literal type="number">16</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"temp_buffers"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of temporary buffers used by each session."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name> <operator>|</operator> <name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>num_temp_buffers</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,
		<expr><name>check_temp_buffers</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"port"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the TCP port the server listens on."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PostPortNumber</name></expr>,
		<expr><name>DEF_PGPORT</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">65535</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"unix_socket_permissions"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the access permissions of the Unix-domain socket."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Unix-domain sockets use the usual Unix file system "</literal>
						 <literal type="string">"permission set. The parameter value is expected "</literal>
						 <literal type="string">"to be a numeric mode specification in the form "</literal>
						 <literal type="string">"accepted by the chmod and umask system calls. "</literal>
						 <literal type="string">"(To use the customary octal format the number must "</literal>
						 <literal type="string">"start with a 0 (zero).)"</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Unix_socket_permissions</name></expr>,
		<expr><literal type="number">0777</literal></expr>, <expr><literal type="number">0000</literal></expr>, <expr><literal type="number">0777</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_unix_socket_permissions</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_file_mode"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the file permissions for log files."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The parameter value is expected "</literal>
						 <literal type="string">"to be a numeric mode specification in the form "</literal>
						 <literal type="string">"accepted by the chmod and umask system calls. "</literal>
						 <literal type="string">"(To use the customary octal format the number must "</literal>
						 <literal type="string">"start with a 0 (zero).)"</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_file_mode</name></expr>,
		<expr><literal type="number">0600</literal></expr>, <expr><literal type="number">0000</literal></expr>, <expr><literal type="number">0777</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_log_file_mode</name></expr>
	}</block></expr>,


	<expr><block>{
		<expr><block>{<expr><literal type="string">"data_directory_mode"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Mode of the data directory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"The parameter value is a numeric mode specification "</literal>
						 <literal type="string">"in the form accepted by the chmod and umask system "</literal>
						 <literal type="string">"calls. (To use the customary octal format the number "</literal>
						 <literal type="string">"must start with a 0 (zero).)"</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>data_directory_mode</name></expr>,
		<expr><literal type="number">0700</literal></expr>, <expr><literal type="number">0000</literal></expr>, <expr><literal type="number">0777</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_data_directory_mode</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"work_mem"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEPRECATED_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum memory to be used for query workspaces."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This much memory can be used by each internal "</literal>
						 <literal type="string">"sort operation and hash table before switching to "</literal>
						 <literal type="string">"temporary disk files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name> <operator>|</operator> <name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>work_mem</name></expr>,
        <expr><literal type="number">32768</literal></expr>, <expr><literal type="number">64</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"maintenance_work_mem"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum memory to be used for maintenance operations."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This includes operations such as VACUUM and CREATE INDEX."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>maintenance_work_mem</name></expr>,
		<expr><literal type="number">65536</literal></expr>, <expr><literal type="number">1024</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * We use the hopefully-safely-small value of 100kB as the compiled-in
	 * default for max_stack_depth.  InitializeGUCOptions will increase it if
	 * possible, depending on the actual platform-specific stack limit.
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_stack_depth"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum stack depth, in kilobytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_stack_depth</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>check_max_stack_depth</name></expr>, <expr><name>assign_max_stack_depth</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"temp_file_limit"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>RESOURCES_DISK</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Limits the total size of all temporary files used by each process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"-1 means no limit."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>temp_file_limit</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_page_hit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost for a page found in the buffer cache."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostPageHit</name></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_page_miss"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost for a page not found in the buffer cache."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostPageMiss</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_page_dirty"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost for a page dirtied by vacuum."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostPageDirty</name></expr>,
		<expr><literal type="number">20</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost amount available before napping."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostLimit</name></expr>,
		<expr><literal type="number">200</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_vacuum_cost_limit"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost amount available before napping, for autovacuum."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_vac_cost_limit</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_files_per_process"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_KERNEL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously open files for each server process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_files_per_process</name></expr>,
		<expr><literal type="number">1000</literal></expr>, <expr><literal type="number">25</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * See also CheckRequiredParameterValues() if this parameter changes
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_prepared_transactions"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously prepared transactions."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_prepared_xacts</name></expr>,
		<expr><literal type="number">50</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>LOCK_DEBUG</name></cpp:ifdef>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_lock_oidmin"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum OID of tables for tracking locks."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Is used to avoid output on system tables."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_lock_oidmin</name></expr>,
		<expr><name>FirstNormalObjectId</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_lock_table"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the OID of the table with unconditionally lock tracing."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Trace_lock_table</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"statement_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed duration of any statement."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>StatementTimeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lock_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed duration of any wait for a lock."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>LockTimeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"idle_in_transaction_session_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed idle time between queries, when in a transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 turns off the timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>IdleInTransactionSessionTimeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_freeze_min_age"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum age at which VACUUM should freeze a table row."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_freeze_min_age</name></expr>,
		<expr><literal type="number">50000000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_freeze_table_age"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Age at which VACUUM should scan whole table to freeze tuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_freeze_table_age</name></expr>,
		<expr><literal type="number">150000000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_multixact_freeze_min_age"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum age at which VACUUM should freeze a MultiXactId in a table row."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_multixact_freeze_min_age</name></expr>,
		<expr><literal type="number">5000000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_multixact_freeze_table_age"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Multixact age at which VACUUM should scan whole table to freeze tuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_multixact_freeze_table_age</name></expr>,
		<expr><literal type="number">150000000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">2000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_defer_cleanup_age"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of transactions by which VACUUM and HOT cleanup should be deferred, if any."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_defer_cleanup_age</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/*
	 * See also CheckRequiredParameterValues() if this parameter changes
	 */</comment>
	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_locks_per_transaction"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of locks per transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The shared lock table is sized on the assumption that "</literal>
						 <literal type="string">"at most max_locks_per_transaction * max_connections distinct "</literal>
						 <literal type="string">"objects will need to be locked at any one time."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_locks_per_xact</name></expr>,
		<expr><literal type="number">128</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_pred_locks_per_transaction"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of predicate locks per transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The shared predicate lock table is sized on the assumption that "</literal>
						 <literal type="string">"at most max_pred_locks_per_transaction * max_connections distinct "</literal>
						 <literal type="string">"objects will need to be locked at any one time."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_predicate_locks_per_xact</name></expr>,
		<expr><literal type="number">64</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_pred_locks_per_relation"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of predicate-locked pages and tuples per relation."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"If more than this total of pages and tuples in the same relation are locked "</literal>
						 <literal type="string">"by a connection, those locks are replaced by a relation-level lock."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_predicate_locks_per_relation</name></expr>,
		<expr><operator>-</operator><literal type="number">2</literal></expr>, <expr><name>INT_MIN</name></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_pred_locks_per_page"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOCK_MANAGEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of predicate-locked tuples per page."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"If more than this number of tuples on the same page are locked "</literal>
						 <literal type="string">"by a connection, those locks are replaced by a page-level lock."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_predicate_locks_per_page</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"authentication_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed time to complete client authentication."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>AuthenticationTimeout</name></expr>,
		<expr><literal type="number">60</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>MAX_AUTHENTICATION_TIMEOUT</name></expr>,
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Not for general use */</comment>
		<expr><block>{<expr><literal type="string">"pre_auth_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Waits N seconds on connection startup before authentication."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This allows attaching a debugger to the process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PreAuthDelay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_PRE_AUTH_DELAY</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_keep_segments"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_SENDING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of WAL files held for standby servers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_keep_segments</name></expr>,
		<expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"min_wal_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum size to shrink the WAL to."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>min_wal_size_mb</name></expr>,
		<expr><name>DEFAULT_MIN_WAL_SEGS</name> <operator>*</operator> <operator>(</operator><name>DEFAULT_XLOG_SEG_SIZE</name> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_wal_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the WAL size that triggers a checkpoint."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_wal_size_mb</name></expr>,
		<expr><name>DEFAULT_MAX_WAL_SEGS</name> <operator>*</operator> <operator>(</operator><name>DEFAULT_XLOG_SEG_SIZE</name> <operator>/</operator> <operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator><operator>)</operator></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_max_wal_size</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"checkpoint_timeout"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum time between automatic WAL checkpoints."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_USER_SET</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CheckPointTimeout</name></expr>,
		<expr><literal type="number">300</literal></expr>, <expr><literal type="number">30</literal></expr>, <expr><literal type="number">86400</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"checkpoint_warning"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables warnings if checkpoint segments are filled more "</literal>
						 <literal type="string">"frequently than this."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Write a message to the server log if checkpoints "</literal>
						 <literal type="string">"caused by the filling of checkpoint segment files happens more "</literal>
						 <literal type="string">"frequently than this number of seconds. Zero turns off the warning."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_S</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CheckPointWarning</name></expr>,
		<expr><literal type="number">30</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"checkpoint_flush_after"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of pages after which previously performed writes are flushed to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>checkpoint_flush_after</name></expr>,
		<expr><name>DEFAULT_CHECKPOINT_FLUSH_AFTER</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>WRITEBACK_MAX_PENDING_FLUSHES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_buffers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of disk-page buffers in shared memory for WAL."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_XBLOCKS</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLOGbuffers</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>(</operator><name>INT_MAX</name> <operator>/</operator> <name>XLOG_BLCKSZ</name><operator>)</operator></expr>,
		<expr><name>check_wal_buffers</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_writer_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between WAL flushes performed in the WAL writer."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>WalWriterDelay</name></expr>,
		<expr><literal type="number">200</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_writer_flush_after"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Amount of WAL written out by WAL writer that triggers a flush."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_XBLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>WalWriterFlushAfter</name></expr>,
		<expr><operator>(</operator><literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <name>XLOG_BLCKSZ</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_wal_senders"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION_SENDING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously running WAL sender processes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_wal_senders</name></expr>,
		<comment type="block">/*
		 * GPDB doesn't support 1:n replication yet.  In normal operation,
		 * when primary and mirror are streaming WAL, only 1 WalSnd should be
		 * active.  We need 2 during base backup, 1 WalSnd to serve backup
		 * request and 1 WalSnd to serve the log streamer process started by
		 * pg_basebackup.
		 */</comment>
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>check_max_wal_senders</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* see max_wal_senders */</comment>
		<expr><block>{<expr><literal type="string">"max_replication_slots"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION_SENDING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously defined replication slots."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_replication_slots</name></expr>,
		<expr><literal type="number">10</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr> <comment type="block">/* XXX? */</comment> ,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_sender_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>REPLICATION_SENDING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum time to wait for WAL replication."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_sender_timeout</name></expr>,
		<expr><literal type="number">300</literal> <operator>*</operator> <literal type="number">1000</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"commit_delay"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the delay in microseconds between transaction commit and "</literal>
						 <literal type="string">"flushing WAL to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_DISALLOW_USER_SET</name></expr>
			<comment type="block">/* we have no microseconds designation, so can't supply units here */</comment>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CommitDelay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"commit_siblings"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum concurrent open transactions before performing "</literal>
						 <literal type="string">"commit_delay."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_DISALLOW_USER_SET</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CommitSiblings</name></expr>,
		<expr><literal type="number">5</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"extra_float_digits"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the number of digits displayed for floating-point values."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"This affects real, double precision, and geometric data types. "</literal>
						 <literal type="string">"A zero or negative parameter value is added to the standard "</literal>
						 <literal type="string">"number of digits (FLT_DIG or DBL_DIG as appropriate). "</literal>
						 <literal type="string">"Any value greater than zero selects precise output mode."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>extra_float_digits</name></expr>,
		<expr><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">15</literal></expr>, <expr><literal type="number">3</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_min_duration_statement"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHEN</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum execution time above which "</literal>
						 <literal type="string">"statements will be logged."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Zero prints all queries, subject to log_statement_sample_rate. "</literal>
						 <literal type="string">"-1 turns this feature off."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_min_duration_statement</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_autovacuum_min_duration"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum execution time above which "</literal>
						 <literal type="string">"autovacuum actions will be logged."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Zero prints all actions. -1 turns autovacuum logging off."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_autovacuum_min_duration</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bgwriter_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Background writer sleep time between rounds."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>BgWriterDelay</name></expr>,
		<expr><literal type="number">200</literal></expr>, <expr><literal type="number">10</literal></expr>, <expr><literal type="number">10000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bgwriter_lru_maxpages"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Background writer maximum number of LRU pages to flush per round."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bgwriter_lru_maxpages</name></expr>,
		<expr><literal type="number">100</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>,	<comment type="block">/* Same upper limit as shared_buffers */</comment>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bgwriter_flush_after"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of pages after which previously performed writes are flushed to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bgwriter_flush_after</name></expr>,
		<expr><name>DEFAULT_BGWRITER_FLUSH_AFTER</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>WRITEBACK_MAX_PENDING_FLUSHES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"effective_io_concurrency"</literal></expr>,
			<expr><name>PGC_USERSET</name></expr>,
			<expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of simultaneous requests that can be handled efficiently by the disk subsystem."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"For RAID arrays, this should be approximately the number of drive spindles in the array."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>effective_io_concurrency</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
		<expr><literal type="number">1</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><literal type="number">0</literal></expr>, <expr><name>MAX_IO_CONCURRENCY</name></expr>,
		<expr><name>check_effective_io_concurrency</name></expr>, <expr><name>assign_effective_io_concurrency</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"backend_flush_after"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of pages after which previously performed writes are flushed to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>backend_flush_after</name></expr>,
		<expr><name>DEFAULT_BACKEND_FLUSH_AFTER</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>WRITEBACK_MAX_PENDING_FLUSHES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_worker_processes"</literal></expr>,
			<expr><name>PGC_POSTMASTER</name></expr>,
			<expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of concurrent worker processes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_worker_processes</name></expr>,
		<expr><literal type="number">8</literal> <operator>+</operator> <name>MaxPMAuxProc</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>check_max_worker_processes</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_logical_replication_workers"</literal></expr>,
			<expr><name>PGC_POSTMASTER</name></expr>,
			<expr><name>REPLICATION_SUBSCRIBERS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of logical replication worker processes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_logical_replication_workers</name></expr>,
		<expr><literal type="number">4</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_sync_workers_per_subscription"</literal></expr>,
			<expr><name>PGC_SIGHUP</name></expr>,
			<expr><name>REPLICATION_SUBSCRIBERS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of table synchronization workers per subscription."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_sync_workers_per_subscription</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_rotation_age"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Automatic log file rotation will occur after N minutes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_RotationAge</name></expr>,
		<expr><name>HOURS_PER_DAY</name> <operator>*</operator> <name>MINS_PER_HOUR</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <name>SECS_PER_MINUTE</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_rotation_size"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Automatic log file rotation will occur after N kilobytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_RotationSize</name></expr>,
		<expr><literal type="number">1</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1024</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_function_args"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the maximum number of function arguments."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_function_args</name></expr>,
		<expr><name>FUNC_MAX_ARGS</name></expr>, <expr><name>FUNC_MAX_ARGS</name></expr>, <expr><name>FUNC_MAX_ARGS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_index_keys"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the maximum number of index keys."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_index_keys</name></expr>,
		<expr><name>INDEX_MAX_KEYS</name></expr>, <expr><name>INDEX_MAX_KEYS</name></expr>, <expr><name>INDEX_MAX_KEYS</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_identifier_length"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the maximum identifier length."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_identifier_length</name></expr>,
		<expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>, <expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>, <expr><name>NAMEDATALEN</name> <operator>-</operator> <literal type="number">1</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"block_size"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the size of a disk block."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>block_size</name></expr>,
		<expr><name>BLCKSZ</name></expr>, <expr><name>BLCKSZ</name></expr>, <expr><name>BLCKSZ</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"segment_size"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the number of pages per disk file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>segment_size</name></expr>,
		<expr><name>RELSEG_SIZE</name></expr>, <expr><name>RELSEG_SIZE</name></expr>, <expr><name>RELSEG_SIZE</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_block_size"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the block size in the write ahead log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_block_size</name></expr>,
		<expr><name>XLOG_BLCKSZ</name></expr>, <expr><name>XLOG_BLCKSZ</name></expr>, <expr><name>XLOG_BLCKSZ</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_retrieve_retry_interval"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time to wait before retrying to retrieve WAL "</literal>
						 <literal type="string">"after a failed attempt."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_retrieve_retry_interval</name></expr>,
		<expr><literal type="number">5000</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_segment_size"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the size of write ahead log segments."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BYTE</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_segment_size</name></expr>,
		<expr><name>DEFAULT_XLOG_SEG_SIZE</name></expr>,
		<expr><name>WalSegMinSize</name></expr>,
		<expr><name>WalSegMaxSize</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_naptime"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time to sleep between autovacuum runs."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_naptime</name></expr>,
		<expr><literal type="number">60</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">1000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_vacuum_threshold"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum number of tuple updates or deletes prior to vacuum."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_vac_thresh</name></expr>,
		<expr><literal type="number">50</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_analyze_threshold"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Minimum number of tuple inserts, updates or deletes prior to analyze."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_anl_thresh</name></expr>,
		<expr><literal type="number">50</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* see varsup.c for why this is PGC_POSTMASTER not PGC_SIGHUP */</comment>
		<expr><block>{<expr><literal type="string">"autovacuum_freeze_max_age"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Age at which to autovacuum a table to prevent transaction ID wraparound."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_freeze_max_age</name></expr>,
		<comment type="block">/* see pg_resetwal if you change the upper-limit value */</comment>
		<expr><literal type="number">200000000</literal></expr>, <expr><literal type="number">100000</literal></expr>, <expr><literal type="number">2000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* see multixact.c for why this is PGC_POSTMASTER not PGC_SIGHUP */</comment>
		<expr><block>{<expr><literal type="string">"autovacuum_multixact_freeze_max_age"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Multixact age at which to autovacuum a table to prevent multixact wraparound."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_multixact_freeze_max_age</name></expr>,
		<expr><literal type="number">400000000</literal></expr>, <expr><literal type="number">10000</literal></expr>, <expr><literal type="number">2000000000</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<comment type="block">/* see max_connections */</comment>
		<expr><block>{<expr><literal type="string">"autovacuum_max_workers"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of simultaneously running autovacuum worker processes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_max_workers</name></expr>,
		<expr><literal type="number">3</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>,
		<expr><name>check_autovacuum_max_workers</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_parallel_maintenance_workers"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of parallel processes per maintenance operation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_parallel_maintenance_workers</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">1024</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_parallel_workers_per_gather"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of parallel processes per executor node."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_parallel_workers_per_gather</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_PARALLEL_WORKER_LIMIT</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"max_parallel_workers"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum number of parallel workers that can be active at one time."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>max_parallel_workers</name></expr>,
		<expr><literal type="number">8</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>MAX_PARALLEL_WORKER_LIMIT</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_work_mem"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum memory to be used by each autovacuum worker process."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_work_mem</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>check_autovacuum_work_mem</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"old_snapshot_threshold"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_ASYNCHRONOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time before a snapshot is too old to read pages changed after the snapshot was taken."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of -1 disables this feature."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>old_snapshot_threshold</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>MINS_PER_HOUR</name> <operator>*</operator> <name>HOURS_PER_DAY</name> <operator>*</operator> <literal type="number">60</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"tcp_keepalives_idle"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between issuing TCP keepalives."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 uses the system default."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>tcp_keepalives_idle</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_tcp_keepalives_idle</name></expr>, <expr><name>show_tcp_keepalives_idle</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"tcp_keepalives_interval"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time between TCP keepalive retransmits."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 uses the system default."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_S</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>tcp_keepalives_interval</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_tcp_keepalives_interval</name></expr>, <expr><name>show_tcp_keepalives_interval</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_renegotiation_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"SSL renegotiation is no longer supported; this can only be 0."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_renegotiation_limit</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"tcp_keepalives_count"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Maximum number of TCP keepalive retransmits."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"This controls the number of consecutive keepalive retransmits that can be "</literal>
						 <literal type="string">"lost before a connection is considered dead. A value of 0 uses the "</literal>
						 <literal type="string">"system default."</literal></expr></argument>)</argument_list></call></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>tcp_keepalives_count</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_tcp_keepalives_count</name></expr>, <expr><name>show_tcp_keepalives_count</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"gin_fuzzy_search_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum allowed result for exact search by GIN."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>GinFuzzySearchLimit</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"effective_cache_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's assumption about the total size of the data caches."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"That is, the total size of the caches (kernel cache and shared buffers) used for PostgreSQL data files. "</literal>
						 <literal type="string">"This is measured in disk pages, which are normally 8 kB each."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name> <operator>|</operator> <name>GUC_EXPLAIN</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>effective_cache_size</name></expr>,
		<expr><name>DEFAULT_EFFECTIVE_CACHE_SIZE</name></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"min_parallel_table_scan_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum amount of table data for a parallel scan."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If the planner estimates that it will read a number of table pages too small to reach this limit, a parallel scan will not be considered."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name> <operator>|</operator> <name>GUC_EXPLAIN</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>min_parallel_table_scan_size</name></expr>,
		<expr><operator>(</operator><literal type="number">8</literal> <operator>*</operator> <literal type="number">1024</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"min_parallel_index_scan_size"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum amount of index data for a parallel scan."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If the planner estimates that it will read a number of index pages too small to reach this limit, a parallel scan will not be considered."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_BLOCKS</name> <operator>|</operator> <name>GUC_EXPLAIN</name></expr>,
		}</block></expr>,
		<expr><operator>&amp;</operator><name>min_parallel_index_scan_size</name></expr>,
		<expr><operator>(</operator><literal type="number">512</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator> <operator>/</operator> <name>BLCKSZ</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name> <operator>/</operator> <literal type="number">3</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Can't be set in postgresql.conf */</comment>
		<expr><block>{<expr><literal type="string">"server_version_num"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the server version as an integer."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>server_version_num</name></expr>,
		<expr><name>PG_VERSION_NUM</name></expr>, <expr><name>PG_VERSION_NUM</name></expr>, <expr><name>PG_VERSION_NUM</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_temp_files"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Log the use of temporary files larger than this number of kilobytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Zero logs all files. The default is -1 (turning this feature off)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_temp_files</name></expr>,
		<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_activity_query_size"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the size reserved for pg_stat_activity.query, in bytes."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_BYTE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_track_activity_query_size</name></expr>,
		<expr><literal type="number">1024</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><literal type="number">102400</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"gin_pending_list_limit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum size of the pending list for GIN index."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_KB</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>gin_pending_list_limit</name></expr>,
		<expr><literal type="number">4096</literal></expr>, <expr><literal type="number">64</literal></expr>, <expr><name>MAX_KILOBYTES</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"tcp_user_timeout"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"TCP user timeout."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"A value of 0 uses the system default."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>tcp_user_timeout</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_tcp_user_timeout</name></expr>, <expr><name>show_tcp_user_timeout</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"client_connection_check_interval"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time interval between checks for disconnection while running queries."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>client_connection_check_interval</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>INT_MAX</name></expr>,
		<expr><name>check_client_connection_check_interval</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_real</name></name></type> <name><name>ConfigureNamesReal</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{<expr><literal type="string">"seq_page_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of a "</literal>
						 <literal type="string">"sequentially fetched disk page."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>seq_page_cost</name></expr>,
		<expr><name>DEFAULT_SEQ_PAGE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"random_page_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of a "</literal>
						 <literal type="string">"nonsequentially fetched disk page."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>random_page_cost</name></expr>,
		<expr><name>DEFAULT_RANDOM_PAGE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"cpu_tuple_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"processing each tuple (row)."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cpu_tuple_cost</name></expr>,
		<expr><name>DEFAULT_CPU_TUPLE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"cpu_index_tuple_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"processing each index entry during an index scan."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cpu_index_tuple_cost</name></expr>,
		<expr><name>DEFAULT_CPU_INDEX_TUPLE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"cpu_operator_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"processing each operator or function call."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cpu_operator_cost</name></expr>,
		<expr><name>DEFAULT_CPU_OPERATOR_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"parallel_tuple_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"passing each tuple (row) from worker to master backend."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>parallel_tuple_cost</name></expr>,
		<expr><name>DEFAULT_PARALLEL_TUPLE_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"parallel_setup_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the cost of "</literal>
						 <literal type="string">"starting up worker processes for parallel query."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>parallel_setup_cost</name></expr>,
		<expr><name>DEFAULT_PARALLEL_SETUP_COST</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_above_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Perform JIT compilation if query is more expensive."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"-1 disables JIT compilation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_above_cost</name></expr>,
		<expr><literal type="number">100000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_optimize_above_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Optimize JITed functions if query is more expensive."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"-1 disables optimization."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_optimize_above_cost</name></expr>,
		<expr><literal type="number">500000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_inline_above_cost"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_COST</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Perform JIT inlining if query is more expensive."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"-1 disables inlining."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_inline_above_cost</name></expr>,
		<expr><literal type="number">500000</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DBL_MAX</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"cursor_tuple_fraction"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the planner's estimate of the fraction of "</literal>
						 <literal type="string">"a cursor's rows that will be retrieved."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cursor_tuple_fraction</name></expr>,
		<expr><name>DEFAULT_CURSOR_TUPLE_FRACTION</name></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_selection_bias"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Unused. Syntax check only for PostgreSQL compatibility."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>defunct_double</name></expr>,
		<expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">100.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"geqo_seed"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Unused. Syntax check only for PostgreSQL compatibility."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>defunct_double</name></expr>,
		<expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bgwriter_lru_multiplier"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>RESOURCES_BGWRITER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Multiple of the average buffer usage to free per round."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bgwriter_lru_multiplier</name></expr>,
		<expr><literal type="number">2.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">10.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"seed"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the seed for random-number generation."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>phony_random_seed</name></expr>,
		<expr><literal type="number">0.0</literal></expr>, <expr><operator>-</operator><literal type="number">1.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>check_random_seed</name></expr>, <expr><name>assign_random_seed</name></expr>, <expr><name>show_random_seed</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cost_delay"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>RESOURCES_VACUUM_DELAY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost delay in milliseconds."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>VacuumCostDelay</name></expr>,
		<expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">100</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_vacuum_cost_delay"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Vacuum cost delay in milliseconds, for autovacuum."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_UNIT_MS</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_vac_cost_delay</name></expr>,
		<expr><literal type="number">2</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><literal type="number">100</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_vacuum_scale_factor"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of tuple updates or deletes prior to vacuum as a fraction of reltuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_vac_scale</name></expr>,
		<expr><literal type="number">0.2</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">100.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"autovacuum_analyze_scale_factor"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>AUTOVACUUM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of tuple inserts, updates or deletes prior to analyze as a fraction of reltuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>autovacuum_anl_scale</name></expr>,
		<expr><literal type="number">0.1</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">100.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"checkpoint_completion_target"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_CHECKPOINTS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Time spent flushing dirty buffers during checkpoint, as fraction of checkpoint interval."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>CheckPointCompletionTarget</name></expr>,
		<expr><literal type="number">0.5</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"vacuum_cleanup_index_scale_factor"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of tuple inserts prior to index cleanup as a fraction of reltuples."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>vacuum_cleanup_index_scale_factor</name></expr>,
		<expr><literal type="number">0.1</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1e10</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_statement_sample_rate"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHEN</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Fraction of statements exceeding log_min_duration_statement to be logged."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"If you only want a sample, use a value between 0.0 (never "</literal>
						 <literal type="string">"log) and 1.0 (always log)."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_statement_sample_rate</name></expr>,
		<expr><literal type="number">1.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_transaction_sample_rate"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHEN</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the fraction of transactions to log for new transactions."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Logs all statements from a fraction of transactions. "</literal>
						 <literal type="string">"Use a value between 0.0 (never log) and 1.0 (log all "</literal>
						 <literal type="string">"statements for all transactions)."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_xact_sample_rate</name></expr>,
		<expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">1.0</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><literal type="number">0.0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_string</name></name></type> <name><name>ConfigureNamesString</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{<expr><literal type="string">"archive_command"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_ARCHIVING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the shell command that will be called to archive a WAL file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLogArchiveCommand</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>show_archive_command</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"restore_command"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_ARCHIVE_RECOVERY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the shell command that will retrieve an archived WAL file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recoveryRestoreCommand</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"archive_cleanup_command"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_ARCHIVE_RECOVERY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the shell command that will be executed at every restart point."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>archiveCleanupCommand</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_end_command"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_ARCHIVE_RECOVERY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the shell command that will be executed once at the end of recovery."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recoveryEndCommand</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_target_timeline"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_RECOVERY_TARGET</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Specifies the timeline to recovery into."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recovery_target_timeline_string</name></expr>,
		<expr><literal type="string">"latest"</literal></expr>,
		<expr><name>check_recovery_target_timeline</name></expr>, <expr><name>assign_recovery_target_timeline</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_target"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_RECOVERY_TARGET</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set to 'immediate' to end recovery as soon as a consistent state is reached."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recovery_target_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_recovery_target</name></expr>, <expr><name>assign_recovery_target</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_target_xid"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_RECOVERY_TARGET</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the transaction ID up to which recovery will proceed."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recovery_target_xid_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_recovery_target_xid</name></expr>, <expr><name>assign_recovery_target_xid</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_target_time"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_RECOVERY_TARGET</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time stamp up to which recovery will proceed."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recovery_target_time_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_recovery_target_time</name></expr>, <expr><name>assign_recovery_target_time</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_target_name"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_RECOVERY_TARGET</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the named restore point up to which recovery will proceed."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recovery_target_name_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_recovery_target_name</name></expr>, <expr><name>assign_recovery_target_name</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_target_lsn"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_RECOVERY_TARGET</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the LSN of the write-ahead log location up to which recovery will proceed."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recovery_target_lsn_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_recovery_target_lsn</name></expr>, <expr><name>assign_recovery_target_lsn</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"promote_trigger_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Specifies a file name whose presence ends recovery in the standby."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PromoteTriggerFile</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"primary_conninfo"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the connection string to be used to connect to the sending server."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PrimaryConnInfo</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"primary_slot_name"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>REPLICATION_STANDBY</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the name of the replication slot to use on the sending server."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>PrimarySlotName</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_primary_slot_name</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"client_encoding"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the client's character set encoding."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>client_encoding_string</name></expr>,
		<expr><literal type="string">"SQL_ASCII"</literal></expr>,
		<expr><name>check_client_encoding</name></expr>, <expr><name>assign_client_encoding</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_line_prefix"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Defunct: controls information prefixed to each log line."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If blank, no prefix is used."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_line_prefix</name></expr>,
		<expr><literal type="string">"%m [%p] "</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_timezone"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time zone to use in log messages."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_timezone_string</name></expr>,
		<expr><literal type="string">"GMT"</literal></expr>,
		<expr><name>check_log_timezone</name></expr>, <expr><name>assign_log_timezone</name></expr>, <expr><name>show_log_timezone</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"DateStyle"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the display format for date and time values."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Also controls interpretation of ambiguous "</literal>
						 <literal type="string">"date inputs."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>datestyle_string</name></expr>,
		<expr><literal type="string">"ISO, MDY"</literal></expr>,
		<expr><name>check_datestyle</name></expr>, <expr><name>assign_datestyle</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_table_access_method"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the default table access method for new tables."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>default_table_access_method</name></expr>,
		<expr><name>DEFAULT_TABLE_ACCESS_METHOD</name></expr>,
		<expr><name>check_default_table_access_method</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_tablespace"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the default tablespace to create tables and indexes in."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"An empty string selects the database's default tablespace."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_IS_NAME</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>default_tablespace</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_default_tablespace</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"temp_tablespaces"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the tablespace(s) to use for temporary tables and sort files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>temp_tablespaces</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_temp_tablespaces</name></expr>, <expr><name>assign_temp_tablespaces</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"dynamic_library_path"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>CLIENT_CONN_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the path for dynamically loadable modules."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If a dynamically loadable module needs to be opened and "</literal>
						 <literal type="string">"the specified name does not have a directory component (i.e., the "</literal>
						 <literal type="string">"name does not contain a slash), the system will search this path for "</literal>
						 <literal type="string">"the specified file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Dynamic_library_path</name></expr>,
		<expr><literal type="string">"$libdir"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"krb_server_keyfile"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the location of the Kerberos server key file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pg_krb_server_keyfile</name></expr>,
		<expr><name>PG_KRB_SRVTAB</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bonjour_name"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the Bonjour service name."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bonjour_name</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* See main.c about why defaults for LC_foo are not all alike */</comment>

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_collate"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the collation order locale."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_collate</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_ctype"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the character classification and case conversion locale."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_ctype</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_messages"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the language in which messages are displayed."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_messages</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_locale_messages</name></expr>, <expr><name>assign_locale_messages</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_monetary"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the locale for formatting monetary amounts."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_monetary</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>check_locale_monetary</name></expr>, <expr><name>assign_locale_monetary</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_numeric"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the locale for formatting numbers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_numeric</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>check_locale_numeric</name></expr>, <expr><name>assign_locale_numeric</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"lc_time"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the locale for formatting date and time values."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>locale_time</name></expr>,
		<expr><literal type="string">"C"</literal></expr>,
		<expr><name>check_locale_time</name></expr>, <expr><name>assign_locale_time</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"session_preload_libraries"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>CLIENT_CONN_PRELOAD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lists shared libraries to preload into each backend."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>session_preload_libraries_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"shared_preload_libraries"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CLIENT_CONN_PRELOAD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lists shared libraries to preload into server."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>shared_preload_libraries_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"local_preload_libraries"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_PRELOAD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Lists unprivileged shared libraries to preload into each backend."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>local_preload_libraries_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"search_path"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the schema search order for names that are not schema-qualified."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_LIST_QUOTE</name> <operator>|</operator> <name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>namespace_search_path</name></expr>,
		<expr><literal type="string">"\"$user\", public"</literal></expr>,
		<expr><name>check_search_path</name></expr>, <expr><name>assign_search_path</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Can't be set in postgresql.conf */</comment>
		<expr><block>{<expr><literal type="string">"server_encoding"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server (database) character set encoding."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>server_encoding_string</name></expr>,
		<expr><literal type="string">"SQL_ASCII"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Can't be set in postgresql.conf */</comment>
		<expr><block>{<expr><literal type="string">"server_version"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Shows the server version."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>server_version_string</name></expr>,
		<expr><name>PG_VERSION</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Not for general use --- used by SET ROLE */</comment>
		<expr><block>{<expr><literal type="string">"role"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the current role."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>role_string</name></expr>,
		<expr><literal type="string">"none"</literal></expr>,
		<expr><name>check_role</name></expr>, <expr><name>assign_role</name></expr>, <expr><name>show_role</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/* Not for general use --- used by SET SESSION AUTHORIZATION */</comment>
		<expr><block>{<expr><literal type="string">"session_authorization"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>UNGROUPED</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the session user name."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name> <operator>|</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>session_authorization_string</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>check_session_authorization</name></expr>, <expr><name>assign_session_authorization</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_destination"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Defunct: Sets the destination for server log output."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Valid values are combinations of \"stderr\", "</literal>
						 <literal type="string">"\"syslog\", \"csvlog\", and \"eventlog\", "</literal>
						 <literal type="string">"depending on the platform."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_destination_string</name></expr>,
		<expr><literal type="string">"stderr"</literal></expr>,
		<expr><name>check_log_destination</name></expr>, <expr><name>assign_log_destination</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_directory"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Defunct: Sets the destination directory for log files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Can be specified as relative to the data directory "</literal>
						 <literal type="string">"or as absolute path."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_directory</name></expr>,
		<expr><literal type="string">"log"</literal></expr>,
		<expr><name>check_canonical_path</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_filename"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the file name pattern for log files."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_filename</name></expr>,
		<expr><literal type="string">"gpdb-%Y-%m-%d_%H%M%S.csv"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"syslog_ident"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the program name used to identify PostgreSQL "</literal>
						 <literal type="string">"messages in syslog."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>syslog_ident_str</name></expr>,
		<expr><literal type="string">"postgres"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_syslog_ident</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"event_source"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>LOGGING_WHERE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the application name used to identify "</literal>
						 <literal type="string">"PostgreSQL messages in the event log."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>event_source</name></expr>,
		<expr><name>DEFAULT_EVENT_SOURCE</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"TimeZone"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the time zone for displaying and interpreting time stamps."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>timezone_string</name></expr>,
		<expr><literal type="string">"GMT"</literal></expr>,
		<expr><name>check_timezone</name></expr>, <expr><name>assign_timezone</name></expr>, <expr><name>show_timezone</name></expr>
	}</block></expr>,
	<expr><block>{
		<expr><block>{<expr><literal type="string">"timezone_abbreviations"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Selects a file of time zone abbreviations."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>timezone_abbreviations_string</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>check_timezone_abbreviations</name></expr>, <expr><name>assign_timezone_abbreviations</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"unix_socket_group"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the owning group of the Unix-domain socket."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"The owning user of the socket is always the user "</literal>
						 <literal type="string">"that starts the server."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Unix_socket_group</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"unix_socket_directories"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the directories where Unix-domain sockets will be created."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Unix_socket_directories</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_UNIX_SOCKETS</name></cpp:ifdef>
		<expr><name>DEFAULT_PGSOCKET_DIR</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="string">""</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"listen_addresses"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CONN_AUTH_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the host name or IP address(es) to listen to."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ListenAddresses</name></expr>,
		<expr><literal type="string">"localhost"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/*
		 * Can't be set by ALTER SYSTEM as it can lead to recursive definition
		 * of data_directory.
		 */</comment>
		<expr><block>{<expr><literal type="string">"data_directory"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server's data directory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>data_directory</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"config_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server's main configuration file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_DISALLOW_IN_FILE</name> <operator>|</operator> <name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ConfigFileName</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"hba_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server's \"hba\" configuration file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>HbaFileName</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ident_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the server's \"ident\" configuration file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>IdentFileName</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"external_pid_file"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>FILE_LOCATIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes the postmaster PID to the specified file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>external_pid_file</name></expr>,
		<expr><name>NULL</name></expr>,
		<expr><name>check_canonical_path</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_library"</literal></expr>, <expr><name>PGC_INTERNAL</name></expr>, <expr><name>PRESET_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Name of the SSL library."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_library</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<expr><literal type="string">"OpenSSL"</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="string">""</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_cert_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL server certificate file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_cert_file</name></expr>,
		<expr><literal type="string">"server.crt"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_key_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL server private key file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_key_file</name></expr>,
		<expr><literal type="string">"server.key"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_ca_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL certificate authority file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_ca_file</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_crl_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL certificate revocation list file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_crl_file</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"stats_temp_directory"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Writes temporary statistics files to the specified directory."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_temp_directory</name></expr>,
		<expr><name>PG_STAT_TMP_DIR</name></expr>,
		<expr><name>check_canonical_path</name></expr>, <expr><name>assign_pgstat_temp_directory</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"synchronous_standby_names"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>REPLICATION_MASTER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Number of synchronous standbys and list of names of potential synchronous ones."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_LIST_INPUT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SyncRepStandbyNames</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_synchronous_standby_names</name></expr>, <expr><name>assign_synchronous_standby_names</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"default_text_search_config"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets default text search configuration."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>TSCurrentConfig</name></expr>,
		<expr><literal type="string">"pg_catalog.simple"</literal></expr>,
		<expr><name>check_TSCurrentConfig</name></expr>, <expr><name>assign_TSCurrentConfig</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_ciphers"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the list of allowed SSL ciphers."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SSLCipherSuites</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<expr><literal type="string">"HIGH:MEDIUM:+3DES:!aNULL"</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="string">"none"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_ecdh_curve"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the curve to use for ECDH."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SSLECDHCurve</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_SSL</name></cpp:ifdef>
		<expr><literal type="string">"prime256v1"</literal></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="string">"none"</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_dh_params_file"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Location of the SSL DH parameters file."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_dh_params_file</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_passphrase_command"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Command to obtain passphrases for SSL."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_passphrase_command</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"application_name"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the application name to be reported in statistics and logs."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name> <operator>|</operator> <name>GUC_REPORT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>application_name</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_application_name</name></expr>, <expr><name>assign_application_name</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"cluster_name"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>PROCESS_TITLE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the name of the cluster, which is included in the process title."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_IS_NAME</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>cluster_name</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_cluster_name</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_consistency_checking"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the WAL resource managers for which WAL consistency checks are done."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Full-page images will be logged for all data blocks and cross-checked against the results of WAL replay."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_LIST_INPUT</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_consistency_checking_string</name></expr>,
		<expr><literal type="string">""</literal></expr>,
		<expr><name>check_wal_consistency_checking</name></expr>, <expr><name>assign_wal_consistency_checking</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"jit_provider"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>CLIENT_CONN_PRELOAD</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"JIT provider to use."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>jit_provider</name></expr>,
		<expr><literal type="string">"llvmjit"</literal></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_enum</name></name></type> <name><name>ConfigureNamesEnum</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{
		<expr><block>{<expr><literal type="string">"backslash_quote"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>COMPAT_OPTIONS_PREVIOUS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets whether \"\\'\" is allowed in string literals."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>backslash_quote</name></expr>,
		<expr><name>BACKSLASH_QUOTE_SAFE_ENCODING</name></expr>, <expr><name>backslash_quote_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"bytea_output"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the output format for bytea."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>bytea_output</name></expr>,
		<expr><name>BYTEA_OUTPUT_HEX</name></expr>, <expr><name>bytea_output_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"client_min_messages"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the message levels that are sent to the client."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Each level includes all the levels that follow it. The later"</literal>
						 <literal type="string">" the level, the fewer messages are sent."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>client_min_messages</name></expr>,
		<expr><name>NOTICE</name></expr>, <expr><name>client_message_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"constraint_exclusion"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables the planner to use constraints to optimize queries."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Table scans will be skipped if their constraints"</literal>
						 <literal type="string">" guarantee that no rows match the query."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>constraint_exclusion</name></expr>,
		<expr><name>CONSTRAINT_EXCLUSION_ON</name></expr>, <expr><name>constraint_exclusion_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<comment type="block">/*
		 * Greenplum needs to reconcile conflict detection based
		 * on predicate locks across cluster to support true
		 * serializability.  See merge fixme in
		 * assign_XactIsoLevel(). String guc sets the value of the
		 * corresponding variable via the assign hook, but enum guc
		 * sets it in set_config_option by new_val. We can't change
		 * the value of newval in the assignment hook, it's the
		 * reason why assign hook function method didn't work in
		 * past. Use the check hook to change 'newval'.
		 */</comment>
		<expr><block>{<expr><literal type="string">"default_transaction_isolation"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the transaction isolation level of each new transaction."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>DefaultXactIsoLevel</name></expr>,
		<expr><name>XACT_READ_COMMITTED</name></expr>, <expr><name>isolation_level_options</name></expr>,
		<expr><name>check_DefaultXactIsoLevel</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"transaction_isolation"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the current transaction's isolation level."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NO_RESET_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_DISALLOW_IN_FILE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XactIsoLevel</name></expr>,
		<expr><name>XACT_READ_COMMITTED</name></expr>, <expr><name>isolation_level_options</name></expr>,
		<expr><name>check_XactIsoLevel</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"IntervalStyle"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_LOCALE</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the display format for interval values."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_REPORT</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>IntervalStyle</name></expr>,
		<expr><name>INTSTYLE_POSTGRES</name></expr>, <expr><name>intervalstyle_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_error_verbosity"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the verbosity of logged messages."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Log_error_verbosity</name></expr>,
		<expr><name>PGERROR_DEFAULT</name></expr>, <expr><name>log_error_verbosity_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_min_messages"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHEN</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the message levels that are logged."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Each level includes all the levels that follow it. The later"</literal>
						 <literal type="string">" the level, the fewer messages are sent."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_min_messages</name></expr>,
		<expr><name>WARNING</name></expr>, <expr><name>server_message_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_min_error_statement"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHEN</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Causes all statements generating error at or above this level to be logged."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Each level includes all the levels that follow it. The later"</literal>
						 <literal type="string">" the level, the fewer messages are sent."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_min_error_statement</name></expr>,
		<expr><name>ERROR</name></expr>, <expr><name>server_message_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"log_statement"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>LOGGING_WHAT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the type of statements logged."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>log_statement</name></expr>,
		<expr><name>LOGSTMT_NONE</name></expr>, <expr><name>log_statement_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"syslog_facility"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEFUNCT_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the syslog \"facility\" to be used when syslog enabled."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Valid values are LOCAL0, LOCAL1, LOCAL2, LOCAL3, "</literal>
						 <literal type="string">"LOCAL4, LOCAL5, LOCAL6, LOCAL7."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>syslog_facility</name></expr>,
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
		<expr><name>LOG_LOCAL0</name></expr>,
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr><literal type="number">0</literal></expr>,
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><name>syslog_facility_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_syslog_facility</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"session_replication_role"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the session's behavior for triggers and rewrite rules."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>SessionReplicationRole</name></expr>,
		<expr><name>SESSION_REPLICATION_ROLE_ORIGIN</name></expr>, <expr><name>session_replication_role_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_session_replication_role</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"synchronous_commit"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the current transaction's synchronization level."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>synchronous_commit</name></expr>,
		<expr><name>SYNCHRONOUS_COMMIT_ON</name></expr>, <expr><name>synchronous_commit_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_synchronous_commit</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"archive_mode"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_ARCHIVING</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Allows archiving of WAL files using archive_command."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>XLogArchiveMode</name></expr>,
		<expr><name>ARCHIVE_MODE_OFF</name></expr>, <expr><name>archive_mode_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"recovery_target_action"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_RECOVERY_TARGET</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the action to perform upon reaching the recovery target."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>recoveryTargetAction</name></expr>,
		<expr><name>RECOVERY_TARGET_ACTION_PAUSE</name></expr>, <expr><name>recovery_target_action_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"trace_recovery_messages"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>DEVELOPER_OPTIONS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Enables logging of recovery-related debugging information."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"Each level includes all the levels that follow it. The later"</literal>
						 <literal type="string">" the level, the fewer messages are sent."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>trace_recovery_messages</name></expr>,

		<comment type="block">/*
		 * client_message_level_options allows too many values, really, but
		 * it's not worth having a separate options array for this.
		 */</comment>
		<expr><name>LOG</name></expr>, <expr><name>client_message_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"track_functions"</literal></expr>, <expr><name>PGC_SUSET</name></expr>, <expr><name>STATS_COLLECTOR</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Collects function-level statistics on database activity."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>pgstat_track_functions</name></expr>,
		<expr><name>TRACK_FUNC_OFF</name></expr>, <expr><name>track_function_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_level"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Set the level of information written to the WAL."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>wal_level</name></expr>,
		<expr><name>WAL_LEVEL_REPLICA</name></expr>, <expr><name>wal_level_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"dynamic_shared_memory_type"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Selects the dynamic shared memory implementation used."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>dynamic_shared_memory_type</name></expr>,
		<expr><name>DEFAULT_DYNAMIC_SHARED_MEMORY_TYPE</name></expr>, <expr><name>dynamic_shared_memory_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"shared_memory_type"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Selects the shared memory implementation used for the main shared memory region."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>shared_memory_type</name></expr>,
		<expr><name>DEFAULT_SHARED_MEMORY_TYPE</name></expr>, <expr><name>shared_memory_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"wal_sync_method"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>WAL_SETTINGS</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Selects the method used for forcing WAL updates to disk."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_DISALLOW_USER_SET</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>sync_method</name></expr>,
		<expr><name>DEFAULT_SYNC_METHOD</name></expr>, <expr><name>sync_method_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>assign_xlog_sync_method</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"xmlbinary"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets how binary values are to be encoded in XML."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>xmlbinary</name></expr>,
		<expr><name>XMLBINARY_BASE64</name></expr>, <expr><name>xmlbinary_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"xmloption"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CLIENT_CONN_STATEMENT</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets whether XML data in implicit parsing and serialization "</literal>
						 <literal type="string">"operations is to be considered as documents or content fragments."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>xmloption</name></expr>,
		<expr><name>XMLOPTION_CONTENT</name></expr>, <expr><name>xmloption_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"huge_pages"</literal></expr>, <expr><name>PGC_POSTMASTER</name></expr>, <expr><name>RESOURCES_MEM</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Use of huge pages on Linux or Windows."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>huge_pages</name></expr>,
		<expr><name>HUGE_PAGES_TRY</name></expr>, <expr><name>huge_pages_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"force_parallel_mode"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Forces use of parallel query facilities."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"If possible, run query using a parallel worker and with parallel restrictions."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>force_parallel_mode</name></expr>,
		<expr><name>FORCE_PARALLEL_OFF</name></expr>, <expr><name>force_parallel_mode_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"password_encryption"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>CONN_AUTH_AUTH</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Encrypt passwords."</literal></expr></argument>)</argument_list></call></expr>,
			<macro><name>gettext_noop</name><argument_list>(<argument><literal type="string">"When a password is specified in CREATE USER or "</literal>
						 <literal type="string">"ALTER USER without writing either ENCRYPTED or UNENCRYPTED, "</literal>
						 <literal type="string">"this parameter determines whether the password is to be encrypted."</literal></argument>)</argument_list></macro>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>Password_encryption</name></expr>,
		<expr><name>PASSWORD_TYPE_MD5</name></expr>, <expr><name>password_encryption_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"plan_cache_mode"</literal></expr>, <expr><name>PGC_USERSET</name></expr>, <expr><name>QUERY_TUNING_OTHER</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Controls the planner's selection of custom or generic plan."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Prepared statements can have custom and generic plans, and the planner "</literal>
						 <literal type="string">"will attempt to choose which is better.  This can be set to override "</literal>
						 <literal type="string">"the default behavior."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>GUC_EXPLAIN</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>plan_cache_mode</name></expr>,
		<expr><name>PLAN_CACHE_MODE_AUTO</name></expr>, <expr><name>plan_cache_mode_options</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_min_protocol_version"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the minimum SSL/TLS protocol version to use."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_min_protocol_version</name></expr>,
		<expr><name>PG_TLS1_VERSION</name></expr>,
		<expr><name>ssl_protocol_versions_info</name> <operator>+</operator> <literal type="number">1</literal></expr>, <comment type="block">/* don't allow PG_TLS_ANY */</comment>
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<expr><block>{
		<expr><block>{<expr><literal type="string">"ssl_max_protocol_version"</literal></expr>, <expr><name>PGC_SIGHUP</name></expr>, <expr><name>CONN_AUTH_SSL</name></expr>,
			<expr><call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Sets the maximum SSL/TLS protocol version to use."</literal></expr></argument>)</argument_list></call></expr>,
			<expr><name>NULL</name></expr>,
			<expr><name>GUC_SUPERUSER_ONLY</name></expr>
		}</block></expr>,
		<expr><operator>&amp;</operator><name>ssl_max_protocol_version</name></expr>,
		<expr><name>PG_TLS_ANY</name></expr>,
		<expr><name>ssl_protocol_versions_info</name></expr>,
		<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>,

	<comment type="block">/* End-of-list marker */</comment>
	<expr><block>{
		<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>}</block></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
	}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/******** end of options list ********/</comment>


<comment type="block">/*
 * To allow continued support of obsolete names for GUC variables, we apply
 * the following mappings to any unrecognized name.  Note that an old name
 * should be mapped to a new one only if the new variable has very similar
 * semantics to the old.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>map_old_guc_names</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"sort_mem"</literal></expr>, <expr><literal type="string">"work_mem"</literal></expr>,
	<expr><literal type="string">"vacuum_mem"</literal></expr>, <expr><literal type="string">"maintenance_work_mem"</literal></expr>,
	<expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Actual lookup of variables is done through this single, sorted array.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>guc_variables</name></decl>;</decl_stmt>

<comment type="block">/* Current number of variables contained in the vector */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_guc_variables</name></decl>;</decl_stmt>

<comment type="block">/* Current number of variables marked with GUC_EXPLAIN */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>num_guc_explain_variables</name></decl>;</decl_stmt>

<comment type="block">/* Vector capacity */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>size_guc_variables</name></decl>;</decl_stmt>


<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>guc_dirty</name></decl>;</decl_stmt>			<comment type="block">/* true if need to do commit/abort work */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>reporting_enabled</name></decl>;</decl_stmt>	<comment type="block">/* true to enable GUC_REPORT */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>GUCNestLevel</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* 1 when in main transaction */</comment>


<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>guc_var_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeGUCOptionsFromEnvironment</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InitializeOneGUCOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>push_old_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ReportGUCOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>reapply_stacked_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>variable</name></decl></parameter>,
								   <parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>pHolder</name></decl></parameter>,
								   <parameter><decl><type><name>GucStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
								   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curvalue</name></decl></parameter>,
								   <parameter><decl><type><name>GucContext</name></type> <name>curscontext</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>cursource</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShowGUCConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ShowAllGUCConfig</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>_ShowOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_units</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>validate_option_array_item</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
									   <parameter><decl><type><name>bool</name></type> <name>skipIfNoPermissions</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_auto_conf_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>head_p</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>replace_auto_config_value</name><parameter_list>(<parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>head_p</name></decl></parameter>, <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail_p</name></decl></parameter>,
									  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DispatchSetPGVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Some infrastructure for checking malloc/strdup/realloc calls
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>guc_malloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<comment type="block">/* Avoid unportable behavior of malloc(0) */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>guc_realloc</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>old</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<comment type="block">/* Avoid unportable behavior of realloc(NULL, 0) */</comment>
	<if_stmt><if>if <condition>(<expr><name>old</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>realloc</name><argument_list>(<argument><expr><name>old</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>guc_strdup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>src</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>data</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Detect whether strval is referenced anywhere in a GUC string item
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>string_field_used</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>strval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>strval</name> <operator>==</operator> <operator>*</operator><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator> <operator>||</operator>
		<name>strval</name> <operator>==</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>||</operator>
		<name>strval</name> <operator>==</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>strval</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name> <operator>||</operator>
			<name>strval</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Support for assigning to a field of a string GUC item.  Free the prior
 * value if it's not referenced anywhere else in the item (including stacked
 * states).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_string_field</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>oldval</name> <init>= <expr><operator>*</operator><name>field</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do the assignment */</comment>
	<expr_stmt><expr><operator>*</operator><name>field</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>

	<comment type="block">/* Free old value if it's not NULL and isn't referenced anymore */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>string_field_used</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detect whether an "extra" struct is referenced anywhere in a GUC item
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>extra_field_used</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <name><name>gconf</name><operator>-&gt;</operator><name>extra</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>reset_extra</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>extra</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name> <operator>||</operator>
			<name>extra</name> <operator>==</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>extra</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Support for assigning to an "extra" field of a GUC item.  Free the prior
 * value if it's not referenced anywhere else in the item (including stacked
 * states).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_extra_field</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>field</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>oldval</name> <init>= <expr><operator>*</operator><name>field</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do the assignment */</comment>
	<expr_stmt><expr><operator>*</operator><name>field</name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>

	<comment type="block">/* Free old value if it's not NULL and isn't referenced anymore */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>oldval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support for copying a variable's active value into a stack entry.
 * The "extra" field associated with the active value is copied, too.
 *
 * NB: be sure stringval and extra fields of a new stack entry are
 * initialized to NULL before this is used, else we'll try to free() them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_stack_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>config_var_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>boolval</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>intval</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>realval</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>stringval</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<expr_stmt><expr><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>enumval</name></name> <operator>=</operator>
				<operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>extra</name></name><operator>)</operator></expr></argument>, <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Support for discarding a no-longer-needed value in a stack entry.
 * The "extra" field associated with the stack entry is cleared, too.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>discard_stack_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>config_var_value</name> <modifier>*</modifier></type><name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<comment type="block">/* no need to do anything */</comment>
			<break>break;</break>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>val</name><operator>.</operator><name>stringval</name></name><operator>)</operator></expr></argument>,
							 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>val</name><operator>-&gt;</operator><name>extra</name></name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Fetch the sorted array pointer (exported for help_config.c's use ONLY)
 */</comment>
<function><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type>
<name>get_guc_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>guc_variables</name></expr>;</return>
</block_content>}</block></function>
<function><type><name>int</name></type> <name>get_num_guc_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>num_guc_variables</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * gp_guc_list_init
 *
 * Builds global lists of interesting GUCs...
 *
 * - gp_guc_list_for_explain: consists of planner GUCs, plus 'work_mem'
 * - gp_guc_list_for_no_plan: planner method enables for cdb_no_plan_for_query().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gp_guc_list_init</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>int</name></type>         <name>i</name></decl>;</decl_stmt>

    <if_stmt><if>if <condition>(<expr><name>gp_guc_list_for_explain</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>gp_guc_list_for_explain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>gp_guc_list_for_explain</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>gp_guc_list_for_no_plan</name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>gp_guc_list_for_no_plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>gp_guc_list_for_no_plan</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name>  <modifier>*</modifier></type><name>gconf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>    <name>explain</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
        <decl_stmt><decl><type><name>bool</name></type>    <name>no_plan</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

        <switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>group</name></name></expr>)</condition>
        <block>{<block_content>
            <case>case <expr><name>QUERY_TUNING</name></expr>:</case>
            <case>case <expr><name>QUERY_TUNING_COST</name></expr>:</case>
            <case>case <expr><name>QUERY_TUNING_OTHER</name></expr>:</case>
                <expr_stmt><expr><name>explain</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>QUERY_TUNING_METHOD</name></expr>:</case>
                <expr_stmt><expr><name>explain</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <expr_stmt><expr><name>no_plan</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
                <break>break;</break>

            <case>case <expr><name>RESOURCES_MEM</name></expr>:</case>
                <if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>guc_name_compare</name><argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"work_mem"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
                    <expr_stmt><expr><name>explain</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
                <break>break;</break>

            <default>default:</default>
                <break>break;</break>
        </block_content>}</block></switch>

        <if_stmt><if>if <condition>(<expr><name>explain</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>gp_guc_list_for_explain</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gp_guc_list_for_explain</name></expr></argument>, <argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
        <if_stmt><if>if <condition>(<expr><name>no_plan</name></expr>)</condition><block type="pseudo"><block_content>
            <expr_stmt><expr><name>gp_guc_list_for_no_plan</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gp_guc_list_for_no_plan</name></expr></argument>, <argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>                               <comment type="block">/* gp_guc_list_init */</comment>

<comment type="block">/*
 * Build the sorted array.  This is split out so that it could be
 * re-executed after startup (e.g., we could allow loadable modules to
 * add vars, and then we'd need to re-sort).
 */</comment>
<function><type><name>void</name></type>
<name>build_guc_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>size_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_vars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_explain_vars</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>guc_vars</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* validate that the config_group array has same # of elements as config_group enumeration */</comment>
	<for>for <control>( <init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>___CONFIG_GROUP_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
	    <expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>config_group_names</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>config_group_names</name><index>[<expr><name>___CONFIG_GROUP_COUNT</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Rather than requiring vartype to be filled in by hand, do this: */</comment>
		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_BOOL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_EXPLAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_explain_vars</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesBool_gp</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_BOOL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_INT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_EXPLAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_explain_vars</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesInt_gp</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_INT</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_REAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_EXPLAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_explain_vars</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesReal_gp</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_REAL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_STRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_EXPLAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_explain_vars</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesString_gp</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_STRING</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_ENUM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_EXPLAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>num_explain_vars</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>&amp;</operator><name><name>ConfigureNamesEnum_gp</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_ENUM</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_vars</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Create table with 20% slack
	 */</comment>
	<expr_stmt><expr><name>size_vars</name> <operator>=</operator> <name>num_vars</name> <operator>+</operator> <name>num_vars</name> <operator>/</operator> <literal type="number">4</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>guc_vars</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>size_vars</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_vars</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesBool</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesBool_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesBool_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesInt</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesInt_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesInt_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesReal</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesReal_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesReal_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesString</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesString_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesString_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesEnum</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>ConfigureNamesEnum_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name><name>gen</name><operator>.</operator><name>name</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>guc_vars</name><index>[<expr><name>num_vars</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>&amp;</operator><name><name>ConfigureNamesEnum_gp</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>gen</name></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>guc_variables</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>guc_variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>guc_variables</name> <operator>=</operator> <name>guc_vars</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_guc_variables</name> <operator>=</operator> <name>num_vars</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_guc_explain_variables</name> <operator>=</operator> <name>num_explain_vars</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>size_guc_variables</name> <operator>=</operator> <name>size_vars</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gpdb_assign_sync_flag</name><argument_list>(<argument><expr><name>guc_variables</name></expr></argument>, <argument><expr><name>num_guc_variables</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* predefine */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>guc_variables</name></expr></argument>, <argument><expr><name>num_guc_variables</name></expr></argument>,
		  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>guc_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add a new GUC variable to the list of known variables. The
 * list is expanded if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>add_guc_variable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>num_guc_variables</name> <operator>+</operator> <literal type="number">1</literal> <operator>&gt;=</operator> <name>size_guc_variables</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Increase the vector by 25%
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>size_vars</name> <init>= <expr><name>size_guc_variables</name> <operator>+</operator> <name>size_guc_variables</name> <operator>/</operator> <literal type="number">4</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>guc_vars</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>size_vars</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>size_vars</name> <operator>=</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>guc_vars</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>guc_malloc</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>size_vars</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>guc_vars</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator>
				<call><name>guc_realloc</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>guc_variables</name></expr></argument>, <argument><expr><name>size_vars</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>guc_vars</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* out of memory */</comment>

		<expr_stmt><expr><name>guc_variables</name> <operator>=</operator> <name>guc_vars</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>size_guc_variables</name> <operator>=</operator> <name>size_vars</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>guc_variables</name><index>[<expr><name>num_guc_variables</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>var</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gpdb_assign_sync_flag</name><argument_list>(<argument><expr><operator>&amp;</operator><name>var</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* predefine */</comment>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>guc_variables</name></expr></argument>, <argument><expr><name>num_guc_variables</name></expr></argument>,
		  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>guc_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create and add a placeholder variable for a custom variable name.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type>
<name>add_placeholder_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>sz</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_string</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gen</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>var</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>gen</name> <operator>=</operator> <operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>gen</name><operator>-&gt;</operator><name>name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>PGC_USERSET</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>CUSTOM_OPTIONS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>short_desc</name></name> <operator>=</operator> <literal type="string">"GUC placeholder variable"</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>GUC_NO_SHOW_ALL</name> <operator>|</operator> <name>GUC_NOT_IN_SAMPLE</name> <operator>|</operator> <name>GUC_CUSTOM_PLACEHOLDER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name>PGC_STRING</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The char* is allocated at the end of the struct since we have no
	 * 'static' place to point to.  Note that the current value, as well as
	 * the boot and reset values, start out NULL.
	 */</comment>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <operator>(</operator><name>var</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>add_guc_variable</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>)</operator> <name>var</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>gen</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>var</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>gen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Look up option NAME.  If it exists, return a pointer to its record,
 * else return NULL.  If create_placeholders is true, we'll create a
 * placeholder record for a valid-looking custom variable name.
 */</comment>
<function><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type>
<name>find_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>create_placeholders</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>key</name> <init>= <expr><operator>&amp;</operator><name>name</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * By equating const char ** with struct config_generic *, we are assuming
	 * the name field is first in config_generic.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>guc_variables</name></expr></argument>,
											 <argument><expr><name>num_guc_variables</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
											 <argument><expr><name>guc_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>*</operator><name>res</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * See if the name is an obsolete name for a variable.  We assume that the
	 * set of supported old names is short enough that a brute-force search is
	 * the best way.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>map_old_guc_names</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>guc_name_compare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>map_old_guc_names</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>find_option</name><argument_list>(<argument><expr><name><name>map_old_guc_names</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>create_placeholders</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Check if the name is qualified, and if so, add a placeholder.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>GUC_QUALIFIER_SEPARATOR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>add_placeholder_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Unknown name */</comment>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * comparator for qsorting and bsearching guc_variables array
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>guc_var_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>confa</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>a</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>confb</name> <init>= <expr><operator>*</operator><operator>(</operator>struct <name>config_generic</name> <operator>*</operator><specifier>const</specifier> <operator>*</operator><operator>)</operator> <name>b</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>guc_name_compare</name><argument_list>(<argument><expr><name><name>confa</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>confb</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * the bare comparison function for GUC names
 */</comment>
<function><type><name>int</name></type>
<name>guc_name_compare</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>namea</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nameb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The temptation to use strcasecmp() here must be resisted, because the
	 * array ordering has to remain stable across setlocale() calls. So, build
	 * our own with a simple ASCII-only downcasing.
	 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>namea</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>nameb</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>cha</name> <init>= <expr><operator>*</operator><name>namea</name><operator>++</operator></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>chb</name> <init>= <expr><operator>*</operator><name>nameb</name><operator>++</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cha</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>cha</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cha</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>chb</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>chb</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>chb</name> <operator>+=</operator> <literal type="char">'a'</literal> <operator>-</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>cha</name> <operator>!=</operator> <name>chb</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>cha</name> <operator>-</operator> <name>chb</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>namea</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* a is longer */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>nameb</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* b is longer */</comment>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Initialize GUC options during program startup.
 *
 * Note that we cannot read the config file yet, since we have not yet
 * processed command-line switches.
 */</comment>
<function><type><name>void</name></type>
<name>InitializeGUCOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Before log_line_prefix could possibly receive a nonempty setting, make
	 * sure that timezone processing is minimally alive (see elog.c).
	 */</comment>
	<expr_stmt><expr><call><name>pg_timezone_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build sorted array of all GUC variables.
	 */</comment>
	<expr_stmt><expr><call><name>build_guc_variables</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Load all variables with their compiled-in defaults, and initialize
	 * status fields as needed.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>InitializeOneGUCOption</name><argument_list>(<argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>guc_dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>reporting_enabled</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Prevent any attempt to override the transaction modes from
	 * non-interactive sources.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>, <argument><expr><literal type="string">"read committed"</literal></expr></argument>,
					<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>,
					<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>, <argument><expr><literal type="string">"no"</literal></expr></argument>,
					<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For historical reasons, some GUC parameters can receive defaults from
	 * environment variables.  Process those settings.
	 */</comment>
	<expr_stmt><expr><call><name>InitializeGUCOptionsFromEnvironment</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assign any GUC values that can come from the server's environment.
 *
 * This is called from InitializeGUCOptions, and also from ProcessConfigFile
 * to deal with the possibility that a setting has been removed from
 * postgresql.conf and should now get a value from the environment.
 * (The latter is a kludge that should probably go away someday; if so,
 * fold this back into InitializeGUCOptions.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeGUCOptionsFromEnvironment</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>env</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>stack_rlimit</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGPORT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>env</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"port"</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ENV_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATESTYLE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>env</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"datestyle"</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ENV_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>env</name> <operator>=</operator> <call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGCLIENTENCODING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>env</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"client_encoding"</literal></expr></argument>, <argument><expr><name>env</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ENV_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * rlimit isn't exactly an "environment variable", but it behaves about
	 * the same.  If we can identify the platform stack depth rlimit, increase
	 * default stack depth setting up to whatever is safe (but at most 2MB).
	 */</comment>
	<expr_stmt><expr><name>stack_rlimit</name> <operator>=</operator> <call><name>get_stack_depth_rlimit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stack_rlimit</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>new_limit</name> <init>= <expr><operator>(</operator><name>stack_rlimit</name> <operator>-</operator> <name>STACK_DEPTH_SLOP</name><operator>)</operator> <operator>/</operator> <literal type="number">1024L</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>new_limit</name> <operator>&gt;</operator> <literal type="number">100</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>limbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name>new_limit</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>new_limit</name></expr></argument>, <argument><expr><literal type="number">2048</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>limbuf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name>new_limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"max_stack_depth"</literal></expr></argument>, <argument><expr><name>limbuf</name></expr></argument>,
							<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_ENV_VAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize one GUC option variable to its compiled-in default.
 *
 * Note: the reason for calling check_hooks is not that we think the boot_val
 * might fail, but that the hooks might wish to compute an "extra" struct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InitializeOneGUCOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>PGC_S_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>reset_source</name></name> <operator>=</operator> <name>PGC_S_DEFAULT</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>PGC_INTERNAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>reset_scontext</name></name> <operator>=</operator> <name>PGC_INTERNAL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>extra</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_bool_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
										  <argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to %d"</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&gt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&lt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_int_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
										 <argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to %d"</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&gt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newval</name> <operator>&lt;=</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_real_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
										  <argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to %g"</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* non-NULL boot_val must always get strdup'd */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_string_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
											<argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to \"%s\""</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name>newval</name></expr> ?</condition><then> <expr><name>newval</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>newval</name> <init>= <expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>extra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_enum_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>,
										  <argument><expr><name>PGC_S_DEFAULT</name></expr></argument>, <argument><expr><name>LOG</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to initialize %s to %d"</literal></expr></argument>,
						 <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name> <operator>=</operator> <name>extra</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Select the configuration files and data directory to be used, and
 * do the initial read of postgresql.conf.
 *
 * This is called after processing command-line switches.
 *		userDoption is the -D switch value if any (NULL if unspecified).
 *		progname is just for use in error messages.
 *
 * Returns true on success; on failure, prints a suitable error message
 * to stderr and returns false.
 */</comment>
<function><type><name>bool</name></type>
<name>SelectConfigFiles</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>userDoption</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>progname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>configdir</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>stat_buf</name></decl>;</decl_stmt>

	<comment type="block">/* configdir is -D option, or $PGDATA if no -D */</comment>
	<if_stmt><if>if <condition>(<expr><name>userDoption</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>configdir</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>userDoption</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>configdir</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><call><name>getenv</name><argument_list>(<argument><expr><literal type="string">"PGDATA"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>configdir</name> <operator>&amp;&amp;</operator> <call><name>stat</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: could not access directory \"%s\": %s\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>,
					 <argument><expr><name>configdir</name></expr></argument>,
					 <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"Run initdb or pg_basebackup to initialize a PostgreSQL data directory.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the configuration file: if config_file was specified on the
	 * command line, use it, else use configdir/postgresql.conf.  In any case
	 * ensure the result is an absolute path, so that it will be interpreted
	 * the same way by future backends.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ConfigFileName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>ConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>CONFIG_FILENAME</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>CONFIG_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the server configuration file.\n"</literal>
					 <literal type="string">"You must specify the --config-file or -D invocation "</literal>
					 <literal type="string">"option or set the PGDATA environment variable.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Set the ConfigFileName GUC variable to its final value, ensuring that
	 * it can't be overridden later.
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"config_file"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now read the config file for the first time.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>ConfigFileName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>stat_buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s: could not access the server configuration file \"%s\": %s\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ConfigFileName</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>errno</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Read the configuration file for the first time.  This time only the
	 * data_directory parameter is picked up to determine the data directory,
	 * so that we can read the PG_AUTOCONF_FILENAME file next time.
	 */</comment>
	<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_POSTMASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the data_directory GUC variable has been set, use that as DataDir;
	 * otherwise use configdir if set; else punt.
	 *
	 * Note: SetDataDir will copy and absolute-ize its argument, so we don't
	 * have to.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>data_directory</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetDataDir</name><argument_list>(<argument><expr><name>data_directory</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SetDataDir</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the database system data.\n"</literal>
					 <literal type="string">"This can be specified as \"data_directory\" in \"%s\", "</literal>
					 <literal type="string">"or by the -D invocation option, or by the "</literal>
					 <literal type="string">"PGDATA environment variable.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Reflect the final DataDir value back into the data_directory GUC var.
	 * (If you are wondering why we don't just make them a single variable,
	 * it's because the EXEC_BACKEND case needs DataDir to be transmitted to
	 * child backends specially.  XXX is that still true?  Given that we now
	 * chdir to DataDir, EXEC_BACKEND can read the config file without knowing
	 * DataDir in advance.)
	 */</comment>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"data_directory"</literal></expr></argument>, <argument><expr><name>DataDir</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now read the config file a second time, allowing any settings in the
	 * PG_AUTOCONF_FILENAME file to take effect.  (This is pretty ugly, but
	 * since we have to determine the DataDir before we can find the autoconf
	 * file, the alternatives seem worse.)
	 */</comment>
	<expr_stmt><expr><call><name>ProcessConfigFile</name><argument_list>(<argument><expr><name>PGC_POSTMASTER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If timezone_abbreviations wasn't set in the configuration file, install
	 * the default value.  We do it this way because we can't safely install a
	 * "real" value until my_exec_path is set, which may not have happened
	 * when InitializeGUCOptions runs, so the bootstrap default value cannot
	 * be the real desired default.
	 */</comment>
	<expr_stmt><expr><call><name>pg_timezone_abbrev_initialize</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Figure out where pg_hba.conf is, and make sure the path is absolute.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>HbaFileName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>HbaFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>HBA_FILENAME</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>HBA_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the \"hba\" configuration file.\n"</literal>
					 <literal type="string">"This can be specified as \"hba_file\" in \"%s\", "</literal>
					 <literal type="string">"or by the -D invocation option, or by the "</literal>
					 <literal type="string">"PGDATA environment variable.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"hba_file"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Likewise for pg_ident.conf.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IdentFileName</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>make_absolute_path</name><argument_list>(<argument><expr><name>IdentFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>configdir</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>fname</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						   <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>IDENT_FILENAME</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>fname</name></expr></argument>, <argument><expr><literal type="string">"%s/%s"</literal></expr></argument>, <argument><expr><name>configdir</name></expr></argument>, <argument><expr><name>IDENT_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"%s does not know where to find the \"ident\" configuration file.\n"</literal>
					 <literal type="string">"This can be specified as \"ident_file\" in \"%s\", "</literal>
					 <literal type="string">"or by the -D invocation option, or by the "</literal>
					 <literal type="string">"PGDATA environment variable.\n"</literal></expr></argument>,
					 <argument><expr><name>progname</name></expr></argument>, <argument><expr><name>ConfigFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"ident_file"</literal></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_OVERRIDE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>fname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>configdir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Reset all options to their saved default values (implements RESET ALL)
 */</comment>
<function><type><name>void</name></type>
<name>ResetAllOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Don't reset non-SET-able values */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>!=</operator> <name>PGC_SUSET</name> <operator>&amp;&amp;</operator>
			<name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>!=</operator> <name>PGC_USERSET</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* Don't reset if special exclusion from RESET ALL */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_NO_RESET_ALL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<comment type="block">/* No need to reset if wasn't SET */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>PGC_S_OVERRIDE</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Save old value to support transaction abort */</comment>
		<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><name>GUC_ACTION_SET</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>PGC_BOOL</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>PGC_INT</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>PGC_REAL</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>PGC_STRING</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><name>PGC_ENUM</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
										  <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
		</block_content>}</block></switch>

		<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>reset_source</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>reset_scontext</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReportGUCOption</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * push_old_value
 *		Push previous state during transactional assignment to a GUC variable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>push_old_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>, <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

	<comment type="block">/* If we're not inside a nest level, do nothing */</comment>
	<if_stmt><if>if <condition>(<expr><name>GUCNestLevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Do we already have a stack entry of the current nest level? */</comment>
	<expr_stmt><expr><name>stack</name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>stack</name> <operator>&amp;&amp;</operator> <name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>&gt;=</operator> <name>GUCNestLevel</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Yes, so adjust its state if necessary */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <name>GUCNestLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name>action</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>GUC_ACTION_SET</name></expr>:</case>
				<comment type="block">/* SET overrides any prior action at same nest level */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET_LOCAL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* must discard old masked value */</comment>
					<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>masked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>GUC_ACTION_LOCAL</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* SET followed by SET LOCAL, remember SET's value */</comment>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>masked_scontext</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>masked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET_LOCAL</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<comment type="block">/* in all other cases, no change to stack entry */</comment>
				<break>break;</break>
			<case>case <expr><name>GUC_ACTION_SAVE</name></expr>:</case>
				<comment type="block">/* Could only have a prior SAVE of same variable */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SAVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>guc_dirty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* must be set already */</comment>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Push a new stack entry
	 *
	 * We keep all the stack entries in TopTransactionContext for simplicity.
	 */</comment>
	<expr_stmt><expr><name>stack</name> <operator>=</operator> <operator>(</operator><name>GucStack</name> <operator>*</operator><operator>)</operator> <call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
												<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GucStack</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prev</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>=</operator> <name>GUCNestLevel</name></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>action</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>GUC_ACTION_SET</name></expr>:</case>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GUC_ACTION_LOCAL</name></expr>:</case>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_LOCAL</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>GUC_ACTION_SAVE</name></expr>:</case>
			<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SAVE</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>stack</name></expr>;</expr_stmt>

	<comment type="block">/* Ensure we remember to pop at end of xact */</comment>
	<expr_stmt><expr><name>guc_dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Do GUC processing at main transaction start.
 */</comment>
<function><type><name>void</name></type>
<name>AtStart_GUC</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The nest level should be 0 between transactions; if it isn't, somebody
	 * didn't call AtEOXact_GUC, or called it with the wrong nestLevel.  We
	 * throw a warning but make no other effort to clean up.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>GUCNestLevel</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"GUC nest level = %d at transaction start"</literal></expr></argument>,
			 <argument><expr><name>GUCNestLevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>GUCNestLevel</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Enter a new nesting level for GUC values.  This is called at subtransaction
 * start, and when entering a function that has proconfig settings, and in
 * some other places where we want to set GUC variables transiently.
 * NOTE we must not risk error here, else subtransaction start will be unhappy.
 */</comment>
<function><type><name>int</name></type>
<name>NewGUCNestLevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>++</operator><name>GUCNestLevel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do GUC processing at transaction or subtransaction commit or abort, or
 * when exiting a function that has proconfig settings, or when undoing a
 * transient assignment to some GUC variables.  (The name is thus a bit of
 * a misnomer; perhaps it should be ExitGUCNestLevel or some such.)
 * During abort, we discard all GUC settings that were applied at nesting
 * levels &gt;= nestLevel.  nestLevel == 1 corresponds to the main transaction.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_GUC</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nestLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>still_dirty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: it's possible to get here with GUCNestLevel == nestLevel-1 during
	 * abort, if there is a failure during transaction start before
	 * AtStart_GUC is called.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nestLevel</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		   <operator>(</operator><name>nestLevel</name> <operator>&lt;=</operator> <name>GUCNestLevel</name> <operator>||</operator>
			<operator>(</operator><name>nestLevel</name> <operator>==</operator> <name>GUCNestLevel</name> <operator>+</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>isCommit</name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Quick exit if nothing's changed in this transaction */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>guc_dirty</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>GUCNestLevel</name> <operator>=</operator> <name>nestLevel</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>still_dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Process and pop each stack entry within the nest level. To simplify
		 * fmgr_security_definer() and other places that use GUC_ACTION_SAVE,
		 * we allow failure exit from code that uses a local nest level to be
		 * recovered at the surrounding transaction or subtransaction abort;
		 * so there could be more than one stack entry to pop.
		 */</comment>
		<while>while <condition>(<expr><operator>(</operator><name>stack</name> <operator>=</operator> <name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			   <name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>&gt;=</operator> <name>nestLevel</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>prev</name> <init>= <expr><name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>restorePrior</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>restoreMasked</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>changed</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * In this next bit, if we don't set either restorePrior or
			 * restoreMasked, we must "discard" any unwanted fields of the
			 * stack entries to avoid leaking memory.  If we do set one of
			 * those flags, unused fields will be cleaned up after restoring.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isCommit</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* if abort, always restore prior value */</comment>
				<expr_stmt><expr><name>restorePrior</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SAVE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>restorePrior</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* transaction commit */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>restoreMasked</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* we keep the current active value */</comment>
					<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>			<comment type="block">/* must be GUC_LOCAL */</comment>
					<expr_stmt><expr><name>restorePrior</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>prev</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
					 <name><name>prev</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>&lt;</operator> <name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* decrement entry's level and do not pop it */</comment>
				<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name><operator>--</operator></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * We have to merge this stack entry into prev. See README for
				 * discussion of this bit.
				 */</comment>
				<switch>switch <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>GUC_SAVE</name></expr>:</case>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* can't get here */</comment>
						<break>break;</break>

					<case>case <expr><name>GUC_SET</name></expr>:</case>
						<comment type="block">/* next level always becomes SET */</comment>
						<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prev</name><operator>-&gt;</operator><name>masked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET</name></expr>;</expr_stmt>
						<break>break;</break>

					<case>case <expr><name>GUC_LOCAL</name></expr>:</case>
						<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET</name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/* LOCAL migrates down */</comment>
							<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>masked_scontext</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>masked</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET_LOCAL</name></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/* else just forget this stack level */</comment>
							<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
						<break>break;</break>

					<case>case <expr><name>GUC_SET_LOCAL</name></expr>:</case>
						<comment type="block">/* prior state at this level no longer wanted */</comment>
						<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<comment type="block">/* copy down the masked state */</comment>
						<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>masked_scontext</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked_scontext</name></name></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>==</operator> <name>GUC_SET_LOCAL</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>discard_stack_value</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>prev</name><operator>-&gt;</operator><name>masked</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>masked</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>state</name></name> <operator>=</operator> <name>GUC_SET_LOCAL</name></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block></else></if_stmt>

			<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>restorePrior</name> <operator>||</operator> <name>restoreMasked</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Perform appropriate restoration of the stacked value */</comment>
				<decl_stmt><decl><type><name>config_var_value</name></type> <name>newvalue</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GucSource</name></type>	<name>newsource</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>GucContext</name></type>	<name>newscontext</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>restoreMasked</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newsource</name> <operator>=</operator> <name>PGC_S_SESSION</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newscontext</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>masked_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prior</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newsource</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newscontext</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>PGC_BOOL</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>bool</name></type>		<name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>boolval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
					<case>case <expr><name>PGC_INT</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>int</name></type>			<name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>intval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
					<case>case <expr><name>PGC_REAL</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>double</name></type>		<name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>realval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
					<case>case <expr><name>PGC_STRING</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>

							<comment type="block">/*
							 * Release stacked values if not used anymore. We
							 * could use discard_stack_value() here, but since
							 * we have type-specific code anyway, might as
							 * well inline it.
							 */</comment>
							<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<break>break;</break>
						</block_content>}</block>
					<case>case <expr><name>PGC_ENUM</name></expr>:</case>
						<block>{<block_content>
							<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>int</name></type>			<name>newval</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>val</name><operator>.</operator><name>enumval</name></name></expr></init></decl>;</decl_stmt>
							<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name><name>newvalue</name><operator>.</operator><name>extra</name></name></expr></init></decl>;</decl_stmt>

							<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name> <operator>||</operator>
								<name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name> <operator>!=</operator> <name>newextra</name></expr>)</condition>
							<block>{<block_content>
								<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
									<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
								<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
												<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name>changed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></if></if_stmt>
							<break>break;</break>
						</block_content>}</block>
				</block_content>}</block></switch>

				<comment type="block">/*
				 * Release stacked extra values if not used anymore.
				 */</comment>
				<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>extra</name></name><operator>)</operator></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* And restore source information */</comment>
				<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>newsource</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>newscontext</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Finish popping the state stack */</comment>
			<expr_stmt><expr><name><name>gconf</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>stack</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Report new value if we changed it */</comment>
			<if_stmt><if>if <condition>(<expr><name>changed</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ReportGUCOption</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * If a guc's value changed on QD,
			 * record it and restore QE before next query start
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name>
					<operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsTransactionBlock</name><argument_list>()</argument_list></call>
					<operator>&amp;&amp;</operator> <name>changed</name>
					<operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>isCommit</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>isCommit</name> <operator>&amp;&amp;</operator> <name>gp_guc_need_restore</name><operator>)</operator><operator>)</operator>
					<operator>&amp;&amp;</operator> <operator>(</operator><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_GPDB_NEED_SYNC</name><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><name>gp_guc_restore_list</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>gp_guc_restore_list</name></expr></argument>, <argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></while>						<comment type="block">/* end of stack-popping loop */</comment>

		<if_stmt><if>if <condition>(<expr><name>stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>still_dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* If there are no remaining stack entries, we can reset guc_dirty */</comment>
	<expr_stmt><expr><name>guc_dirty</name> <operator>=</operator> <name>still_dirty</name></expr>;</expr_stmt>

	<comment type="block">/* Update nesting level */</comment>
	<expr_stmt><expr><name>GUCNestLevel</name> <operator>=</operator> <name>nestLevel</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Start up automatic reporting of changes to variables marked GUC_REPORT.
 * This is executed at completion of backend startup.
 */</comment>
<function><type><name>void</name></type>
<name>BeginReportingGUCOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Build global lists of GUCs for use. */</comment>
	<expr_stmt><expr><call><name>gp_guc_list_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Don't do anything unless talking to an interactive frontend of protocol
	 * 3.0 or later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>!=</operator> <name>DestRemote</name> <operator>||</operator>
		<call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>reporting_enabled</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/* Transmit initial values of interesting variables */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ReportGUCOption</name><argument_list>(<argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * ReportGUCOption: if appropriate, transmit option value to frontend
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReportGUCOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>reporting_enabled</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>_ShowOption</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>msgbuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><literal type="char">'S'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a value from one of the human-friendly units ("kB", "min" etc.)
 * to the given base unit.  'value' and 'unit' are the input value and unit
 * to convert from (there can be trailing spaces in the unit string).
 * The converted value is stored in *base_value.
 * It's caller's responsibility to round off the converted value as necessary
 * and check for out-of-range.
 *
 * Returns true on success, false if the input unit is not recognized.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>convert_to_base_unit</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>base_unit</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>base_value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>unitstr</name><index>[<expr><name>MAX_UNIT_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>unitlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unit_conversion</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* extract unit string to compare to table entries */</comment>
	<expr_stmt><expr><name>unitlen</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>unit</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>unit</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		   <name>unitlen</name> <operator>&lt;</operator> <name>MAX_UNIT_LEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>unitstr</name><index>[<expr><name>unitlen</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>unit</name><operator>++</operator><operator>)</operator></expr>;</expr_stmt></block_content></block></while>
	<expr_stmt><expr><name><name>unitstr</name><index>[<expr><name>unitlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<comment type="block">/* allow whitespace after unit */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>unit</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>unit</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>unit</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* unit too long, or garbage after it */</comment>

	<comment type="block">/* now search the appropriate table */</comment>
	<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>&amp;</operator> <name>GUC_UNIT_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>memory_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>time_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>==</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base_unit</name> <operator>&amp;&amp;</operator>
			<call><name>strcmp</name><argument_list>(<argument><expr><name>unitstr</name></expr></argument>, <argument><expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>cvalue</name> <init>= <expr><name>value</name> <operator>*</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the user gave a fractional value such as "30.1GB", round it
			 * off to the nearest multiple of the next smaller unit, if there
			 * is one.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>unit</name> <operator>&amp;&amp;</operator>
				<name>base_unit</name> <operator>==</operator> <name><name>table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>base_unit</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>cvalue</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>cvalue</name> <operator>/</operator> <name><name>table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>multiplier</name></expr></argument>)</argument_list></call> <operator>*</operator>
					<name><name>table</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>multiplier</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><operator>*</operator><name>base_value</name> <operator>=</operator> <name>cvalue</name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert an integer value in some base unit to a human-friendly unit.
 *
 * The output unit is chosen so that it's the greatest unit that can represent
 * the value without loss.  For example, if the base unit is GUC_UNIT_KB, 1024
 * is converted to 1 MB, but 1025 is represented as 1025 kB.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_int_from_base_unit</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>base_value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base_unit</name></decl></parameter>,
						   <parameter><decl><type><name>int64</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unit_conversion</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>unit</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>&amp;</operator> <name>GUC_UNIT_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>memory_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>time_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>==</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base_unit</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Accept the first conversion that divides the value evenly.  We
			 * assume that the conversions for each base unit are ordered from
			 * greatest unit to the smallest!
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name> <operator>&lt;=</operator> <literal type="number">1.0</literal> <operator>||</operator>
				<name>base_value</name> <operator>%</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>base_value</name> <operator>/</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>unit</name> <operator>=</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>unit</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a floating-point value in some base unit to a human-friendly unit.
 *
 * Same as above, except we have to do the math a bit differently, and
 * there's a possibility that we don't find any exact divisor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_real_from_base_unit</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>base_value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>base_unit</name></decl></parameter>,
							<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>unit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>unit_conversion</name> <modifier>*</modifier></type><name>table</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>unit</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>&amp;</operator> <name>GUC_UNIT_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>memory_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>table</name> <operator>=</operator> <name>time_unit_conversion_table</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><operator>*</operator><name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>base_unit</name> <operator>==</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>base_unit</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Accept the first conversion that divides the value evenly; or
			 * if there is none, use the smallest (last) target unit.
			 *
			 * What we actually care about here is whether snprintf with "%g"
			 * will print the value as an integer, so the obvious test of
			 * "*value == rint(*value)" is too strict; roundoff error might
			 * make us choose an unreasonably small unit.  As a compromise,
			 * accept a divisor that is within 1e-8 of producing an integer.
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>base_value</name> <operator>/</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>multiplier</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>unit</name> <operator>=</operator> <name><name>table</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>unit</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>value</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<call><name>fabs</name><argument_list>(<argument><expr><operator>(</operator><call><name>rint</name><argument_list>(<argument><expr><operator>*</operator><name>value</name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>*</operator><name>value</name><operator>)</operator> <operator>-</operator> <literal type="number">1.0</literal></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1e-8</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>unit</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the name of a GUC's base unit (e.g. "ms") given its flags.
 * Return NULL if the GUC is unitless.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_config_unit_name</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>GUC_UNIT_MEMORY</name> <operator>|</operator> <name>GUC_UNIT_TIME</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<return>return <expr><name>NULL</name></expr>;</return>		<comment type="block">/* GUC has no units */</comment>
		<case>case <expr><name>GUC_UNIT_BYTE</name></expr>:</case>
			<return>return <expr><literal type="string">"B"</literal></expr>;</return>
		<case>case <expr><name>GUC_UNIT_KB</name></expr>:</case>
			<return>return <expr><literal type="string">"kB"</literal></expr>;</return>
		<case>case <expr><name>GUC_UNIT_MB</name></expr>:</case>
			<return>return <expr><literal type="string">"MB"</literal></expr>;</return>
		<case>case <expr><name>GUC_UNIT_BLOCKS</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>bbuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

				<comment type="block">/* initialize if first time through */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>bbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>bbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>bbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%dkB"</literal></expr></argument>, <argument><expr><name>BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>bbuf</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>GUC_UNIT_XBLOCKS</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>xbuf</name><index>[<expr><literal type="number">8</literal></expr>]</index></name></decl>;</decl_stmt>

				<comment type="block">/* initialize if first time through */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>xbuf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>xbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%dkB"</literal></expr></argument>, <argument><expr><name>XLOG_BLCKSZ</name> <operator>/</operator> <literal type="number">1024</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<return>return <expr><name>xbuf</name></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>GUC_UNIT_MS</name></expr>:</case>
			<return>return <expr><literal type="string">"ms"</literal></expr>;</return>
		<case>case <expr><name>GUC_UNIT_S</name></expr>:</case>
			<return>return <expr><literal type="string">"s"</literal></expr>;</return>
		<case>case <expr><name>GUC_UNIT_MIN</name></expr>:</case>
			<return>return <expr><literal type="string">"min"</literal></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized GUC units value: %d"</literal></expr></argument>,
				 <argument><expr><name>flags</name> <operator>&amp;</operator> <operator>(</operator><name>GUC_UNIT_MEMORY</name> <operator>|</operator> <name>GUC_UNIT_TIME</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Try to parse value as an integer.  The accepted formats are the
 * usual decimal, octal, or hexadecimal formats, as well as floating-point
 * formats (which will be rounded to integer after any units conversion).
 * Optionally, the value can be followed by a unit name if "flags" indicates
 * a unit is allowed.
 *
 * If the string parses okay, return true, else false.
 * If okay and result is not NULL, return the value in *result.
 * If not okay and hintmsg is not NULL, *hintmsg is set to a suitable
 * HINT message, or NULL if no hint provided.
 */</comment>
<function><type><name>bool</name></type>
<name>parse_int</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>hintmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We assume here that double is wide enough to represent any integer
	 * value with adequate precision.
	 */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<comment type="block">/* To suppress compiler warnings, always set output params */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Try to parse as an integer (allowing octal or hex input).  If the
	 * conversion stops at a decimal point or 'e', or overflows, re-parse as
	 * float.  This should work fine as long as we have no unit names starting
	 * with 'e'.  If we ever do, the test could be extended to check for a
	 * sign or digit after 'e', but for now that's unnecessary.
	 */</comment>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'.'</literal> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>endptr</name> <operator>==</operator> <literal type="char">'E'</literal> <operator>||</operator>
		<name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no HINT for these cases */</comment>

	<comment type="block">/* reject NaN (infinities will fail range check below) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* treat same as syntax error; no HINT */</comment>

	<comment type="block">/* allow whitespace between number and unit */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Handle possible unit */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GUC_UNIT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* this setting does not accept a unit */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>convert_to_base_unit</name><argument_list>(<argument><expr><name>val</name></expr></argument>,
								  <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GUC_UNIT</name><operator>)</operator></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* invalid unit, or garbage after the unit; set hint and fail. */</comment>
			<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GUC_UNIT_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>memory_units_hint</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>time_units_hint</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Round to int, then check for overflow */</comment>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;</operator> <name>INT_MAX</name> <operator>||</operator> <name>val</name> <operator>&lt;</operator> <name>INT_MIN</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"Value exceeds integer range."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to parse value as a floating point number in the usual format.
 * Optionally, the value can be followed by a unit name if "flags" indicates
 * a unit is allowed.
 *
 * If the string parses okay, return true, else false.
 * If okay and result is not NULL, return the value in *result.
 * If not okay and hintmsg is not NULL, *hintmsg is set to a suitable
 * HINT message, or NULL if no hint provided.
 */</comment>
<function><type><name>bool</name></type>
<name>parse_real</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>hintmsg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<comment type="block">/* To suppress compiler warnings, always set output params */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>value</name> <operator>||</operator> <name>errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* no HINT for these cases */</comment>

	<comment type="block">/* reject NaN (infinities will fail range checks later) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* treat same as syntax error; no HINT */</comment>

	<comment type="block">/* allow whitespace between number and unit */</comment>
	<while>while <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>endptr</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* Handle possible unit */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GUC_UNIT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* this setting does not accept a unit */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>convert_to_base_unit</name><argument_list>(<argument><expr><name>val</name></expr></argument>,
								  <argument><expr><name>endptr</name></expr></argument>, <argument><expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GUC_UNIT</name><operator>)</operator></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* invalid unit, or garbage after the unit; set hint and fail. */</comment>
			<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GUC_UNIT_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>memory_units_hint</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>hintmsg</name> <operator>=</operator> <name>time_units_hint</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Lookup the name for an enum option with the selected value.
 * Should only ever be called with known-valid values, so throws
 * an elog(ERROR) if the enum option is not found.
 *
 * The returned string is a pointer to static data and not
 * allocated for modification.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>config_enum_lookup_by_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>val</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>val</name></name> <operator>==</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find enum option %d for %s"</literal></expr></argument>,
		 <argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* silence compiler */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Lookup the value for an enum option with the selected name
 * (case-insensitive).
 * If the enum option is found, sets the retval value and returns
 * true. If it's not found, return false and retval is set to 0.
 */</comment>
<function><type><name>bool</name></type>
<name>config_enum_lookup_by_name</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						   <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>retval</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>val</name></name></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>retval</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Return a list of all available options for an enum, excluding
 * hidden ones, separated by the given separator.
 * If prefix is non-NULL, it is added before the first enum value.
 * If suffix is non-NULL, it is added to the end of the string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>config_enum_get_options</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>separator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>retstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>seplen</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>seplen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>separator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>entry</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>options</name></name></expr>;</init> <condition><expr><name>entry</name> <operator>&amp;&amp;</operator> <name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr>;</condition> <incr><expr><name>entry</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>hidden</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name>separator</name></expr></argument>, <argument><expr><name>seplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * All the entries may have been hidden, leaving the string empty if no
	 * prefix was given. This indicates a broken GUC setup, since there is no
	 * use for an enum without any values, so we just check to make sure we
	 * don't write to invalid memory instead of actually trying to do
	 * something smart with it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>retstr</name><operator>.</operator><name>len</name></name> <operator>&gt;=</operator> <name>seplen</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Replace final separator */</comment>
		<expr_stmt><expr><name><name>retstr</name><operator>.</operator><name>data</name><index>[<expr><name><name>retstr</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name>seplen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>retstr</name><operator>.</operator><name>len</name></name> <operator>-=</operator> <name>seplen</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>retstr</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>retstr</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Parse and validate a proposed value for the specified configuration
 * parameter.
 *
 * This does built-in checks (such as range limits for an integer parameter)
 * and also calls any check hook the parameter may have.
 *
 * record: GUC variable's info record
 * name: variable name (should match the record of course)
 * value: proposed value, as a string
 * source: identifies source of value (check hooks may need this)
 * elevel: level to log any error reports at
 * newval: on success, converted parameter value is returned here
 * newextra: on success, receives any "extra" data returned by check hook
 *	(caller must initialize *newextra to NULL)
 *
 * Returns true if OK, false if not (or throws error, if elevel &gt;= ERROR)
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>parse_and_validate_value</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						 <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
						 <parameter><decl><type><name><name>union</name> <name>config_var_val</name></name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>newextra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_bool</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>boolval</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" requires a Boolean value"</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_bool_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>boolval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
										  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_int</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>intval</name></name></expr></argument>,
							   <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hintmsg</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <ternary><condition><expr><name>hintmsg</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>newval</name><operator>-&gt;</operator><name>intval</name></name> <operator>&lt;</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name> <operator>||</operator> <name><name>newval</name><operator>-&gt;</operator><name>intval</name></name> <operator>&gt;</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name> <init>= <expr><call><name>get_config_unit_name</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%d%s%s is outside the valid range for parameter \"%s\" (%d .. %d)"</literal></expr></argument>,
									<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>intval</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name>unit</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
									<argument><expr><ternary><condition><expr><name>unit</name></expr> ?</condition><then> <expr><name>unit</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
									<argument><expr><name>name</name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_int_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>intval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
										 <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_real</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>realval</name></name></expr></argument>,
								<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>hintmsg</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <ternary><condition><expr><name>hintmsg</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>newval</name><operator>-&gt;</operator><name>realval</name></name> <operator>&lt;</operator> <name><name>conf</name><operator>-&gt;</operator><name>min</name></name> <operator>||</operator> <name><name>newval</name><operator>-&gt;</operator><name>realval</name></name> <operator>&gt;</operator> <name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name> <init>= <expr><call><name>get_config_unit_name</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%g%s%s is outside the valid range for parameter \"%s\" (%g .. %g)"</literal></expr></argument>,
									<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>realval</name></name></expr></argument>,
									<argument><expr><ternary><condition><expr><name>unit</name></expr> ?</condition><then> <expr><literal type="string">" "</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
									<argument><expr><ternary><condition><expr><name>unit</name></expr> ?</condition><then> <expr><name>unit</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
									<argument><expr><name>name</name></expr></argument>,
									<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_real_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>realval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
										  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * The value passed by the caller could be transient, so we
				 * always strdup it.
				 */</comment>
				<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * The only built-in "parsing" check we have is to apply
				 * truncation if GUC_IS_NAME.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_IS_NAME</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>truncate_identifier</name><argument_list>(<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>,
										<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_string_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
											<argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newval</name><operator>-&gt;</operator><name>stringval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>config_enum_lookup_by_name</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>enumval</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hintmsg</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>hintmsg</name> <operator>=</operator> <call><name>config_enum_get_options</name><argument_list>(<argument><expr><name>conf</name></expr></argument>,
													  <argument><expr><literal type="string">"Available values: "</literal></expr></argument>,
													  <argument><expr><literal type="string">"."</literal></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
									<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <ternary><condition><expr><name>hintmsg</name></expr> ?</condition><then> <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>hintmsg</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hintmsg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<return>return <expr><name>false</name></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_enum_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>newval</name><operator>-&gt;</operator><name>enumval</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>,
										  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Sets option `name' to given value.
 *
 * The value should be a string, which will be parsed and converted to
 * the appropriate data type.  The context and source parameters indicate
 * in which context this function is being called, so that it can apply the
 * access restrictions properly.
 *
 * If value is NULL, set the option to its default value (normally the
 * reset_val, but if source == PGC_S_DEFAULT we instead use the boot_val).
 *
 * action indicates whether to set the value globally in the session, locally
 * to the current top transaction, or just for the duration of a function call.
 *
 * If changeVal is false then don't really set the option but do all
 * the checks to see if it would work.
 *
 * elevel should normally be passed as zero, allowing this function to make
 * its standard choice of ereport level.  However some callers need to be
 * able to override that choice; they should pass the ereport level to use.
 *
 * Return value:
 *	+1: the value is valid and was successfully applied.
 *	0:	the name or value is invalid (but see below).
 *	-1: the value was not applied because of context, priority, or changeVal.
 *
 * If there is an error (non-existing option, invalid value) then an
 * ereport(ERROR) is thrown *unless* this is called for a source for which
 * we don't want an ERROR (currently, those are defaults, the config file,
 * and per-database or per-user settings, as well as callers who specify
 * a less-than-ERROR elevel).  In those cases we write a suitable error
 * message via ereport() and return 0.
 *
 * See also SetConfigOption for an external interface.
 */</comment>
<function><type><name>int</name></type>
<name>set_config_option</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
				  <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>,
				  <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>changeVal</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>is_reload</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>union</name> <name>config_var_val</name></name></type> <name>newval_union</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>prohibitValueChange</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>makeDefault</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name> <operator>||</operator> <name>source</name> <operator>==</operator> <name>PGC_S_FILE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * To avoid cluttering the log, only the postmaster bleats loudly
			 * about problems with the config file.
			 */</comment>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <ternary><condition><expr><name>IsUnderPostmaster</name></expr> ?</condition><then> <expr><name>DEBUG3</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_GLOBAL</name> <operator>||</operator>
				 <name>source</name> <operator>==</operator> <name>PGC_S_DATABASE</name> <operator>||</operator>
				 <name>source</name> <operator>==</operator> <name>PGC_S_USER</name> <operator>||</operator>
				 <name>source</name> <operator>==</operator> <name>PGC_S_DATABASE_USER</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>WARNING</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>ERROR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * GUC_ACTION_SAVE changes are acceptable during a parallel operation,
	 * because the current worker will also pop the change.  We're probably
	 * dealing with a function having a proconfig entry.  Only the function's
	 * body should observe the change, and peer workers do not share in the
	 * execution of a function call started by this worker.
	 *
	 * Other changes might need to affect other workers, so forbid them.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>changeVal</name> <operator>&amp;&amp;</operator> <name>action</name> <operator>!=</operator> <name>GUC_ACTION_SAVE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameters during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if option can be set by the user.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_DISALLOW_USER_SET</name></expr>)</condition>
 	<block>{<block_content>
		<comment type="block">/* Only print a warning in the dispatch or utility mode */</comment>
		<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"\"%s\": can not be set by the user and will be ignored."</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>  <comment type="block">/* end if (record-&gt;flags &amp; GUC_DISALLOW_USER_SET) */</comment>

	<comment type="block">/*
	 * Check if the option can be set at this time. See guc.h for the precise
	 * rules.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_INTERNAL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>PGC_INTERNAL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_POSTMASTER</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_SIGHUP</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * We are re-reading a PGC_POSTMASTER variable from
				 * postgresql.conf.  We can't change the setting, so we should
				 * give a warning if the DBA tries to change it.  However,
				 * because of variant formats, canonicalization by check
				 * hooks, etc, we can't just compare the given string directly
				 * to what's stored.  Set a flag to check below after we have
				 * the final storable value.
				 */</comment>
				<expr_stmt><expr><name>prohibitValueChange</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>context</name> <operator>!=</operator> <name>PGC_POSTMASTER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_SIGHUP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>!=</operator> <name>PGC_SIGHUP</name> <operator>&amp;&amp;</operator> <name>context</name> <operator>!=</operator> <name>PGC_POSTMASTER</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed now"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Hmm, the idea of the SIGHUP context is "ought to be global, but
			 * can be changed after postmaster start". But there's nothing
			 * that prevents a crafty administrator from sending SIGHUP
			 * signals to individual backends only.
			 */</comment>
			<break>break;</break>
		<case>case <expr><name>PGC_SU_BACKEND</name></expr>:</case>
			<comment type="block">/* Reject if we're connecting but user is not superuser */</comment>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_BACKEND</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to set parameter \"%s\""</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* fall through to process the same as PGC_BACKEND */</comment>
			<comment type="block">/* FALLTHROUGH */</comment>
		<case>case <expr><name>PGC_BACKEND</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_SIGHUP</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * If a PGC_BACKEND or PGC_SU_BACKEND parameter is changed in
				 * the config file, we want to accept the new value in the
				 * postmaster (whence it will propagate to
				 * subsequently-started backends), but ignore it in existing
				 * backends.  This is a tad klugy, but necessary because we
				 * don't re-read the config file during backend start.
				 *
				 * In EXEC_BACKEND builds, this works differently: we load all
				 * non-default settings from the CONFIG_EXEC_PARAMS file
				 * during backend start.  In that case we must accept
				 * PGC_SIGHUP settings, so as to have the same value as if
				 * we'd forked from the postmaster.  This can also happen when
				 * using RestoreGUCState() within a background worker that
				 * needs to have the same settings as the user backend that
				 * started it. is_reload will be true when either situation
				 * applies.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_reload</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>context</name> <operator>!=</operator> <name>PGC_POSTMASTER</name> <operator>&amp;&amp;</operator>
					 <name>context</name> <operator>!=</operator> <name>PGC_BACKEND</name> <operator>&amp;&amp;</operator>
					 <name>context</name> <operator>!=</operator> <name>PGC_SU_BACKEND</name> <operator>&amp;&amp;</operator>
					 <name>source</name> <operator>!=</operator> <name>PGC_S_CLIENT</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be set after connection starts"</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_SUSET</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_USERSET</name> <operator>||</operator> <name>context</name> <operator>==</operator> <name>PGC_BACKEND</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to set parameter \"%s\""</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><literal type="number">0</literal></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>PGC_USERSET</name></expr>:</case>
			<comment type="block">/* always okay */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Print out warnings for the attempt to set the GUC in DEPRECATED_OPTIONS. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>group</name></name> <operator>==</operator> <name>DEPRECATED_OPTIONS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Only print a warning in the dispatch or utility mode */</comment>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"\"%s\": setting is deprecated, and may be removed"</literal>
				 <literal type="string">" in a future release."</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Ignore attempted set if the config_group is DEFUNCT_OPTIONS.*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>group</name></name> <operator>==</operator> <name>DEFUNCT_OPTIONS</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Only print a warning in the dispatch or utility mode */</comment>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>, <argument><expr><literal type="string">"\"%s\": setting is ignored because it is defunct"</literal></expr></argument>,
				 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Disallow changing GUC_NOT_WHILE_SEC_REST values if we are inside a
	 * security restriction context.  We can reject this regardless of the GUC
	 * context or source, mainly because sources that it might be reasonable
	 * to override for won't be seen while inside a function.
	 *
	 * Note: variables marked GUC_NOT_WHILE_SEC_REST should usually be marked
	 * GUC_NO_RESET_ALL as well, because ResetAllOptions() doesn't check this.
	 * An exception might be made if the reset value is assumed to be "safe".
	 *
	 * Note: this flag is currently used for "session_authorization" and
	 * "role".  We need to prohibit changing these inside a local userid
	 * context because when we exit it, GUC won't be notified, leaving things
	 * out of sync.  (This could be fixed by forcing a new GUC nesting level,
	 * but that would change behavior in possibly-undesirable ways.)  Also, we
	 * prohibit changing these in a security-restricted operation because
	 * otherwise RESET could be used to regain the session user's privileges.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_NOT_WHILE_SEC_REST</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>InLocalUserIdChange</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Phrasing of this error message is historical, but it's the most
			 * common case.
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameter \"%s\" within security-definer function"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>InSecurityRestrictedOperation</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameter \"%s\" within security-restricted operation"</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Should we set reset/stacked values?	(If so, the behavior is not
	 * transactional.)	This is done either when we get a default value from
	 * the database's/user's/client's default settings or when we reset a
	 * value to its default.
	 */</comment>
	<expr_stmt><expr><name>makeDefault</name> <operator>=</operator> <name>changeVal</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>source</name> <operator>&lt;=</operator> <name>PGC_S_OVERRIDE</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name>value</name> <operator>!=</operator> <name>NULL</name><operator>)</operator> <operator>||</operator> <name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Ignore attempted set if overridden by previously processed setting.
	 * However, if changeVal is false then plow ahead anyway since we are
	 * trying to find out if the value is potentially good, not actually use
	 * it. Also keep going if makeDefault is true, since we may want to set
	 * the reset/stacked values even if we can't set the variable itself.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>source</name></name> <operator>&gt;</operator> <name>source</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>changeVal</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>makeDefault</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG3</name></expr></argument>, <argument><expr><literal type="string">"\"%s\": setting ignored because previous source is higher priority"</literal></expr></argument>,
				 <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>changeVal</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Evaluate value and set variable.
	 */</comment>
	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.boolval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_bool_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
											  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>boolval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.intval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_int_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
											 <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>intval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.realval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_real_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
											  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>realval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.stringval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* non-NULL boot_val must always get strdup'd */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
							<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>newval</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_string_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
												<argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * strdup not needed, since reset_val is already under
					 * guc.c's control
					 */</comment>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* newval shouldn't be NULL, so we're a bit sloppy here */</comment>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>newval</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
						<call><name>strcmp</name><argument_list>(<argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>,
											 <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newval anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newval</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>string_field_used</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>newval</name></cpp:macro> <cpp:value>(newval_union.enumval)</cpp:value></cpp:define>

				<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
												  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>newval_union</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>boot_val</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>call_enum_check_hook</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>,
											  <argument><expr><name>source</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name>newval</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>newextra</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>source</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>context</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>prohibitValueChange</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>!=</operator> <name>newval</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>|=</operator> <name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed without restarting the server"</literal></expr></argument>,
										<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><literal type="number">0</literal></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;=</operator> <operator>~</operator><name>GUC_PENDING_RESTART</name></expr>;</expr_stmt>
					<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
				</block_content>}</block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>changeVal</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Save old value to support transaction abort */</comment>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>makeDefault</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>push_old_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>action</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name><name>conf</name><operator>-&gt;</operator><name>assign_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>extra</name></name></expr></argument>,
									<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>makeDefault</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>stack</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>reset_extra</name></name></expr></argument>,
										<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
					<for>for <control>(<init><expr><name>stack</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr>;</init> <condition><expr><name>stack</name></expr>;</condition> <incr><expr><name>stack</name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></incr>)</control>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>&lt;=</operator> <name>source</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>enumval</name></name> <operator>=</operator> <name>newval</name></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>set_extra_field</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>extra</name></name></expr></argument>,
											<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name> <operator>=</operator> <name>source</name></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
						</block_content>}</block></if></if_stmt>
					</block_content>}</block></for>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* Perhaps we didn't install newextra anywhere */</comment>
				<if_stmt><if>if <condition>(<expr><name>newextra</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>extra_field_used</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>conf</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>, <argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>newval</name></cpp:undef>
			</block_content>}</block>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>changeVal</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_REPORT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ReportGUCOption</name><argument_list>(<argument><expr><name>record</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><ternary><condition><expr><name>changeVal</name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Set the fields for source file and line number the setting came from.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_config_sourcefile</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>sourcefile</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>sourceline</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * To avoid cluttering the log, only the postmaster bleats loudly about
	 * problems with the config file.
	 */</comment>
	<expr_stmt><expr><name>elevel</name> <operator>=</operator> <ternary><condition><expr><name>IsUnderPostmaster</name></expr> ?</condition><then> <expr><name>DEBUG3</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* should not happen */</comment>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sourcefile</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>sourcefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>sourcefile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>=</operator> <name>sourcefile</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <name>sourceline</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set a config option to the given value.
 *
 * See also set_config_option; this is just the wrapper to be called from
 * outside GUC.  (This function should be used when possible, because its API
 * is more stable than set_config_option's.)
 *
 * Note: there is no support here for setting source file/line, as it
 * is currently not needed.
 */</comment>
<function><type><name>void</name></type>
<name>SetConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
				<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>,
							 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>



<comment type="block">/*
 * Fetch the current value of the option `name', as a string.
 *
 * If the option doesn't exist, return NULL if missing_ok is true (NOTE that
 * this cannot be distinguished from a string variable with a NULL value!),
 * otherwise throw an ereport and don't return.
 *
 * If restrict_privileged is true, we also enforce that only superusers and
 * members of the pg_read_all_settings role can see GUC_SUPERUSER_ONLY
 * variables.  This should only be passed as true in user-driven calls.
 *
 * The string is *not* allocated for modification and is really only
 * valid until the next call to configuration related functions.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>restrict_privileged</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>restrict_privileged</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or a member of pg_read_all_settings to examine \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<return>return <expr><ternary><condition><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</return>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
					 <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>,
					 <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<return>return <expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr>;</return>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<return>return <expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>,
											   <argument><expr><operator>*</operator><operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>variable</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the RESET value associated with the given option.
 *
 * Note: this is not re-entrant, due to use of static result buffer;
 * not to mention that a string variable could have its reset_val changed.
 * Beware of assuming the result value is good for very long.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>GetConfigOptionResetString</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or a member of pg_read_all_settings to examine \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<return>return <expr><ternary><condition><expr><operator>(</operator><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</return>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>buffer</name></expr>;</return>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<return>return <expr><operator>(</operator><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr>;</return>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<return>return <expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></argument>,
											   <argument><expr><operator>(</operator><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name><operator>)</operator><operator>-&gt;</operator><name>reset_val</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the GUC flags associated with the given option.
 *
 * If the option doesn't exist, return 0 if missing_ok is true,
 * otherwise throw an ereport and don't return.
 */</comment>
<function><type><name>int</name></type>
<name>GetConfigOptionFlags</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * flatten_set_variable_args
 *		Given a parsenode List as emitted by the grammar for SET,
 *		convert to the flat string representation used by GUC.
 *
 * We need to be told the name of the variable the args are for, because
 * the flattening rules vary (ugh).
 *
 * The result is NULL if args is NIL (i.e., SET ... TO DEFAULT), otherwise
 * a palloc'd string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>flatten_set_variable_args</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/* Fast path if just DEFAULT */</comment>
	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get flags for the variable; if it's not known, use default flags.
	 * (Caller might throw error later, but not our business to do so here.)
	 */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>flags</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Complain if list input and non-list variable */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>flags</name> <operator>&amp;</operator> <name>GUC_LIST_INPUT</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET %s takes only one argument"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Each list member may be a plain A_Const node, or an A_Const within a
	 * TypeCast; the latter case is supported only for ConstInterval arguments
	 * (for SET TIME ZONE).
	 */</comment>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>args</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TypeName</name>   <modifier>*</modifier></type><name>typeName</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>tc</name> <init>= <expr><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>typeName</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>typeName</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>T_Integer</name></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>intVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_Float</name></expr>:</case>
				<comment type="block">/* represented as a string, so just copy it */</comment>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>T_String</name></expr>:</case>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>typeName</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * Must be a ConstInterval argument for TIME ZONE. Coerce
					 * to interval and back to normalize the value and account
					 * for any typmod.
					 */</comment>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>typoid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int32</name></type>		<name>typmod</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>Datum</name></type>		<name>interval</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>intervalout</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>typenameTypeIdAndMod</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>typeName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typoid</name> <operator>==</operator> <name>INTERVALOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>interval</name> <operator>=</operator>
						<call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>interval_in</name></expr></argument>,
											<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>typmod</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name>intervalout</name> <operator>=</operator>
						<call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>interval_out</name></expr></argument>,
															<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"INTERVAL '%s'"</literal></expr></argument>, <argument><expr><name>intervalout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Plain string literal or identifier.  For quote mode,
					 * quote it if it's not a vanilla identifier.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GUC_LIST_QUOTE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block>

	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write updated configuration parameter values into a temporary file.
 * This function traverses the list of parameters and quotes the string
 * values before writing them.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_auto_conf_file</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Emit file header containing warning comment */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"# Do not edit this file manually!\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"# It will be overwritten by the ALTER SYSTEM command.\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Emit each parameter, properly quoting the value */</comment>
	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <name>head</name></expr>;</init> <condition><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>escaped</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" = '"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>escaped</name> <operator>=</operator> <call><name>escape_single_quotes_ascii</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>escaped</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>escaped</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"'\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if write didn't set errno, assume problem is no disk space */</comment>
			<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENOSPC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* fsync before considering the write to be successful */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pg_fsync</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not fsync file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the given list of configuration parameters, adding, replacing
 * or deleting the entry for item "name" (delete if "value" == NULL).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>replace_auto_config_value</name><parameter_list>(<parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>head_p</name></decl></parameter>, <parameter><decl><type><name>ConfigVariable</name> <modifier>*</modifier><modifier>*</modifier></type><name>tail_p</name></decl></parameter>,
						  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>item</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Search the list for an existing match (we assume there's only one) */</comment>
	<for>for <control>(<init><expr><name>item</name> <operator>=</operator> <operator>*</operator><name>head_p</name></expr>;</init> <condition><expr><name>item</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>item</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* found a match, replace it */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>value</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* update the parameter value */</comment>
				<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* delete the configuration parameter from list */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>head_p</name> <operator>==</operator> <name>item</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>head_p</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>tail_p</name> <operator>==</operator> <name>item</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>tail_p</name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Not there; no work if we're trying to delete it */</comment>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* OK, append a new entry */</comment>
	<expr_stmt><expr><name>item</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof <name/></sizeof>*<name>item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>value</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>errmsg</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* new item has no location */</comment>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>sourceline</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>ignore</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>applied</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>item</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>head_p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>head_p</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><operator>(</operator><operator>*</operator><name>tail_p</name><operator>)</operator><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>item</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>tail_p</name> <operator>=</operator> <name>item</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Execute ALTER SYSTEM statement.
 *
 * Read the old PG_AUTOCONF_FILENAME file, merge in the new variable value,
 * and write out an updated file.  If the command is ALTER SYSTEM RESET ALL,
 * we can skip reading the old file and just write an empty file.
 *
 * An LWLock is used to serialize updates of the configuration file.
 *
 * In case of an error, we leave the original automatic
 * configuration file (PG_AUTOCONF_FILENAME) intact.
 */</comment>
<function><type><name>void</name></type>
<name>AlterSystemSetConfigFile</name><parameter_list>(<parameter><decl><type><name>AlterSystemStmt</name> <modifier>*</modifier></type><name>altersysstmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>resetall</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>tail</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>Tmpfd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>AutoConfFileName</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>AutoConfTmpFileName</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_ftshandler</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser to execute ALTER SYSTEM command"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Extract statement arguments
	 */</comment>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>altersysstmt</name><operator>-&gt;</operator><name>setstmt</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>altersysstmt</name><operator>-&gt;</operator><name>setstmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>ExtractSetVariableArgs</name><argument_list>(<argument><expr><name><name>altersysstmt</name><operator>-&gt;</operator><name>setstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>VAR_SET_DEFAULT</name></expr>:</case>
		<case>case <expr><name>VAR_RESET</name></expr>:</case>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>VAR_RESET_ALL</name></expr>:</case>
			<expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>resetall</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized alter system stmt type: %d"</literal></expr></argument>,
				 <argument><expr><name><name>altersysstmt</name><operator>-&gt;</operator><name>setstmt</name><operator>-&gt;</operator><name>kind</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Unless it's RESET_ALL, validate the target variable and value
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>resetall</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				   <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Don't allow parameters that can't be set in configuration files to
		 * be set in PG_AUTOCONF_FILENAME file.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_INTERNAL</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_DISALLOW_IN_FILE</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_DISALLOW_IN_AUTO_FILE</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			 <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					 <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CANT_CHANGE_RUNTIME_PARAM</name></expr></argument>)</argument_list></call><operator>,</operator>
					  <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" cannot be changed"</literal></expr></argument>,
							 <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If a value is specified, verify that it's sane.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name><name>union</name> <name>config_var_val</name></name></type> <name>newval</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>newextra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Check that it's acceptable for the indicated parameter */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>parse_and_validate_value</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
										  <argument><expr><name>PGC_S_FILE</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>,
										  <argument><expr><operator>&amp;</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newextra</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
								<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>PGC_STRING</name> <operator>&amp;&amp;</operator> <name><name>newval</name><operator>.</operator><name>stringval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name><name>newval</name><operator>.</operator><name>stringval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>newextra</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>newextra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We must also reject values containing newlines, because the
			 * grammar for config files doesn't support embedded newlines in
			 * string literals.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter value for ALTER SYSTEM must not contain a newline"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * PG_AUTOCONF_FILENAME and its corresponding temporary file are always in
	 * the data directory, so we can reference them by simple relative paths.
	 */</comment>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AutoConfFileName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
			 <argument><expr><name>PG_AUTOCONF_FILENAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s.%s"</literal></expr></argument>,
			 <argument><expr><name>AutoConfFileName</name></expr></argument>,
			 <argument><expr><literal type="string">"tmp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Only one backend is allowed to operate on PG_AUTOCONF_FILENAME at a
	 * time.  Use AutoFileLock to ensure that.  We must hold the lock while
	 * reading the old file contents.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>AutoFileLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're going to reset everything, then no need to open or parse the
	 * old file.  We'll just write out an empty list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>resetall</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>stat</name></name></type> <name>st</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>stat</name><argument_list>(<argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>st</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* open old file PG_AUTOCONF_FILENAME */</comment>
			<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>infile</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>infile</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>infile</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
								<argument><expr><name>AutoConfFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* parse it */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ParseConfigFp</name><argument_list>(<argument><expr><name>infile</name></expr></argument>, <argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_CONFIG_FILE_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse contents of file \"%s\""</literal></expr></argument>,
								<argument><expr><name>AutoConfFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>infile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Now, replace any existing entry with the new value, or add it if
		 * not present.
		 */</comment>
		<expr_stmt><expr><call><name>replace_auto_config_value</name><argument_list>(<argument><expr><operator>&amp;</operator><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tail</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * To ensure crash safety, first write the new file data to a temp file,
	 * then atomically rename it into place.
	 *
	 * If there is a temp file left over due to a previous crash, it's okay to
	 * truncate and reuse it.
	 */</comment>
	<expr_stmt><expr><name>Tmpfd</name> <operator>=</operator> <call><name>BasicOpenFile</name><argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>,
						  <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_RDWR</name> <operator>|</operator> <name>O_TRUNC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>Tmpfd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>AutoConfTmpFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Use a TRY block to clean up the file if we fail.  Since we need a TRY
	 * block anyway, OK to use BasicOpenFile rather than OpenTransientFile.
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Write and sync the new contents to the temporary file */</comment>
		<expr_stmt><expr><call><name>write_auto_conf_file</name><argument_list>(<argument><expr><name>Tmpfd</name></expr></argument>, <argument><expr><name>AutoConfTmpFileName</name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Close before renaming; may be required on some platforms */</comment>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>Tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>Tmpfd</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * As the rename is atomic operation, if any problem occurs after this
		 * at worst it can lose the parameters set by last ALTER SYSTEM
		 * command.
		 */</comment>
		<expr_stmt><expr><call><name>durable_rename</name><argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>, <argument><expr><name>AutoConfFileName</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* Close file first, else unlink might fail on some platforms */</comment>
		<if_stmt><if>if <condition>(<expr><name>Tmpfd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>Tmpfd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Unlink, but ignore any error */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>unlink</name><argument_list>(<argument><expr><name>AutoConfTmpFileName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FreeConfigVariables</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>AutoFileLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SET command
 */</comment>
<function><type><name>void</name></type>
<name>ExecSetVariableStmt</name><parameter_list>(<parameter><decl><type><name>VariableSetStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isTopLevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GucAction</name></type>	<name>action</name> <init>= <expr><ternary><condition><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr> ?</condition><then> <expr><name>GUC_ACTION_LOCAL</name></expr> </then><else>: <expr><name>GUC_ACTION_SET</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Workers synchronize these parameters at the start of the parallel
	 * operation; then, we block SET during the operation.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsInParallelMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TRANSACTION_STATE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot set parameters during a parallel operation"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
		<case>case <expr><name>VAR_SET_CURRENT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name> <operator>&amp;&amp;</operator>
				<name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET LOCAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"set_variable_fault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									 <argument><expr><call><name>ExtractSetVariableArgs</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
									 <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
									 <argument><expr><name>action</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>DispatchSetPGVariable</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VAR_SET_MULTI</name></expr>:</case>

			<comment type="block">/*
			 * Special-case SQL syntaxes.  The TRANSACTION and SESSION
			 * CHARACTERISTICS cases effectively set more than one variable
			 * per statement.  TRANSACTION SNAPSHOT only takes one argument,
			 * but we put it here anyway since it's a special case and not
			 * related to any GUC variable.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"TRANSACTION"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<macro><name>foreach</name><argument_list>(<argument>head</argument>, <argument>stmt-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SET TRANSACTION element: %s"</literal></expr></argument>,
							 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"SESSION CHARACTERISTICS"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>

				<macro><name>foreach</name><argument_list>(<argument>head</argument>, <argument>stmt-&gt;args</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DefElem</name>    <modifier>*</modifier></type><name>item</name> <init>= <expr><operator>(</operator><name>DefElem</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"default_transaction_isolation"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_read_only"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"default_transaction_read_only"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_deferrable"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>SetPGVariable</name><argument_list>(<argument><expr><literal type="string">"default_transaction_deferrable"</literal></expr></argument>,
									  <argument><expr><call><name>list_make1</name><argument_list>(<argument><expr><name><name>item</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SET SESSION element: %s"</literal></expr></argument>,
							 <argument><expr><name><name>item</name><operator>-&gt;</operator><name>defname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"TRANSACTION SNAPSHOT"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>A_Const</name>    <modifier>*</modifier></type><name>con</name> <init>= <expr><call><name>linitial_node</name><argument_list>(<argument><expr><name>A_Const</name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET LOCAL TRANSACTION SNAPSHOT is not implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>nodeTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_String</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ImportSnapshot</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected SET MULTI element: %s"</literal></expr></argument>,
					 <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>VAR_SET_DEFAULT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>is_local</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"SET LOCAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* fall through */</comment>
		<case>case <expr><name>VAR_RESET</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"transaction_isolation"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
				<name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>WarnNoTransactionBlock</name><argument_list>(<argument><expr><name>isTopLevel</name></expr></argument>, <argument><expr><literal type="string">"RESET TRANSACTION"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"reset_variable_fault"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>,
									 <argument><expr><name>NULL</name></expr></argument>,
									 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
									 <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
									 <argument><expr><name>action</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>VAR_RESET_ALL</name></expr>:</case>
			<expr_stmt><expr><call><name>ResetAllOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>VAR_SET_DEFAULT</name> <operator>||</operator>
		<name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>VAR_RESET</name> <operator>||</operator>
		<name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>VAR_RESET_ALL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * RESET must be dispatched different, because it can't
			 * be in a user transaction
			 */</comment>
			<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name> <operator>==</operator> <name>VAR_RESET_ALL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"RESET ALL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"RESET %s"</literal></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>CdbDispatchSetCommand</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the value to assign for a VariableSetStmt, or NULL if it's RESET.
 * The result is palloc'd.
 *
 * This is exported for use by actions such as ALTER ROLE SET.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>ExtractSetVariableArgs</name><parameter_list>(<parameter><decl><type><name>VariableSetStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>stmt</name><operator>-&gt;</operator><name>kind</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>VAR_SET_VALUE</name></expr>:</case>
			<return>return <expr><call><name>flatten_set_variable_args</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>VAR_SET_CURRENT</name></expr>:</case>
			<return>return <expr><call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name><name>stmt</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
		<default>default:</default>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * SetPGVariable - SET command exported as an easily-C-callable function.
 *
 * This provides access to SET TO value, as well as SET TO DEFAULT (expressed
 * by passing args == NIL), but not SET FROM CURRENT functionality.
 */</comment>
<function><type><name>void</name></type>
<name>SetPGVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SetPGVariableOptDispatch</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>is_local</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* GPDB: Like SetPGVariable, but with extra 'gp_dispatch' parameter.  */</comment>
<function><type><name>void</name></type>
<name>SetPGVariableOptDispatch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>gp_dispatch</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>argstring</name> <init>= <expr><call><name>flatten_set_variable_args</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Note SET DEFAULT (argstring == NULL) is equivalent to RESET */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
							 <argument><expr><name>argstring</name></expr></argument>,
							 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
							 <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>is_local</name></expr> ?</condition><then> <expr><name>GUC_ACTION_LOCAL</name></expr> </then><else>: <expr><name>GUC_ACTION_SET</name></expr></else></ternary></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_dispatch</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DispatchSetPGVariable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>is_local</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>DispatchSetPGVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_local</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buffer</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * client_encoding is always kept at SQL_ASCII in QE processes. (See also
	 * cdbconn_doConnectStart().)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"client_encoding"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>( <argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>args</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"RESET %s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SET "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_local</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"LOCAL "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%s TO "</literal></expr></argument>, <argument><expr><call><name>quote_identifier</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB: We handle the timezone GUC specially. This is because the
		 * timezone GUC can be set with the SET TIME ZONE .. syntax which is an
		 * alias for SET timezone. Instead of dispatching the SET TIME ZONE ..
		 * as a special case, we dispatch the already set time zone from the QD
		 * with the usual SET syntax flavor (SET timezone TO &lt;&gt;).
		 * Please refer to Issue: #9055 for additional detail.
		 * #9055 - https://github.com/greenplum-db/gpdb/issues/9055
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"timezone"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
							 <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><literal type="string">"timezone"</literal></expr></argument>,
																	  <argument><expr><name>NULL</name></expr></argument>,
																	  <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>args</argument>)</argument_list></macro>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>A_Const</name>	   <modifier>*</modifier></type><name>con</name></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>l</name> <operator>!=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>TypeCast</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>TypeCast</name>   <modifier>*</modifier></type><name>tc</name> <init>= <expr><operator>(</operator><name>TypeCast</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><name>arg</name> <operator>=</operator> <name><name>tc</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>con</name> <operator>=</operator> <operator>(</operator><name>A_Const</name> <operator>*</operator><operator>)</operator> <name>arg</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>con</name></expr></argument>, <argument><expr><name>A_Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<switch>switch <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><name>T_Integer</name></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>intVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_Float</name></expr>:</case>
						<comment type="block">/* represented as a string, so just copy it */</comment>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><name>T_String</name></expr>:</case>
						<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strVal</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<comment type="block">/*
						 * Plain string literal or identifier. Quote it.
						 */</comment>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<break>break;</break>
					<default>default:</default>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized node type: %d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>con</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
				</block_content>}</block></switch>
			</block_content>}</block>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>CdbDispatchSetCommand</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SET command wrapped as a SQL callable function.
 */</comment>
<function><type><name>Datum</name></type>
<name>set_config_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>new_value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_local</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"SET requires parameter name"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get the GUC variable name */</comment>
	<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the desired value or set to NULL for a reset request */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Get the desired state of is_local. Default to false if provided value
	 * is NULL
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_local</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>is_local</name> <operator>=</operator> <call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Note SET DEFAULT (argstring == NULL) is equivalent to RESET */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>,
							 <argument><expr><name>value</name></expr></argument>,
							 <argument><expr><operator>(</operator><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary><operator>)</operator></expr></argument>,
							 <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>is_local</name></expr> ?</condition><then> <expr><name>GUC_ACTION_LOCAL</name></expr> </then><else>: <expr><name>GUC_ACTION_SET</name></expr></else></ternary></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsBootstrapProcessingMode</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type>	<name>buffer</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>quoted_name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>		   <modifier>*</modifier></type><name>quoted_value</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>quoted_name</name> <operator>=</operator> <call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>quoted_value</name> <operator>=</operator> <call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"SELECT pg_catalog.set_config(%s, %s, %s)"</literal></expr></argument>,
						 <argument><expr><name>quoted_name</name></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>quoted_value</name></expr> ?</condition><then> <expr><name>quoted_value</name></expr> </then><else>: <expr><literal type="string">"NULL"</literal></expr></else></ternary></expr></argument>,
						 <argument><expr><ternary><condition><expr><name>is_local</name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>quoted_value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>quoted_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>quoted_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>CdbDispatchSetCommand</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* cancelOnError */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* get the new current value */</comment>
	<expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert return string to text */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Common code for DefineCustomXXXVariable subroutines: allocate the
 * new variable's config struct and fill in generic fields.
 */</comment>
<function><type><specifier>static</specifier> <name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type>
<name>init_custom_variable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
					 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
					 <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
					 <parameter><decl><type><name><name>enum</name> <name>config_type</name></name></type> <name>type</name></decl></parameter>,
					 <parameter><decl><type><name>size_t</name></type> <name>sz</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Only allow custom PGC_POSTMASTER variables to be created during shared
	 * library preload; any later than that, we can't ensure that the value
	 * doesn't change after startup.  This is a fatal elog if it happens; just
	 * erroring out isn't safe because we don't know what the calling loadable
	 * module might already have hooked into.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_POSTMASTER</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>process_shared_preload_libraries_in_progress</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"cannot create PGC_POSTMASTER variables after startup"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can't support custom GUC_LIST_QUOTE variables, because the wrong
	 * things would happen if such a variable were set or pg_dump'd when the
	 * defining extension isn't loaded.  Again, treat this as fatal because
	 * the loadable module may be partly initialized already.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>flags</name> <operator>&amp;</operator> <name>GUC_LIST_QUOTE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"extensions cannot define GUC_LIST_QUOTE variables"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Before pljava commit 398f3b876ed402bdaec8bc804f29e2be95c75139
	 * (2015-12-15), two of that module's PGC_USERSET variables facilitated
	 * trivial escalation to superuser privileges.  Restrict the variables to
	 * protect sites that have yet to upgrade pljava.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>context</name> <operator>==</operator> <name>PGC_USERSET</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pljava.classpath"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator>
		 <call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"pljava.vmoptions"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>context</name> <operator>=</operator> <name>PGC_SUSET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>gen</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>)</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>gen</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>sz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>name</name></name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>context</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>CUSTOM_OPTIONS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>short_desc</name></name> <operator>=</operator> <name>short_desc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>long_desc</name></name> <operator>=</operator> <name>long_desc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>flags</name></name> <operator>=</operator> <name>flags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>gen</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <name>type</name></expr>;</expr_stmt>

	<return>return <expr><name>gen</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Common code for DefineCustomXXXVariable subroutines: insert the new
 * variable into the GUC variable array, replacing any placeholder.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>define_custom_variable</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>variable</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>nameAddr</name> <init>= <expr><operator>&amp;</operator><name>name</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>pHolder</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * See if there's a placeholder by the same name.
	 */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <operator>(</operator>struct <name>config_generic</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>nameAddr</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>guc_variables</name></expr></argument>,
											 <argument><expr><name>num_guc_variables</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
											 <argument><expr><name>guc_var_compare</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No placeholder to replace, so we can just add it ... but first,
		 * make sure it's initialized to its default value.
		 */</comment>
		<expr_stmt><expr><call><name>InitializeOneGUCOption</name><argument_list>(<argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_guc_variable</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * This better be a placeholder
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><operator>(</operator><operator>*</operator><name>res</name><operator>)</operator><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_CUSTOM_PLACEHOLDER</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"attempt to redefine parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><operator>(</operator><operator>*</operator><name>res</name><operator>)</operator><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>PGC_STRING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pHolder</name> <operator>=</operator> <operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>*</operator><name>res</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * First, set the variable to its default value.  We must do this even
	 * though we intend to immediately apply a new value, since it's possible
	 * that the new value is invalid.
	 */</comment>
	<expr_stmt><expr><call><name>InitializeOneGUCOption</name><argument_list>(<argument><expr><name>variable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Replace the placeholder. We aren't changing the name, so no re-sorting
	 * is necessary
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>res</name> <operator>=</operator> <name>variable</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Assign the string value(s) stored in the placeholder to the real
	 * variable.  Essentially, we need to duplicate all the active and stacked
	 * values, but with appropriate validation and datatype adjustment.
	 *
	 * If an assignment fails, we report a WARNING and keep going.  We don't
	 * want to throw ERROR for bad values, because it'd bollix the add-on
	 * module that's presumably halfway through getting loaded.  In such cases
	 * the default or previous state will become active instead.
	 */</comment>

	<comment type="block">/* First, apply the reset value if any */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pHolder</name><operator>-&gt;</operator><name>reset_val</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>,
								 <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name></expr></argument>,
								 <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr></argument>,
								 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* That should not have resulted in stacking anything */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now, apply current and stacked values, in the order they were stacked */</comment>
	<expr_stmt><expr><call><name>reapply_stacked_values</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>pHolder</name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>stack</name></name></expr></argument>,
						   <argument><expr><operator>*</operator><operator>(</operator><name><name>pHolder</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator></expr></argument>,
						   <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>scontext</name></name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Also copy over any saved source-location information */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>sourcefile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>set_config_sourcefile</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>sourcefile</name></name></expr></argument>,
							  <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>sourceline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Free up as much as we conveniently can of the placeholder structure.
	 * (This neglects any stack items, so it's possible for some memory to be
	 * leaked.  Since this can only happen once per session per variable, it
	 * doesn't seem worth spending much code on.)
	 */</comment>
	<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>pHolder</name></expr></argument>, <argument><expr><name><name>pHolder</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_string_field</name><argument_list>(<argument><expr><name>pHolder</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pHolder</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>pHolder</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Recursive subroutine for define_custom_variable: reapply non-reset values
 *
 * We recurse so that the values are applied in the same order as originally.
 * At each recursion level, apply the upper-level value (passed in) in the
 * fashion implied by the stack entry.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>reapply_stacked_values</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>variable</name></decl></parameter>,
					   <parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>pHolder</name></decl></parameter>,
					   <parameter><decl><type><name>GucStack</name> <modifier>*</modifier></type><name>stack</name></decl></parameter>,
					   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>curvalue</name></decl></parameter>,
					   <parameter><decl><type><name>GucContext</name></type> <name>curscontext</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>cursource</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>name</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucStack</name>   <modifier>*</modifier></type><name>oldvarstack</name> <init>= <expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* First, recurse, so that stack items are processed bottom to top */</comment>
		<expr_stmt><expr><call><name>reapply_stacked_values</name><argument_list>(<argument><expr><name>variable</name></expr></argument>, <argument><expr><name>pHolder</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>,
							   <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>prior</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>,
							   <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* See how to apply the passed-in value */</comment>
		<switch>switch <condition>(<expr><name><name>stack</name><operator>-&gt;</operator><name>state</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>GUC_SAVE</name></expr>:</case>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
										 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GUC_SET</name></expr>:</case>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
										 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GUC_LOCAL</name></expr>:</case>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
										 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>

			<case>case <expr><name>GUC_SET_LOCAL</name></expr>:</case>
				<comment type="block">/* first, apply the masked value as SET */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>masked</name><operator>.</operator><name>val</name><operator>.</operator><name>stringval</name></name></expr></argument>,
										 <argument><expr><name><name>stack</name><operator>-&gt;</operator><name>masked_scontext</name></name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* then apply the current value as LOCAL */</comment>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
										 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
										 <argument><expr><name>GUC_ACTION_LOCAL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										 <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* If we successfully made a stack entry, adjust its nest level */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name></name> <operator>!=</operator> <name>oldvarstack</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name> <operator>=</operator> <name><name>stack</name><operator>-&gt;</operator><name>nest_level</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We are at the end of the stack.  If the active/previous value is
		 * different from the reset value, it must represent a previously
		 * committed session value.  Apply it, and then drop the stack entry
		 * that set_config_option will have created under the impression that
		 * this is to be just a transactional assignment.  (We leak the stack
		 * entry.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>curvalue</name> <operator>!=</operator> <name><name>pHolder</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>||</operator>
			<name>curscontext</name> <operator>!=</operator> <name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_scontext</name></name> <operator>||</operator>
			<name>cursource</name> <operator>!=</operator> <name><name>pHolder</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>reset_source</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>curvalue</name></expr></argument>,
									 <argument><expr><name>curscontext</name></expr></argument>, <argument><expr><name>cursource</name></expr></argument>,
									 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>variable</name><operator>-&gt;</operator><name>stack</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomBoolVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name></type> <name>bootValue</name></decl></parameter>,
						 <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						 <parameter><decl><type><name>GucBoolCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucBoolAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_BOOL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomIntVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>bootValue</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>minValue</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>maxValue</name></decl></parameter>,
						<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						<parameter><decl><type><name>GucIntCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						<parameter><decl><type><name>GucIntAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						<parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_INT</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>minValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>maxValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomRealVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						 <parameter><decl><type><name>double</name></type> <name>bootValue</name></decl></parameter>,
						 <parameter><decl><type><name>double</name></type> <name>minValue</name></decl></parameter>,
						 <parameter><decl><type><name>double</name></type> <name>maxValue</name></decl></parameter>,
						 <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						 <parameter><decl><type><name>GucRealCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucRealAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_REAL</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_real</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>min</name></name> <operator>=</operator> <name>minValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>max</name></name> <operator>=</operator> <name>maxValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomStringVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bootValue</name></decl></parameter>,
						   <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						   <parameter><decl><type><name>GucStringCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						   <parameter><decl><type><name>GucStringAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						   <parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_STRING</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_string</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>DefineCustomEnumVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>short_desc</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>long_desc</name></decl></parameter>,
						 <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valueAddr</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>bootValue</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name><name>struct</name> <name>config_enum_entry</name></name> <modifier>*</modifier></type><name>options</name></decl></parameter>,
						 <parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>,
						 <parameter><decl><type><name>int</name></type> <name>flags</name></decl></parameter>,
						 <parameter><decl><type><name>GucEnumCheckHook</name></type> <name>check_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucEnumAssignHook</name></type> <name>assign_hook</name></decl></parameter>,
						 <parameter><decl><type><name>GucShowHook</name></type> <name>show_hook</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator>
		<call><name>init_custom_variable</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>short_desc</name></expr></argument>, <argument><expr><name>long_desc</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>,
							 <argument><expr><name>PGC_ENUM</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_enum</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>variable</name></name> <operator>=</operator> <name>valueAddr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>=</operator> <name>bootValue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>options</name></name> <operator>=</operator> <name>options</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>check_hook</name></name> <operator>=</operator> <name>check_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>assign_hook</name></name> <operator>=</operator> <name>assign_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>var</name><operator>-&gt;</operator><name>show_hook</name></name> <operator>=</operator> <name>show_hook</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>define_custom_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>var</name><operator>-&gt;</operator><name>gen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>EmitWarningsOnPlaceholders</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>className</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>classLen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>className</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>var</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>var</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_CUSTOM_PLACEHOLDER</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<call><name>strncmp</name><argument_list>(<argument><expr><name>className</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name>classLen</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>name</name><index>[<expr><name>classLen</name></expr>]</index></name> <operator>==</operator> <name>GUC_QUALIFIER_SEPARATOR</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
							<argument><expr><name><name>var</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * SHOW command
 */</comment>
<function><type><name>void</name></type>
<name>GetPGVariable</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>guc_name_compare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowAllGUCConfig</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ShowGUCConfigOption</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>TupleDesc</name></type>
<name>GetPGVariableResultDesc</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>guc_name_compare</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* need a tuple descriptor representing three TEXT columns */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"setting"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"description"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>

		<comment type="block">/* Get the canonical spelling of name */</comment>
		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* need a tuple descriptor representing a single TEXT column */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>tupdesc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * SHOW command
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShowGUCConfigOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>varname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

	<comment type="block">/* Get the value and canonical spelling of name */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varname</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* need a tuple descriptor representing a single TEXT column */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prepare for projection of tuples */</comment>
	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send it */</comment>
	<expr_stmt><expr><call><name>do_text_output_oneline</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SHOW ALL command
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ShowAllGUCConfig</name><parameter_list>(<parameter><decl><type><name>DestReceiver</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupOutputState</name> <modifier>*</modifier></type><name>tstate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <init>= <expr><block>{<expr><name>false</name></expr>, <expr><name>false</name></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<comment type="block">/* need a tuple descriptor representing three TEXT columns */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"setting"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitBuiltinEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"description"</literal></expr></argument>,
							  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* prepare for projection of tuples */</comment>
	<expr_stmt><expr><name>tstate</name> <operator>=</operator> <call><name>begin_tup_output_tupdesc</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>setting</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_NO_SHOW_ALL</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* assign to the values array */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>setting</name> <operator>=</operator> <call><name>_ShowOption</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>setting</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>setting</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>isnull</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>short_desc</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* send it to dest */</comment>
		<expr_stmt><expr><call><name>do_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* clean up */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>setting</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>setting</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>end_tup_output</name><argument_list>(<argument><expr><name>tstate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * return if the option were modified (w.r.t. config file)
 */</comment>
<function><type><name>bool</name></type> <name>is_guc_modified</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <operator>*</operator><operator>(</operator><name><name>lconf</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator><operator>)</operator></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <operator>*</operator><operator>(</operator><name><name>lconf</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator><operator>)</operator></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <operator>*</operator><operator>(</operator><name><name>lconf</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator><operator>)</operator></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>, <argument><expr><operator>*</operator><operator>(</operator><name><name>lconf</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<return>return <expr><operator>(</operator><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>!=</operator> <operator>*</operator><operator>(</operator><name><name>lconf</name><operator>-&gt;</operator><name>variable</name></name><operator>)</operator><operator>)</operator></expr>;</return>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected GUC type: %d"</literal></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Returns an array of modified GUC options to show in EXPLAIN. Only options
 * related to query planning (marked with GUC_EXPLAIN), with values different
 * from built-in defaults.
 */</comment>
<function><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type>
<name>get_explain_guc_options</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate enough space to fit all GUC_EXPLAIN options. We may not need
	 * all the space, but there are fairly few such options so we don't waste
	 * a lot of memory.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr>struct <name>config_generic</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>num_guc_explain_variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* return only options visible to the user */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_NO_SHOW_ALL</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* only parameters explicitly marked for inclusion in explain */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_EXPLAIN</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* skip GUC variables that match the built-in default */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_guc_modified</name><argument_list>(<argument><expr><name>conf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* assign to the values array */</comment>
		<expr_stmt><expr><name><name>result</name><index>[<expr><operator>*</operator><name>num</name></expr>]</index></name> <operator>=</operator> <name>conf</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>num</name> <operator>=</operator> <operator>*</operator><name>num</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>num</name> <operator>&lt;=</operator> <name>num_guc_explain_variables</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return GUC variable value by name; optionally return canonical form of
 * name.  If the GUC is unset, then throw an error unless missing_ok is true,
 * in which case return NULL.  Return value is palloc'd (but *varname isn't).
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetConfigOptionByName</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>varname</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>missing_ok</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>missing_ok</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>varname</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"must be superuser or a member of pg_read_all_settings to examine \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>varname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>varname</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><call><name>_ShowOption</name><argument_list>(<argument><expr><name>record</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return GUC variable value by variable number; optionally return canonical
 * form of name.  Return value is palloc'd.
 */</comment>
<function><type><name>void</name></type>
<name>GetConfigOptionByNum</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>varnum</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>noshow</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>conf</name></decl>;</decl_stmt>

	<comment type="block">/* check requested variable number valid */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>varnum</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>varnum</name> <operator>&lt;</operator> <name>num_guc_variables</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>conf</name> <operator>=</operator> <name><name>guc_variables</name><index>[<expr><name>varnum</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>noshow</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_NO_SHOW_ALL</name><operator>)</operator> <operator>||</operator>
			<operator>(</operator><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_SUPERUSER_ONLY</name><operator>)</operator> <operator>&amp;&amp;</operator>
			 <operator>!</operator><call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>noshow</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>noshow</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* first get the generic attributes */</comment>

	<comment type="block">/* name */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt>

	<comment type="block">/* setting: use _ShowOption in order to avoid duplicating the logic */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>_ShowOption</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unit, if any (NULL is fine) */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>get_config_unit_name</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>flags</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* group */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name><name>config_group_names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>group</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* short_desc */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>short_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* extra_desc */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>long_desc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* context */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name><name>GucContext_Names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>context</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* vartype */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <name><name>config_type_names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* source */</comment>
	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">8</literal></expr>]</index></name> <operator>=</operator> <name><name>GucSource_Names</name><index>[<expr><name><name>conf</name><operator>-&gt;</operator><name>source</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* now get the type specific attributes */</comment>
	<switch>switch <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><ternary><condition><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>max</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g"</literal></expr></argument>, <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<comment type="block">/* reset_val */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>lconf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>

				<comment type="block">/*
				 * NOTE! enumvals with double quotes in them are not
				 * supported!
				 */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <call><name>config_enum_get_options</name><argument_list>(<argument><expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>conf</name></expr></argument>,
													 <argument><expr><literal type="string">"{\""</literal></expr></argument>, <argument><expr><literal type="string">"\"}"</literal></expr></argument>, <argument><expr><literal type="string">"\",\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>lconf</name></expr></argument>,
																 <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>boot_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>lconf</name></expr></argument>,
																 <argument><expr><name><name>lconf</name><operator>-&gt;</operator><name>reset_val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<block>{<block_content>
				<comment type="block">/*
				 * should never get here, but in case we do, set 'em to NULL
				 */</comment>

				<comment type="block">/* min_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">9</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* max_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">10</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* enumvals */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">11</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* boot_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">12</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

				<comment type="block">/* reset_val */</comment>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">13</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If the setting came from a config file, set the source location. For
	 * security reasons, we don't show source file/line number for
	 * insufficiently-privileged users.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>PGC_S_FILE</name> <operator>&amp;&amp;</operator>
		<call><name>is_member_of_role</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>DEFAULT_ROLE_READ_ALL_SETTINGS</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>conf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">14</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">15</literal></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">16</literal></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>conf</name><operator>-&gt;</operator><name>status</name></name> <operator>&amp;</operator> <name>GUC_PENDING_RESTART</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"t"</literal></expr> </then><else>: <expr><literal type="string">"f"</literal></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return the total number of GUC variables
 */</comment>
<function><type><name>int</name></type>
<name>GetNumConfigOptions</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>num_guc_variables</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * show_config_by_name - equiv to SHOW X command but implemented as
 * a function.
 */</comment>
<function><type><name>Datum</name></type>
<name>show_config_by_name</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varval</name></decl>;</decl_stmt>

	<comment type="block">/* Get the value */</comment>
	<expr_stmt><expr><name>varval</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Convert to text */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>varval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * show_config_by_name_missing_ok - equiv to SHOW X command but implemented as
 * a function.  If X does not exist, suppress the error and just return NULL
 * if missing_ok is true.
 */</comment>
<function><type><name>Datum</name></type>
<name>show_config_by_name_missing_ok</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>missing_ok</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varval</name></decl>;</decl_stmt>

	<comment type="block">/* Get the value */</comment>
	<expr_stmt><expr><name>varval</name> <operator>=</operator> <call><name>GetConfigOptionByName</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* return NULL if no such variable */</comment>
	<if_stmt><if>if <condition>(<expr><name>varval</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert to text */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>varval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * show_all_settings - equiv to SHOW ALL command but implemented as
 * a Table Function.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_PG_SETTINGS_ATTS</name></cpp:macro>	<cpp:value>17</cpp:value></cpp:define>

<function><type><name>Datum</name></type>
<name>show_all_settings</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>call_cntr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_calls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttInMetadata</name> <modifier>*</modifier></type><name>attinmeta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* stuff done only on the first call of the function */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * switch to memory context appropriate for multiple function calls
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * need a tuple descriptor representing NUM_PG_SETTINGS_ATTS columns
		 * of the appropriate types
		 */</comment>
		<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>NUM_PG_SETTINGS_ATTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"setting"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"unit"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"category"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"short_desc"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"extra_desc"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"context"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"vartype"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">9</literal></expr></argument>, <argument><expr><literal type="string">"source"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><literal type="string">"min_val"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">11</literal></expr></argument>, <argument><expr><literal type="string">"max_val"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">12</literal></expr></argument>, <argument><expr><literal type="string">"enumvals"</literal></expr></argument>,
						   <argument><expr><name>TEXTARRAYOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">13</literal></expr></argument>, <argument><expr><literal type="string">"boot_val"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">14</literal></expr></argument>, <argument><expr><literal type="string">"reset_val"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">15</literal></expr></argument>, <argument><expr><literal type="string">"sourcefile"</literal></expr></argument>,
						   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">16</literal></expr></argument>, <argument><expr><literal type="string">"sourceline"</literal></expr></argument>,
						   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">17</literal></expr></argument>, <argument><expr><literal type="string">"pending_restart"</literal></expr></argument>,
						   <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Generate attribute metadata needed later to produce tuples from raw
		 * C strings
		 */</comment>
		<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <call><name>TupleDescGetAttInMetadata</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name> <operator>=</operator> <name>attinmeta</name></expr>;</expr_stmt>

		<comment type="block">/* total number of tuples to be returned */</comment>
		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <call><name>GetNumConfigOptions</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* stuff done on every call of the function */</comment>
	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>call_cntr</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>max_calls</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>attinmeta</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>attinmeta</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>call_cntr</name> <operator>&lt;</operator> <name>max_calls</name></expr>)</condition>	<comment type="block">/* do when there is more left to send */</comment>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name><name>values</name><index>[<expr><name>NUM_PG_SETTINGS_ATTS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>noshow</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get the next visible GUC variable name and value
		 */</comment>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><call><name>GetConfigOptionByNum</name><argument_list>(<argument><expr><name>call_cntr</name></expr></argument>, <argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator><operator>*</operator><operator>)</operator> <name>values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>noshow</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>noshow</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* bump the counter and get the next config setting */</comment>
				<expr_stmt><expr><name>call_cntr</name> <operator>=</operator> <operator>++</operator><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>;</expr_stmt>

				<comment type="block">/* make sure we haven't gone too far now */</comment>
				<if_stmt><if>if <condition>(<expr><name>call_cntr</name> <operator>&gt;=</operator> <name>max_calls</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block> while <condition>(<expr><name>noshow</name></expr>)</condition>;</do>

		<comment type="block">/* build a tuple */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>BuildTupleFromCStrings</name><argument_list>(<argument><expr><name>attinmeta</name></expr></argument>, <argument><expr><name>values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make the tuple into a datum */</comment>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* do when there is no more left */</comment>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * show_all_file_settings
 *
 * Returns a table of all parameter settings in all configuration files
 * which includes the config file pathname, the line number, a sequence number
 * indicating the order in which the settings were encountered, the parameter
 * name and value, a bool showing if the value could be applied, and possibly
 * an associated error message.  (For problems such as syntax errors, the
 * parameter name/value might be NULL.)
 *
 * Note: no filtering is done here, instead we depend on the GRANT system
 * to prevent unprivileged users from accessing this function or the view
 * built on top of it.
 */</comment>
<function><type><name>Datum</name></type>
<name>show_all_file_settings</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_PG_FILE_SETTINGS_ATTS</name></cpp:macro> <cpp:value>7</cpp:value></cpp:define>
	<decl_stmt><decl><type><name>ReturnSetInfo</name> <modifier>*</modifier></type><name>rsinfo</name> <init>= <expr><operator>(</operator><name>ReturnSetInfo</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>resultinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>tupstore</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ConfigVariable</name> <modifier>*</modifier></type><name>conf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>seqno</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>per_query_ctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Check to see if caller supports us returning a tuplestore */</comment>
	<if_stmt><if>if <condition>(<expr><name>rsinfo</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rsinfo</name></expr></argument>, <argument><expr><name>ReturnSetInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"set-valued function called in context that cannot accept a set"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>rsinfo</name><operator>-&gt;</operator><name>allowedModes</name></name> <operator>&amp;</operator> <name>SFRM_Materialize</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"materialize mode required, but it is not "</literal> \
						<literal type="string">"allowed in this context"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Scan the config files using current context as workspace */</comment>
	<expr_stmt><expr><name>conf</name> <operator>=</operator> <call><name>ProcessConfigFileInternal</name><argument_list>(<argument><expr><name>PGC_SIGHUP</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>DEBUG3</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Switch into long-lived context to construct returned data structures */</comment>
	<expr_stmt><expr><name>per_query_ctx</name> <operator>=</operator> <name><name>rsinfo</name><operator>-&gt;</operator><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_query_memory</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>per_query_ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuple descriptor for our result type */</comment>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>NUM_PG_FILE_SETTINGS_ATTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"sourcefile"</literal></expr></argument>,
					   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"sourceline"</literal></expr></argument>,
					   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"seqno"</literal></expr></argument>,
					   <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"name"</literal></expr></argument>,
					   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"setting"</literal></expr></argument>,
					   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"applied"</literal></expr></argument>,
					   <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"error"</literal></expr></argument>,
					   <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a tuplestore to return our results in */</comment>
	<expr_stmt><expr><name>tupstore</name> <operator>=</operator> <call><name>tuplestore_begin_heap</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>returnMode</name></name> <operator>=</operator> <name>SFRM_Materialize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setResult</name></name> <operator>=</operator> <name>tupstore</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>rsinfo</name><operator>-&gt;</operator><name>setDesc</name></name> <operator>=</operator> <name>tupdesc</name></expr>;</expr_stmt>

	<comment type="block">/* The rest can be done in short-lived context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process the results and create a tuplestore */</comment>
	<for>for <control>(<init><expr><name>seqno</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>conf</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>conf</name> <operator>=</operator> <name><name>conf</name><operator>-&gt;</operator><name>next</name></name></expr><operator>,</operator> <expr><name>seqno</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>NUM_PG_FILE_SETTINGS_ATTS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>NUM_PG_FILE_SETTINGS_ATTS</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>values</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>values</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* sourcefile */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* sourceline (not meaningful if no sourcefile) */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* seqno */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>seqno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* name */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* setting */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>value</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>value</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* applied */</comment>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>applied</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* error */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>errmsg</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>errmsg</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* shove row into tuplestore */</comment>
		<expr_stmt><expr><call><name>tuplestore_putvalues</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>tuplestore_donestoring</name><argument_list>(<argument><expr><name>tupstore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>_ShowOption</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_units</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><literal type="number">256</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr> ?</condition><then> <expr><literal type="string">"on"</literal></expr> </then><else>: <expr><literal type="string">"off"</literal></expr></else></ternary></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Use int64 arithmetic to avoid overflows in units
					 * conversion.
					 */</comment>
					<decl_stmt><decl><type><name>int64</name></type>		<name>result</name> <init>= <expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>use_units</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_UNIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>convert_int_from_base_unit</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
												   <argument><expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_UNIT</name></expr></argument>,
												   <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>INT64_FORMAT</name> <literal type="string">"%s"</literal></expr></argument>,
							 <argument><expr><name>result</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type>		<name>result</name> <init>= <expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>unit</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>use_units</name> <operator>&amp;&amp;</operator> <name>result</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_UNIT</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>convert_real_from_base_unit</name><argument_list>(<argument><expr><name>result</name></expr></argument>,
													<argument><expr><name><name>record</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_UNIT</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name>unit</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%g%s"</literal></expr></argument>,
							 <argument><expr><name>result</name></expr></argument>, <argument><expr><name>unit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <name>buffer</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>record</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name><name>conf</name><operator>-&gt;</operator><name>show_hook</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* just to keep compiler quiet */</comment>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><call><name>pstrdup</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EXEC_BACKEND</name></cpp:ifdef>

<comment type="block">/*
 *	These routines dump out all non-default GUC options into a binary
 *	file that is read by all exec'ed backends.  The format is:
 *
 *		variable name, string, null terminated
 *		variable value, string, null terminated
 *		variable sourcefile, string, null terminated (empty if none)
 *		variable sourceline, integer
 *		variable source, integer
 *		variable scontext, integer
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_one_nondefault_variable</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>, <parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%.17g"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
						<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fprintf</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fputc</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fwrite</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>write_nondefault_variables</name><parameter_list>(<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name> <operator>==</operator> <name>PGC_POSTMASTER</name> <operator>||</operator> <name>context</name> <operator>==</operator> <name>PGC_SIGHUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>elevel</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>context</name> <operator>==</operator> <name>PGC_SIGHUP</name><operator>)</operator></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>ERROR</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open file
	 */</comment>
	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>CONFIG_EXEC_PARAMS_NEW</name></expr></argument>, <argument><expr><literal type="string">"w"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>CONFIG_EXEC_PARAMS_NEW</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_one_nondefault_variable</name><argument_list>(<argument><expr><name>fp</name></expr></argument>, <argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to file \"%s\": %m"</literal></expr></argument>,
						<argument><expr><name>CONFIG_EXEC_PARAMS_NEW</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Put new file in place.  This could delay on Win32, but we don't hold
	 * any exclusive locks.
	 */</comment>
	<expr_stmt><expr><call><name>rename</name><argument_list>(<argument><expr><name>CONFIG_EXEC_PARAMS_NEW</name></expr></argument>, <argument><expr><name>CONFIG_EXEC_PARAMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 *	Read string, including null byte from file
 *
 *	Return NULL on EOF and nothing read
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_string_with_null</name><parameter_list>(<parameter><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>ch</name></decl>,
				<decl><type ref="prev"/><name>maxlen</name> <init>= <expr><literal type="number">256</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <call><name>fgetc</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>EOF</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>maxlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>i</name> <operator>==</operator> <name>maxlen</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>guc_realloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>maxlen</name> <operator>*=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>str</name><index>[<expr><name>i</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>ch</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>ch</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>;</do>

	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	This routine loads a previous postmaster dump of its non-default
 *	settings.
 */</comment>
<function><type><name>void</name></type>
<name>read_nondefault_variables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>varvalue</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>varsourcefile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varsourceline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucSource</name></type>	<name>varsource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucContext</name></type>	<name>varscontext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Assert that PGC_BACKEND/PGC_SU_BACKEND case in set_config_option() will
	 * do the right thing.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsInitProcessingMode</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Open file
	 */</comment>
	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>AllocateFile</name><argument_list>(<argument><expr><name>CONFIG_EXEC_PARAMS</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fp</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* File not found is fine */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>!=</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from file \"%s\": %m"</literal></expr></argument>,
							<argument><expr><name>CONFIG_EXEC_PARAMS</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>varname</name> <operator>=</operator> <call><name>read_string_with_null</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"failed to locate variable \"%s\" in exec config params file"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>varvalue</name> <operator>=</operator> <call><name>read_string_with_null</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>varsourcefile</name> <operator>=</operator> <call><name>read_string_with_null</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varsourceline</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varsourceline</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>varsourceline</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varsource</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varsource</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>varsource</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>fread</name><argument_list>(<argument><expr><operator>&amp;</operator><name>varscontext</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varscontext</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fp</name></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>varscontext</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"invalid format of exec config params file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>varvalue</name></expr></argument>,
								 <argument><expr><name>varscontext</name></expr></argument>, <argument><expr><name>varsource</name></expr></argument>,
								 <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>varsourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_config_sourcefile</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>varsourcefile</name></expr></argument>, <argument><expr><name>varsourceline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>varname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>varvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>varsourcefile</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>FreeFile</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* EXEC_BACKEND */</comment>

<comment type="block">/*
 * can_skip_gucvar:
 * When serializing, determine whether to skip this GUC.  When restoring, the
 * negation of this test determines whether to restore the compiled-in default
 * value before processing serialized values.
 *
 * A PGC_S_DEFAULT setting on the serialize side will typically match new
 * postmaster children, but that can be false when got_SIGHUP == true and the
 * pending configuration change modifies this setting.  Nonetheless, we omit
 * PGC_S_DEFAULT settings from serialization and make up for that by restoring
 * defaults before applying serialized values.
 *
 * PGC_POSTMASTER variables always have the same value in every child of a
 * particular postmaster.  Most PGC_INTERNAL variables are compile-time
 * constants; a few, like server_encoding and lc_ctype, are handled specially
 * outside the serialize/restore procedure.  Therefore, SerializeGUCState()
 * never sends these, and RestoreGUCState() never changes them.
 *
 * Role is a special variable in the sense that its current value can be an
 * invalid value and there are multiple ways by which that can happen (like
 * after setting the role, someone drops it).  So we handle it outside of
 * serialize/restore machinery.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>can_skip_gucvar</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_POSTMASTER</name> <operator>||</operator>
		<name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_INTERNAL</name> <operator>||</operator> <name><name>gconf</name><operator>-&gt;</operator><name>source</name></name> <operator>==</operator> <name>PGC_S_DEFAULT</name> <operator>||</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><literal type="string">"role"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * estimate_variable_size:
 *		Compute space needed for dumping the given GUC variable.
 *
 * It's OK to overestimate, but not to underestimate.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>estimate_variable_size</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>valsize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>can_skip_gucvar</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Name, plus trailing zero byte. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* Get the maximum display length of the GUC value. */</comment>
	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">5</literal></expr>;</expr_stmt>	<comment type="block">/* max(strlen('true'), strlen('false')) */</comment>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Instead of getting the exact display length, use max
				 * length.  Also reduce the max length for typical ranges of
				 * small values.  Maximum value is 2147483647, i.e. 10 chars.
				 * Include one byte for sign.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>Abs</name><argument_list>(<argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">10</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * We are going to print it with %e with REALTYPE_PRECISION
				 * fractional digits.  Account for sign, leading digit,
				 * decimal point, and exponent with up to 3 digits.  E.g.
				 * -3.99329042340000021e+110
				 */</comment>
				<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator> <name>REALTYPE_PRECISION</name> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * If the value is NULL, we transmit it as an empty string.
				 * Although this is not physically the same value, GUC
				 * generally treats a NULL the same as empty string.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>valsize</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>valsize</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>valsize</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/* Allow space for terminating zero-byte for value */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>valsize</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Allow space for terminating zero-byte for sourcefile */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Include line whenever file is nonempty. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>&amp;&amp;</operator> <name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * EstimateGUCStateSpace:
 * Returns the size needed to store the GUC state for the current process
 */</comment>
<function><type><name>Size</name></type>
<name>EstimateGUCStateSpace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Add space reqd for saving the data size of the guc state */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Add up the space needed for each GUC variable */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>,
						<argument><expr><call><name>estimate_variable_size</name><argument_list>(<argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * do_serialize:
 * Copies the formatted string into the destination.  Moves ahead the
 * destination pointer, and decrements the maxbytes by that many bytes. If
 * maxbytes is not sufficient to copy the string, error out.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_serialize</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>maxbytes</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>vargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>maxbytes</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough space to serialize GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>vsnprintf</name><argument_list>(<argument><expr><operator>*</operator><name>destptr</name></expr></argument>, <argument><expr><operator>*</operator><name>maxbytes</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>vargs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Shouldn't happen. Better show errno description. */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"vsnprintf failed: %m with format string \"%s\""</literal></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&gt;=</operator> <operator>*</operator><name>maxbytes</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* This shouldn't happen either, really. */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough space to serialize GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Shift the destptr ahead of the null terminator */</comment>
	<expr_stmt><expr><operator>*</operator><name>destptr</name> <operator>+=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>maxbytes</name> <operator>-=</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Binary copy version of do_serialize() */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_serialize_binary</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>maxbytes</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>val</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>valsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>valsize</name> <operator>&gt;</operator> <operator>*</operator><name>maxbytes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough space to serialize GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>destptr</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>valsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>destptr</name> <operator>+=</operator> <name>valsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>maxbytes</name> <operator>-=</operator> <name>valsize</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * serialize_variable:
 * Dumps name, value and other information of a GUC variable into destptr.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>serialize_variable</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>destptr</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>maxbytes</name></decl></parameter>,
				   <parameter><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>can_skip_gucvar</name><argument_list>(<argument><expr><name>gconf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PGC_BOOL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_bool</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>,
							 <argument><expr><operator>(</operator><ternary><condition><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_INT</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_int</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_REAL</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_real</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%.*e"</literal></expr></argument>,
							 <argument><expr><name>REALTYPE_PRECISION</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_STRING</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_string</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<comment type="block">/* NULL becomes empty string, see estimate_variable_size() */</comment>
				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
							 <argument><expr><ternary><condition><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr> ?</condition><then> <expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>

		<case>case <expr><name>PGC_ENUM</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name> <init>= <expr><operator>(</operator>struct <name>config_enum</name> <operator>*</operator><operator>)</operator> <name>gconf</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
							 <argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name><name>conf</name><operator>-&gt;</operator><name>variable</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>do_serialize</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><ternary><condition><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr> ?</condition><then> <expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name></name> <operator>&amp;&amp;</operator> <name><name>gconf</name><operator>-&gt;</operator><name>sourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>do_serialize_binary</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>,
							<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>sourceline</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>do_serialize_binary</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>source</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>do_serialize_binary</name><argument_list>(<argument><expr><name>destptr</name></expr></argument>, <argument><expr><name>maxbytes</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>gconf</name><operator>-&gt;</operator><name>scontext</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SerializeGUCState:
 * Dumps the complete GUC state onto the memory location at start_address.
 */</comment>
<function><type><name>void</name></type>
<name>SerializeGUCState</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>curptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>actual_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>bytes_left</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Reserve space for saving the actual size of the guc state */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>maxsize</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curptr</name> <operator>=</operator> <name>start_address</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>bytes_left</name> <operator>=</operator> <name>maxsize</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>serialize_variable</name><argument_list>(<argument><expr><operator>&amp;</operator><name>curptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bytes_left</name></expr></argument>, <argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Store actual size without assuming alignment of start_address. */</comment>
	<expr_stmt><expr><name>actual_size</name> <operator>=</operator> <name>maxsize</name> <operator>-</operator> <name>bytes_left</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>start_address</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>actual_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>actual_size</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * read_gucstate:
 * Actually it does not read anything, just returns the srcptr. But it does
 * move the srcptr past the terminating zero byte, so that the caller is ready
 * to read the next string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>read_gucstate</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>srcptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>srcend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>retptr</name> <init>= <expr><operator>*</operator><name>srcptr</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>srcptr</name> <operator>&gt;=</operator> <name>srcend</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incomplete GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* The string variables are all null terminated */</comment>
	<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <operator>*</operator><name>srcptr</name></expr>;</init> <condition><expr><name>ptr</name> <operator>&lt;</operator> <name>srcend</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>ptr</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>ptr</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<empty_stmt>;</empty_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>&gt;=</operator> <name>srcend</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find null terminator in GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Set the new position to the byte following the terminating NUL */</comment>
	<expr_stmt><expr><operator>*</operator><name>srcptr</name> <operator>=</operator> <name>ptr</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<return>return <expr><name>retptr</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Binary read version of read_gucstate(). Copies into dest */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>read_gucstate_binary</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>srcptr</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>srcend</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>srcptr</name> <operator>+</operator> <name>size</name> <operator>&gt;</operator> <name>srcend</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"incomplete GUC state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>*</operator><name>srcptr</name></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>srcptr</name> <operator>+=</operator> <name>size</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * RestoreGUCState:
 * Reads the GUC state at the specified address and updates the GUCs with the
 * values read from the GUC state.
 */</comment>
<function><type><name>void</name></type>
<name>RestoreGUCState</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>gucstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>varname</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>varvalue</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>varsourcefile</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varsourceline</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucSource</name></type>	<name>varsource</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GucContext</name></type>	<name>varscontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcptr</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>gucstate</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>srcend</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* See comment at can_skip_gucvar(). */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_guc_variables</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>can_skip_gucvar</name><argument_list>(<argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>InitializeOneGUCOption</name><argument_list>(<argument><expr><name><name>guc_variables</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>

	<comment type="block">/* First item is the length of the subsequent data */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><name>gucstate</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>srcptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>srcend</name> <operator>=</operator> <name>srcptr</name> <operator>+</operator> <name>len</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>srcptr</name> <operator>&lt;</operator> <name>srcend</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>varname</name> <operator>=</operator> <call><name>read_gucstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>varvalue</name> <operator>=</operator> <call><name>read_gucstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>varsourcefile</name> <operator>=</operator> <call><name>read_gucstate</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>varsourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>read_gucstate_binary</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>varsourceline</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varsourceline</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>varsourceline</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>read_gucstate_binary</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>varsource</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varsource</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>read_gucstate_binary</name><argument_list>(<argument><expr><operator>&amp;</operator><name>srcptr</name></expr></argument>, <argument><expr><name>srcend</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>varscontext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>varscontext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>varvalue</name></expr></argument>, <argument><expr><name>varscontext</name></expr></argument>, <argument><expr><name>varsource</name></expr></argument>,
								   <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"parameter \"%s\" could not be set"</literal></expr></argument>, <argument><expr><name>varname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>varsourcefile</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>set_config_sourcefile</name><argument_list>(<argument><expr><name>varname</name></expr></argument>, <argument><expr><name>varsourcefile</name></expr></argument>, <argument><expr><name>varsourceline</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * A little "long argument" simulation, although not quite GNU
 * compliant. Takes a string of the form "some-option=some value" and
 * returns name = "some_option" and value = "some value" in malloc'ed
 * storage. Note that '-' is converted to '_' in the option name. If
 * there is no '=' in the input string then value will be NULL.
 */</comment>
<function><type><name>void</name></type>
<name>ParseLongOption</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>string</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>equal_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cp</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertArg</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>equal_pos</name> <operator>=</operator> <call><name>strcspn</name><argument_list>(<argument><expr><name>string</name></expr></argument>, <argument><expr><literal type="string">"="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>string</name><index>[<expr><name>equal_pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>equal_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><operator>*</operator><name>name</name></expr></argument>, <argument><expr><name>string</name></expr></argument>, <argument><expr><name>equal_pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>string</name><index>[<expr><name>equal_pos</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no equal sign in string */</comment>
		<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>guc_strdup</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><name>string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>value</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<for>for <control>(<init><expr><name>cp</name> <operator>=</operator> <operator>*</operator><name>name</name></expr>;</init> <condition><expr><operator>*</operator><name>cp</name></expr>;</condition> <incr><expr><name>cp</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>cp</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>cp</name> <operator>=</operator> <literal type="char">'_'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Handle options fetched from pg_db_role_setting.setconfig,
 * pg_proc.proconfig, etc.  Caller must specify proper context/source/action.
 *
 * The array parameter must be an array of TEXT (it must not be NULL).
 */</comment>
<function><type><name>void</name></type>
<name>ProcessGUCArray</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>,
				<parameter><decl><type><name>GucContext</name></type> <name>context</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>GucAction</name></type> <name>action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>array</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>value</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>array_ref</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
					  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
					  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> ,
					  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ParseLongOption</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>name</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>value</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not parse setting for parameter \"%s\""</literal></expr></argument>,
							<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
								 <argument><expr><name>context</name></expr></argument>, <argument><expr><name>source</name></expr></argument>,
								 <argument><expr><name>action</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>


<comment type="block">/*
 * Add an entry to an option array.  The array parameter may be NULL
 * to indicate the current table entry is NULL.
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>GUCArrayAdd</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>newval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test if the option is valid and we're allowed to set it */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>validate_option_array_item</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* normalize name (converts obsolete GUC names to modern spellings) */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* build new item for array */</comment>
	<expr_stmt><expr><name>newval</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s=%s"</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>array</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ARR_LBOUND</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* add after end */</comment>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>array_ref</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
						  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
						  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
						  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> ,
						  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>current</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* check for match up through and including '=' */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>current</name></expr></argument>, <argument><expr><name>newval</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>index</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>array_set</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>,
					  <argument><expr><name>datum</name></expr></argument>,
					  <argument><expr><name>false</name></expr></argument>,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlena array */</comment> ,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
					  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
					  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> )</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>datum</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
							<argument><expr><name>TEXTOID</name></expr></argument>,
							<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>a</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Delete an entry from an option array.  The array parameter may be NULL
 * to indicate the current table entry is NULL.  Also, if the return value
 * is NULL then a null should be stored.
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>GUCArrayDelete</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* test if the option is valid and we're allowed to set it */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>validate_option_array_item</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* normalize name (converts obsolete GUC names to modern spellings) */</comment>
	<expr_stmt><expr><name>record</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>record</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>name</name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>name</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* if array is currently null, then surely nothing to delete */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>array</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newarray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>array_ref</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
					  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
					  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> ,
					  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ignore entry if it's what we want to delete */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal>
			<operator>&amp;&amp;</operator> <name><name>val</name><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>]</index></name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* else add it to the output array */</comment>
		<if_stmt><if>if <condition>(<expr><name>newarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarray</name> <operator>=</operator> <call><name>array_set</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>,
								 <argument><expr><name>d</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
								 <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarray</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>TEXTOID</name></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>newarray</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Given a GUC array, delete all settings from it that our permission
 * level allows: if superuser, delete them all; if regular user, only
 * those that are PGC_USERSET
 */</comment>
<function><type><name>ArrayType</name> <modifier>*</modifier></type>
<name>GUCArrayReset</name><parameter_list>(<parameter><decl><type><name>ArrayType</name> <modifier>*</modifier></type><name>array</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>newarray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>

	<comment type="block">/* if array is currently null, nothing to do */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>array</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if we're superuser, we can delete everything, so just do it */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newarray</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>d</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>eqsgn</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>d</name> <operator>=</operator> <call><name>array_ref</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>i</name></expr></argument>,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
					  <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
					  <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
					  <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> ,
					  <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>d</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>eqsgn</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="char">'='</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>eqsgn</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<comment type="block">/* skip if we have permission to delete it */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>validate_option_array_item</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* else add it to the output array */</comment>
		<if_stmt><if>if <condition>(<expr><name>newarray</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarray</name> <operator>=</operator> <call><name>array_set</name><argument_list>(<argument><expr><name>newarray</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>index</name></expr></argument>,
								 <argument><expr><name>d</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* varlenarray */</comment> ,
								 <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument> <comment type="block">/* TEXT's typlen */</comment> ,
								 <argument><expr><name>false</name></expr></argument> <comment type="block">/* TEXT's typbyval */</comment> ,
								 <argument><expr><literal type="char">'i'</literal></expr></argument> <comment type="block">/* TEXT's typalign */</comment> )</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newarray</name> <operator>=</operator> <call><name>construct_array</name><argument_list>(<argument><expr><operator>&amp;</operator><name>d</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>,
									   <argument><expr><name>TEXTOID</name></expr></argument>,
									   <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>index</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>newarray</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate a proposed option setting for GUCArrayAdd/Delete/Reset.
 *
 * name is the option name.  value is the proposed value for the Add case,
 * or NULL for the Delete/Reset cases.  If skipIfNoPermissions is true, it's
 * not an error to have no permissions to set the option.
 *
 * Returns true if OK, false if skipIfNoPermissions is true and user does not
 * have permission to change this option (all other error cases result in an
 * error being thrown).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>validate_option_array_item</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>skipIfNoPermissions</name></decl></parameter>)</parameter_list>

<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>config_generic</name></name> <modifier>*</modifier></type><name>gconf</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * There are three cases to consider:
	 *
	 * name is a known GUC variable.  Check the value normally, check
	 * permissions normally (i.e., allow if variable is USERSET, or if it's
	 * SUSET and user is superuser).
	 *
	 * name is not known, but exists or can be created as a placeholder (i.e.,
	 * it has a prefixed name).  We allow this case if you're a superuser,
	 * otherwise not.  Superusers are assumed to know what they're doing. We
	 * can't allow it for other users, because when the placeholder is
	 * resolved it might turn out to be a SUSET variable;
	 * define_custom_variable assumes we checked that.
	 *
	 * name is not known and can't be created as a placeholder.  Throw error,
	 * unless skipIfNoPermissions is true, in which case return false.
	 */</comment>
	<expr_stmt><expr><name>gconf</name> <operator>=</operator> <call><name>find_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gconf</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* not known, failed to make a placeholder */</comment>
		<if_stmt><if>if <condition>(<expr><name>skipIfNoPermissions</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unrecognized configuration parameter \"%s\""</literal></expr></argument>,
						<argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>GUC_CUSTOM_PLACEHOLDER</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We cannot do any meaningful check on the value, so only permissions
		 * are useful to check.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>skipIfNoPermissions</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"permission denied to set parameter \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* manual permissions check so we can avoid an error being thrown */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_USERSET</name></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>gconf</name><operator>-&gt;</operator><name>context</name></name> <operator>==</operator> <name>PGC_SUSET</name> <operator>&amp;&amp;</operator> <call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* ok */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>skipIfNoPermissions</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* if a permissions error should be thrown, let set_config_option do it */</comment>

	<comment type="block">/* test for permissions and valid option value */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>value</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>PGC_SUSET</name></expr> </then><else>: <expr><name>PGC_USERSET</name></expr></else></ternary></expr></argument>,
							 <argument><expr><name>PGC_S_TEST</name></expr></argument>, <argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Called by check_hooks that want to override the normal
 * ERRCODE_INVALID_PARAMETER_VALUE SQLSTATE for check hook failures.
 *
 * Note that GUC_check_errmsg() etc are just macros that result in a direct
 * assignment to the associated variables.  That is ugly, but forced by the
 * limitations of C's macro mechanisms.
 */</comment>
<function><type><name>void</name></type>
<name>GUC_check_errcode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sqlerrcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>sqlerrcode</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Convenience functions to manage calling a variable's check_hook.
 * These mostly take care of the protocol for letting check hooks supply
 * portions of the error report on failure.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_bool_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_bool</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					 <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": %d"</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_int_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_int</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					<parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": %d"</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_real_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_real</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					 <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": %g"</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_string_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_string</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					   <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>, <argument><expr><ternary><condition><expr><operator>*</operator><name>newval</name></expr> ?</condition><then> <expr><operator>*</operator><name>newval</name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>call_enum_check_hook</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>config_enum</name></name> <modifier>*</modifier></type><name>conf</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>,
					 <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Quick success if no hook */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Reset variables that might be set by hook */</comment>
	<expr_stmt><expr><name>GUC_check_errcode_value</name> <operator>=</operator> <name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errmsg_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errdetail_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>GUC_check_errhint_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name><name>conf</name><operator>-&gt;</operator><name>check_hook</name></name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>source</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>GUC_check_errcode_value</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errmsg_string</name></expr> ?</condition><then>
				 <expr><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errmsg_string</name></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value for parameter \"%s\": \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>conf</name><operator>-&gt;</operator><name>gen</name><operator>.</operator><name>name</name></name></expr></argument>,
						<argument><expr><call><name>config_enum_lookup_by_value</name><argument_list>(<argument><expr><name>conf</name></expr></argument>, <argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errdetail_string</name></expr> ?</condition><then>
				 <expr><call><name>errdetail_internal</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errdetail_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>,</operator>
				 <ternary><condition><expr><name>GUC_check_errhint_string</name></expr> ?</condition><then>
				 <expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>GUC_check_errhint_string</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Flush any strings created in ErrorContext */</comment>
		<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * check_hook, assign_hook and show_hook subroutines
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_wal_consistency_checking</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name><name>newwalconsistency</name><index>[<expr><name>RM_MAX_ID</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Initialize the array */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>newwalconsistency</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>RM_MAX_ID</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tok</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RmgrId</name></type>		<name>rmid</name></decl>;</decl_stmt>

		<comment type="block">/* Check for 'all'. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"all"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>rmid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rmid</name> <operator>&lt;=</operator> <name>RM_MAX_ID</name></expr>;</condition> <incr><expr><name>rmid</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_mask</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>newwalconsistency</name><index>[<expr><name>rmid</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Check if the token matches with any individual resource
			 * manager.
			 */</comment>
			<for>for <control>(<init><expr><name>rmid</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>rmid</name> <operator>&lt;=</operator> <name>RM_MAX_ID</name></expr>;</condition> <incr><expr><name>rmid</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_name</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<name><name>RmgrTable</name><index>[<expr><name>rmid</name></expr>]</index></name><operator>.</operator><name>rm_mask</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>newwalconsistency</name><index>[<expr><name>rmid</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* If a valid resource manager is found, check for the next one. */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Unrecognized key word: \"%s\"."</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* assign new value */</comment>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><name>RM_MAX_ID</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>*</operator><name>extra</name></expr></argument>, <argument><expr><name>newwalconsistency</name></expr></argument>, <argument><expr><operator>(</operator><name>RM_MAX_ID</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_wal_consistency_checking</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>wal_consistency_checking</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_log_destination</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>rawstring</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>elemlist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newlogdest</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>myextra</name></decl>;</decl_stmt>

	<comment type="block">/* Need a modifiable copy of string */</comment>
	<expr_stmt><expr><name>rawstring</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Parse string into list of identifiers */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>SplitIdentifierString</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemlist</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* syntax error in list */</comment>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"List syntax is invalid."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>elemlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tok</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"stderr"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_STDERR</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"csvlog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"syslog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_SYSLOG</name></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strcasecmp</name><argument_list>(<argument><expr><name>tok</name></expr></argument>, <argument><expr><literal type="string">"eventlog"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newlogdest</name> <operator>|=</operator> <name>LOG_DESTINATION_EVENTLOG</name></expr>;</expr_stmt></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Unrecognized key word: \"%s\"."</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>rawstring</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>elemlist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>myextra</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>myextra</name> <operator>=</operator> <name>newlogdest</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>myextra</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_log_destination</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>Log_destination</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>extra</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_syslog_facility</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>set_syslog_parameters</name><argument_list>(<argument><expr><ternary><condition><expr><name>syslog_ident_str</name></expr> ?</condition><then> <expr><name>syslog_ident_str</name></expr> </then><else>: <expr><literal type="string">"postgres"</literal></expr></else></ternary></expr></argument>,
						  <argument><expr><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Without syslog support, just ignore it */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_syslog_ident</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>set_syslog_parameters</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>syslog_facility</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<comment type="block">/* Without syslog support, it will always be set to "none", so ignore */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_session_replication_role</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Must flush the plan cache when changing replication role; but don't
	 * flush unnecessarily.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>SessionReplicationRole</name> <operator>!=</operator> <name>newval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ResetPlanCache</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_temp_buffers</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Once local buffers have been initialized, it's too late to change this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>NLocBuffer</name> <operator>&amp;&amp;</operator> <name>NLocBuffer</name> <operator>!=</operator> <operator>*</operator><name>newval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"\"temp_buffers\" cannot be changed after any temporary tables have been accessed in the session."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_bonjour</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_BONJOUR</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"Bonjour is not supported by this build"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_ssl</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>USE_SSL</name></cpp:ifndef>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errmsg</name><argument_list>(<argument><expr><literal type="string">"SSL is not supported by this build"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_stage_log_stats</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&amp;&amp;</operator> <name>log_statement_stats</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot enable parameter when \"log_statement_stats\" is true."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_log_stats</name><parameter_list>(<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>log_parser_stats</name> <operator>||</operator> <name>log_planner_stats</name> <operator>||</operator> <name>log_executor_stats</name> <operator>||</operator> <name>log_dispatch_stats</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"Cannot enable \"log_statement_stats\" when "</literal>
							<literal type="string">"\"log_parser_stats\", \"log_planner_stats\", "</literal>
							<literal type="string">"\"log_dispatch_stats\", "</literal>
							<literal type="string">"or \"log_executor_stats\" is true."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_canonical_path</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Since canonicalize_path never enlarges the string, we can just modify
	 * newval in-place.  But watch out for NULL, which is the default value
	 * for external_pid_file.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>canonicalize_path</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_timezone_abbreviations</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The boot_val given above for timezone_abbreviations is NULL. When we
	 * see this we just do nothing.  If this value isn't overridden from the
	 * config file then pg_timezone_abbrev_initialize() will eventually
	 * replace it with "Default".  This hack has two purposes: to avoid
	 * wasting cycles loading values that might soon be overridden from the
	 * config file, and to avoid trying to read the timezone abbrev files
	 * during InitializeGUCOptions().  The latter doesn't work in an
	 * EXEC_BACKEND subprocess because my_exec_path hasn't been set yet and so
	 * we can't locate PGSHAREDIR.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>source</name> <operator>==</operator> <name>PGC_S_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* OK, load the file and produce a malloc'd TimeZoneAbbrevTable */</comment>
	<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <call><name>load_tzoffsets</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* tzparser.c returns NULL on failure, reporting via GUC_check_errmsg */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>extra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_timezone_abbreviations</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Do nothing for the boot_val default of NULL */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>extra</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>InstallTimeZoneAbbrevs</name><argument_list>(<argument><expr><operator>(</operator><name>TimeZoneAbbrevTable</name> <operator>*</operator><operator>)</operator> <name>extra</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_timezone_abbrev_initialize --- set default value if not done already
 *
 * This is called after initial loading of postgresql.conf.  If no
 * timezone_abbreviations setting was found therein, select default.
 * If a non-default value is already installed, nothing will happen.
 *
 * This can also be called from ProcessConfigFile to establish the default
 * value after a postgresql.conf entry for it is removed.
 */</comment>
<function><type><name>void</name></type>
<name>pg_timezone_abbrev_initialize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>SetConfigOption</name><argument_list>(<argument><expr><literal type="string">"timezone_abbreviations"</literal></expr></argument>, <argument><expr><literal type="string">"Default"</literal></expr></argument>,
					<argument><expr><name>PGC_POSTMASTER</name></expr></argument>, <argument><expr><name>PGC_S_DYNAMIC_DEFAULT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_archive_command</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>XLogArchivingActive</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>XLogArchiveCommand</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><literal type="string">"(disabled)"</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_tcp_keepalives_idle</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * The kernel API provides no way to test a value without setting it; and
	 * once we set it we might fail to unset it.  So there seems little point
	 * in fully implementing the check-then-assign GUC API for these
	 * variables.  Instead we just do the assignment on demand.  pqcomm.c
	 * reports any problems via elog(LOG).
	 *
	 * This approach means that the GUC value might have little to do with the
	 * actual kernel value, so we use a show_hook that retrieves the kernel
	 * value rather than trusting GUC's copy.
	 */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_setkeepalivesidle</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_tcp_keepalives_idle</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>nbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>pq_getkeepalivesidle</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nbuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_tcp_keepalives_interval</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_setkeepalivesinterval</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_tcp_keepalives_interval</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>nbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>pq_getkeepalivesinterval</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nbuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_tcp_keepalives_count</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_setkeepalivescount</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_tcp_keepalives_count</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>nbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>pq_getkeepalivescount</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nbuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_tcp_user_timeout</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>pq_settcpusertimeout</name><argument_list>(<argument><expr><name>newval</name></expr></argument>, <argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>show_tcp_user_timeout</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* See comments in assign_tcp_keepalives_idle */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>nbuf</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>nbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>pq_gettcpusertimeout</name><argument_list>(<argument><expr><name>MyProcPort</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>nbuf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_maxconnections</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
		<name>max_worker_processes</name> <operator>+</operator> <name>max_wal_senders</name> <operator>&gt;</operator> <name>MAX_BACKENDS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_autovacuum_max_workers</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MaxConnections</name> <operator>+</operator> <operator>*</operator><name>newval</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
		<name>max_worker_processes</name> <operator>+</operator> <name>max_wal_senders</name> <operator>&gt;</operator> <name>MAX_BACKENDS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_max_wal_senders</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MaxConnections</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
		<name>max_worker_processes</name> <operator>+</operator> <operator>*</operator><name>newval</name> <operator>&gt;</operator> <name>MAX_BACKENDS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_autovacuum_work_mem</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * -1 indicates fallback.
	 *
	 * If we haven't yet changed the boot_val default of -1, just let it be.
	 * Autovacuum will look to maintenance_work_mem instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We clamp manually-set values to at least 1MB.  Since
	 * maintenance_work_mem is always set to at least this value, do the same
	 * here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&lt;</operator> <literal type="number">1024</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>newval</name> <operator>=</operator> <literal type="number">1024</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_max_worker_processes</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MaxConnections</name> <operator>+</operator> <name>autovacuum_max_workers</name> <operator>+</operator> <literal type="number">1</literal> <operator>+</operator>
		<operator>*</operator><name>newval</name> <operator>+</operator> <name>max_wal_senders</name> <operator>&gt;</operator> <name>MAX_BACKENDS</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>&lt;</operator> <name>MaxPMAuxProc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"max_worker_processes less than %d, must reserve %d "</literal>
			 <literal type="string">"for auxiliary processes like FTS"</literal></expr></argument>, <argument><expr><name>MaxPMAuxProc</name></expr></argument>, <argument><expr><name>MaxPMAuxProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_effective_io_concurrency</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<decl_stmt><decl><type><name>double</name></type>		<name>new_prefetch_pages</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ComputeIoConcurrency</name><argument_list>(<argument><expr><operator>*</operator><name>newval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>new_prefetch_pages</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>myextra</name> <init>= <expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <call><name>guc_malloc</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>myextra</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>new_prefetch_pages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>extra</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>myextra</name></expr>;</expr_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>GUC_check_errdetail</name><argument_list>(<argument><expr><literal type="string">"effective_io_concurrency must be set to 0 on platforms that lack posix_fadvise()."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>assign_effective_io_concurrency</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>extra</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_PREFETCH</name></cpp:ifdef>
	<expr_stmt><expr><name>target_prefetch_pages</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>extra</name><operator>)</operator></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_PREFETCH */</comment>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_client_connection_check_interval</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>newval</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>extra</name></decl></parameter>, <parameter><decl><type><name>GucSource</name></type> <name>source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><operator>(</operator><call><name>defined</name><argument_list>(<argument><expr><name>POLLRDHUP</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call><operator>)</operator></expr></cpp:if>
	<comment type="block">/* Linux and OSX only, for now.  See pq_check_connection(). */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>newval</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<macro><name>GUC_check_errdetail</name><argument_list>(<argument><literal type="string">"client_connection_check_interval must be set to 0 on platforms that lack POLLRDHUP and not OSX."</literal>;
		return false;
	}
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	return true;
}

static void
assign_pgstat_temp_directory(const char *newval, void *extra)
{
	<comment type="block">/* check_canonical_path already canonicalized newval for us */</comment>
	char	   *dname;
	char	   *tname;
	char	   *fname;

	<comment type="block">/* directory */</comment>
	dname = guc_malloc(ERROR, strlen(newval) + <literal type="number">1</literal>);	<comment type="block">/* runtime dir */</comment>
	sprintf(dname, <literal type="string">"%s"</literal>, newval);

	<comment type="block">/* global stats */</comment>
	tname = guc_malloc(ERROR, strlen(newval) + <literal type="number">12</literal>); <comment type="block">/* /global.tmp */</comment>
	sprintf(tname, <literal type="string">"%s/global.tmp"</literal>, newval);
	fname = guc_malloc(ERROR, strlen(newval) + <literal type="number">13</literal>); <comment type="block">/* /global.stat */</comment>
	sprintf(fname, <literal type="string">"%s/global.stat"</literal>, newval);

	if (pgstat_stat_directory)
		free(pgstat_stat_directory);
	pgstat_stat_directory = dname;
	if (pgstat_stat_tmpname)
		free(pgstat_stat_tmpname);
	pgstat_stat_tmpname = tname;
	if (pgstat_stat_filename)
		free(pgstat_stat_filename);
	pgstat_stat_filename = fname;
}

static bool
check_application_name(char **newval, void **extra, GucSource source)
{
	<comment type="block">/* Only allow clean ASCII chars in the application name */</comment>
	pg_clean_ascii(*newval);

	return true;
}

static void
assign_application_name(const char *newval, void *extra)
{
	<comment type="block">/* Update the pg_stat_activity view */</comment>
	pgstat_report_appname(newval);
}

static bool
check_cluster_name(char **newval, void **extra, GucSource source)
{
	<comment type="block">/* Only allow clean ASCII chars in the cluster name */</comment>
	pg_clean_ascii(*newval);

	return true;
}

static const char *
show_unix_socket_permissions(void)
{
	static char buf[<literal type="number">12</literal>];

	snprintf(buf, sizeof(buf), <literal type="string">"%04o"</literal>, Unix_socket_permissions);
	return buf;
}

static const char *
show_log_file_mode(void)
{
	static char buf[<literal type="number">12</literal>];

	snprintf(buf, sizeof(buf), <literal type="string">"%04o"</literal>, Log_file_mode);
	return buf;
}

static const char *
show_data_directory_mode(void)
{
	static char buf[<literal type="number">12</literal>];

	snprintf(buf, sizeof(buf), <literal type="string">"%04o"</literal>, data_directory_mode);
	return buf;
}

static bool
check_recovery_target_timeline(char **newval, void **extra, GucSource source)
{
	RecoveryTargetTimeLineGoal rttg;
	RecoveryTargetTimeLineGoal *myextra;

	if (strcmp(*newval, <literal type="string">"current"</literal>) == <literal type="number">0</literal>)
		rttg = RECOVERY_TARGET_TIMELINE_CONTROLFILE;
	else if (strcmp(*newval, <literal type="string">"latest"</literal>) == <literal type="number">0</literal>)
		rttg = RECOVERY_TARGET_TIMELINE_LATEST;
	else
	{
		rttg = RECOVERY_TARGET_TIMELINE_NUMERIC;

		errno = <literal type="number">0</literal>;
		strtoul(*newval, NULL, <literal type="number">0</literal>);
		if (errno == EINVAL || errno == ERANGE)
		{
			GUC_check_errdetail(<literal type="string">"recovery_target_timeline is not a valid number."</literal>);
			return false;
		}
	}

	myextra = (RecoveryTargetTimeLineGoal *) guc_malloc(ERROR, sizeof(RecoveryTargetTimeLineGoal));
	*myextra = rttg;
	*extra = (void *) myextra;

	return true;
}

static void
assign_recovery_target_timeline(const char *newval, void *extra)
{
	recoveryTargetTimeLineGoal = *((RecoveryTargetTimeLineGoal *) extra);
	if (recoveryTargetTimeLineGoal == RECOVERY_TARGET_TIMELINE_NUMERIC)
		recoveryTargetTLIRequested = (TimeLineID) strtoul(newval, NULL, <literal type="number">0</literal>);
	else
		recoveryTargetTLIRequested = <literal type="number">0</literal>;
}

<comment type="block">/*
 * Recovery target settings: Only one of the several recovery_target* settings
 * may be set.  Setting a second one results in an error.  The global variable
 * recoveryTarget tracks which kind of recovery target was chosen.  Other
 * variables store the actual target value (for example a string or a xid).
 * The assign functions of the parameters check whether a competing parameter
 * was already set.  But we want to allow setting the same parameter multiple
 * times.  We also want to allow unsetting a parameter and setting a different
 * one, so we unset recoveryTarget when the parameter is set to an empty
 * string.
 */</comment>

static void
pg_attribute_noreturn()
error_multiple_recovery_targets(void)
{
	ereport(ERROR,
			(errcode(ERRCODE_INVALID_PARAMETER_VALUE),
			 errmsg(<literal type="string">"multiple recovery targets specified"</literal>),
			 errdetail(<literal type="string">"At most one of recovery_target, recovery_target_lsn, recovery_target_name, recovery_target_time, recovery_target_xid may be set."</literal>)));
}

static bool
check_recovery_target(char **newval, void **extra, GucSource source)
{
	if (strcmp(*newval, <literal type="string">"immediate"</literal>) != <literal type="number">0</literal> &amp;&amp; strcmp(*newval, <literal type="string">""</literal>) != <literal type="number">0</literal>)
	{
		GUC_check_errdetail(<literal type="string">"The only allowed value is \"immediate\"."</literal>);
		return false;
	}
	return true;
}

static void
assign_recovery_target(const char *newval, void *extra)
{
	if (recoveryTarget != RECOVERY_TARGET_UNSET &amp;&amp;
		recoveryTarget != RECOVERY_TARGET_IMMEDIATE)
		error_multiple_recovery_targets();

	if (newval &amp;&amp; strcmp(newval, <literal type="string">""</literal>) != <literal type="number">0</literal>)
		recoveryTarget = RECOVERY_TARGET_IMMEDIATE;
	else
		recoveryTarget = RECOVERY_TARGET_UNSET;
}

static bool
check_recovery_target_xid(char **newval, void **extra, GucSource source)
{
	if (strcmp(*newval, <literal type="string">""</literal>) != <literal type="number">0</literal>)
	{
		TransactionId xid;
		TransactionId *myextra;

		errno = <literal type="number">0</literal>;
		xid = (TransactionId) strtoul(*newval, NULL, <literal type="number">0</literal>);
		if (errno == EINVAL || errno == ERANGE)
			return false;

		myextra = (TransactionId *) guc_malloc(ERROR, sizeof(TransactionId));
		*myextra = xid;
		*extra = (void *) myextra;
	}
	return true;
}

static void
assign_recovery_target_xid(const char *newval, void *extra)
{
	if (recoveryTarget != RECOVERY_TARGET_UNSET &amp;&amp;
		recoveryTarget != RECOVERY_TARGET_XID)
		error_multiple_recovery_targets();

	if (newval &amp;&amp; strcmp(newval, <literal type="string">""</literal>) != <literal type="number">0</literal>)
	{
		recoveryTarget = RECOVERY_TARGET_XID;
		recoveryTargetXid = *((TransactionId *) extra);
	}
	else
		recoveryTarget = RECOVERY_TARGET_UNSET;
}

<comment type="block">/*
 * The interpretation of the recovery_target_time string can depend on the
 * time zone setting, so we need to wait until after all GUC processing is
 * done before we can do the final parsing of the string.  This check function
 * only does a parsing pass to catch syntax errors, but we store the string
 * and parse it again when we need to use it.
 */</comment>
static bool
check_recovery_target_time(char **newval, void **extra, GucSource source)
{
	if (strcmp(*newval, <literal type="string">""</literal>) != <literal type="number">0</literal>)
	{
		<comment type="block">/* reject some special values */</comment>
		if (strcmp(*newval, <literal type="string">"now"</literal>) == <literal type="number">0</literal> ||
			strcmp(*newval, <literal type="string">"today"</literal>) == <literal type="number">0</literal> ||
			strcmp(*newval, <literal type="string">"tomorrow"</literal>) == <literal type="number">0</literal> ||
			strcmp(*newval, <literal type="string">"yesterday"</literal>) == <literal type="number">0</literal>)
		{
			return false;
		}

		<comment type="block">/*
		 * parse timestamp value (see also timestamptz_in())
		 */</comment>
		{
			char	   *str = *newval;
			fsec_t		fsec;
			struct pg_tm tt</argument>,
					   <argument>*tm = &amp;tt;
			int			tz;
			int			dtype;
			int			nf;
			int			dterr;
			char	   *field[MAXDATEFIELDS];
			int			ftype[MAXDATEFIELDS];
			char		workbuf[MAXDATELEN + MAXDATEFIELDS];
			TimestampTz timestamp;

			dterr = ParseDateTime(str, workbuf, sizeof(workbuf),
								  field, ftype, MAXDATEFIELDS, &amp;nf);
			if (dterr == <literal type="number">0</literal>)
				dterr = DecodeDateTime(field, ftype, nf, &amp;dtype, tm, &amp;fsec, &amp;tz);
			if (dterr != <literal type="number">0</literal>)
				return false;
			if (dtype != DTK_DATE)
				return false;

			if (tm2timestamp(tm, fsec, &amp;tz, &amp;timestamp) != <literal type="number">0</literal>)
			{
				GUC_check_errdetail(<literal type="string">"timestamp out of range: \"%s\""</literal>, str);
				return false;
			}
		}
	}
	return true;
}

static void
assign_recovery_target_time(const char *newval, void *extra)
{
	if (recoveryTarget != RECOVERY_TARGET_UNSET &amp;&amp;
		recoveryTarget != RECOVERY_TARGET_TIME)
		error_multiple_recovery_targets();

	if (newval &amp;&amp; strcmp(newval, <literal type="string">""</literal>) != <literal type="number">0</literal>)
		recoveryTarget = RECOVERY_TARGET_TIME;
	else
		recoveryTarget = RECOVERY_TARGET_UNSET;
}

static bool
check_recovery_target_name(char **newval, void **extra, GucSource source)
{
	<comment type="block">/* Use the value of newval directly */</comment>
	if (strlen(*newval) &gt;= MAXFNAMELEN)
	{
		GUC_check_errdetail(<literal type="string">"%s is too long (maximum %d characters)."</literal>,
							<literal type="string">"recovery_target_name"</literal>, MAXFNAMELEN - <literal type="number">1</literal>);
		return false;
	}
	return true;
}

static void
assign_recovery_target_name(const char *newval, void *extra)
{
	if (recoveryTarget != RECOVERY_TARGET_UNSET &amp;&amp;
		recoveryTarget != RECOVERY_TARGET_NAME)
		error_multiple_recovery_targets();

	if (newval &amp;&amp; strcmp(newval, <literal type="string">""</literal>) != <literal type="number">0</literal>)
	{
		recoveryTarget = RECOVERY_TARGET_NAME;
		recoveryTargetName = newval;
	}
	else
		recoveryTarget = RECOVERY_TARGET_UNSET;
}

static bool
check_recovery_target_lsn(char **newval, void **extra, GucSource source)
{
	if (strcmp(*newval, <literal type="string">""</literal>) != <literal type="number">0</literal>)
	{
		XLogRecPtr	lsn;
		XLogRecPtr *myextra;
		bool		have_error = false;

		lsn = pg_lsn_in_internal(*newval, &amp;have_error);
		if (have_error)
			return false;

		myextra = (XLogRecPtr *) guc_malloc(ERROR, sizeof(XLogRecPtr));
		*myextra = lsn;
		*extra = (void *) myextra;
	}
	return true;
}

static void
assign_recovery_target_lsn(const char *newval, void *extra)
{
	if (recoveryTarget != RECOVERY_TARGET_UNSET &amp;&amp;
		recoveryTarget != RECOVERY_TARGET_LSN)
		error_multiple_recovery_targets();

	if (newval &amp;&amp; strcmp(newval, <literal type="string">""</literal>) != <literal type="number">0</literal>)
	{
		recoveryTarget = RECOVERY_TARGET_LSN;
		recoveryTargetLSN = *((XLogRecPtr *) extra);
	}
	else
		recoveryTarget = RECOVERY_TARGET_UNSET;
}

static bool
check_primary_slot_name(char **newval, void **extra, GucSource source)
{
	if (*newval &amp;&amp; strcmp(*newval, <literal type="string">""</literal>) != <literal type="number">0</literal> &amp;&amp;
		!ReplicationSlotValidateName(*newval, WARNING))
		return false;

	return true;
}

static bool
check_default_with_oids(bool *newval, void **extra, GucSource source)
{
	if (*newval)
	{
		<comment type="block">/* check the GUC's definition for an explanation */</comment>
		GUC_check_errcode(ERRCODE_FEATURE_NOT_SUPPORTED);
		GUC_check_errmsg(<literal type="string">"tables declared WITH OIDS are not supported"</literal>);

		return false;
	}

	return true;
}</argument></argument_list></macro></block_content></block></if></if_stmt></block_content></block></function>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"guc-file.c"</cpp:file></cpp:include>
</unit>
