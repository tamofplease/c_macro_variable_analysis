<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/misc/faultinjector.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * faultinjector.c
 *	  GP Fault Injectors are used for Greenplum internal testing only.
 * 
 * Fault injectors are used for fine control during testing. They allow a
 * developer to create deterministic tests for scenarios that are hard to
 * reproduce. This is done by programming actions at certain key areas to
 * suspend, skip, or even panic the process. Fault injectors are set in shared
 * memory so they are accessible to all segment processes.
 *
 * Portions Copyright (c) 2009-2010 Greenplum Inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/utils/misc/faultinjector.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/autovacuum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/bgwriter.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/spin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/dest.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<comment type="block">/*
 * internal include
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"faultinjector_warnings.h"</cpp:file></cpp:include>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>

<comment type="block">/*
 * gettext() can't be used in a static initializer... This breaks nls builds.
 * So, to work around this issue, I've made _() be a no-op.
 */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>x</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct <name>FaultInjectorShmem_s</name> <block>{
	<decl_stmt><decl><type><name>slock_t</name></type>		<name>lock</name></decl>;</decl_stmt>
	
	<decl_stmt><decl><type><name>int</name></type>			<name>numActiveFaults</name></decl>;</decl_stmt> <comment type="block">/* number of fault injections set */</comment>
	
	<decl_stmt><decl><type><name>HTAB</name>		<modifier>*</modifier></type><name>hash</name></decl>;</decl_stmt>
}</block></struct></type> <name>FaultInjectorShmem_s</name>;</typedef>

<decl_stmt><decl><type><name>bool</name></type> <name>am_faulthandler</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier>	<name>FaultInjectorShmem_s</name> <modifier>*</modifier></type><name>faultInjectorShmem</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * faultInjectorSlots_ptr points to this until shmem is initialized. Just to
 * keep any FaultInjector_InjectFaultIfSet calls from crashing.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>dummy</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>int</name> <modifier>*</modifier></type><name>numActiveFaults_ptr</name> <init>= <expr><operator>&amp;</operator><name>dummy</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FiLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FiLockRelease</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>FaultInjectorEntry_s</name><modifier>*</modifier></type> <name>FaultInjector_LookupHashEntry</name><parameter_list>(
								<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>faultName</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>FaultInjectorEntry_s</name><modifier>*</modifier></type> <name>FaultInjector_InsertHashEntry</name><parameter_list>(
								<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>faultName</name></decl></parameter>,
								<parameter><decl><type><name>bool</name>	<modifier>*</modifier></type><name>exists</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>FaultInjector_NewHashEntry</name><parameter_list>(
								<parameter><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>FaultInjector_MarkEntryAsResume</name><parameter_list>(
								<parameter><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FaultInjector_RemoveHashEntry</name><parameter_list>(
								<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>faultName</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>FaultInjector_SetFaultInjection</name><parameter_list>(<parameter><decl><type><name>FaultInjectorEntry_s</name> <modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>FaultInjectorType_e</name></type> <name>FaultInjectorTypeStringToEnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>faultType</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>DDLStatement_e</name></type> <name>FaultInjectorDDLStringToEnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ddlString</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* Arrays to map between enum values and strings */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name><name>FaultInjectorTypeEnumToString</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FI_TYPE</name><parameter_list>(<parameter><type><name>id</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>str,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector_lists.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FI_TYPE</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name><name>FaultInjectorDDLEnumToString</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FI_DDL_STATEMENT</name><parameter_list>(<parameter><type><name>id</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>str,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector_lists.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FI_DDL_STATEMENT</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>
<name><name>FaultInjectorStateEnumToString</name><index>[]</index></name> <init>= <expr><block>{
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FI_STATE</name><parameter_list>(<parameter><type><name>id</name></type></parameter>, <parameter><type><name>str</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>str,</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector_lists.h"</cpp:file></cpp:include>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>FI_STATE</name></cpp:undef>
}</block></expr></init></decl>;</decl_stmt>

<function><type><specifier>static</specifier> <name>FaultInjectorType_e</name></type>
<name>FaultInjectorTypeStringToEnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>faultTypeString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FaultInjectorType_e</name></type>	<name>faultTypeEnum</name> <init>= <expr><name>FaultInjectorTypeMax</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>ii</name></decl>;</decl_stmt>
	
	<for>for <control>(<init><expr><name>ii</name><operator>=</operator><name>FaultInjectorTypeNotSpecified</name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>FaultInjectorTypeMax</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>faultTypeString</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>faultTypeEnum</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>faultTypeEnum</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>DDLStatement_e</name></type>
<name>FaultInjectorDDLStringToEnum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>ddlString</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DDLStatement_e</name></type>	<name>ddlEnum</name> <init>= <expr><name>DDLMax</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>ii</name></decl>;</decl_stmt>
	
	<for>for <control>(<init><expr><name>ii</name><operator>=</operator><name>DDLNotSpecified</name></expr>;</init> <condition><expr><name>ii</name> <operator>&lt;</operator> <name>DDLMax</name></expr>;</condition> <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>FaultInjectorDDLEnumToString</name><index>[<expr><name>ii</name></expr>]</index></name></expr></argument>, <argument><expr><name>ddlString</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>ddlEnum</name> <operator>=</operator> <name>ii</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>ddlEnum</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FiLockAcquire</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>	
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>FiLockRelease</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>	
	<expr_stmt><expr><call><name>SpinLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>void</name></type> <name>InjectFaultInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>warnings_init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/****************************************************************
 * FAULT INJECTOR routines
 ****************************************************************/</comment>
<function><type><name>Size</name></type>
<name>FaultInjector_ShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>	<name>size</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>hash_estimate_size</name><argument_list>(
							  <argument><expr><operator>(</operator><name>Size</name><operator>)</operator><name>FAULTINJECTOR_MAX_SLOTS</name></expr></argument>, 
							  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorEntry_s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorShmem_s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><name>size</name></expr>;</return>	
</block_content>}</block></function>

<comment type="block">/*
 * Hash table contains fault injection that are set on the system waiting to be injected.
 * FaultInjector identifier is the key in the hash table.
 * Hash table in shared memory is initialized only on primary and mirror segment. 
 * It is not initialized on master host.
 */</comment>
<function><type><name>void</name></type>
<name>FaultInjector_ShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>	<name>hash_ctl</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>foundPtr</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>faultInjectorShmem</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorShmem_s</name> <operator>*</operator><operator>)</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"fault injector"</literal></expr></argument>,
																  <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorShmem_s</name></expr></argument>)</argument_list></sizeof></expr></argument>,
																  <argument><expr><operator>&amp;</operator><name>foundPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>faultInjectorShmem</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough shared memory for fault injector"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	

	<expr_stmt><expr><name>numActiveFaults_ptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>numActiveFaults</name></name></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><operator>!</operator> <name>foundPtr</name></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>faultInjectorShmem</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorShmem_s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>	
	
	<expr_stmt><expr><call><name>SpinLockInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>lock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>numActiveFaults</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>FAULT_NAME_MAX_LENGTH</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorEntry_s</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>string_hash</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"fault injector hash"</literal></expr></argument>,
								   <argument><expr><name>FAULTINJECTOR_MAX_SLOTS</name></expr></argument>,
								   <argument><expr><name>FAULTINJECTOR_MAX_SLOTS</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
								   <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, 
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough shared memory for fault injector"</literal></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<return>return;</return>						  
</block_content>}</block></function>

<function><type><name>FaultInjectorType_e</name></type>
<name>FaultInjector_InjectFaultIfSet_out_of_line</name><parameter_list>(
							   <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>				 <name>faultName</name></decl></parameter>,
							   <parameter><decl><type><name>DDLStatement_e</name></type>			 <name>ddlStatement</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>				 <name>databaseName</name></decl></parameter>,
							   <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type>				 <name>tableName</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>   <modifier>*</modifier></type><name>entryShared</name></decl>, <decl><type ref="prev"/><name>localEntry</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>entryLocal</name> <init>= <expr><operator>&amp;</operator><name>localEntry</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>					<name><name>databaseNameLocal</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>					<name><name>tableNameLocal</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>ii</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>cnt</name> <init>= <expr><literal type="number">3600</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FaultInjectorType_e</name></type> <name>retvalue</name> <init>= <expr><name>FaultInjectorTypeNotSpecified</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>faultName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>localEntry</name><operator>.</operator><name>faultName</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"fault name too long: '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>faultName</name></expr></argument>, <argument><expr><name>FaultInjectorNameAll</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid fault name '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>databaseName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"database name too long:'%s'"</literal></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>tableName</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>NAMEDATALEN</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"table name too long: '%s'"</literal></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Auto-vacuum worker and launcher process, may run at unpredictable times
	 * while running tests. So, skip setting any faults for auto-vacuum
	 * launcher or worker. If anytime in future need to test these processes
	 * using fault injector framework, this restriction needs to be lifted and
	 * some other mechanism needs to be placed to avoid flaky failures.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsAutoVacuumLauncherProcess</name><argument_list>()</argument_list></call> <operator>||</operator>
		<operator>(</operator><call><name>IsAutoVacuumWorkerProcess</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		 <operator>!</operator><operator>(</operator><literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"vacuum_update_dat_frozen_xid"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"auto_vac_worker_before_do_autovacuum"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"auto_vac_worker_after_report_activity"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"auto_vac_worker_abort"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"analyze_after_hold_lock"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call> <operator>||</operator>
		   <literal type="number">0</literal> <operator>==</operator> <call><name>strcmp</name><argument_list>(<argument><expr><literal type="string">"analyze_finished_one_relation"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>FaultInjectorTypeNotSpecified</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Return immediately if no fault has been injected ever.  It is
	 * important to not touch the spinlock, especially if this is the
	 * postmaster process.  If one of the backend processes dies while
	 * holding the spin lock, and postmaster comes here before resetting
	 * the shared memory, it waits without holder process and eventually
	 * goes into PANIC.  Also this saves a few cycles to acquire the spin
	 * lock and look into the shared hash table.
	 *
	 * Although this is a race condition without lock, a false negative is
	 * ok given this framework is purely for dev/testing.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>numActiveFaults</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>FaultInjectorTypeNotSpecified</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>databaseNameLocal</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>databaseNameLocal</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tableNameLocal</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tableNameLocal</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entryShared</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name>faultName</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>entryShared</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* fault injection is not set */</comment>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entryShared</name><operator>-&gt;</operator><name>gpSessionid</name></name> <operator>!=</operator> <name>InvalidGpSessionId</name> <operator>&amp;&amp;</operator> <name><name>entryShared</name><operator>-&gt;</operator><name>gpSessionid</name></name> <operator>!=</operator> <name>gp_session_id</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* fault injection is not set for the specified session */</comment>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entryShared</name><operator>-&gt;</operator><name>ddlStatement</name></name> <operator>!=</operator> <name>ddlStatement</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* fault injection is not set for the specified DDL */</comment>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entryShared</name><operator>-&gt;</operator><name>databaseName</name></name></expr></argument>, <argument><expr><name>databaseNameLocal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* fault injection is not set for the specified database name */</comment>
			<break>break;</break></block_content></block></if></if_stmt>
	
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entryShared</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>, <argument><expr><name>tableNameLocal</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* fault injection is not set for the specified table name */</comment>
			<break>break;</break></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entryShared</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>==</operator> <name>FaultInjectorStateCompleted</name> <operator>||</operator>
			<name><name>entryShared</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>==</operator> <name>FaultInjectorStateFailed</name></expr>)</condition> <block>{<block_content>
			<comment type="block">/* fault injection was already executed */</comment>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>entryShared</name><operator>-&gt;</operator><name>numTimesTriggered</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>entryShared</name><operator>-&gt;</operator><name>numTimesTriggered</name></name> <operator>&lt;</operator> <name><name>entryShared</name><operator>-&gt;</operator><name>startOccurrence</name></name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Update the injection fault entry in hash table */</comment>
		<expr_stmt><expr><name><name>entryShared</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>=</operator> <name>FaultInjectorStateTriggered</name></expr>;</expr_stmt>

		<comment type="block">/* Mark fault injector to completed */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>entryShared</name><operator>-&gt;</operator><name>endOccurrence</name></name> <operator>!=</operator> <name>INFINITE_END_OCCURRENCE</name> <operator>&amp;&amp;</operator>
			<name><name>entryShared</name><operator>-&gt;</operator><name>numTimesTriggered</name></name> <operator>&gt;=</operator> <name><name>entryShared</name><operator>-&gt;</operator><name>endOccurrence</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entryShared</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>=</operator> <name>FaultInjectorStateCompleted</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>entryLocal</name></expr></argument>, <argument><expr><name>entryShared</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FaultInjectorEntry_s</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>retvalue</name> <operator>=</operator> <name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><literal type="number">0</literal></expr>)</condition>;</do>

	<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>retvalue</name> <operator>==</operator> <name>FaultInjectorTypeNotSpecified</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>FaultInjectorTypeNotSpecified</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Inject fault */</comment>
	<switch>switch <condition>(<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FaultInjectorTypeNotSpecified</name></expr>:</case>
			
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeSleep</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
			
			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>extraArg</name></name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeFatal</name></expr>:</case>
			<comment type="block">/*
			 * Sometimes Fatal is upgraded to Panic (e.g. when it is called in
			 * critical section or when it is called during QD prepare
			 * handling).  We should avoid core file generation for this
			 * scenario, just like what we do for the FaultInjectorTypePanic
			 * case.  Even FATAL is not upgraded to PANIC the process will quit
			 * soon, it does not affect subsequent code.
			 */</comment>
			<expr_stmt><expr><call><name>AvoidCorefileGeneration</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, 
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypePanic</name></expr>:</case>
			<expr_stmt><expr><call><name>AvoidCorefileGeneration</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, 
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	

			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeError</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, 
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeInfiniteLoop</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, 
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>ii</name><operator>=</operator><literal type="number">0</literal></expr>;</init>
				 <condition><expr><name>ii</name> <operator>&lt;</operator> <name>cnt</name> <operator>&amp;&amp;</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</condition>
				 <incr><expr><name>ii</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="line">// sleep for 1 sec (1 sec * 3600 = 1 hour)</comment>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<break>break;</break>
			
		<case>case <expr><name>FaultInjectorTypeSuspend</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
			
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, 
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
			
			<while>while <condition>(<expr><operator>(</operator><name>entry</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				   <name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>!=</operator> <name>FaultInjectorTypeResume</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="line">// 1 sec</comment>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, 
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, 
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault 'NULL', fault name:'%s'  "</literal></expr></argument>,
								<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Since the entry is gone already, we should NOT update
				 * the entry below.  (There could be other places in this
				 * function that are under the same situation, but I'm too
				 * tired to look for them...)
				 */</comment>
				<return>return <expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>;</return>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>FaultInjectorTypeSkip</name></expr>:</case>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, 
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>							
			<break>break;</break>

		<case>case <expr><name>FaultInjectorTypeResume</name></expr>:</case>
			<break>break;</break>
			
		<case>case <expr><name>FaultInjectorTypeSegv</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>AvoidCorefileGeneration</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><specifier>volatile</specifier> <name>int</name> <operator>*</operator><operator>)</operator> <literal type="number">0</literal> <operator>=</operator> <literal type="number">1234</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>
		
		<case>case <expr><name>FaultInjectorTypeInterrupt</name></expr>:</case>
		<block>{<block_content>
			<comment type="block">/*
			 * The place where this type of fault is injected must have
			 * has HOLD_INTERRUPTS() .. RESUME_INTERRUPTS() around it, otherwise
			 * the interrupt could be handled inside the fault injector itself
			 */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>InterruptPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>QueryCancelPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>FaultInjectorTypeFinishPending</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>QueryFinishPending</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block>

		<default>default:</default>
			
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, 
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unexpected error, fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
			
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
		
	<return>return <expr><operator>(</operator><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lookup if fault injection is set
 */</comment>
<function><type><specifier>static</specifier> <name>FaultInjectorEntry_s</name><modifier>*</modifier></type>
<name>FaultInjector_LookupHashEntry</name><parameter_list>(
							  <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>faultName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorEntry_s</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
												  <argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, 
												  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>faultName</name></expr></argument>, <comment type="line">// key</comment>
												  <argument><expr><name>HASH_FIND</name></expr></argument>, 
												  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG5</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"FaultInjector_LookupHashEntry() could not find fault injection hash entry:'%s' "</literal></expr></argument>,
						<argument><expr><name>faultName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt> 
	
	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * insert fault injection in hash table 
 */</comment> 
<function><type><specifier>static</specifier> <name>FaultInjectorEntry_s</name><modifier>*</modifier></type>
<name>FaultInjector_InsertHashEntry</name><parameter_list>(
							<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>faultName</name></decl></parameter>,
							<parameter><decl><type><name>bool</name>	<modifier>*</modifier></type><name>exists</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	
	<decl_stmt><decl><type><name>bool</name></type>					<name>foundPtr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorEntry_s</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
												  <argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, 
												  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>faultName</name></expr></argument>, <comment type="line">// key</comment>
												  <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>foundPtr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>exists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return <expr><name>entry</name></expr>;</return>
	</block_content>}</block></if></if_stmt> 
	
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"FaultInjector_InsertHashEntry() entry_key:%s"</literal></expr></argument>,
		 <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>foundPtr</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>exists</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>exists</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * 
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FaultInjector_RemoveHashEntry</name><parameter_list>(
							  <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>faultName</name></decl></parameter>)</parameter_list>
<block>{<block_content>	
	
	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>					<name>isRemoved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorEntry_s</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(
												  <argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>, 
												  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>faultName</name></expr></argument>, <comment type="line">// key</comment>
												  <argument><expr><name>HASH_REMOVE</name></expr></argument>, 
												  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>entry</name></expr>)</condition> 
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, 
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault removed, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
						<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>isRemoved</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<return>return <expr><name>isRemoved</name></expr>;</return>			
</block_content>}</block></function>

<comment type="block">/*
 *
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type> 
<name>FaultInjector_NewHashEntry</name><parameter_list>(
						   <parameter><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	
	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entryLocal</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>					<name>exists</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>status</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>numActiveFaults</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;=</operator> <name>FAULTINJECTOR_MAX_SLOTS</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert fault injection, no slots available"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name:'%s' fault type:'%s'"</literal></expr></argument>,
						   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						   <argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, 
				 <argument><expr><literal type="string">"could not insert fault injection, max slots:'%d' reached"</literal></expr></argument>,
				 <argument><expr><name>FAULTINJECTOR_MAX_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<goto>goto <name>exit</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>entryLocal</name> <operator>=</operator> <call><name>FaultInjector_InsertHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>exists</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
	<if_stmt><if>if <condition>(<expr><name>entryLocal</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert fault injection entry into table, no memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name:'%s' fault type:'%s'"</literal></expr></argument>,
						   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						   <argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, 
				 <argument><expr><literal type="string">"could not insert fault injection, no memory"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<goto>goto <name>exit</name>;</goto>
	</block_content>}</block></if></if_stmt>
		
	<if_stmt><if>if <condition>(<expr><name>exists</name></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot insert fault injection entry into table, entry already exists"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name:'%s' fault type:'%s' "</literal></expr></argument>,
						   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						   <argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, 
				 <argument><expr><literal type="string">"could not insert fault injection, entry already exists"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<goto>goto <name>exit</name>;</goto>
	</block_content>}</block></if></if_stmt>
		
	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>extraArg</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>extraArg</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>ddlStatement</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>ddlStatement</name></name></expr>;</expr_stmt>
	
	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>startOccurrence</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>startOccurrence</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>endOccurrence</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>endOccurrence</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>gpSessionid</name></name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>gpSessionid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>numTimesTriggered</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>databaseName</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>databaseName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>=</operator> <name>FaultInjectorStateWaiting</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>numActiveFaults</name></name><operator>++</operator></expr>;</expr_stmt>
		
	<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"FaultInjector_NewHashEntry(): '%s'"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
<label><name>exit</name>:</label>
		
	<return>return <expr><name>status</name></expr>;</return>			
</block_content>}</block></function>

<comment type="block">/*
 * update hash entry with state 
 */</comment>		
<function><type><specifier>static</specifier> <name>int</name></type> 
<name>FaultInjector_MarkEntryAsResume</name><parameter_list>(
							<parameter><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	
	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entryLocal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>status</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>==</operator> <name>FaultInjectorTypeResume</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entryLocal</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<if_stmt><if>if <condition>(<expr><name>entryLocal</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot update fault injection hash entry with fault injection status, no entry found"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name:'%s' fault type:'%s'"</literal></expr></argument>,
						   <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
						   <argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<goto>goto <name>exit</name>;</goto>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>!=</operator> <name>FaultInjectorTypeSuspend</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, 
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"only suspend fault can be resumed"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name> <operator>=</operator> <name>FaultInjectorTypeResume</name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LOG(fault injector): update fault injection hash entry identifier:'%s' state:'%s'"</literal></expr></argument>,
					<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
					<argument><expr><name><name>FaultInjectorStateEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorState</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
<label><name>exit</name>:</label>	
	
	<return>return <expr><name>status</name></expr>;</return>			
</block_content>}</block></function>

<comment type="block">/*
 * Inject fault according to its type.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>FaultInjector_SetFaultInjection</name><parameter_list>(
						   <parameter><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entry</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>		<name>status</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>	<name>isRemoved</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	
	<switch>switch <condition>(<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>)</condition> <block>{<block_content>
		<case>case <expr><name>FaultInjectorTypeReset</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type>			<name>hash_status</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entryLocal</name></decl>;</decl_stmt>
			
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>, <argument><expr><name>FaultInjectorNameAll</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_status</name></expr></argument>, <argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				
				<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				
				<while>while <condition>(<expr><operator>(</operator><name>entryLocal</name> <operator>=</operator> <operator>(</operator><name>FaultInjectorEntry_s</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name>isRemoved</name> <operator>=</operator> <call><name>FaultInjector_RemoveHashEntry</name><argument_list>(<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>isRemoved</name> <operator>==</operator> <name>true</name></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>numActiveFaults</name></name><operator>--</operator></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>					
				</block_content>}</block></while>
				<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>numActiveFaults</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>FiLockAcquire</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>isRemoved</name> <operator>=</operator> <call><name>FaultInjector_RemoveHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isRemoved</name> <operator>==</operator> <name>true</name></expr>)</condition> <block>{<block_content>
					<expr_stmt><expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>numActiveFaults</name></name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>FiLockRelease</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
				
			<if_stmt><if>if <condition>(<expr><name>isRemoved</name> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LOG(fault injector): could not remove fault injection from hash identifier:'%s'"</literal></expr></argument>,
								<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>FaultInjectorTypeWaitUntilTriggered</name></expr>:</case>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entryLocal</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type> <name>retry_count</name> <init>= <expr><literal type="number">3000</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* 10 minutes */</comment>

			<while>while <condition>(<expr><operator>(</operator><name>entryLocal</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
				   <name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorState</name></name> <operator>!=</operator> <name>FaultInjectorStateCompleted</name> <operator>&amp;&amp;</operator>
				   <name><name>entryLocal</name><operator>-&gt;</operator><name>numTimesTriggered</name></name> <operator>-</operator> <name><name>entryLocal</name><operator>-&gt;</operator><name>startOccurrence</name></name> <operator>&lt;</operator> <name><name>entry</name><operator>-&gt;</operator><name>extraArg</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">200000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>  <comment type="block">/* 0.2 sec */</comment>
				<expr_stmt><expr><name>retry_count</name><operator>--</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>retry_count</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault not triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
									<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
									<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Timed-out as 10 minutes max wait happens until triggered."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>entryLocal</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered %d times, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>numTimesTriggered</name></name></expr></argument>,
							<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_OK</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault not set, fault name:'%s'  "</literal></expr></argument>,
								<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		</block_content>}</block>

		<case>case <expr><name>FaultInjectorTypeStatus</name></expr>:</case>
		<block>{<block_content>	
			<decl_stmt><decl><type><name>FaultInjectorEntry_s</name>	<modifier>*</modifier></type><name>entryLocal</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>                     <name>length</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>faultInjectorShmem</name><operator>-&gt;</operator><name>hash</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"Success: "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>entryLocal</name> <operator>=</operator> <call><name>FaultInjector_LookupHashEntry</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>entryLocal</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(
					<argument><expr><operator>(</operator><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name> <operator>+</operator> <name>length</name><operator>)</operator></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <name>length</name></expr></argument>,
					<argument><expr><literal type="string">"fault name:'%s' "</literal>
					<literal type="string">"fault type:'%s' "</literal>
					<literal type="string">"ddl statement:'%s' "</literal>
					<literal type="string">"database name:'%s' "</literal>
					<literal type="string">"table name:'%s' "</literal>
					<literal type="string">"start occurrence:'%d' "</literal>
					<literal type="string">"end occurrence:'%d' "</literal>
					<literal type="string">"extra arg:'%d' "</literal>
					<literal type="string">"fault injection state:'%s'  "</literal>
					<literal type="string">"num times hit:'%d' \n"</literal></expr></argument>,
					<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
					<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>,
					<argument><expr><name><name>FaultInjectorDDLEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>ddlStatement</name></name></expr>]</index></name></expr></argument>,
					<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>databaseName</name></name></expr></argument>,
					<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>tableName</name></name></expr></argument>,
					<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>startOccurrence</name></name></expr></argument>,
					<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>endOccurrence</name></name></expr></argument>,
					<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>extraArg</name></name></expr></argument>,
					<argument><expr><name><name>FaultInjectorStateEnumToString</name><index>[<expr><name><name>entryLocal</name><operator>-&gt;</operator><name>faultInjectorState</name></name></expr>]</index></name></expr></argument>,
					<argument><expr><name><name>entryLocal</name><operator>-&gt;</operator><name>numTimesTriggered</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>,
								  <argument><expr><literal type="string">"Failure: fault name:'%s' not set"</literal></expr></argument>,
								  <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>length</name> <operator>&gt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"fault status truncated from %d to %zu characters"</literal></expr></argument>,
					 <argument><expr><name>length</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>bufOutput</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block>
		<case>case <expr><name>FaultInjectorTypeResume</name></expr>:</case>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, 
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FAULT_INJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault triggered, fault name:'%s' fault type:'%s' "</literal></expr></argument>,
							<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>faultName</name></name></expr></argument>,
							<argument><expr><name><name>FaultInjectorTypeEnumToString</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>faultInjectorType</name></name></expr>]</index></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>	
			
			<expr_stmt><expr><call><name>FaultInjector_MarkEntryAsResume</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<break>break;</break>
		</block_content>}</block>
		<default>default:</default> 
			
			<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>FaultInjector_NewHashEntry</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>status</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>HandleFaultMessage</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>msg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>name</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>type</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>ddl</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>db</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>table</name><index>[<expr><name>NAMEDATALEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>extra</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>sid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>msg</name></expr></argument>, <argument><expr><literal type="string">"faultname=%s type=%s ddl=%s db=%s table=%s "</literal>
			   <literal type="string">"start=%d end=%d extra=%d sid=%d"</literal></expr></argument>,
			   <argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>ddl</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>start</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>extra</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sid</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">9</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid fault message: %s"</literal></expr></argument>, <argument><expr><name>msg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* The value '#' means not specified. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ddl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>ddl</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>db</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>db</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'#'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>table</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>InjectFault</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>ddl</name></expr></argument>, <argument><expr><name>db</name></expr></argument>, <argument><expr><name>table</name></expr></argument>, <argument><expr><name>start</name></expr></argument>, <argument><expr><name>end</name></expr></argument>, <argument><expr><name>extra</name></expr></argument>, <argument><expr><name>sid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'T'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>Natts_fault_message_response</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"status"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* table oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>Anum_fault_message_response_status</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* attnum */</comment>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* type oid */</comment>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* typlen */</comment>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* typmod */</comment>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* format code */</comment>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send a DataRow message */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'D'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>Natts_fault_message_response</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* # of columns */</comment>

	<expr_stmt><expr><call><name>pq_sendint</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendbytes</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EndCommand</name><argument_list>(<argument><expr><name>GPCONN_TYPE_FAULT</name></expr></argument>, <argument><expr><name>DestRemote</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>InjectFault</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>faultName</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>type</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>ddlStatement</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>databaseName</name></decl></parameter>,
			<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>tableName</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>startOccurrence</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>endOccurrence</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>extraArg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>gpSessionid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type> <name>buf</name> <init>= <expr><call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FaultInjectorEntry_s</name></type> <name>faultEntry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"injecting fault: name %s, type %s, DDL %s, db %s, table %s, startOccurrence %d, endOccurrence %d, extraArg %d, sid %d"</literal></expr></argument>,
		 <argument><expr><name>faultName</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>ddlStatement</name></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>,
		 <argument><expr><name>startOccurrence</name></expr></argument>, <argument><expr><name>endOccurrence</name></expr></argument>, <argument><expr><name>extraArg</name></expr></argument>, <argument><expr><name>gpSessionid</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>=</operator> <call><name>FaultInjectorTypeStringToEnum</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>ddlStatement</name></name> <operator>=</operator> <call><name>FaultInjectorDDLStringToEnum</name><argument_list>(<argument><expr><name>ddlStatement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>extraArg</name></name> <operator>=</operator> <name>extraArg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>startOccurrence</name></name> <operator>=</operator> <name>startOccurrence</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>endOccurrence</name></name> <operator>=</operator> <name>endOccurrence</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>gpSessionid</name></name> <operator>=</operator> <name>gpSessionid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>faultEntry</name><operator>.</operator><name>numTimesTriggered</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Validations:
	 *
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>faultName</name></name></expr></argument>, <argument><expr><name>faultName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>faultName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>faultName</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"fault name too long: '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Fault name should be no more than %d characters."</literal></expr></argument>,
						   <argument><expr><name>FAULT_NAME_MAX_LENGTH</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>==</operator> <name>FaultInjectorTypeMax</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not recognize fault type '%s'"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Special fault name "all" is only used to reset all faults */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>!=</operator> <name>FaultInjectorTypeReset</name> <operator>&amp;&amp;</operator>
		<call><name>strcmp</name><argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>faultName</name></name></expr></argument>, <argument><expr><name>FaultInjectorNameAll</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid fault name '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>==</operator> <name>FaultInjectorTypeSleep</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>extraArg</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>extraArg</name></expr></argument> &gt;</argument_list></name> <literal type="number">7200</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid sleep time, allowed range [0, 7200 sec]"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>faultEntry</name><operator>.</operator><name>ddlStatement</name></name> <operator>==</operator> <name>DDLMax</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not recognize DDL statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>databaseName</name></name></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>databaseName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>databaseName</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"database name too long: '%s'"</literal></expr></argument>, <argument><expr><name>databaseName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Database name should be no more than %d characters."</literal></expr></argument>,
						   <argument><expr><name>NAMEDATALEN</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>tableName</name></name></expr></argument>, <argument><expr><name>tableName</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>tableName</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>&gt;=</operator>
		<sizeof>sizeof<argument_list>(<argument><expr><name><name>faultEntry</name><operator>.</operator><name>tableName</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"table name too long: '%s'"</literal></expr></argument>, <argument><expr><name>tableName</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Table name should be no more than %d characters."</literal></expr></argument>,
						   <argument><expr><name>NAMEDATALEN</name><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>startOccurrence</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">1</literal> <operator>||</operator> <name>startOccurrence</name></expr></argument> &gt;</argument_list></name> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid start occurrence number, allowed range [1, 1000]"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><name>endOccurrence</name> <operator>!=</operator> <name>INFINITE_END_OCCURRENCE</name> <operator>&amp;&amp;</operator> <name>endOccurrence</name> <operator>&lt;</operator> <name>startOccurrence</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_PROTOCOL_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid end occurrence number, allowed range [startOccurrence, ] or -1"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<comment type="block">/*
	 * Warnings:
	 *
	 */</comment>
	<expr_stmt><expr><call><name>emit_warnings</name><argument_list>(<argument><expr><name>faultEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<if_stmt><if>if <condition>(<expr><call><name>FaultInjector_SetFaultInjection</name><argument_list>(<argument><expr><operator>&amp;</operator><name>faultEntry</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>faultEntry</name><operator>.</operator><name>faultInjectorType</name></name> <operator>==</operator> <name>FaultInjectorTypeStatus</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>faultEntry</name><operator>.</operator><name>bufOutput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Success:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"injected fault '%s' type '%s'"</literal></expr></argument>, <argument><expr><name>faultName</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Failure: %s"</literal></expr></argument>, <argument><expr><name><name>faultEntry</name><operator>.</operator><name>bufOutput</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</unit>
