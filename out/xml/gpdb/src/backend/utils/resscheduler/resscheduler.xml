<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/resscheduler/resscheduler.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * resscheduler.c
 *	  POSTGRES resource scheduling management code.
 *
 *
 * Portions Copyright (c) 2006-2010, Greenplum inc.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	    src/backend/utils/resscheduler/resscheduler.c
 *
 *
-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/indexing.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resqueuecapability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbllize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/print.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/planner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"rewrite/rewriteHandler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/utility.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resource_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resscheduler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/metrics_utils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * GUC variables.
 */</comment>
<decl_stmt><decl><type><name>int</name></type> 	<name>gp_resqueue_memory_policy</name> <init>= <expr><name>RESMANAGER_MEMORY_POLICY_NONE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>gp_log_resqueue_memory</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>		<name>gp_resqueue_memory_policy_auto_fixed_mem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>	<name>gp_resqueue_print_operator_memory_limits</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>


<decl_stmt><decl><type><name>int</name></type>		<name>MaxResourceQueues</name></decl>;</decl_stmt>						<comment type="block">/* Max # of queues. */</comment>
<decl_stmt><decl><type><name>int</name></type>		<name>MaxResourcePortalsPerXact</name></decl>;</decl_stmt>				<comment type="block">/* Max # tracked portals -
												 * per backend . */</comment>
<decl_stmt><decl><type><name>bool</name></type>	<name>ResourceSelectOnly</name></decl>;</decl_stmt>						<comment type="block">/* Only lock SELECT/DECLARE? */</comment>
<decl_stmt><decl><type><name>bool</name></type>	<name>ResourceCleanupIdleGangs</name></decl>;</decl_stmt>				<comment type="block">/* Cleanup idle gangs? */</comment>


<comment type="block">/*
 * Global variables
 */</comment>
<decl_stmt><decl><type><name>ResSchedulerData</name>	<modifier>*</modifier></type><name>ResScheduler</name></decl>;</decl_stmt>	<comment type="block">/* Resource Scheduler (shared) data .*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>		<name>MyQueueId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* resource queue for current role. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type>		<name>MyQueueIdIsValid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt> <comment type="block">/* Is MyQueueId valid? */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>uint32</name></type>	<name>portalId</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* id of portal, for tracking cursors. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int32</name></type>	<name>numHoldPortals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* # of holdable cursors tracked. */</comment>

<comment type="block">/*
 * ResSchedulerShmemSize -- estimate size the scheduler structures will need in
 *	shared memory.
 *
 */</comment>
<function><type><name>Size</name></type>
<name>ResSchedulerShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* The hash of queues.*/</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>MaxResourceQueues</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResQueueData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The scheduler structure. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResSchedulerData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add a safety margin */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResPortalIncrementShmemSize -- Estimate the size of the increment hash.
 *
 * Notes
 *	We allow one extra slot for unnamed portals, as it is simpler to not
 *	count them at all.
 */</comment>
<function><type><name>Size</name></type> 
<name>ResPortalIncrementShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>Size</name></type>	<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>	<name>max_table_size</name> <init>= <expr><operator>(</operator><name>MaxResourcePortalsPerXact</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>MaxBackends</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>max_table_size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResPortalIncrement</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add a safety margin */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InitResScheduler -- initialize the scheduler queues hash in shared memory.
 *
 * The queuek hash table has no data in it as yet (InitResQueues cannot be 
 * called until catalog access is available.
 *
 */</comment>
<function><type><name>void</name></type>
<name>InitResScheduler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/* Create the scheduler structure. */</comment>
	<expr_stmt><expr><name>ResScheduler</name> <operator>=</operator> <operator>(</operator><name>ResSchedulerData</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Resource Scheduler Data"</literal></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResSchedulerData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Specify that we have no initialized queues yet. */</comment>
	<expr_stmt><expr><name><name>ResScheduler</name><operator>-&gt;</operator><name>num_queues</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>			<comment type="block">/* We are already initialized. */</comment>

	<comment type="block">/* Create the resource queue hash (empty at this point). */</comment>
	<expr_stmt><expr><name>found</name> <operator>=</operator> <call><name>ResQueueHashTableInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough shared memory for resource scheduler"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"initialized resource scheduler"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	

	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * InitResPortalIncrementHash - Initialize the portal increment hash.
 *
 * Notes:
 *	Simply calls the internal initialization function.
 */</comment>
<function><type><name>void</name></type>
<name>InitResPortalIncrementHash</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>	<name>result</name></decl>;</decl_stmt>


	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ResPortalIncrementHashTableInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"could not initialize portal increment hash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"initialized portal increment hash"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * InitResQueues -- initialize the resource queues in shared memory. Note this
 * can only be done after enough setup has been done. This uses
 * heap_open etc which in turn requires shared memory to be set up.
 */</comment>

<function><type><name>void</name></type> 
<name>InitResQueues</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>			<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>numQueues</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>queuesok</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>sscan</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ResScheduler</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block" format="doxygen">/**
	 * The resqueue shared mem initialization must be serialized. Only the first session
	 * should do the init.
	 * Serialization is done the ResQueueLock LW_EXCLUSIVE. However, we must obtain all DB
	 * lock before obtaining LWlock.
	 * So, we must have obtained ResQueueRelationId and ResQueueCapabilityRelationId lock
	 * first.
	 */</comment>
	<comment type="block">/* XXX XXX: should this be rowexclusive ? */</comment>
	<decl_stmt><decl><type><name>Relation</name></type> <name>relResqueue</name> <init>= <expr><call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>LockRelationOid</name><argument_list>(<argument><expr><name>ResQueueCapabilityRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ResScheduler</name><operator>-&gt;</operator><name>num_queues</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Hash table has already been loaded */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>ResQueueCapabilityRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relResqueue</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relResqueue</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_resqueue</name></type>	<name>queueform</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>					<name>queueid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>				<name>overcommit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>float4</name></type>				<name>ignorelimit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Cost</name></type>				<name><name>thresholds</name><index>[<expr><name>NUM_RES_LIMIT_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>				<modifier>*</modifier></type><name>queuename</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>numQueues</name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>queueform</name> <operator>=</operator> <operator>(</operator><name>Form_pg_resqueue</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>queueid</name> <operator>=</operator> <name><name>queueform</name><operator>-&gt;</operator><name>oid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>queuename</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>queueform</name><operator>-&gt;</operator><name>rsqname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name> <operator>=</operator> <name><name>queueform</name><operator>-&gt;</operator><name>rsqcountlimit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name> <operator>=</operator> <name><name>queueform</name><operator>-&gt;</operator><name>rsqcostlimit</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>thresholds</name><index>[<expr><name>RES_MEMORY_LIMIT</name></expr>]</index></name> <operator>=</operator> <call><name>ResourceQueueGetMemoryLimit</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>overcommit</name> <operator>=</operator> <name><name>queueform</name><operator>-&gt;</operator><name>rsqovercommit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ignorelimit</name> <operator>=</operator> <name><name>queueform</name><operator>-&gt;</operator><name>rsqignorecostlimit</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>queuesok</name> <operator>=</operator> <call><name>ResCreateQueue</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>, <argument><expr><name>thresholds</name></expr></argument>, <argument><expr><name>overcommit</name></expr></argument>, <argument><expr><name>ignorelimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queuesok</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block" format="doxygen">/** Break out of loop. Close relations, relinquish LWLock and then error out */</comment> 
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>UnlockRelationOid</name><argument_list>(<argument><expr><name>ResQueueCapabilityRelationId</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>relResqueue</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queuesok</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient resource queues available"</literal></expr></argument>)</argument_list></call><operator>,</operator>
		<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase max_resource_queues to %d."</literal></expr></argument>, <argument><expr><name>numQueues</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,<argument><expr><literal type="string">"initialized %d resource queues"</literal></expr></argument>, <argument><expr><name>numQueues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResCreateQueue -- initialize the elements for a resource queue.
 *
 * Notes:
 *	It is expected that the appropriate lightweight lock is held before
 *	calling this - unless we are the startup process.
 */</comment>
<function><type><name>bool</name></type>
<name>ResCreateQueue</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>queueid</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name><name>limits</name><index>[<expr><name>NUM_RES_LIMIT_TYPES</name></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>overcommit</name></decl></parameter>,
			   <parameter><decl><type><name>float4</name></type> <name>ignorelimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>ResQueue</name></type>		<name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* If the new queue pointer is NULL, then we are out of queues. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ResScheduler</name><operator>-&gt;</operator><name>num_queues</name></name> <operator>&gt;=</operator> <name>MaxResourceQueues</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * Has an entry for this 
	 */</comment>
	
	<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>ResQueueHashNew</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queue</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You may need to increase max_resource_queues."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<comment type="block">/* Set queue oid and offset in the scheduler array */</comment>
	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>queueid</name></name> <operator>=</operator> <name>queueid</name></expr>;</expr_stmt>

	<comment type="block">/* Set the number of limits 0 initially. */</comment>
	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>num_limits</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* Set overcommit.*/</comment>
	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>overcommit</name></name> <operator>=</operator> <name>overcommit</name></expr>;</expr_stmt>

	<comment type="block">/* Set ignore cost limit. */</comment>
	<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>ignorecostlimit</name></name> <operator>=</operator> <name>ignorelimit</name></expr>;</expr_stmt>

	<comment type="block">/* Now run through all the possible limit types.*/</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_RES_LIMIT_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Specific initializations for the limit types (the current two are
		 * in fact the same).
		 */</comment>
		<switch>switch <condition>(<expr><name>i</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RES_COUNT_LIMIT</name></expr>:</case>
			<case>case <expr><name>RES_COST_LIMIT</name></expr>:</case>
			<case>case <expr><name>RES_MEMORY_LIMIT</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>num_limits</name></name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name> <operator>=</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_is_max</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown resource limit type %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></switch>


	</block_content>}</block></for>
	<expr_stmt><expr><name><name>ResScheduler</name><operator>-&gt;</operator><name>num_queues</name></name><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResAlterQueue -- Change thresholds, overcommit for a resource queue.
 *
 * Notes:
 *	It is expected that the appropriate lightweight lock is held before
 *	calling this.
 */</comment>
<function><type><name>ResAlterQueueResult</name></type>
<name>ResAlterQueue</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>queueid</name></decl></parameter>, <parameter><decl><type><name>Cost</name></type> <name><name>limits</name><index>[<expr><name>NUM_RES_LIMIT_TYPES</name></expr>]</index></name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>overcommit</name></decl></parameter>,
			  <parameter><decl><type><name>float4</name></type> <name>ignorelimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>ResQueue</name></type>		<name>queue</name> <init>= <expr><call><name>ResQueueHashFind</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>result</name> <init>= <expr><name>ALTERQUEUE_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>
	

	<comment type="block">/* Handed an Oid for something other than a queue, bail out! */</comment>
	<if_stmt><if>if <condition>(<expr><name>queue</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>ALTERQUEUE_ERROR</name></expr>;</return></block_content></block></if></if_stmt>


	<comment type="block">/* 
	 * Now run through all the possible limit types, checking all the
	 * intended changes are ok.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_RES_LIMIT_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Don't sanity check thresholds if that are about to be disabled. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * MPP-4340:
		 * The goal of the resource queues is to allow us to throttle work
		 * onto the cluster: a key requirement is that given a queue we be able to
		 * change the limit values -- especially in a situation where we're already
		 * overloading the system, we'd like to be able to drop the queue limit.
		 *
		 * The original sanity checks here disallowed modifications which might
		 * reduce the threshold. To throttle the system for better performance,
		 * work had to get cancelled. That's an unacceptable limitation; so
		 * now we allow the queues to be changed.
		 *
		 * Overcommit is a much more serious type of change.
		 *
		 * For overcommitable limits we need to ensure the queue is not in 
		 * an overcommited state if we about to turn overcommit off.
		 */</comment>
		<switch>switch <condition>(<expr><name>i</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RES_COUNT_LIMIT</name></expr>:</case>
				<break>break;</break>

			<case>case <expr><name>RES_COST_LIMIT</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* 
				 * Don't turn overcommit off if queue could be overcommitted.
				 * We err on the side of caution in this case and demand that
				 * the queue is idle - we don't want to leave a query waiting 
				 * forever in the wait queue. We use the same roundoff limit
				 * value (0.1) as ResLockCheckLimit does.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>overcommit</name> <operator>&amp;&amp;</operator> <name><name>queue</name><operator>-&gt;</operator><name>overcommit</name></name> <operator>&amp;&amp;</operator> 
					<operator>(</operator><name><name>queue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>&gt;</operator> <literal type="number">0.1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>result</name> <operator>=</operator> <name>ALTERQUEUE_OVERCOMMITTED</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			
			<break>break;</break>
			
			<case>case <expr><name>RES_MEMORY_LIMIT</name></expr>:</case>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<comment type="block">/*
	 * If threshold and overcommit alterations are all ok, do the changes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>result</name> <operator>==</operator> <name>ALTERQUEUE_OK</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_RES_LIMIT_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/*
			 * Assign the new thresholds.
			 */</comment>
			<switch>switch <condition>(<expr><name>i</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RES_COUNT_LIMIT</name></expr>:</case>
				<case>case <expr><name>RES_COST_LIMIT</name></expr>:</case>
				<case>case <expr><name>RES_MEMORY_LIMIT</name></expr>:</case>
				<block>{<block_content>
					
					<if_stmt><if>if <condition>(<expr><name><name>queue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name> <operator>!=</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name> <operator>=</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			</block_content>}</block></switch>
	
		</block_content>}</block></for>

		<comment type="block">/* Set overcommit if that has changed. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>queue</name><operator>-&gt;</operator><name>overcommit</name></name> <operator>!=</operator> <name>overcommit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>overcommit</name></name> <operator>=</operator> <name>overcommit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Set ignore cost limit if that has changed. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>queue</name><operator>-&gt;</operator><name>ignorecostlimit</name></name> <operator>!=</operator> <name>ignorelimit</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>queue</name><operator>-&gt;</operator><name>ignorecostlimit</name></name> <operator>=</operator> <name>ignorelimit</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResDestroyQueue -- destroy a resource queue.
 *
 * Notes:
 *	It is expected that the appropriate lightweight lock is held before
 *	calling this.
 */</comment>
<function><type><name>bool</name></type>
<name>ResDestroyQueue</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>queueid</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>ResQueue</name></type>		<name>queue</name> <init>= <expr><call><name>ResQueueHashFind</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>allzero</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>
	

	<comment type="block">/* Handed an Oid for something other than a queue, bail out! */</comment>
	<if_stmt><if>if <condition>(<expr><name>queue</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>


	<comment type="block">/* 
	 * Now run through all the possible limit types, checking all the
	 * current counters are zero.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr> ;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_RES_LIMIT_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Specific checks for the limit types (the current two are
		 * in fact the same).
		 */</comment>
		<switch>switch <condition>(<expr><name>i</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RES_COUNT_LIMIT</name></expr>:</case>
			<case>case <expr><name>RES_COST_LIMIT</name></expr>:</case>
			<case>case <expr><name>RES_MEMORY_LIMIT</name></expr>:</case>
			<block>{<block_content>
				
				<if_stmt><if>if <condition>(<expr><name><name>queue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>allzero</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		</block_content>}</block></switch>


	</block_content>}</block></for>

	<comment type="block">/*
	 * No non-zero current values for the queue, are able to destroy it.
	 *
	 * Some care is needed, as this leaves the possibility of a connected
	 * user still using this queue via a ALTER ROLE ... RESOURCE QUEUE while
	 * he is connected. However this is no worse than being able to DROP a 
	 * ROLE that is corrently connected!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>allzero</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ResQueueHashRemove</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ResScheduler</name><operator>-&gt;</operator><name>num_queues</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
	
</block_content>}</block></function>

<comment type="block">/*
 * ResLockPortal -- get a resource lock for Portal execution.
 */</comment>
<function><type><name>void</name></type>
<name>ResLockPortal</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>QueryDesc</name> <modifier>*</modifier></type><name>qDesc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldReleaseLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* Release resource lock? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>takeLock</name></decl>;</decl_stmt>					<comment type="block">/* Take resource lock? */</comment>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>queueid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>lockResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResPortalIncrement</name></type>	<name>incData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>plan</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>qDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>qDesc</name><operator>-&gt;</operator><name>plannedstmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>qDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>planTree</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_QUEUE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>queueid</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>queueId</name></name></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Check we have a valid queue before going any further.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>queueid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>

		<comment type="block">/*
		 * Check the source tag to see if the original statement is suitable for
		 * locking. 
		 */</comment>
		<switch>switch <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>sourceTag</name></name></expr>)</condition>
		<block>{<block_content>

			<comment type="block">/*
			 * For INSERT/UPDATE/DELETE Skip if we have specified only SELECT,
			 * otherwise drop through to handle like a SELECT.
			 */</comment>
			<case>case <expr><name>T_InsertStmt</name></expr>:</case>
			<case>case <expr><name>T_DeleteStmt</name></expr>:</case>
			<case>case <expr><name>T_UpdateStmt</name></expr>:</case>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>ResourceSelectOnly</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>takeLock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>shouldReleaseLock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block>
			<comment type="block">/* fallthrough */</comment>


			<case>case <expr><name>T_SelectStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Setup the resource portal increments, ready to be added.
				 */</comment>
				<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>portalId</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsResManagerMemoryPolicyAuto</name><argument_list>()</argument_list></call> <operator>||</operator>
						   <call><name>IsResManagerMemoryPolicyEagerFree</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
					<decl_stmt><decl><type><name>uint64</name></type> <name>queryMemory</name> <init>= <expr><name><name>qDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryMemory</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>LogResManagerMemory</name><argument_list>()</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>GP_RESMANAGER_MEMORY_LOG_LEVEL</name></expr></argument>, <argument><expr><literal type="string">"query requested %.0fKB"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>queryMemory</name> <operator>/</operator> <literal type="number">1024.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>					
					
					<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_MEMORY_LIMIT</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <name>queryMemory</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else 
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_MEMORY_LIMIT</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>				
				</block_content>}</block></else></if_stmt>
				<expr_stmt><expr><name>takeLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>shouldReleaseLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	
			<comment type="block">/*
			 * We are declaring a cursor - do the same as T_SelectStmt, but
			 * need to additionally consider setting the isHold option.
			 */</comment>
			<case>case <expr><name>T_DeclareCursorStmt</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/*
				 * Setup the resource portal increments, ready to be added.
				 */</comment>
				<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>portalId</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>plan</name><operator>-&gt;</operator><name>total_cost</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>isHold</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_HOLD</name></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsResManagerMemoryPolicyAuto</name><argument_list>()</argument_list></call> <operator>||</operator>
						   <call><name>IsResManagerMemoryPolicyEagerFree</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					
					<decl_stmt><decl><type><name>uint64</name></type> <name>queryMemory</name> <init>= <expr><name><name>qDesc</name><operator>-&gt;</operator><name>plannedstmt</name><operator>-&gt;</operator><name>query_mem</name></name></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queryMemory</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>LogResManagerMemory</name><argument_list>()</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>NOTICE</name></expr></argument>, <argument><expr><literal type="string">"query requested %.0fKB"</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name>queryMemory</name> <operator>/</operator> <literal type="number">1024.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_MEMORY_LIMIT</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <name>queryMemory</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else 
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_MEMORY_LIMIT</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>				
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><name>takeLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>shouldReleaseLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	
			<comment type="block">/*
			 * We do not want to lock any of these query types.
			 */</comment>
			<default>default:</default>
			<block>{<block_content>
	
				<expr_stmt><expr><name>takeLock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>shouldReleaseLock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
	
		</block_content>}</block></switch>
	
		<comment type="block">/*
		 * Get the resource lock.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>takeLock</name></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RESLOCK_DEBUG</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"acquire resource lock for queue %u (portal %u)"</literal></expr></argument>, 
					<argument><expr><name>queueid</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><call><name>SET_LOCKTAG_RESOURCE_QUEUE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<expr_stmt><expr><name>lockResult</name> <operator>=</operator> <call><name>ResLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>incData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<block>{<block_content>
				<comment type="block">/* 
				 * We might have been waiting for a resource queue lock when we get 
				 * here. Calling ResLockRelease without calling ResLockWaitCancel will 
				 * cause the locallock to be cleaned up, but will leave the global
				 * variable lockAwaited still pointing to the locallock hash 
				 * entry.
				 */</comment>
				<expr_stmt><expr><call><name>ResLockWaitCancel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		

				<comment type="block">/* If we had acquired the resource queue lock, release it and clean up */</comment>	
				<expr_stmt><expr><call><name>ResLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
				<comment type="block">/* GPDB hook for collecting query info */</comment>
				<if_stmt><if>if <condition>(<expr><name>query_info_collect_hook</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call>(<modifier>*</modifier><name>query_info_collect_hook</name>)<argument_list>(<argument><expr><name>METRICS_QUERY_ERROR</name></expr></argument>, <argument><expr><name>qDesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queueId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name> <operator>=</operator> <name>INVALID_PORTALID</name></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* 
			 * See if query was too small to bother locking at all, i.e had
			 * cost smaller than the ignore cost threshold for the queue.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>lockResult</name> <operator>==</operator> <name>LOCKACQUIRE_NOT_AVAIL</name></expr>)</condition>
			<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RESLOCK_DEBUG</name></cpp:ifdef>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"cancel resource lock for queue %u (portal %u)"</literal></expr></argument>, 
						<argument><expr><name>queueid</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				<comment type="block">/* 
				 * Reset portalId and queueid for this portal so the queue
				 * and increment accounting tests continue to work properly.
				 */</comment>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queueId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name> <operator>=</operator> <name>INVALID_PORTALID</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>shouldReleaseLock</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Count holdable cursors (if we are locking this one) .*/</comment>
			<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_HOLD</name> <operator>&amp;&amp;</operator> <name>shouldReleaseLock</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>numHoldPortals</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		</block_content>}</block></if></if_stmt>

	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>hasResQueueLock</name></name> <operator>=</operator> <name>shouldReleaseLock</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* This function is a simple version of ResLockPortal, which is used specially
 * for utility statements; the main logic is same as ResLockPortal, but remove
 * some unnecessary lines and make some tiny adjustments for utility stmts */</comment>
<function><type><name>void</name></type>
<name>ResLockUtilityPortal</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>float4</name></type> <name>ignoreCostLimit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldReleaseLock</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>queueid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>lockResult</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResPortalIncrement</name></type>	<name>incData</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>queueid</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>queueId</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check we have a valid queue before going any further.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>queueid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Setup the resource portal increments, ready to be added.
		 */</comment>
		<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>portalId</name></name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name> <operator>=</operator> <name>ignoreCostLimit</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>incData</name><operator>.</operator><name>increments</name><index>[<expr><name>RES_MEMORY_LIMIT</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>Cost</name><operator>)</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>shouldReleaseLock</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get the resource lock.
		 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RESLOCK_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"acquire resource lock for queue %u (portal %u)"</literal></expr></argument>,
				<argument><expr><name>queueid</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>SET_LOCKTAG_RESOURCE_QUEUE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><name>lockResult</name> <operator>=</operator> <call><name>ResLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>incData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<comment type="block">/*
			 * We might have been waiting for a resource queue lock when we get
			 * here. Calling ResLockRelease without calling ResLockWaitCancel will
			 * cause the locallock to be cleaned up, but will leave the global
			 * variable lockAwaited still pointing to the locallock hash
			 * entry.
			 */</comment>
			<expr_stmt><expr><call><name>ResLockWaitCancel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* If we had acquired the resource queue lock, release it and clean up */</comment>
			<expr_stmt><expr><call><name>ResLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Clean up if we got cancelled while waiting.
			 */</comment>

			<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>queueId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name> <operator>=</operator> <name>INVALID_PORTALID</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>hasResQueueLock</name></name> <operator>=</operator> <name>shouldReleaseLock</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ResUnLockPortal -- release a resource lock for a portal.
 */</comment>
<function><type><name>void</name></type>
<name>ResUnLockPortal</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKTAG</name></type>					<name>tag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>						<name>queueid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>queueid</name> <operator>=</operator> <name><name>portal</name><operator>-&gt;</operator><name>queueId</name></name></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Check we have a valid queue before going any further.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>queueid</name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RESLOCK_DEBUG</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"release resource lock for queue %u (portal %u)"</literal></expr></argument>, 
			 <argument><expr><name>queueid</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>SET_LOCKTAG_RESOURCE_QUEUE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name>queueid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResLockRelease</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name><name>portal</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Count holdable cursors.*/</comment>
		<if_stmt><if>if <condition>(<expr><name><name>portal</name><operator>-&gt;</operator><name>cursorOptions</name></name> <operator>&amp;</operator> <name>CURSOR_OPT_HOLD</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numHoldPortals</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>numHoldPortals</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	
	<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>hasResQueueLock</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * GetResQueueForRole -- determine what resource queue a role is going to use.
 *
 * Notes
 *	This could be called for each of ResLockPortal and ResUnLockPortal, but we 
 *	can eliminate a relation open and lock if it is cached.
 */</comment>
<function><type><name>Oid</name></type>	
<name>GetResQueueForRole</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>roleid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>queueid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>roleid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tuple</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>DEFAULTRESQUEUE_OID</name></expr>;</return></block_content></block></if></if_stmt> <comment type="block">/* role not found */</comment>

	<expr_stmt><expr><name>queueid</name> <operator>=</operator> <call><name>SysCacheGetAttr</name><argument_list>(<argument><expr><name>AUTHOID</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>Anum_pg_authid_rolresqueue</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* MPP-6926: use default queue if none specified */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>queueid</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>queueid</name> <operator>=</operator> <name>DEFAULTRESQUEUE_OID</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>queueid</name></expr>;</return>
	
</block_content>}</block></function>


<comment type="block">/*
 * SetResQueueId -- set the cached value for the current resource queue.
 *
 * Notes
 *	Needs to be called at session initialization and after (or in) SET ROLE.
 */</comment>
<function><type><name>void</name></type>
<name>SetResQueueId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>MyQueueId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MyQueueIdIsValid</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * GetResQueueId -- return the current cached value for the resource queue.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetResQueueId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyQueueIdIsValid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * GPDB_94_MERGE_FIXME: cannot do catalog lookups, if we're not in a
		 * transaction. Just play dumb, then. Arguably, abort processing
		 * shouldn't be governed by resource queues, anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsTransactionState</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>MyQueueId</name> <operator>=</operator> <call><name>GetResQueueForRole</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>MyQueueIdIsValid</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>MyQueueId</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResQueueIdForName -- Return the Oid for a resource queue name
 *
 * Notes:
 *	Used by the various admin commands to convert a user supplied queue name
 *	to Oid.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetResQueueIdForName</name><parameter_list>(<parameter><decl><type><name>char</name>	<modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ScanKeyData</name></type> <name>scankey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type> <name>scan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>queueid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>heap_open</name><argument_list>(<argument><expr><name>ResQueueRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* SELECT oid FROM pg_resqueue WHERE rsqname = :1 */</comment>
	<expr_stmt><expr><call><name>ScanKeyInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>,
				<argument><expr><name>Anum_pg_resqueue_rsqname</name></expr></argument>,
				<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>, <argument><expr><name>F_NAMEEQ</name></expr></argument>,
				<argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>name</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>scan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>ResQueueRsqnameIndexId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>scankey</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>tuple</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>queueid</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_resqueue</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>queueid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_close</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>queueid</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResCreatePortalId -- return an id for a portal
 *
 * Notes
 * 	We return a new id for any named portal, but zero for an un-named one. 
 *	This is because we use the id to track cursors, and there can only be one
 *	un-named portal active.
 */</comment>
<function><type><name>uint32</name></type>
<name>ResCreatePortalId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>uint32</name></type>				<name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResPortalTag</name></type>		<name>portalTag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>				<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Unnamed portal. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>name</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>id</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return <expr><name>id</name></expr>;</return>
	</block_content>}</block></if></if_stmt>


	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * Named portal.
	 * Search for a id we can re-use from a closed portal - we want to do this
	 * so we can have MaxResourcePortalsPerXact *open* tracked (named) portals 
	 * in a transaction.
	 */</comment>
	<for>for <control>(<init><expr><name>id</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>id</name> <operator>&lt;=</operator> <name>portalId</name></expr>;</condition> <incr><expr><name>id</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResPortalTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>portalId</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ResIncrementFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
	
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * No re-usable portal ids, check we have not exhaused the # of trackable
	 * portals and return the next id.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>portalId</name> <operator>&gt;=</operator> <name>MaxResourcePortalsPerXact</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient portal ids available"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase max_resource_portals_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>id</name> <operator>=</operator> <operator>(</operator><operator>++</operator><name>portalId</name><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>id</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * AtCommit_ResScheduler -- do any pre-commit processing for Resource 
 *	Scheduling.
 */</comment>
<function><type><name>void</name></type>
<name>AtCommit_ResScheduler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

	<comment type="block">/* reset the portal id. */</comment>
	<if_stmt><if>if <condition>(<expr><name>numHoldPortals</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>portalId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * AtAbort_ResScheduler -- do any abort processing for Resource 
 *	Scheduling.
 */</comment>
<function><type><name>void</name></type>
<name>AtAbort_ResScheduler</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

	<comment type="block">/* reset the portal id. */</comment>
	<if_stmt><if>if <condition>(<expr><name>numHoldPortals</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>portalId</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* This routine checks whether specified utility stmt should be involved into
 * resource queue mgmt; if yes, take the slot from the resource queue; if we
 * want to track additional utility stmts, add it into the condition check */</comment>
<function><type><name>void</name></type>
<name>ResHandleUtilityStmt</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CopyStmt</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name>CreateTableAsStmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name>
		<operator>&amp;&amp;</operator> <call><name>IsResQueueEnabled</name><argument_list>()</argument_list></call>
		<operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>ResourceSelectOnly</name><operator>)</operator>
		<operator>&amp;&amp;</operator> <operator>!</operator><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>ResQueue</name></type> <name>resQueue</name> <init>= <expr><call><name>ResQueueHashFind</name><argument_list>(<argument><expr><name><name>portal</name><operator>-&gt;</operator><name>queueId</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>numSlots</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>resQueue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>numSlots</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition> <comment type="block">/* statement limit exists */</comment>
		<block>{<block_content>
			<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_QUEUE</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>ResLockUtilityPortal</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name><name>resQueue</name><operator>-&gt;</operator><name>ignorecostlimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>portal</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>PORTAL_ACTIVE</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

</unit>
