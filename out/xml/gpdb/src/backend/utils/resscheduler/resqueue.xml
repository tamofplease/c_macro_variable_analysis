<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/resscheduler/resqueue.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * resqueue.c
 *	  POSTGRES internals code for resource queues and locks.
 *
 *
 * Portions Copyright (c) 2006-2008, Greenplum inc.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2008, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	    src/backend/utils/resscheduler/resqueue.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase_rmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resourcetype.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resqueue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc_tables.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/portal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resource_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resscheduler.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/queue.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResCleanUpLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wakeupNeeded</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>ResPortalIncrement</name> <modifier>*</modifier></type><name>ResIncrementAdd</name><parameter_list>(<parameter><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incSet</name></decl></parameter>,
										   <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>,
										   <parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>,
										   <parameter><decl><type><name>ResIncrementAddStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ResIncrementRemove</name><parameter_list>(<parameter><decl><type><name>ResPortalTag</name> <modifier>*</modifier></type><name>portaltag</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResWaitOnLock</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResLockUpdateLimit</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>, <parameter><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>increment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inError</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ResGrantLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ResUnGrantLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>uint64</name></type> <name>ResourceQueueGetSuperuserQueryMemoryLimit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<comment type="block">/*
 * Global Variables
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ResPortalIncrementHash</name></decl>;</decl_stmt>	<comment type="block">/* Hash of resource increments. */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ResQueueHash</name></decl>;</decl_stmt>		<comment type="block">/* Hash of resource queues. */</comment>


<comment type="block">/*
 * Record structure holding the to be exposed per queue data, used by
 * pg_resqueue_status().
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>queueid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>queuecountthreshold</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>queuecostthreshold</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>queuememthreshold</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>queuecountvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>queuecostvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>queuememvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queuewaiters</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queueholders</name></decl>;</decl_stmt>
}</block></struct></type>	<name>QueueStatusRec</name>;</typedef>


<comment type="block">/*
 * Function context for data persisting over repeated calls, used by
 * pg_resqueue_status().
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>QueueStatusRec</name> <modifier>*</modifier></type><name>record</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numRecords</name></decl>;</decl_stmt>

}</block></struct></type>	<name>QueueStatusContext</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>BuildQueueStatusContext</name><parameter_list>(<parameter><decl><type><name>QueueStatusContext</name> <modifier>*</modifier></type><name>fctx</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * ResLockAcquire -- acquire a resource lock.
 *
 * Notes and critisms:
 *
 *	Returns LOCKACQUIRE_OK if we get the lock,
 *			LOCKACQUIRE_NOT_AVAIL if we don't want to take the lock after all.
 *
 *	Analogous to LockAcquire, but the lockmode and session boolean are not
 *	required in the function prototype as we are *always* lockmode ExclusiveLock
 *	and have no session locks.
 *
 *	The semantics of resource locks mean that lockmode has minimal meaning -
 *	the conflict rules are determined by the state of the counters of the
 *	corresponding queue. We are maintaining the lock lockmode and related
 *	elements (holdmask etc), in order to ease comparison with standard locks
 *	at deadlock check time (well, so we hope anyway.)
 *
 * The "locktag" here consists of the queue-id and the "lockmethod" of
 * "resource-queue" and an identifier specifying that this is a
 * resource-locktag.
 *
 */</comment>
<function><type><name>LockAcquireResult</name></type>
<name>ResLockAcquire</name><parameter_list>(<parameter><decl><type><name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>ExclusiveLock</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCKTAG</name></type> <name>proclocktag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCKTAG</name></type> <name>localtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>proclock_hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>partition</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLockId</name></type>	<name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResQueue</name></type>	<name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResIncrementAddStatus</name></type> <name>addStatus</name></decl>;</decl_stmt>

	<comment type="block">/* Setup the lock method bits. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name> <operator>==</operator> <name>RESOURCE_LOCKMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Provide a resource owner. */</comment>
	<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find or create a LOCALLOCK entry for this lock and lockmode
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localtag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localtag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* must clear padding */</comment>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>lock</name></name> <operator>=</operator> <operator>*</operator><name>locktag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>LockMethodLocalHash</name></expr></argument>,
										  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localtag</name></expr></argument>,
										  <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if it's a new locallock object, initialize it, if it already exists
	 * then that is enough for the resource locks.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>localtag</name><operator>.</operator><name>lock</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>istemptable</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>numLockOwners</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>maxLockOwners</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>holdsStrongLockCount</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockCleared</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lockOwners</name></name> <operator>=</operator> <operator>(</operator><name>LOCALLOCKOWNER</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><name><name>locallock</name><operator>-&gt;</operator><name>maxLockOwners</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LOCALLOCKOWNER</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We are going to examine the shared lock table. */</comment>
	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partition</name> <operator>=</operator> <call><name>LockHashPartition</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find or create a lock with this tag.
	 */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>locktag</name></expr></argument>,
												<argument><expr><name>hashcode</name></expr></argument>,
												<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>lock</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You may need to increase max_resource_queues."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * if it's a new lock object, initialize it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>waitMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ProcQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_LOCKMODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MAX_LOCKMODES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Create the hash key for the proclock table.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proclocktag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>PROCLOCKTAG</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* Clear padding. */</comment>
	<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myLock</name></name> <operator>=</operator> <name>lock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proclocktag</name><operator>.</operator><name>myProc</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>proclock_hashcode</name> <operator>=</operator> <call><name>ProcLockHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proclocktag</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find or create a proclock entry with this tag.
	 */</comment>
	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <operator>(</operator><name>PROCLOCK</name> <operator>*</operator><operator>)</operator> <call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>,
														<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>proclocktag</name></expr></argument>,
														<argument><expr><name>proclock_hashcode</name></expr></argument>,
														<argument><expr><name>HASH_ENTER_NULL</name></expr></argument>,
														<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name> <operator>=</operator> <name>proclock</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proclock</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Not enough shmem for the proclock. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * There are no other requestors of this lock, so garbage-collect
			 * the lock object.  We *must* do this to avoid a permanent leak
			 * of shared memory, because there won't be anything to cause
			 * anyone to release the lock object later.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>,
											 <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>,
											 <argument><expr><name>hashcode</name></expr></argument>,
											 <argument><expr><name>HASH_REMOVE</name></expr></argument>,
											 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"lock table corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You may need to increase max_resource_queues."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If new, initialize the new entry.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Resource queues don't participate in "group locking", used to share
		 * locks between leader process and parallel worker processes in
		 * PostgreSQL. But we better still set 'groupLeader', it is assumed
		 * to be valid on all PROCLOCKs, and is accessed e.g. by
		 * GetLockStatusData().
		 */</comment>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>groupLeader</name></name> <operator>=</operator> <ternary><condition><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
			<expr><name><name>MyProc</name><operator>-&gt;</operator><name>lockGroupLeader</name></name></expr> </then><else>: <expr><name>MyProc</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>releaseMask</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<comment type="block">/* Add proclock to appropriate lists */</comment>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>MyProc</name><operator>-&gt;</operator><name>myProcLocks</name><index>[<expr><name>partition</name></expr>]</index></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SHMQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>portalLinks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <operator>~</operator><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Could do a deadlock risk check here. */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * lock-&gt;nRequested and lock-&gt;requested[] count the total number of
	 * requests, whether granted or waiting, so increment those immediately.
	 * The other counts don't increment till we get the lock.
	 */</comment>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up existing queue */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>GetResQueueFromLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/*
		 * Something wrong happened - our RQ is gone. Release all locks and
		 * clean out
		 */</comment>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockReleaseAll</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the query cost is smaller than the ignore cost limit for this queue
	 * then don't try to take a lock at all.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name> <operator>&lt;</operator> <name><name>queue</name><operator>-&gt;</operator><name>ignorecostlimit</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Decrement requested. */</comment>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Clean up the locallock. Since a single locallock can represent
		 * multiple locked portals in the same backend, we can only remove it if
		 * this is the last portal.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ResCleanUpLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * To avoid queue accounting problems, we will need to reset the
		 * queueId and portalId for this portal *after* returning from here.
		 */</comment>
		<return>return <expr><name>LOCKACQUIRE_NOT_AVAIL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we are going to take a lock, Add an increment to the
	 * increment hash for this process.
	 */</comment>
	<expr_stmt><expr><name>incrementSet</name> <operator>=</operator> <call><name>ResIncrementAdd</name><argument_list>(<argument><expr><name>incrementSet</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>addStatus</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>addStatus</name> <operator>!=</operator> <name>RES_INCREMENT_ADD_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have failed to add the increment. So decrement the requested
		 * counters, relinquish locks and raise the appropriate error.
		 */</comment>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>addStatus</name> <operator>==</operator> <name>RES_INCREMENT_ADD_OOSM</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of shared memory adding portal increments"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"You may need to increase max_resource_portals_per_transaction."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"duplicate portal id %u for proc %d"</literal></expr></argument>,
							   <argument><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>, <argument><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check if the lock can be acquired (i.e. if the resource the lock and
	 * queue control is not exhausted).
	 */</comment>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ResLockCheckLimit</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>incrementSet</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>STATUS_ERROR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The requested lock has individual increments that are larger than
		 * some of the thresholds for the corrosponding queue, and overcommit
		 * is not enabled for them. So abort and clean up.
		 */</comment>
		<decl_stmt><decl><type><name>ResPortalTag</name></type> <name>portalTag</name></decl>;</decl_stmt>

		<comment type="block">/* Adjust the counters as we no longer want this lock. */</comment>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Clean up the locallock. Since a single locallock can represent
		 * multiple locked portals in the same backend, we can only remove it if
		 * this is the last portal.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>ResCleanUpLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Kill off the increment. */</comment>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResPortalTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>portalId</name></name> <operator>=</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>portalId</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResIncrementRemove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"statement requires more resources than resource queue allows"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>status</name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The requested lock will *not* exhaust the limit for this resource
		 * queue, so record this in the local lock hash, and grant it.
		 */</comment>
		<expr_stmt><expr><call><name>ResGrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResLockUpdateLimit</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>incrementSet</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Note the start time for queue statistics. */</comment>
		<expr_stmt><expr><call><name>pgstat_record_start_queue_exec</name><argument_list>(<argument><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>,
									   <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>status</name> <operator>==</operator> <name>STATUS_FOUND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The requested lock will exhaust the limit for this resource queue,
		 * so must wait.
		 */</comment>

		<comment type="block">/* Set bitmask of locks this process already holds on this object. */</comment>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>heldLocks</name></name> <operator>=</operator> <name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name></expr>;</expr_stmt> <comment type="block">/* Do we need to do this? */</comment>

		<comment type="block">/*
		 * Set the portal id so we can identify what increments we are wanting
		 * to apply at wakeup.
		 */</comment>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitPortalId</name></name> <operator>=</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>portalId</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Note count and wait time for queue statistics. */</comment>
		<expr_stmt><expr><call><name>pgstat_count_queue_wait</name><argument_list>(<argument><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>,
								<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_record_start_queue_wait</name><argument_list>(<argument><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>,
									   <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Sleep till someone wakes me up.
		 */</comment>
		<expr_stmt><expr><call><name>ResWaitOnLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>owner</name></expr></argument>, <argument><expr><name>incrementSet</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Have been awakened, check state is consistent.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"ResLockAcquire failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Reset the portal id. */</comment>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>waitPortalId</name></name> <operator>=</operator> <name>INVALID_PORTALID</name></expr>;</expr_stmt>

		<comment type="block">/* End wait time and start execute time statistics for this queue. */</comment>
		<expr_stmt><expr><call><name>pgstat_record_end_queue_wait</name><argument_list>(<argument><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>,
									 <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_record_start_queue_exec</name><argument_list>(<argument><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>portalId</name></name></expr></argument>,
									   <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Release the	partition lock. */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>LOCKACQUIRE_OK</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ResLockRelease -- release a resource lock.
 *
 * The "locktag" here consists of the queue-id and the "lockmethod" of
 * "resource-queue" and an identifier specifying that this is a
 * resource-locktag.
 */</comment>
<function><type><name>bool</name></type>
<name>ResLockRelease</name><parameter_list>(<parameter><decl><type><name>LOCKTAG</name> <modifier>*</modifier></type><name>locktag</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>resPortalId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>ExclusiveLock</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCKTAG</name></type> <name>localtag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCALLOCK</name>  <modifier>*</modifier></type><name>locallock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLockId</name></type>	<name>partitionLock</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResPortalTag</name></type> <name>portalTag</name></decl>;</decl_stmt>

	<comment type="block">/* Check the lock method bits. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_lockmethodid</name></name> <operator>==</operator> <name>RESOURCE_LOCKMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Provide a resource owner. */</comment>
	<expr_stmt><expr><name>owner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Find the LOCALLOCK entry for this lock and lockmode
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>localtag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>localtag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* must clear padding */</comment>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>lock</name></name> <operator>=</operator> <operator>*</operator><name>locktag</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localtag</name><operator>.</operator><name>mode</name></name> <operator>=</operator> <name>lockmode</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>locallock</name> <operator>=</operator> <operator>(</operator><name>LOCALLOCK</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>LockMethodLocalHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>localtag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the lock request did not get very far, cleanup is easy.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>locallock</name> <operator>||</operator>
		<operator>!</operator><name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name> <operator>||</operator>
		<operator>!</operator><name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Resource queue %d: no lock to release"</literal></expr></argument>, <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>locallock</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr>;</expr_stmt>

	<comment type="block">/* We are going to examine the shared lock table. */</comment>
	<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Verify that our LOCALLOCK still matches the shared tables.
	 *
	 * While waiting for the lock, our request could have been canceled to
	 * resolve a deadlock.  It could already have been removed from the shared
	 * LOCK and PROCLOCK tables, and those entries could have been reallocated
	 * for some other request.  Then all we need to do is clean up the
	 * LOCALLOCK entry.
	 */</comment>
	<expr_stmt><expr><name>lock</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>lock</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>proclock</name> <operator>=</operator> <name><name>locallock</name><operator>-&gt;</operator><name>proclock</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name></name> <operator>!=</operator> <name>lock</name> <operator>||</operator>
		<name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myProc</name></name> <operator>!=</operator> <name>MyProc</name> <operator>||</operator>
		<call><name>memcmp</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>locallock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>lock</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Resource queue %d: lock already gone"</literal></expr></argument>, <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Double-check that we are actually holding a lock of the type we want to
	 * Release.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator> <name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Resource queue %d: proclock not held"</literal></expr></argument>, <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ResCleanUpLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find the increment for this portal and process.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResPortalTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>portalId</name></name> <operator>=</operator> <name>resPortalId</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>incrementSet</name> <operator>=</operator> <call><name>ResIncrementFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>incrementSet</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Resource queue %d: increment not found on unlock"</literal></expr></argument>, <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Clean up the locallock. Since a single locallock can represent
		 * multiple locked portals in the same backend, we can only remove it if
		 * this is the last portal.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ResCleanUpLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Un-grant the lock.
	 */</comment>
	<expr_stmt><expr><call><name>ResUnGrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResLockUpdateLimit</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>incrementSet</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Perform clean-up, waking up any waiters!
	 *
	 * Clean up the locallock. Since a single locallock can represent
	 * multiple locked portals in the same backend, we can only remove it if
	 * this is the last portal.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>RemoveLocalLock</name><argument_list>(<argument><expr><name>locallock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ResCleanUpLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Clean up the increment set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ResIncrementRemove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no increment to remove for portal id %u and pid %d"</literal></expr></argument>, <argument><expr><name>resPortalId</name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* not reached */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update execute statistics for this queue, count and elapsed time. */</comment>
	<expr_stmt><expr><call><name>pgstat_count_queue_exec</name><argument_list>(<argument><expr><name>resPortalId</name></expr></argument>, <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pgstat_record_end_queue_exec</name><argument_list>(<argument><expr><name>resPortalId</name></expr></argument>, <argument><expr><name><name>locktag</name><operator>-&gt;</operator><name>locktag_field1</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>IsResQueueLockedForPortal</name><parameter_list>(<parameter><decl><type><name>Portal</name></type> <name>portal</name></decl></parameter>)</parameter_list> <block>{<block_content>
	<return>return <expr><name><name>portal</name><operator>-&gt;</operator><name>hasResQueueLock</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResLockCheckLimit -- test whether the given process acquiring the this lock
 *	will cause a resource to exceed its limits.
 *
 * Notes:
 *	Returns STATUS_FOUND if limit will be exhausted, STATUS_OK if not.
 *
 *	If increment is true, then the resource counter associated with the lock
 *	is to be incremented, if false then decremented.
 *
 *	Named similarly to the LockCheckconflicts() for standard locks, but it is
 *	not checking a table of lock mode conflicts, but whether a shared counter
 *	for some resource is exhausted.
 *
 *	The resource queue lightweight lock (ResQueueLock) must be held while
 *	this function is called.
 *
 * MPP-4340: modified logic so that we return STATUS_OK when
 * decrementing resource -- decrements shouldn't care, let's not stop
 * them from freeing resources!
 */</comment>
<function><type><name>int</name></type>
<name>ResLockCheckLimit</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>, <parameter><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>increment</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResQueue</name></type>	<name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResLimit</name></type>	<name>limits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>over_limit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>will_overcommit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>status</name> <init>= <expr><name>STATUS_OK</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>increment_amt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the queue for this lock. */</comment>
	<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>GetResQueueFromLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>limits</name> <operator>=</operator> <name><name>queue</name><operator>-&gt;</operator><name>limits</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_RES_LIMIT_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Skip the default threshold, as it means 'no limit'.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RES_COUNT_LIMIT</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_is_max</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Setup whether to increment or decrement the # active. */</comment>
					<if_stmt><if>if <condition>(<expr><name>increment</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>increment_amt</name> <operator>=</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>+</operator> <name>increment_amt</name> <operator>&gt;</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>over_limit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>increment_amt</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>*</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RESLOCK_DEBUG</name></cpp:ifdef>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"checking count limit threshold %.0f current %.0f"</literal></expr></argument>,
						 <argument><expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr></argument>, <argument><expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>RES_COST_LIMIT</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_is_max</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Setup whether to increment or decrement the cost. */</comment>
					<if_stmt><if>if <condition>(<expr><name>increment</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>increment_amt</name> <operator>=</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

						<comment type="block">/* Check if this will overcommit */</comment>
						<if_stmt><if>if <condition>(<expr><name>increment_amt</name> <operator>&gt;</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>will_overcommit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>queue</name><operator>-&gt;</operator><name>overcommit</name></name></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * Autocommit is enabled, allow statements that
							 * blowout the limit if noone else is active!
							 */</comment>
							<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>+</operator> <name>increment_amt</name> <operator>&gt;</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name><operator>)</operator> <operator>&amp;&amp;</operator>
								<operator>(</operator><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>&gt;</operator> <literal type="number">0.1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>over_limit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<comment type="block">/*
							 * No autocommit, so always fail statements that
							 * blowout the limit.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>+</operator> <name>increment_amt</name> <operator>&gt;</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><name>over_limit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>increment_amt</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>*</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RESLOCK_DEBUG</name></cpp:ifdef>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"checking cost limit threshold %.2f current %.2f"</literal></expr></argument>,
						 <argument><expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr></argument>, <argument><expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>RES_MEMORY_LIMIT</name></expr>:</case>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_is_max</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Setup whether to increment or decrement the # active. */</comment>
					<if_stmt><if>if <condition>(<expr><name>increment</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>increment_amt</name> <operator>=</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>+</operator> <name>increment_amt</name> <operator>&gt;</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>over_limit</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>increment_amt</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>*</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RESLOCK_DEBUG</name></cpp:ifdef>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"checking memory limit threshold %.0f current %.0f"</literal></expr></argument>,
						 <argument><expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr></argument>, <argument><expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
				</block_content>}</block>
				<break>break;</break>

			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>will_overcommit</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>queue</name><operator>-&gt;</operator><name>overcommit</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>over_limit</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>STATUS_FOUND</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>status</name></expr>;</return>

</block_content>}</block></function>


<comment type="block">/*
 * ResLockUpdateLimit -- update the resource counter for this lock with the
 *	increment for the process.
 *
 * Notes:
 *	If increment is true, then the resource counter associated with the lock
 *	is to be incremented, if false then decremented.
 *
 * Warnings:
 *	The resource queue lightweight lock (ResQueueLock) must be held while
 *	this function is called.
 */</comment>
<function><type><name>void</name></type>
<name>ResLockUpdateLimit</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>, <parameter><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>increment</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>inError</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResQueue</name></type>	<name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResLimit</name></type>	<name>limits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>increment_amt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the queue for this lock. */</comment>
	<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>GetResQueueFromLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>limits</name> <operator>=</operator> <name><name>queue</name><operator>-&gt;</operator><name>limits</name></name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_RES_LIMIT_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * MPP-8454: NOTE that if our resource-queue has been modified since
		 * we locked our resources, on unlock it is possible that we're
		 * deducting an increment that we never added -- the lowest value we
		 * should allow is 0.0.
		 *
		 */</comment>
		<switch>switch <condition>(<expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RES_COUNT_LIMIT</name></expr>:</case>
			<case>case <expr><name>RES_COST_LIMIT</name></expr>:</case>
			<case>case <expr><name>RES_MEMORY_LIMIT</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Cost</name></type>		<name>new_value</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_is_max</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* setup whether to increment or decrement the # active. */</comment>
					<if_stmt><if>if <condition>(<expr><name>increment</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>increment_amt</name> <operator>=</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>increment_amt</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>*</operator> <name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

					<expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>+</operator> <name>increment_amt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>new_value</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>new_value</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<expr_stmt><expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current_value</name> <operator>=</operator> <name>new_value</name></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>

			<default>default:</default>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetResQueueFromLock -- find the resource queue for a given lock;
 *
 * Notes:
 *	should be handed a locktag containing a valid queue id.
 *	should hold the resource queue lightweight lock during this operation
 */</comment>
<function><type><name>ResQueue</name></type>
<name>GetResQueueFromLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ResQueue</name></type>	<name>queue</name> <init>= <expr><call><name>ResQueueHashFind</name><argument_list>(<argument><expr><call><name>GET_RESOURCE_QUEUEID_FOR_LOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>queue</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot find queue id %d"</literal></expr></argument>, <argument><expr><call><name>GET_RESOURCE_QUEUEID_FOR_LOCK</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>queue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ResGrantLock -- grant a resource lock.
 *
 * Warnings:
 *	It is expected that the partition lock is held before calling this
 *	function, as the various shared queue counts are inspected.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResGrantLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>ExclusiveLock</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Update the standard lock stuff, for locks and proclocks. */</comment>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name> <operator>|=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>==</operator> <name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>waitMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>		<comment type="block">/* no more waiters. */</comment>

	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>|=</operator> <call><name>LOCKBIT_ON</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the holders count. */</comment>
	<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ResUnGrantLock --  opposite of ResGrantLock.
 *
 * Notes:
 *	The equivalant standard lock function returns true only if there are waiters,
 *	we don't do this.
 *
 * Warnings:
 *	It is expected that the partition lock held before calling this
 *	function, as the various shared queue counts are inspected.
 */</comment>
<function><type><name>bool</name></type>
<name>ResUnGrantLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name>ExclusiveLock</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name> <operator>&lt;=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update the standard lock stuff. */</comment>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* change the conflict mask.  No more of this lock type. */</comment>
		<expr_stmt><expr><name><name>lock</name><operator>-&gt;</operator><name>grantMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Update the holders count. */</comment>
	<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* Fix the per-proclock state. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResCleanUpLock -- lock cleanup, remove entry from lock queues and start
 *	waking up waiters.
 *
 * MPP-6055/MPP-6144: we get called more than once; if we've already cleaned
 * up, don't walk off the end of lists; or panic when we can't find our hashtable
 * entries.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResCleanUpLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>wakeupNeeded</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This check should really be an assertion. But to guard against edge cases
	 * previously not encountered, PANIC instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name> <operator>!=</operator> <name>LOCKTAG_RESOURCE_QUEUE</name> <operator>||</operator>
		<name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name> <operator>!=</operator> <name>LOCKTAG_RESOURCE_QUEUE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"We are trying to clean up a non-resource queue lock"</literal></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"lock's locktag type = %d and proclock's locktag type = %d"</literal></expr></argument>,
						  <argument><expr><name><name>lock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name></expr></argument>,
						  <argument><expr><name><name>proclock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>myLock</name><operator>-&gt;</operator><name>tag</name><operator>.</operator><name>locktag_type</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this was my last hold on this lock, delete my entry in the proclock
	 * table.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>holdMask</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>proclock</name><operator>-&gt;</operator><name>nLocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>proclock_hashcode</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>lockLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>procLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>proclock_hashcode</name> <operator>=</operator> <call><name>ProcLockHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>tag</name></name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodProcLockHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>proclock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>,
									<argument><expr><name>proclock_hashcode</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The caller just released the last lock, so garbage-collect the lock
		 * object.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>SHMQueueEmpty</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>procLocks</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>hash_search</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If appropriate, awaken any waiters.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>wakeupNeeded</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ResProcLockRemoveSelfAndWakeup</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * WaitOnResLock -- wait to acquire a resource lock.
 *
 *
 * Warnings:
 *	It is expected that the partition lock is held before calling this
 *	function, as the various shared queue counts are inspected.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ResWaitOnLock</name><parameter_list>(<parameter><decl><type><name>LOCALLOCK</name> <modifier>*</modifier></type><name>locallock</name></decl></parameter>, <parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>, <parameter><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name> <init>= <expr><name><name>locallock</name><operator>-&gt;</operator><name>hashcode</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLockId</name></type>	<name>partitionLock</name> <init>= <expr><call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>new_status</name><index>[<expr><literal type="number">160</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* Report change to waiting status */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We should avoid using palloc() here */</comment>
		<expr_stmt><expr><name>old_status</name> <operator>=</operator> <call><name>get_real_act_ps_display</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">9</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%.*s queuing"</literal></expr></argument>,
				 <argument><expr><name>len</name></expr></argument>, <argument><expr><name>old_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Truncate off " queuing" */</comment>
		<expr_stmt><expr><name><name>new_status</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>awaitedLock</name> <operator>=</operator> <name>locallock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>awaitedOwner</name> <operator>=</operator> <name>owner</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now sleep.
	 *
	 * NOTE: self-deadlocks will throw (do a non-local return).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ResProcSleep</name><argument_list>(<argument><expr><name>ExclusiveLock</name></expr></argument>, <argument><expr><name>locallock</name></expr></argument>, <argument><expr><name>incrementSet</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>STATUS_OK</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We failed as a result of a deadlock, see CheckDeadLock(). Quit now.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>DeadLockReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>awaitedLock</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Report change to non-waiting status */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResProcLockRemoveSelfAndWakeup -- awaken any processses waiting on a resource lock.
 *
 * Notes:
 *	It always remove itself from the waitlist.
 *	Need to only awaken enough as many waiters as the resource controlled by
 *	the the lock should allow!
 */</comment>
<function><type><name>void</name></type>
<name>ResProcLockRemoveSelfAndWakeup</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>waitQueue</name> <init>= <expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>waitProcs</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>queue_size</name> <init>= <expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LWLockId</name></type>	<name>partitionLock</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>status</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * XXX: This code is ugly and hard to read -- it should be a lot simpler,
	 * especially when there are some odd cases (process sitting on its own
	 * wait-queue).
	 */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queue_size</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>queue_size</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>queue_size</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Get the portal we are waiting on, and then its set of increments.
		 */</comment>
		<decl_stmt><decl><type><name>ResPortalTag</name></type> <name>portalTag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl>;</decl_stmt>

		<comment type="block">/* Our own process may be on our wait-queue! */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name> <operator>==</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>nextproc</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>nextproc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name>proc</name> <operator>=</operator> <name>nextproc</name></expr>;</expr_stmt>

			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResPortalTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>portalId</name></name> <operator>=</operator> <name><name>proc</name><operator>-&gt;</operator><name>waitPortalId</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>incrementSet</name> <operator>=</operator> <call><name>ResIncrementFind</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>incrementSet</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>lock</name><operator>-&gt;</operator><name>tag</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>partitionLock</name> <operator>=</operator> <call><name>LockHashPartitionLock</name><argument_list>(<argument><expr><name>hashcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>partitionLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no increment data for  portal id %u and pid %d"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitPortalId</name></name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * See if it is ok to wake this guy. (note that the wakeup writes to
		 * the wait list, and gives back a *new* next proc).
		 */</comment>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <call><name>ResLockCheckLimit</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name></expr></argument>, <argument><expr><name>incrementSet</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>STATUS_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResGrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResLockUpdateLimit</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name></expr></argument>, <argument><expr><name>incrementSet</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>proc</name> <operator>=</operator> <call><name>ResProcWakeup</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>STATUS_OK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Otherwise move on to the next guy. */</comment>
			<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResProcWakeup -- wake a sleeping process.
 *
 * (could we just use ProcWakeup here?)
 */</comment>
<function><type><name>PGPROC</name> <modifier>*</modifier></type>
<name>ResProcWakeup</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>waitStatus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name>	   <modifier>*</modifier></type><name>retProc</name></decl>;</decl_stmt>

	<comment type="block">/* Proc should be sleeping ... */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>prev</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Save next process before we zap the list link */</comment>
	<expr_stmt><expr><name>retProc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>

	<comment type="block">/* Remove process from wait queue */</comment>
	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name><operator>)</operator><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* Clean up process' state and pass it the ok/fail signal */</comment>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>=</operator> <name>waitStatus</name></expr>;</expr_stmt>

	<comment type="block">/* And awaken it */</comment>
	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>retProc</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResRemoveFromWaitQueue -- Remove a process from the wait queue, cleaning up
 *	any locks.
 */</comment>
<function><type><name>void</name></type>
<name>ResRemoveFromWaitQueue</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>waitLock</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PROCLOCK</name>   <modifier>*</modifier></type><name>proclock</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>LOCKMODE</name></type>	<name>lockmode</name> <init>= <expr><name><name>proc</name><operator>-&gt;</operator><name>waitLockMode</name></name></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>LOCKMETHODID</name></type> <name>lockmethodid</name> <init>= <expr><call><name>LOCK_LOCKMETHOD</name><argument_list>(<argument><expr><operator>*</operator><name>waitLock</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* USE_ASSERT_CHECKING */</comment>
	<decl_stmt><decl><type><name>ResPortalTag</name></type> <name>portalTag</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure lockmethod is for a resource lock. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lockmethodid</name> <operator>==</operator> <name>RESOURCE_LOCKMETHOD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make sure proc is waiting */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>waitLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitLock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remove proc from lock's wait queue */</comment>
	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitLock</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* Undo increments of request counts by waiting process */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitLock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitLock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <name><name>proc</name><operator>-&gt;</operator><name>waitLock</name><operator>-&gt;</operator><name>nGranted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>waitLock</name><operator>-&gt;</operator><name>nRequested</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>waitLock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>waitLock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* don't forget to clear waitMask bit if appropriate */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>waitLock</name><operator>-&gt;</operator><name>granted</name><index>[<expr><name>lockmode</name></expr>]</index></name> <operator>==</operator> <name><name>waitLock</name><operator>-&gt;</operator><name>requested</name><index>[<expr><name>lockmode</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>waitLock</name><operator>-&gt;</operator><name>waitMask</name></name> <operator>&amp;=</operator> <call><name>LOCKBIT_OFF</name><argument_list>(<argument><expr><name>lockmode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Clean up the proc's own state */</comment>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitProcLock</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>proc</name><operator>-&gt;</operator><name>waitStatus</name></name> <operator>=</operator> <name>STATUS_ERROR</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove the waited on portal increment.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResPortalTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portalTag</name><operator>.</operator><name>portalId</name></name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>waitPortalId</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ResIncrementRemove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portalTag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Delete the proclock immediately if it represents no already-held locks.
	 * (This must happen now because if the owner of the lock decides to
	 * release it, and the requested/granted counts then go to zero,
	 * LockRelease expects there to be no remaining proclocks.) Then see if
	 * any other waiters for the lock can be woken up now.
	 */</comment>
	<expr_stmt><expr><call><name>ResCleanUpLock</name><argument_list>(<argument><expr><name>waitLock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>


<comment type="block">/*
 * ResCheckSelfDeadLock -- Check to see if I am going to deadlock myself.
 *
 * What happens here is we scan our own set of portals and total up the
 * increments. If this exceeds any of the thresholds for the queue then
 * we need to signal that a self deadlock is about to occurr - modulo some
 * footwork for overcommit-able queues.
 */</comment>
<function><type><name>bool</name></type>
<name>ResCheckSelfDeadLock</name><parameter_list>(<parameter><decl><type><name>LOCK</name> <modifier>*</modifier></type><name>lock</name></decl></parameter>, <parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>, <parameter><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResQueue</name></type>	<name>queue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResLimit</name></type>	<name>limits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name><name>incrementTotals</name><index>[<expr><name>NUM_RES_LIMIT_TYPES</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPortals</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>countThesholdOvercommitted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>costThesholdOvercommitted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>memoryThesholdOvercommitted</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Get the resource queue lock before checking the increments. */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the queue for this lock. */</comment>
	<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>GetResQueueFromLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>limits</name> <operator>=</operator> <name><name>queue</name><operator>-&gt;</operator><name>limits</name></name></expr>;</expr_stmt>

	<comment type="block">/* Get the increment totals and number of portals for this queue. */</comment>
	<expr_stmt><expr><call><name>TotalResPortalIncrements</name><argument_list>(<argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>queueid</name></name></expr></argument>,
							 <argument><expr><name>incrementTotals</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numPortals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now check them against the thresholds using the same logic as
	 * ResLockCheckLimit.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_RES_LIMIT_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name> <operator>==</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name></expr>)</condition>
		<block>{<block_content>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>RES_COUNT_LIMIT</name></expr>:</case>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>incrementTotals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>countThesholdOvercommitted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>RES_COST_LIMIT</name></expr>:</case>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>incrementTotals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>costThesholdOvercommitted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>

			<case>case <expr><name>RES_MEMORY_LIMIT</name></expr>:</case>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>incrementTotals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>limits</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>memoryThesholdOvercommitted</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<comment type="block">/* If any threshold is overcommitted then set the result. */</comment>
	<if_stmt><if>if <condition>(<expr><name>countThesholdOvercommitted</name> <operator>||</operator> <name>costThesholdOvercommitted</name> <operator>||</operator> <name>memoryThesholdOvercommitted</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the queue can be overcommited and we are overcommitting with 1
	 * portal and *not* overcommitting the count threshold then don't trigger
	 * a self deadlock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>queue</name><operator>-&gt;</operator><name>overcommit</name></name> <operator>&amp;&amp;</operator> <name>numPortals</name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name>countThesholdOvercommitted</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're about to abort out of a partially completed lock acquisition.
		 *
		 * In order to allow our ref-counts to figure out how to clean things
		 * up we're going to "grant" the lock, which will immediately be
		 * cleaned up when our caller throws an ERROR.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>&gt;</operator> <name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* we're no longer waiting. */</comment>
			<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResGrantLock</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ResLockUpdateLimit</name><argument_list>(<argument><expr><name>lock</name></expr></argument>, <argument><expr><name>proclock</name></expr></argument>, <argument><expr><name>incrementSet</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* our caller will throw an ERROR. */</comment>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResPortalIncrementHashTableInit - Initialize the increment hash.
 *
 * Notes:
 *	This stores the possible increments that a given statement will cause to
 *	be added to the limits for a resource queue.
 *	We allocate one extra slot for each backend, to free us from counting
 *	un-named portals.
 */</comment>
<function><type><name>bool</name></type>
<name>ResPortalIncrementHashTableInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>max_table_size</name> <init>= <expr><operator>(</operator><name>MaxResourcePortalsPerXact</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <name>MaxBackends</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hash_flags</name></decl>;</decl_stmt>

	<comment type="block">/* Set key and entry sizes. */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResPortalTag</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResPortalIncrement</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>hash_flags</name> <operator>=</operator> <operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>ResPortalIncrementHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Portal Increment Hash"</literal></expr></argument>,
										   <argument><expr><name>max_table_size</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>,
										   <argument><expr><name>max_table_size</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
										   <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ResPortalIncrementHash</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResIncrementAdd -- Add a new increment element to the increment hash.
 *
 * We return the increment added. We return NULL if we are run out of shared
 * memory. In case there is an existing increment element in the hash table,
 * we have encountered a duplicate portal - so we return the existing increment
 * for ERROR reporting purposes. The status output argument is updated to
 * indicate the outcome of the routine.
 *
 *	The resource queue lightweight lock (ResQueueLock) *must* be held for
 *	this operation.
 */</comment>
<function><type><specifier>static</specifier> <name>ResPortalIncrement</name> <modifier>*</modifier></type>
<name>ResIncrementAdd</name><parameter_list>(<parameter><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incSet</name></decl></parameter>,
				<parameter><decl><type><name>PROCLOCK</name> <modifier>*</modifier></type><name>proclock</name></decl></parameter>,
				<parameter><decl><type><name>ResourceOwner</name></type> <name>owner</name></decl></parameter>,
				<parameter><decl><type><name>ResIncrementAddStatus</name> <modifier>*</modifier></type><name>status</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResPortalTag</name></type> <name>portaltag</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
	<comment type="block">/* Simulate an out-of-shared-memory error by bypassing the increment hash. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(<argument><expr><literal type="string">"res_increment_add_oosm"</literal></expr></argument>,
									   <argument><expr><name>DDLNotSpecified</name></expr></argument>,
									   <argument><expr><literal type="string">""</literal></expr></argument>,
									   <argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>RES_INCREMENT_ADD_OOSM</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* Set up the key. */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portaltag</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResPortalTag</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portaltag</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name><name>incSet</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>portaltag</name><operator>.</operator><name>portalId</name></name> <operator>=</operator> <name><name>incSet</name><operator>-&gt;</operator><name>portalId</name></name></expr>;</expr_stmt>

	<comment type="block">/* Add (or find) the value. */</comment>
	<expr_stmt><expr><name>incrementSet</name> <operator>=</operator> <operator>(</operator><name>ResPortalIncrement</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>ResPortalIncrementHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>portaltag</name></expr></argument>, <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>incrementSet</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>RES_INCREMENT_ADD_OOSM</name></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize it. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>pid</name></name> <operator>=</operator> <name><name>incSet</name><operator>-&gt;</operator><name>pid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>portalId</name></name> <operator>=</operator> <name><name>incSet</name><operator>-&gt;</operator><name>portalId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>isHold</name></name> <operator>=</operator> <name><name>incSet</name><operator>-&gt;</operator><name>isHold</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>isCommitted</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_RES_LIMIT_TYPES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>incrementSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>incSet</name><operator>-&gt;</operator><name>increments</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proclock</name><operator>-&gt;</operator><name>portalLinks</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>incrementSet</name><operator>-&gt;</operator><name>portalLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We have added this portId before - something has gone wrong! */</comment>
		<expr_stmt><expr><call><name>ResIncrementRemove</name><argument_list>(<argument><expr><operator>&amp;</operator><name>portaltag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>RES_INCREMENT_ADD_DUPLICATE_PORTAL</name></expr>;</expr_stmt>
		<return>return <expr><name>incrementSet</name></expr>;</return>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>status</name> <operator>=</operator> <name>RES_INCREMENT_ADD_OK</name></expr>;</expr_stmt>
	<return>return <expr><name>incrementSet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResIncrementFind -- Find the increment for a portal and process.
 *
 * Notes
 *	Return a pointer to where the new increment is stored (NULL if not found).
 *
 *	The resource queue lightweight lock (ResQueueLock) *must* be held for
 *	this operation.
 */</comment>
<function><type><name>ResPortalIncrement</name> <modifier>*</modifier></type>
<name>ResIncrementFind</name><parameter_list>(<parameter><decl><type><name>ResPortalTag</name> <modifier>*</modifier></type><name>portaltag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>incrementSet</name> <operator>=</operator> <operator>(</operator><name>ResPortalIncrement</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>ResPortalIncrementHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>portaltag</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>incrementSet</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>incrementSet</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResIncrementRemove -- Remove a  increment for a portal and process.
 *
 * Notes
 *	The resource queue lightweight lock (ResQueueLock) *must* be held for
 *	this operation.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ResIncrementRemove</name><parameter_list>(<parameter><decl><type><name>ResPortalTag</name> <modifier>*</modifier></type><name>portaltag</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResPortalIncrement</name> <modifier>*</modifier></type><name>incrementSet</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>incrementSet</name> <operator>=</operator> <operator>(</operator><name>ResPortalIncrement</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>ResPortalIncrementHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>portaltag</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>incrementSet</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>incrementSet</name><operator>-&gt;</operator><name>portalLink</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResQueueHashTableInit -- initialize the hash table of resource queues.
 *
 * Notes:
 */</comment>
<function><type><name>bool</name></type>
<name>ResQueueHashTableInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>info</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hash_flags</name></decl>;</decl_stmt>

	<comment type="block">/* Set key and entry sizes. */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResQueueData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>hash_flags</name> <operator>=</operator> <operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name><operator>)</operator></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>RESLOCK_DEBUG</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"Creating hash table for %d queues"</literal></expr></argument>, <argument><expr><name>MaxResourceQueues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>ResQueueHash</name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Queue Hash"</literal></expr></argument>,
								 <argument><expr><name>MaxResourceQueues</name></expr></argument>,
								 <argument><expr><name>MaxResourceQueues</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>,
								 <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ResQueueHash</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ResQueuehashNew -- return a new (empty) queue object to initialize.
 *
 * Notes
 *	The resource queue lightweight lock (ResQueueLock) *must* be held for
 *	this operation.
 */</comment>
<function><type><name>ResQueue</name></type>
<name>ResQueueHashNew</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>queueid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResQueueData</name> <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>queue</name> <operator>=</operator> <operator>(</operator><name>ResQueueData</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>ResQueueHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>queueid</name></expr></argument>, <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* caller should test that the queue does not exist already */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queue</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>ResQueue</name><operator>)</operator> <name>queue</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ResQueueHashFind -- return the queue for a given oid.
 *
 * Notes
 *	The resource queue lightweight lock (ResQueueLock) *must* be held for
 *	this operation.
 */</comment>
<function><type><name>ResQueue</name></type>
<name>ResQueueHashFind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>queueid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResQueueData</name> <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>queue</name> <operator>=</operator> <operator>(</operator><name>ResQueueData</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name>ResQueueHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>queueid</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queue</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>ResQueue</name><operator>)</operator> <name>queue</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ResQueueHashRemove -- remove the queue for a given oid.
 *
 * Notes
 *	The resource queue lightweight lock (ResQueueLock) *must* be held for
 *	this operation.
 */</comment>
<function><type><name>bool</name></type>
<name>ResQueueHashRemove</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>queueid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>queue</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>queue</name> <operator>=</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ResQueueHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>queueid</name></expr></argument>, <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>queue</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Number of columns produced by pg_resqueue_status() */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_RESQUEUE_STATUS_COLUMNS</name></cpp:macro> <cpp:value>5</cpp:value></cpp:define>

<comment type="block">/*
 * pg_resqueue_status - produce a view with one row per resource queue
 *	showing internal information (counter values, waiters, holders).
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_resqueue_status</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueueStatusContext</name> <modifier>*</modifier></type><name>fctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* User function context. */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>

		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Switch context when allocating stuff to be used in later calls */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <operator>(</operator><name>QueueStatusContext</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueueStatusContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Allocate space for the per-call area - this overestimates, but
		 * means we can take the resource rescheduler lock after our memory
		 * context switching.
		 */</comment>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>record</name></name> <operator>=</operator> <operator>(</operator><name>QueueStatusRec</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueueStatusRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MaxResourceQueues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>fctx</name></expr>;</expr_stmt>

		<comment type="block">/* Construct a tuple descriptor for the result rows. */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupledesc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>PG_RESQUEUE_STATUS_COLUMNS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"queueid"</literal></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"queuecountvalue"</literal></expr></argument>, <argument><expr><name>FLOAT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"queuecostvalue"</literal></expr></argument>, <argument><expr><name>FLOAT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"queuewaiters"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"queueholders"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Return to original context when allocating transient memory */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsResQueueEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Get a snapshot of current state of resource queues */</comment>
			<expr_stmt><expr><call><name>BuildQueueStatusContext</name><argument_list>(<argument><expr><name>fctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>numRecords</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>numRecords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the saved state. */</comment>
	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>&lt;</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QueueStatusRec</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>record</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PG_RESQUEUE_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>PG_RESQUEUE_STATUS_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>queueid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Make the counters null if the limit is disbaled. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>queuecountthreshold</name></name> <operator>!=</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>queuecountvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>record</name><operator>-&gt;</operator><name>queuecostthreshold</name></name> <operator>!=</operator> <name>INVALID_RES_LIMIT_THRESHOLD</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Float4GetDatum</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>queuecostvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>


		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>queuewaiters</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name><name>record</name><operator>-&gt;</operator><name>queueholders</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<comment type="block">/* Build and return the tuple. */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * This copies out the current state of resource queues.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>BuildQueueStatusContext</name><parameter_list>(<parameter><decl><type><name>QueueStatusContext</name> <modifier>*</modifier></type><name>fctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_calls</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numRecords</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HASH_SEQ_STATUS</name></type> <name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResQueueData</name> <modifier>*</modifier></type><name>queue</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>fctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>record</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Take all the partition locks. This is necessary as we want to to use
	 * the same lock order as the rest of the code - i.e. partition locks
	 * *first* *then* the queue lock (otherwise we could deadlock ourselves).
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Lock resource queue structures.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Initialize for a sequential scan of the resource queue hash. */</comment>
	<expr_stmt><expr><call><name>hash_seq_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>, <argument><expr><name>ResQueueHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_calls</name> <operator>=</operator> <call><name>hash_get_num_entries</name><argument_list>(<argument><expr><name>ResQueueHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>num_calls</name> <operator>==</operator> <name><name>ResScheduler</name><operator>-&gt;</operator><name>num_queues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numRecords</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>queue</name> <operator>=</operator> <operator>(</operator><name>ResQueueData</name> <operator>*</operator><operator>)</operator> <call><name>hash_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>QueueStatusRec</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>record</name><index>[<expr><name>numRecords</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResLimit</name></type>	<name>limits</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>hashcode</name></decl>;</decl_stmt>

		<comment type="block" format="doxygen">/**
		 * Gather thresholds and current values on activestatements, cost and memory
		 */</comment>
		<expr_stmt><expr><name>limits</name> <operator>=</operator> <name><name>queue</name><operator>-&gt;</operator><name>limits</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queueid</name></name> <operator>=</operator> <name><name>queue</name><operator>-&gt;</operator><name>queueid</name></name></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>NUM_RES_LIMIT_TYPES</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<switch>switch <condition>(<expr><name><name>limits</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>RES_COUNT_LIMIT</name></expr>:</case>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queuecountthreshold</name></name> <operator>=</operator> <name><name>limits</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queuecountvalue</name></name> <operator>=</operator> <name><name>limits</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>current_value</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>RES_COST_LIMIT</name></expr>:</case>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queuecostthreshold</name></name> <operator>=</operator> <name><name>limits</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queuecostvalue</name></name> <operator>=</operator> <name><name>limits</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>current_value</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>RES_MEMORY_LIMIT</name></expr>:</case>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queuememthreshold</name></name> <operator>=</operator> <name><name>limits</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queuememvalue</name></name> <operator>=</operator><name><name>limits</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>current_value</name></expr>;</expr_stmt>
					<break>break;</break>

				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized resource queue limit type: %d"</literal></expr></argument>, <argument><expr><name><name>limits</name><index>[<expr><name>j</name></expr>]</index></name><operator>.</operator><name>type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></switch>
		</block_content>}</block></for>

		<comment type="block">/*
		 * Get the holders and waiters count for the corresponding resource
		 * lock.
		 */</comment>
		<decl_stmt><decl><type><name>LOCKTAG</name></type>		<name>tag</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>LOCK</name>	   <modifier>*</modifier></type><name>lock</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>SET_LOCKTAG_RESOURCE_QUEUE</name><argument_list>(<argument><expr><name>tag</name></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>queueid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hashcode</name> <operator>=</operator> <call><name>LockTagHashCode</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>bool</name></type>		<name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>lock</name> <operator>=</operator> <operator>(</operator><name>LOCK</name> <operator>*</operator><operator>)</operator>
			<call><name>hash_search_with_hash_value</name><argument_list>(<argument><expr><name>LockMethodLockHash</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tag</name></expr></argument>, <argument><expr><name>hashcode</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name> <operator>||</operator> <operator>!</operator><name>lock</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queuewaiters</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queueholders</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queuewaiters</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nRequested</name></name> <operator>-</operator> <name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>record</name><operator>-&gt;</operator><name>queueholders</name></name> <operator>=</operator> <name><name>lock</name><operator>-&gt;</operator><name>nGranted</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>numRecords</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numRecords</name> <operator>&lt;=</operator> <name>MaxResourceQueues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Release the resource scheduler lock. */</comment>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* ...and the partition locks. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>NUM_LOCK_PARTITIONS</name></expr>;</init> <condition><expr><operator>--</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition><incr/>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><call><name>LockHashPartitionLockByIndex</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/* Set the real no. of calls as we know it now! */</comment>
	<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>numRecords</name></name> <operator>=</operator> <name>numRecords</name></expr>;</expr_stmt>
	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/* Number of records produced per queue. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_RESQUEUE_STATUS_KV_RECORDS_PER_QUEUE</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>

<comment type="block">/* Number of columns produced by function */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_RESQUEUE_STATUS_KV_COLUMNS</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>

<comment type="block">/* Scratch space used to write out strings */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_RESQUEUE_STATUS_KV_BUFSIZE</name></cpp:macro> <cpp:value>256</cpp:value></cpp:define>

<comment type="block">/*
 * pg_resqueue_status_extended - outputs the current state of resource queues in the following format:
 * (queueid, key, value) where key and value are text. This makes the function extremely flexible.
 */</comment>
<function><type><name>Datum</name></type>
<name>pg_resqueue_status_kv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QueueStatusContext</name> <modifier>*</modifier></type><name>fctx</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* User function context. */</comment>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>

		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Switch context when allocating stuff to be used in later calls */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <operator>(</operator><name>QueueStatusContext</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueueStatusContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Allocate space for the per-call area - this overestimates, but
		 * means we can take the resource rescheduler lock after our memory
		 * context switching.
		 */</comment>
		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>record</name></name> <operator>=</operator> <operator>(</operator><name>QueueStatusRec</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>QueueStatusRec</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>MaxResourceQueues</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>fctx</name></expr>;</expr_stmt>

		<comment type="block">/* Construct a tuple descriptor for the result rows. */</comment>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupledesc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>PG_RESQUEUE_STATUS_KV_COLUMNS</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"queueid"</literal></expr></argument>, <argument><expr><name>OIDOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"key"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"value"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupledesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Return to original context when allocating transient memory */</comment>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsResQueueEnabled</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Get a snapshot of current state of resource queues */</comment>
			<expr_stmt><expr><call><name>BuildQueueStatusContext</name><argument_list>(<argument><expr><name>fctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>numRecords</name></name> <operator>*</operator> <name>PG_RESQUEUE_STATUS_KV_RECORDS_PER_QUEUE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>numRecords</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Get the saved state. */</comment>
	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>&lt;</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>max_calls</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>/</operator> <name>PG_RESQUEUE_STATUS_KV_RECORDS_PER_QUEUE</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* record number */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name> <init>= <expr><name><name>funcctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>%</operator> <name>PG_RESQUEUE_STATUS_KV_RECORDS_PER_QUEUE</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* which attribute is
																						 * being produced */</comment>
		<decl_stmt><decl><type><name>QueueStatusRec</name> <modifier>*</modifier></type><name>record</name> <init>= <expr><operator>&amp;</operator><name><name>fctx</name><operator>-&gt;</operator><name>record</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>PG_RESQUEUE_STATUS_KV_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>PG_RESQUEUE_STATUS_KV_COLUMNS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>PG_RESQUEUE_STATUS_KV_BUFSIZE</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>queueid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>j</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="number">0</literal></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"rsqcountlimit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>queuecountthreshold</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">1</literal></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"rsqcountvalue"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>record</name><operator>-&gt;</operator><name>queuecountvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">2</literal></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"rsqcostlimit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>queuecostthreshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">3</literal></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"rsqcostvalue"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>queuecostvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">4</literal></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"rsqmemorylimit"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>queuememthreshold</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">5</literal></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"rsqmemoryvalue"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%.2f"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>queuememvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">6</literal></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"rsqwaiters"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>queuewaiters</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="number">7</literal></expr>:</case>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><literal type="string">"rsqholders"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>record</name><operator>-&gt;</operator><name>queueholders</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>false</name> <operator>&amp;&amp;</operator> <literal type="string">"Cannot reach here"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>

		<comment type="block">/* Build and return the tuple. */</comment>
		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

 <comment type="block" format="doxygen">/**
  * What is the memory limit on a queue per the catalog in bytes. Returns -1 if not set.
  */</comment>
<function><type><name>int64</name></type> <name>ResourceQueueGetMemoryLimitInCatalog</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>queueId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>memoryLimitKB</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queueId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type> <name>capabilitiesList</name> <init>= <expr><call><name>GetResqueueCapabilityEntry</name><argument_list>(<argument><expr><name>queueId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt> <comment type="block">/* This is a list of lists */</comment>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>le</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>le</argument>, <argument>capabilitiesList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>key</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>le</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>(</operator><name>Value</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_Integer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* This is resource type id */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>intVal</name><argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>PG_RESRCTYPE_MEMORY_LIMIT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Value</name> <modifier>*</modifier></type><name>val</name> <init>= <expr><call><name>lsecond</name><argument_list>(<argument><expr><name>entry</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>val</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>T_String</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
			<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>=
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
			<expr><operator>(</operator><name>void</name><operator>)</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<call><name>parse_int</name><argument_list>(<argument><expr><call><name>strVal</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>memoryLimitKB</name></expr></argument>, <argument><expr><name>GUC_UNIT_KB</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>capabilitiesList</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>memoryLimitKB</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name>memoryLimitKB</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>memoryLimitKB</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>int64</name><operator>)</operator> <name>memoryLimitKB</name> <operator>*</operator> <literal type="number">1024</literal></expr>;</return>

</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Get memory limit associated with queue in bytes.
 * Returns -1 if a limit does not exist.
 */</comment>
<function><type><name>int64</name></type> <name>ResourceQueueGetMemoryLimit</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>queueId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>memoryLimitBytes</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queueId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>memoryLimitBytes</name> <operator>=</operator> <call><name>ResourceQueueGetMemoryLimitInCatalog</name><argument_list>(<argument><expr><name>queueId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>memoryLimitBytes</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Given a queueid, how much memory should a query take in bytes.
 */</comment>
<function><type><name>uint64</name></type> <name>ResourceQueueGetQueryMemoryLimit</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>queueId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_UTILITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>queueId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* resource queue will not limit super user */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>superuser</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ResourceQueueGetSuperuserQueryMemoryLimit</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block" format="doxygen">/** Assert that I do not hold lwlock */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>int64</name></type> <name>resqLimitBytes</name> <init>= <expr><call><name>ResourceQueueGetMemoryLimit</name><argument_list>(<argument><expr><name>queueId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/**
	 * If there is no memory limit on the queue, simply use statement_mem.
	 */</comment>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name>resqLimitBytes</name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>resqLimitBytes</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>resqLimitBytes</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>statement_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block" format="doxygen">/**
	 * This method should only be called while holding exclusive lock on ResourceQueues. This means
	 * that nobody can modify any resource queue while current process is performing this computation.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>ResQueue</name></type> <name>resQueue</name> <init>= <expr><call><name>ResQueueHashFind</name><argument_list>(<argument><expr><name>queueId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResQueueLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>resQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numSlots</name> <init>= <expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>resQueue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>RES_COUNT_LIMIT</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>costLimit</name> <init>= <expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>resQueue</name><operator>-&gt;</operator><name>limits</name><index>[<expr><name>RES_COST_LIMIT</name></expr>]</index></name><operator>.</operator><name>threshold_value</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>planCost</name> <init>= <expr><name><name>stmt</name><operator>-&gt;</operator><name>planTree</name><operator>-&gt;</operator><name>total_cost</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>planCost</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>planCost</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>planCost</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>LogResManagerMemory</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>GP_RESMANAGER_MEMORY_LOG_LEVEL</name></expr></argument>, <argument><expr><literal type="string">"numslots: %d, costlimit: %f"</literal></expr></argument>, <argument><expr><name>numSlots</name></expr></argument>, <argument><expr><name>costLimit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>numSlots</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block" format="doxygen">/** there is no statement limit set */</comment>
		<expr_stmt><expr><name>numSlots</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>costLimit</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block" format="doxygen">/** there is no cost limit set */</comment>
		<expr_stmt><expr><name>costLimit</name> <operator>=</operator> <name>planCost</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>double</name></type> <name>minRatio</name> <init>= <expr><call><name>Min</name><argument_list>( <argument><expr><literal type="number">1.0</literal><operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numSlots</name></expr></argument>, <argument><expr><name>planCost</name> <operator>/</operator> <name>costLimit</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>minRatio</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minRatio</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>LogResManagerMemory</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>GP_RESMANAGER_MEMORY_LOG_LEVEL</name></expr></argument>, <argument><expr><literal type="string">"slotratio: %0.3f, costratio: %0.3f, minratio: %0.3f"</literal></expr></argument>,
				<argument><expr><literal type="number">1.0</literal><operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>numSlots</name></expr></argument>, <argument><expr><name>planCost</name> <operator>/</operator> <name>costLimit</name></expr></argument>, <argument><expr><name>minRatio</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>queryMem</name> <init>= <expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>resqLimitBytes</name> <operator>*</operator> <name>minRatio</name></expr></init></decl>;</decl_stmt>

	<comment type="block" format="doxygen">/**
	 * If user requests more using statement_mem, grant that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>queryMem</name> <operator>&lt;</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>statement_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>queryMem</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name>statement_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>queryMem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * How much memory should superuser queries get?
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type> <name>ResourceQueueGetSuperuserQueryMemoryLimit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>uint64</name><operator>)</operator> <name>statement_mem</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</return>
</block_content>}</block></function>
</unit>
