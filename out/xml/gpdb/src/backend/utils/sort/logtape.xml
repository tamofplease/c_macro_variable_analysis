<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/sort/logtape.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * logtape.c
 *	  Management of "logical tapes" within temporary files.
 *
 * This module exists to support sorting via multiple merge passes (see
 * tuplesort.c).  Merging is an ideal algorithm for tape devices, but if
 * we implement it on disk by creating a separate file for each "tape",
 * there is an annoying problem: the peak space usage is at least twice
 * the volume of actual data to be sorted.  (This must be so because each
 * datum will appear in both the input and output tapes of the final
 * merge pass.  For seven-tape polyphase merge, which is otherwise a
 * pretty good algorithm, peak usage is more like 4x actual data volume.)
 *
 * We can work around this problem by recognizing that any one tape
 * dataset (with the possible exception of the final output) is written
 * and read exactly once in a perfectly sequential manner.  Therefore,
 * a datum once read will not be required again, and we can recycle its
 * space for use by the new tape dataset(s) being generated.  In this way,
 * the total space usage is essentially just the actual data volume, plus
 * insignificant bookkeeping and start/stop overhead.
 *
 * Few OSes allow arbitrary parts of a file to be released back to the OS,
 * so we have to implement this space-recycling ourselves within a single
 * logical file.  logtape.c exists to perform this bookkeeping and provide
 * the illusion of N independent tape devices to tuplesort.c.  Note that
 * logtape.c itself depends on buffile.c to provide a "logical file" of
 * larger size than the underlying OS may support.
 *
 * For simplicity, we allocate and release space in the underlying file
 * in BLCKSZ-size blocks.  Space allocation boils down to keeping track
 * of which blocks in the underlying file belong to which logical tape,
 * plus any blocks that are free (recycled and not yet reused).
 * The blocks in each logical tape form a chain, with a prev- and next-
 * pointer in each block.
 *
 * The initial write pass is guaranteed to fill the underlying file
 * perfectly sequentially, no matter how data is divided into logical tapes.
 * Once we begin merge passes, the access pattern becomes considerably
 * less predictable --- but the seeking involved should be comparable to
 * what would happen if we kept each logical tape in a separate file,
 * so there's no serious performance penalty paid to obtain the space
 * savings of recycling.  We try to localize the write accesses by always
 * writing to the lowest-numbered free block when we have a choice; it's
 * not clear this helps much, but it can't hurt.  (XXX perhaps a LIFO
 * policy for free blocks would be better?)
 *
 * To further make the I/Os more sequential, we can use a larger buffer
 * when reading, and read multiple blocks from the same tape in one go,
 * whenever the buffer becomes empty.
 *
 * To support the above policy of writing to the lowest free block, the
 * freelist is a min heap.
 *
 * Since all the bookkeeping and buffer memory is allocated with palloc(),
 * and the underlying file(s) are made with OpenTemporaryFile, all resources
 * for a logical tape set are certain to be cleaned up even if processing
 * is aborted by ereport(ERROR).  To avoid confusion, the caller should take
 * care that all calls for a single LogicalTapeSet are made in the same
 * palloc context.
 *
 * To support parallel sort operations involving coordinated callers to
 * tuplesort.c routines across multiple workers, it is necessary to
 * concatenate each worker BufFile/tapeset into one single logical tapeset
 * managed by the leader.  Workers should have produced one final
 * materialized tape (their entire output) when this happens in leader.
 * There will always be the same number of runs as input tapes, and the same
 * number of input tapes as participants (worker Tuplesortstates).
 *
 * Portions Copyright (c) 1996-2020, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/sort/logtape.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buffile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/logtape.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memdebug.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<comment type="block">/*
 * A TapeBlockTrailer is stored at the end of each BLCKSZ block.
 *
 * The first block of a tape has prev == -1.  The last block of a tape
 * stores the number of valid bytes on the block, inverted, in 'next'
 * Therefore next &lt; 0 indicates the last block.
 */</comment>
<typedef>typedef <type><struct>struct <name>TapeBlockTrailer</name>
<block>{
	<decl_stmt><decl><type><name>long</name></type>		<name>prev</name></decl>;</decl_stmt>			<comment type="block">/* previous block on this tape, or -1 on first
								 * block */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>next</name></decl>;</decl_stmt>			<comment type="block">/* next block on this tape, or # of valid
								 * bytes on last block (if &lt; 0) */</comment>
}</block></struct></type> <name>TapeBlockTrailer</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockPayloadSize</name></cpp:macro>  <cpp:value>(BLCKSZ - sizeof(TapeBlockTrailer))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockGetTrailer</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((TapeBlockTrailer *) ((char *) buf + TapeBlockPayloadSize))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockIsLast</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(TapeBlockGetTrailer(buf)-&gt;next &lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockGetNBytes</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(TapeBlockIsLast(buf) ? \
	 (- TapeBlockGetTrailer(buf)-&gt;next) : TapeBlockPayloadSize)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TapeBlockSetNBytes</name><parameter_list>(<parameter><type><name>buf</name></type></parameter>, <parameter><type><name>nbytes</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(TapeBlockGetTrailer(buf)-&gt;next = -(nbytes))</cpp:value></cpp:define>

<comment type="block">/*
 * When multiple tapes are being written to concurrently (as in HashAgg),
 * avoid excessive fragmentation by preallocating block numbers to individual
 * tapes. Each preallocation doubles in size starting at
 * TAPE_WRITE_PREALLOC_MIN blocks up to TAPE_WRITE_PREALLOC_MAX blocks.
 *
 * No filesystem operations are performed for preallocation; only the block
 * numbers are reserved. This may lead to sparse writes, which will cause
 * ltsWriteBlock() to fill in holes with zeros.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAPE_WRITE_PREALLOC_MIN</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TAPE_WRITE_PREALLOC_MAX</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>

<comment type="block">/*
 * This data structure represents a single "logical tape" within the set
 * of logical tapes stored in the same file.
 *
 * While writing, we hold the current partially-written data block in the
 * buffer.  While reading, we can hold multiple blocks in the buffer.  Note
 * that we don't retain the trailers of a block when it's read into the
 * buffer.  The buffer therefore contains one large contiguous chunk of data
 * from the tape.
 */</comment>
<typedef>typedef <type><struct>struct <name>LogicalTape</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>writing</name></decl>;</decl_stmt>		<comment type="block">/* T while in write phase */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>frozen</name></decl>;</decl_stmt>			<comment type="block">/* T if blocks should not be freed when read */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name></decl>;</decl_stmt>			<comment type="block">/* does buffer need to be written? */</comment>

	<comment type="block">/*
	 * Block numbers of the first, current, and next block of the tape.
	 *
	 * The "current" block number is only valid when writing, or reading from
	 * a frozen tape.  (When reading from an unfrozen tape, we use a larger
	 * read buffer that holds multiple blocks, so the "current" block is
	 * ambiguous.)
	 *
	 * When concatenation of worker tape BufFiles is performed, an offset to
	 * the first block in the unified BufFile space is applied during reads.
	 */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>firstBlockNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>curBlockNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>nextBlockNumber</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>offsetBlockNumber</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Buffer for current data block(s).
	 */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buffer</name></decl>;</decl_stmt>			<comment type="block">/* physical buffer (separately palloc'd) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>buffer_size</name></decl>;</decl_stmt>	<comment type="block">/* allocated size of the buffer */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>max_size</name></decl>;</decl_stmt>		<comment type="block">/* highest useful, safe buffer_size */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>			<comment type="block">/* next read/write position in buffer */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>			<comment type="block">/* total # of valid bytes in buffer */</comment>

	<comment type="block">/*
	 * Preallocated block numbers are held in an array sorted in descending
	 * order; blocks are consumed from the end of the array (lowest block
	 * numbers first).
	 */</comment>
	<decl_stmt><decl><type><name>long</name>	   <modifier>*</modifier></type><name>prealloc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nprealloc</name></decl>;</decl_stmt>		<comment type="block">/* number of elements in list */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>prealloc_size</name></decl>;</decl_stmt>	<comment type="block">/* number of elements list can hold */</comment>
}</block></struct></type> <name>LogicalTape</name>;</typedef>

<comment type="block">/*
 * This data structure represents a set of related "logical tapes" sharing
 * space in a single underlying file.  (But that "file" may be multiple files
 * if needed to escape OS limits on file size; buffile.c handles that for us.)
 * The number of tapes is fixed at creation.
 */</comment>
<struct>struct <name>LogicalTapeSet</name>
<block>{
	<decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>pfile</name></decl>;</decl_stmt>			<comment type="block">/* underlying file for whole tape set */</comment>

	<comment type="block">/*
	 * File size tracking.  nBlocksWritten is the size of the underlying file,
	 * in BLCKSZ blocks.  nBlocksAllocated is the number of blocks allocated
	 * by ltsReleaseBlock(), and it is always greater than or equal to
	 * nBlocksWritten.  Blocks between nBlocksAllocated and nBlocksWritten are
	 * blocks that have been allocated for a tape, but have not been written
	 * to the underlying file yet.  nHoleBlocks tracks the total number of
	 * blocks that are in unused holes between worker spaces following BufFile
	 * concatenation.
	 */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>nBlocksAllocated</name></decl>;</decl_stmt>	<comment type="block">/* # of blocks allocated */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>nBlocksWritten</name></decl>;</decl_stmt> <comment type="block">/* # of blocks used in underlying file */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>nHoleBlocks</name></decl>;</decl_stmt>	<comment type="block">/* # of "hole" blocks left */</comment>

	<comment type="block">/*
	 * We store the numbers of recycled-and-available blocks in freeBlocks[].
	 * When there are no such blocks, we extend the underlying file.
	 *
	 * If forgetFreeSpace is true then any freed blocks are simply forgotten
	 * rather than being remembered in freeBlocks[].  See notes for
	 * LogicalTapeSetForgetFreeSpace().
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>forgetFreeSpace</name></decl>;</decl_stmt>	<comment type="block">/* are we remembering free blocks? */</comment>
	<decl_stmt><decl><type><name>long</name>	   <modifier>*</modifier></type><name>freeBlocks</name></decl>;</decl_stmt>		<comment type="block">/* resizable array holding minheap */</comment>
	<decl_stmt><decl><type><name>long</name></type>		<name>nFreeBlocks</name></decl>;</decl_stmt>	<comment type="block">/* # of currently free blocks */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>freeBlocksLen</name></decl>;</decl_stmt>	<comment type="block">/* current allocated length of freeBlocks[] */</comment>

	<comment type="block">/* The array of logical tapes. */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nTapes</name></decl>;</decl_stmt>			<comment type="block">/* # of logical tapes in set */</comment>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>tapes</name></decl>;</decl_stmt>			<comment type="block">/* has nTapes nentries */</comment>
}</block>;</struct>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ltsWriteBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ltsReadBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>ltsGetFreeBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>long</name></type> <name>ltsGetPreallocBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ltsReleaseBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ltsConcatWorkerTapes</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>TapeShare</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>,
								 <parameter><decl><type><name>SharedFileSet</name> <modifier>*</modifier></type><name>fileset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ltsInitTape</name><parameter_list>(<parameter><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ltsInitReadBuffer</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl></parameter>)</parameter_list>;</function_decl>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>LogicalTapeGetBufFilename</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>BufFileGetFilename</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a block-sized buffer to the specified block of the underlying file.
 *
 * No need for an error return convention; we ereport() on any error.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ltsWriteBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * BufFile does not support "holes", so if we're about to write a block
	 * that's past the current end of file, fill the space between the current
	 * end of file and the target block with zeros.
	 *
	 * This should happen rarely, otherwise you are not writing very
	 * sequentially.  In current use, this only happens when the sort ends
	 * writing a run, and switches to another tape.  The last block of the
	 * previous tape isn't flushed to disk until the end of the sort, so you
	 * get one-block hole, where the last block of the previous tape will
	 * later go.
	 *
	 * Note that BufFile concatenation can leave "holes" in BufFile between
	 * worker-owned block ranges.  These are tracked for reporting purposes
	 * only.  We never read from nor write to these hole blocks, and so they
	 * are not considered here.
	 */</comment>
	<while>while <condition>(<expr><name>blocknum</name> <operator>&gt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGAlignedBlock</name></type> <name>zerobuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>zerobuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>zerobuf</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ltsWriteBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name></expr></argument>, <argument><expr><name><name>zerobuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Write the requested block */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileSeekBlock</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to block %ld of temporary file"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update nBlocksWritten, if we extended the file */</comment>
	<if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>==</operator> <name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read a block-sized buffer from the specified block of the underlying file.
 *
 * No need for an error return convention; we ereport() on any error.   This
 * module should never attempt to read a block it doesn't know is there.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ltsReadBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nread</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufFileSeekBlock</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek to block %ld of temporary file"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>nread</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nread</name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read block %ld of temporary file: read only %zu of %zu bytes"</literal></expr></argument>,
						<argument><expr><name>blocknum</name></expr></argument>, <argument><expr><name>nread</name></expr></argument>, <argument><expr><operator>(</operator><name>size_t</name><operator>)</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read as many blocks as we can into the per-tape buffer.
 *
 * Returns true if anything was read, 'false' on EOF.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ltsReadFillBuffer</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>thisbuf</name> <init>= <expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>long</name></type>		<name>datablocknum</name> <init>= <expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Fetch next block number */</comment>
		<if_stmt><if>if <condition>(<expr><name>datablocknum</name> <operator>==</operator> <operator>-</operator><literal type="number">1L</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* EOF */</comment>
		<comment type="block">/* Apply worker offset, needed for leader tapesets */</comment>
		<expr_stmt><expr><name>datablocknum</name> <operator>+=</operator> <name><name>lt</name><operator>-&gt;</operator><name>offsetBlockNumber</name></name></expr>;</expr_stmt>

		<comment type="block">/* Read the block */</comment>
		<expr_stmt><expr><call><name>ltsReadBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>datablocknum</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>thisbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ltsReleaseBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>datablocknum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>+=</operator> <call><name>TapeBlockGetNBytes</name><argument_list>(<argument><expr><name>thisbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>TapeBlockIsLast</name><argument_list>(<argument><expr><name>thisbuf</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
			<comment type="block">/* EOF */</comment>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name>thisbuf</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Advance to next block, if we have buffer space left */</comment>
	</block_content>}</block> while <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>-</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>&gt;</operator> <name>BLCKSZ</name></expr>)</condition>;</do>

	<return>return <expr><operator>(</operator><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>&gt;</operator> <literal type="number">0</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>swap_nodes</name><parameter_list>(<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>heap</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>a</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>swap</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>swap</name> <operator>=</operator> <name><name>heap</name><index>[<expr><name>a</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>heap</name><index>[<expr><name>a</name></expr>]</index></name> <operator>=</operator> <name><name>heap</name><index>[<expr><name>b</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>heap</name><index>[<expr><name>b</name></expr>]</index></name> <operator>=</operator> <name>swap</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>long</name></type>
<name>left_offset</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>long</name></type>
<name>right_offset</name><parameter_list>(<parameter><decl><type><name>unsigned</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="number">2</literal> <operator>*</operator> <name>i</name> <operator>+</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>unsigned</name> <name>long</name></type>
<name>parent_offset</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>i</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Select the lowest currently unused block by taking the first element from
 * the freelist min heap.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>ltsGetFreeBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name>	   <modifier>*</modifier></type><name>heap</name> <init>= <expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>blocknum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>heapsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>pos</name></decl>;</decl_stmt>

	<comment type="block">/* freelist empty; allocate a new block */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksAllocated</name></name><operator>++</operator></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name><operator>--</operator></expr>;</expr_stmt>
		<return>return <expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* take top of minheap */</comment>
	<expr_stmt><expr><name>blocknum</name> <operator>=</operator> <name><name>heap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* replace with end of minheap array */</comment>
	<expr_stmt><expr><name><name>heap</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>heap</name><index>[<expr><operator>--</operator><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/* sift down */</comment>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>heapsize</name> <operator>=</operator> <name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>left</name> <init>= <expr><call><name>left_offset</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>right</name> <init>= <expr><call><name>right_offset</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>min_child</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>heapsize</name> <operator>&amp;&amp;</operator> <name>right</name> <operator>&lt;</operator> <name>heapsize</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_child</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>heap</name><index>[<expr><name>left</name></expr>]</index></name> <operator>&lt;</operator> <name><name>heap</name><index>[<expr><name>right</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><name>left</name></expr> </then><else>: <expr><name>right</name></expr></else></ternary></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>left</name> <operator>&lt;</operator> <name>heapsize</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_child</name> <operator>=</operator> <name>left</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>right</name> <operator>&lt;</operator> <name>heapsize</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>min_child</name> <operator>=</operator> <name>right</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>heap</name><index>[<expr><name>min_child</name></expr>]</index></name> <operator>&gt;=</operator> <name><name>heap</name><index>[<expr><name>pos</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>swap_nodes</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>min_child</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>min_child</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>blocknum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return the lowest free block number from the tape's preallocation list.
 * Refill the preallocation list if necessary.
 */</comment>
<function><type><specifier>static</specifier> <name>long</name></type>
<name>ltsGetPreallocBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* sorted in descending order, so return the last element */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>nprealloc</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name><index>[<expr><operator>--</operator><name><name>lt</name><operator>-&gt;</operator><name>nprealloc</name></name></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name> <operator>=</operator> <name>TAPE_WRITE_PREALLOC_MIN</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name> <operator>&lt;</operator> <name>TAPE_WRITE_PREALLOC_MAX</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* when the preallocation list runs out, double the size */</comment>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name> <operator>&gt;</operator> <name>TAPE_WRITE_PREALLOC_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name> <operator>=</operator> <name>TAPE_WRITE_PREALLOC_MAX</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name></name></expr></argument>,
										 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* refill preallocation list */</comment>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nprealloc</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>lt</name><operator>-&gt;</operator><name>nprealloc</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>ltsGetFreeBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* verify descending order */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>==</operator> <name><name>lt</name><operator>-&gt;</operator><name>nprealloc</name></name> <operator>||</operator> <name><name>lt</name><operator>-&gt;</operator><name>prealloc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>&gt;</operator> <name><name>lt</name><operator>-&gt;</operator><name>prealloc</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name><index>[<expr><operator>--</operator><name><name>lt</name><operator>-&gt;</operator><name>nprealloc</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return a block# to the freelist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ltsReleaseBlock</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name>	   <modifier>*</modifier></type><name>heap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>pos</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Do nothing if we're no longer interested in remembering free space.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lts</name><operator>-&gt;</operator><name>forgetFreeSpace</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Enlarge freeBlocks array if full.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>&gt;=</operator> <name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the freelist becomes very large, just return and leak this free
		 * block.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*</operator> <literal type="number">2</literal> <operator>&gt;</operator> <name>MaxAllocSize</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr></argument>,
											<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>heap</name> <operator>=</operator> <name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pos</name> <operator>=</operator> <name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name></expr>;</expr_stmt>

	<comment type="block">/* place entry at end of minheap array */</comment>
	<expr_stmt><expr><name><name>heap</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>=</operator> <name>blocknum</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* sift up */</comment>
	<while>while <condition>(<expr><name>pos</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>parent</name> <init>= <expr><call><name>parent_offset</name><argument_list>(<argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>heap</name><index>[<expr><name>parent</name></expr>]</index></name> <operator>&lt;</operator> <name><name>heap</name><index>[<expr><name>pos</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>swap_nodes</name><argument_list>(<argument><expr><name>heap</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Claim ownership of a set of logical tapes from existing shared BufFiles.
 *
 * Caller should be leader process.  Though tapes are marked as frozen in
 * workers, they are not frozen when opened within leader, since unfrozen tapes
 * use a larger read buffer. (Frozen tapes have smaller read buffer, optimized
 * for random access.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ltsConcatWorkerTapes</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>TapeShare</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>,
					 <parameter><decl><type><name>SharedFileSet</name> <modifier>*</modifier></type><name>fileset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>tapeblocks</name> <init>= <expr><literal type="number">0L</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>		<name>nphysicalblocks</name> <init>= <expr><literal type="number">0L</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* Should have at least one worker tape, plus leader's tape */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name> <operator>&gt;=</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Build concatenated view of all BufFiles, remembering the block number
	 * where each source file begins.  No changes are needed for leader/last
	 * tape.
	 */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>file</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>filesize</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pg_itoa</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>file</name> <operator>=</operator> <call><name>BufFileOpenShared</name><argument_list>(<argument><expr><name>fileset</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>filesize</name> <operator>=</operator> <call><name>BufFileSize</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Stash first BufFile, and concatenate subsequent BufFiles to that.
		 * Store block offset into each tape as we go.
		 */</comment>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>=</operator> <name><name>shared</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>firstblocknumber</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name> <operator>=</operator> <name>file</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>offsetBlockNumber</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>offsetBlockNumber</name></name> <operator>=</operator> <call><name>BufFileAppend</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<comment type="block">/* Don't allocate more for read buffer than could possibly help */</comment>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>max_size</name></name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>MaxAllocSize</name></expr></argument>, <argument><expr><name>filesize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>tapeblocks</name> <operator>=</operator> <name>filesize</name> <operator>/</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nphysicalblocks</name> <operator>+=</operator> <name>tapeblocks</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Set # of allocated blocks, as well as # blocks written.  Use extent of
	 * new BufFile space (from 0 to end of last worker's tape space) for this.
	 * Allocated/written blocks should include space used by holes left
	 * between concatenated BufFiles.
	 */</comment>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksAllocated</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>offsetBlockNumber</name></name> <operator>+</operator> <name>tapeblocks</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name> <operator>=</operator> <name><name>lts</name><operator>-&gt;</operator><name>nBlocksAllocated</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute number of hole blocks so that we can later work backwards, and
	 * instrument number of physical blocks.  We don't simply use physical
	 * blocks directly for instrumentation because this would break if we ever
	 * subsequently wrote to the leader tape.
	 *
	 * Working backwards like this keeps our options open.  If shared BufFiles
	 * ever support being written to post-export, logtape.c can automatically
	 * take advantage of that.  We'd then support writing to the leader tape
	 * while recycling space from worker tapes, because the leader tape has a
	 * zero offset (write routines won't need to have extra logic to apply an
	 * offset).
	 *
	 * The only thing that currently prevents writing to the leader tape from
	 * working is the fact that BufFiles opened using BufFileOpenShared() are
	 * read-only by definition, but that could be changed if it seemed
	 * worthwhile.  For now, writing to the leader tape will raise a "Bad file
	 * descriptor" error, so tuplesort must avoid writing to the leader tape
	 * altogether.
	 */</comment>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nHoleBlocks</name></name> <operator>=</operator> <name><name>lts</name><operator>-&gt;</operator><name>nBlocksAllocated</name></name> <operator>-</operator> <name>nphysicalblocks</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize per-tape struct.  Note we allocate the I/O buffer lazily.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ltsInitTape</name><parameter_list>(<parameter><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>offsetBlockNumber</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* palloc() larger than MaxAllocSize would fail */</comment>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>max_size</name></name> <operator>=</operator> <name>MaxAllocSize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nprealloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Lazily allocate and initialize the read buffer. This avoids waste when many
 * tapes are open at once, but not all are active between rewinding and
 * reading.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ltsInitReadBuffer</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Read the first block, or reset if tape is empty */</comment>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ltsReadFillBuffer</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create a set of logical tapes in a temporary underlying file.
 *
 * Each tape is initialized in write state.  Serial callers pass ntapes,
 * NULL argument for shared, and -1 for worker.  Parallel worker callers
 * pass ntapes, a shared file handle, NULL shared argument,  and their own
 * worker number.  Leader callers, which claim shared worker tapes here,
 * must supply non-sentinel values for all arguments except worker number,
 * which should be -1.
 *
 * Leader caller is passing back an array of metadata each worker captured
 * when LogicalTapeFreeze() was called for their final result tapes.  Passed
 * tapes array is actually sized ntapes - 1, because it includes only
 * worker tapes, whereas leader requires its own leader tape.  Note that we
 * rely on the assumption that reclaimed worker tapes will only be read
 * from once by leader, and never written to again (tapes are initialized
 * for writing, but that's only to be consistent).  Leader may not write to
 * its own tape purely due to a restriction in the shared buffile
 * infrastructure that may be lifted in the future.
 */</comment>
<function><type><name>LogicalTapeSet</name> <modifier>*</modifier></type>
<name>LogicalTapeSetCreate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>ntapes</name></decl></parameter>, <parameter><decl><type><name>TapeShare</name> <modifier>*</modifier></type><name>shared</name></decl></parameter>, <parameter><decl><type><name>SharedFileSet</name> <modifier>*</modifier></type><name>fileset</name></decl></parameter>,
					 <parameter><decl><type><name>int</name></type> <name>worker</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Create top-level struct including per-tape LogicalTape structs.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ntapes</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lts</name> <operator>=</operator> <operator>(</operator><name>LogicalTapeSet</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>LogicalTapeSet</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksAllocated</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksWritten</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nHoleBlocks</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>forgetFreeSpace</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>=</operator> <literal type="number">32</literal></expr>;</expr_stmt>	<comment type="block">/* reasonable initial guess */</comment>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name> <operator>=</operator> <operator>(</operator><name>long</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocksLen</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>long</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nFreeBlocks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name> <operator>=</operator> <name>ntapes</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>tapes</name></name> <operator>=</operator> <operator>(</operator><name>LogicalTape</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ntapes</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalTape</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ntapes</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ltsInitTape</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Create temp BufFile storage as required.
	 *
	 * Leader concatenates worker tapes, which requires special adjustment to
	 * final tapeset data.  Things are simpler for the worker case and the
	 * serial case, though.  They are generally very similar -- workers use a
	 * shared fileset, whereas serial sorts use a conventional serial BufFile.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>shared</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ltsConcatWorkerTapes</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>shared</name></expr></argument>, <argument><expr><name>fileset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>fileset</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>filename</name><index>[<expr><name>MAXPGPATH</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>pg_itoa</name><argument_list>(<argument><expr><name>worker</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>work_set</name> <operator>=</operator> <call><name>workfile_mgr_create_set</name><argument_list>(<argument><expr><literal type="string">"LogicalTape"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>false</name></expr></argument> <comment type="block">/* hold pin */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name> <operator>=</operator> <call><name>BufFileCreateShared</name><argument_list>(<argument><expr><name>fileset</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>work_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><literal type="string">"LogicalTape"</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>lts</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Close a logical tape set and release all resources.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeSetClose</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>tapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>freeBlocks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Mark a logical tape set as not needing management of free space anymore.
 *
 * This should be called if the caller does not intend to write any more data
 * into the tape set, but is reading from un-frozen tapes.  Since no more
 * writes are planned, remembering free blocks is no longer useful.  Setting
 * this flag lets us avoid wasting time and space in ltsReleaseBlock(), which
 * is not designed to handle large numbers of free blocks.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeSetForgetFreeSpace</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>forgetFreeSpace</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write to a logical tape.
 *
 * There are no error returns; we ereport() on failure.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeWrite</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
				 <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nthistime</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>offsetBlockNumber</name></name> <operator>==</operator> <literal type="number">0L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Allocate data buffer and first block on first write */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <call><name>ltsGetPreallocBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>TapeBlockPayloadSize</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Buffer full, dump it out */</comment>
			<decl_stmt><decl><type><name>long</name></type>		<name>nextBlockNumber</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Hmm, went directly from reading to writing? */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid logtape state: should be dirty"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * First allocate the next block, so that we can store it in the
			 * 'next' pointer of this block.
			 */</comment>
			<expr_stmt><expr><name>nextBlockNumber</name> <operator>=</operator> <call><name>ltsGetPreallocBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* set the next-pointer and dump the current block. */</comment>
			<expr_stmt><expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name> <operator>=</operator> <name>nextBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ltsWriteBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* initialize the prev-pointer of the next block */</comment>
			<expr_stmt><expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name>nextBlockNumber</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>nthistime</name> <operator>=</operator> <name>TapeBlockPayloadSize</name> <operator>-</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nthistime</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nthistime</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nthistime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>nthistime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <name>nthistime</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>&lt;</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>nthistime</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>nthistime</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Rewind logical tape and switch from writing to reading.
 *
 * The tape must currently be in writing state, or "frozen" in read state.
 *
 * 'buffer_size' specifies how much memory to use for the read buffer.
 * Regardless of the argument, the actual amount of memory used is between
 * BLCKSZ and MaxAllocSize, and is a multiple of BLCKSZ.  The given value is
 * rounded down and truncated to fit those constraints, if necessary.  If the
 * tape is frozen, the 'buffer_size' argument is ignored, and a small BLCKSZ
 * byte buffer is used.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeRewindForRead</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>buffer_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Round and cap buffer_size if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buffer_size</name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* need at least one block */</comment>
		<if_stmt><if>if <condition>(<expr><name>buffer_size</name> <operator>&lt;</operator> <name>BLCKSZ</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>buffer_size</name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* palloc() larger than max_size is unlikely to be helpful */</comment>
		<if_stmt><if>if <condition>(<expr><name>buffer_size</name> <operator>&gt;</operator> <name><name>lt</name><operator>-&gt;</operator><name>max_size</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>buffer_size</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>max_size</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* round down to BLCKSZ boundary */</comment>
		<expr_stmt><expr><name>buffer_size</name> <operator>-=</operator> <name>buffer_size</name> <operator>%</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Completion of a write phase.  Flush last partial data block, and
		 * rewind for normal (destructive) read.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * As long as we've filled the buffer at least once, its contents
			 * are entirely defined from valgrind's point of view, even though
			 * contents beyond the current end point may be stale.  But it's
			 * possible - at least in the case of a parallel sort - to sort
			 * such small amount of data that we do not fill the buffer even
			 * once.  Tell valgrind that its contents are defined, so it
			 * doesn't bleat.
			 */</comment>
			<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>,
									  <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>-</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>TapeBlockSetNBytes</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ltsWriteBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This is only OK if tape is frozen; we rewind for (another) read
		 * pass.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* the buffer is lazily allocated, but set the size here */</comment>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <name>buffer_size</name></expr>;</expr_stmt>

	<comment type="block">/* free the preallocation list, and return unused block numbers */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name><name>lt</name><operator>-&gt;</operator><name>nprealloc</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ltsReleaseBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nprealloc</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>prealloc_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Rewind logical tape and switch from reading to writing.
 *
 * NOTE: we assume the caller has read the tape to the end; otherwise
 * untouched data will not have been freed. We could add more code to free
 * any unread blocks, but in current usage of this module it'd be useless
 * code.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeRewindForWrite</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read from a logical tape.
 *
 * Early EOF is indicated by return value less than #bytes requested.
 */</comment>
<function><type><name>size_t</name></type>
<name>LogicalTapeRead</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
				<parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nread</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nthistime</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ltsInitReadBuffer</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>&gt;=</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Try to load more data into buffer. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ltsReadFillBuffer</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* EOF */</comment>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>nthistime</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>-</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nthistime</name> <operator>&gt;</operator> <name>size</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nthistime</name> <operator>=</operator> <name>size</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nthistime</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr></argument>, <argument><expr><name>nthistime</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>+=</operator> <name>nthistime</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>ptr</name> <operator>+</operator> <name>nthistime</name><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>size</name> <operator>-=</operator> <name>nthistime</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nread</name> <operator>+=</operator> <name>nthistime</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>nread</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * "Freeze" the contents of a tape so that it can be read multiple times
 * and/or read backwards.  Once a tape is frozen, its contents will not
 * be released until the LogicalTapeSet is destroyed.  This is expected
 * to be used only for the final output pass of a merge.
 *
 * This *must* be called just at the end of a write pass, before the
 * tape is rewound (after rewind is too late!).  It performs a rewind
 * and switch to read mode "for free".  An immediately following rewind-
 * for-read call is OK but not necessary.
 *
 * share output argument is set with details of storage used for tape after
 * freezing, which may be passed to LogicalTapeSetCreate within leader
 * process later.  This metadata is only of interest to worker callers
 * freezing their final output for leader (single materialized tape).
 * Serial sorts should set share to NULL.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeFreeze</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>TapeShare</name> <modifier>*</modifier></type><name>share</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>offsetBlockNumber</name></name> <operator>==</operator> <literal type="number">0L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Completion of a write phase.  Flush last partial data block, and rewind
	 * for nondestructive read.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>dirty</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * As long as we've filled the buffer at least once, its contents are
		 * entirely defined from valgrind's point of view, even though
		 * contents beyond the current end point may be stale.  But it's
		 * possible - at least in the case of a parallel sort - to sort such
		 * small amount of data that we do not fill the buffer even once. Tell
		 * valgrind that its contents are defined, so it doesn't bleat.
		 */</comment>
		<expr_stmt><expr><call><name>VALGRIND_MAKE_MEM_DEFINED</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>+</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>,
								  <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>-</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>TapeBlockSetNBytes</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ltsWriteBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>writing</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The seek and backspace functions assume a single block read buffer.
	 * That's OK with current usage.  A larger buffer is helpful to make the
	 * read pattern of the backing file look more sequential to the OS, when
	 * we're reading from multiple tapes.  But at the end of a sort, when a
	 * tape is frozen, we only read from a single tape anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>||</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>!=</operator> <name>BLCKSZ</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>=</operator> <name>BLCKSZ</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Read the first block, or reset if tape is empty */</comment>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1L</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>ltsReadBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TapeBlockIsLast</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1L</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <call><name>TapeBlockGetNBytes</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Handle extra steps when caller is to share its tapeset */</comment>
	<if_stmt><if>if <condition>(<expr><name>share</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BufFileExportShared</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>pfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>share</name><operator>-&gt;</operator><name>firstblocknumber</name></name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add additional tapes to this tape set. Not intended to be used when any
 * tapes are frozen.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeSetExtend</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nAdditional</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nTapesOrig</name> <init>= <expr><name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name> <operator>+=</operator> <name>nAdditional</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lts</name><operator>-&gt;</operator><name>tapes</name></name> <operator>=</operator> <operator>(</operator><name>LogicalTape</name> <operator>*</operator><operator>)</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>lts</name><operator>-&gt;</operator><name>tapes</name></name></expr></argument>,
										  <argument><expr><name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>LogicalTape</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>nTapesOrig</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ltsInitTape</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Backspace the tape a given number of bytes.  (We also support a more
 * general seek interface, see below.)
 *
 * *Only* a frozen-for-read tape can be backed up; we don't support
 * random access during write, and an unfrozen read tape may have
 * already discarded the desired data!
 *
 * Returns the number of bytes backed up.  It can be less than the
 * requested amount, if there isn't that much data before the current
 * position.  The tape is positioned to the beginning of the tape in
 * that case.
 */</comment>
<function><type><name>size_t</name></type>
<name>LogicalTapeBackspace</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>seekpos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ltsInitReadBuffer</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Easy case for seek within current block.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>size</name> <operator>&lt;=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>-=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>size</name></expr>;</expr_stmt>
		<return>return <expr><name>size</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Not-so-easy case, have to walk back the chain of blocks.  This
	 * implementation would be pretty inefficient for long seeks, but we
	 * really aren't doing that (a seek over one tuple is typical).
	 */</comment>
	<expr_stmt><expr><name>seekpos</name> <operator>=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt> <comment type="block">/* part within this block */</comment>
	<while>while <condition>(<expr><name>size</name> <operator>&gt;</operator> <name>seekpos</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>long</name></type>		<name>prev</name> <init>= <expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>prev</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>==</operator> <operator>-</operator><literal type="number">1L</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Tried to back up beyond the beginning of tape. */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>!=</operator> <name><name>lt</name><operator>-&gt;</operator><name>firstBlockNumber</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected end of tape"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<return>return <expr><name>seekpos</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ltsReadBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>prev</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name> <operator>!=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"broken tape, next of block %ld is %ld, expected %ld"</literal></expr></argument>,
				 <argument><expr><name>prev</name></expr></argument>,
				 <argument><expr><call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr></argument>,
				 <argument><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <name>TapeBlockPayloadSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name>prev</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>seekpos</name> <operator>+=</operator> <name>TapeBlockPayloadSize</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * 'seekpos' can now be greater than 'size', because it points to the
	 * beginning the target block.  The difference is the position within the
	 * page.
	 */</comment>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>seekpos</name> <operator>-</operator> <name>size</name></expr>;</expr_stmt>
	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Seek to an arbitrary position in a logical tape.
 *
 * *Only* a frozen-for-read tape can be seeked.
 *
 * Must be called with a block/offset previously returned by
 * LogicalTapeTell().
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeSeek</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
				<parameter><decl><type><name>long</name></type> <name>blocknum</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>offset</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>offset</name> <operator>&lt;=</operator> <name>TapeBlockPayloadSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ltsInitReadBuffer</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>blocknum</name> <operator>!=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ltsReadBlock</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>blocknum</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name> <operator>=</operator> <name>blocknum</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name> <operator>=</operator> <name>TapeBlockPayloadSize</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>nextBlockNumber</name></name> <operator>=</operator> <call><name>TapeBlockGetTrailer</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>next</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>offset</name> <operator>&gt;</operator> <name><name>lt</name><operator>-&gt;</operator><name>nbytes</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tape seek position"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>lt</name><operator>-&gt;</operator><name>pos</name></name> <operator>=</operator> <name>offset</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain current position in a form suitable for a later LogicalTapeSeek.
 *
 * NOTE: it'd be OK to do this during write phase with intention of using
 * the position for a seek after freezing.  Not clear if anyone needs that.
 */</comment>
<function><type><name>void</name></type>
<name>LogicalTapeTell</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tapenum</name></decl></parameter>,
				<parameter><decl><type><name>long</name> <modifier>*</modifier></type><name>blocknum</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>offset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>LogicalTape</name> <modifier>*</modifier></type><name>lt</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>tapenum</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tapenum</name> <operator>&lt;</operator> <name><name>lts</name><operator>-&gt;</operator><name>nTapes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lt</name> <operator>=</operator> <operator>&amp;</operator><name><name>lts</name><operator>-&gt;</operator><name>tapes</name><index>[<expr><name>tapenum</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lt</name><operator>-&gt;</operator><name>buffer</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ltsInitReadBuffer</name><argument_list>(<argument><expr><name>lts</name></expr></argument>, <argument><expr><name>lt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>offsetBlockNumber</name></name> <operator>==</operator> <literal type="number">0L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* With a larger buffer, 'pos' wouldn't be the same as offset within page */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lt</name><operator>-&gt;</operator><name>buffer_size</name></name> <operator>==</operator> <name>BLCKSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>blocknum</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>curBlockNumber</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>offset</name> <operator>=</operator> <name><name>lt</name><operator>-&gt;</operator><name>pos</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Obtain total disk space currently used by a LogicalTapeSet, in blocks.
 */</comment>
<function><type><name>long</name></type>
<name>LogicalTapeSetBlocks</name><parameter_list>(<parameter><decl><type><name>LogicalTapeSet</name> <modifier>*</modifier></type><name>lts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>lts</name><operator>-&gt;</operator><name>nBlocksAllocated</name></name> <operator>-</operator> <name><name>lts</name><operator>-&gt;</operator><name>nHoleBlocks</name></name></expr>;</return>
</block_content>}</block></function>
</unit>
