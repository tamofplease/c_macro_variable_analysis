<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/sort/tuplestore.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tuplestore.c
 *	  Generalized routines for temporary tuple storage.
 *
 * This module handles temporary storage of tuples for purposes such
 * as Materialize nodes, hashjoin batch files, etc.  It is essentially
 * a dumbed-down version of tuplesort.c; it does no sorting of tuples
 * but can only store and regurgitate a sequence of tuples.  However,
 * because no sort is required, it is allowed to start reading the sequence
 * before it has all been written.  This is particularly useful for cursors,
 * because it allows random access within the already-scanned portion of
 * a query without having to process the underlying scan to completion.
 * Also, it is possible to support multiple independent read pointers.
 *
 * A temporary file is used to handle the data if it exceeds the
 * space limit specified by the caller.
 *
 * The (approximate) amount of memory allowed to the tuplestore is specified
 * in kilobytes by the caller.  We absorb tuples and simply store them in an
 * in-memory array as long as we haven't exceeded maxKBytes.  If we do exceed
 * maxKBytes, we dump all the tuples into a temp file and then read from that
 * when needed.
 *
 * Upon creation, a tuplestore supports a single read pointer, numbered 0.
 * Additional read pointers can be created using tuplestore_alloc_read_pointer.
 * Mark/restore behavior is supported by copying read pointers.
 *
 * When the caller requests backward-scan capability, we write the temp file
 * in a format that allows either forward or backward scan.  Otherwise, only
 * forward scan is allowed.  A request for backward scan must be made before
 * putting any tuples into the tuplestore.  Rewind is normally allowed but
 * can be turned off via tuplestore_set_eflags; turning off rewind for all
 * read pointers enables truncation of the tuplestore at the oldest read point
 * for minimal memory usage.  (The caller must explicitly call tuplestore_trim
 * at appropriate times for truncation to actually happen.)
 *
 * Note: in TSS_WRITEFILE state, the temp file's seek position is the
 * current write position, and the write-position variables in the tuplestore
 * aren't kept up to date.  Similarly, in TSS_READFILE state the temp file's
 * seek position is the active read pointer's position, and that read pointer
 * isn't kept up to date.  We update the appropriate variables using ftell()
 * before switching to the other state or activating a different read pointer.
 *
 *
 * Greenplum changes
 * -----------------
 *
 * In Greenplum, tuplestores have one extra capability: a tuplestore can
 * be created and filled in one process, and opened for reading in another
 * process. To do this, call tuplestore_make_shared() immediately
 * after creating the tuplestore, in the writer process. Then populate the
 * tuplestore as usual, by calling tuplestore_puttupleslot(). When you're
 * finished writing to it, call tuplestore_freeze(). tuplestore_freeze()
 * flushes all the tuples to the file. No new rows may be added after
 * freezing it.
 *
 * After freezing, you can open the tupletore for reading in the other
 * process by calling tuplestore_open_shared(). It may be opened for reading
 * as many times as you want, in different processes, until it is destroyed
 * by the original writer process by calling tuplestore_end().
 *
 * Note that tuplestore doesn't do any synchronization across processes!
 * It is up to the calling code to do the freezing, opening for reading, and
 * destroying the tuplestore in the right order!
 *
 * Portions Copyright (c) 2007-2010, Greenplum Inc.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/sort/tuplestore.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/tablespace.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buffile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/instrument.h"</cpp:file></cpp:include>        <comment type="block">/* struct Instrumentation */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/workfile_mgr.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Possible states of a Tuplestore object.  These denote the states that
 * persist between calls of Tuplestore routines.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>TSS_INMEM</name></decl>,					<comment type="block">/* Tuples still fit in memory */</comment>
	<decl><name>TSS_WRITEFILE</name></decl>,				<comment type="block">/* Writing to temp file */</comment>
	<decl><name>TSS_READFILE</name></decl>				<comment type="block">/* Reading from temp file */</comment>
}</block></enum></type> <name>TupStoreStatus</name>;</typedef>

<comment type="block">/*
 * State for a single read pointer.  If we are in state INMEM then all the
 * read pointers' "current" fields denote the read positions.  In state
 * WRITEFILE, the file/offset fields denote the read positions.  In state
 * READFILE, inactive read pointers have valid file/offset, but the active
 * read pointer implicitly has position equal to the temp file's seek position.
 *
 * Special case: if eof_reached is true, then the pointer's read position is
 * implicitly equal to the write position, and current/file/offset aren't
 * maintained.  This way we need not update all the read pointers each time
 * we write.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>			<comment type="block">/* capability flags */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>eof_reached</name></decl>;</decl_stmt>	<comment type="block">/* read has reached EOF */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>current</name></decl>;</decl_stmt>		<comment type="block">/* next array index to read */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>file</name></decl>;</decl_stmt>			<comment type="block">/* temp file# */</comment>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>offset</name></decl>;</decl_stmt>			<comment type="block">/* byte offset in file */</comment>
}</block></struct></type> <name>TSReadPointer</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>TSHARE_NOT_SHARED</name></decl>,
	<decl><name>TSHARE_WRITER</name></decl>,
	<decl><name>TSHARE_READER</name></decl>
}</block></enum></type> <name>TSSharedStatus</name>;</typedef>

<comment type="block">/*
 * Private state of a Tuplestore operation.
 */</comment>
<struct>struct <name>Tuplestorestate</name>
<block>{
	<decl_stmt><decl><type><name>TupStoreStatus</name></type> <name>status</name></decl>;</decl_stmt>		<comment type="block">/* enumerated value as shown above */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>			<comment type="block">/* capability flags (OR of pointers' flags) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>backward</name></decl>;</decl_stmt>		<comment type="block">/* store extra length words in file? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>interXact</name></decl>;</decl_stmt>		<comment type="block">/* keep open through transactions? */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>truncated</name></decl>;</decl_stmt>		<comment type="block">/* tuplestore_trim has removed tuples? */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>availMem</name></decl>;</decl_stmt>		<comment type="block">/* remaining memory available, in bytes */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>allowedMem</name></decl>;</decl_stmt>		<comment type="block">/* total memory allowed, in bytes */</comment>
	<decl_stmt><decl><type><name>int64</name></type>		<name>tuples</name></decl>;</decl_stmt>			<comment type="block">/* number of tuples added */</comment>
	<decl_stmt><decl><type><name>BufFile</name>    <modifier>*</modifier></type><name>myfile</name></decl>;</decl_stmt>			<comment type="block">/* underlying file, or NULL if none */</comment>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>context</name></decl>;</decl_stmt>		<comment type="block">/* memory context for holding tuples */</comment>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>resowner</name></decl>;</decl_stmt>		<comment type="block">/* resowner for holding temp files */</comment>

	<decl_stmt><decl><type><name>TSSharedStatus</name></type> <name>share_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>frozen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedFileSet</name> <modifier>*</modifier></type><name>fileset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shared_filename</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl>;</decl_stmt> <comment type="block">/* workfile set to use when using workfile manager */</comment>

	<comment type="block">/*
	 * These function pointers decouple the routines that must know what kind
	 * of tuple we are handling from the routines that don't need to know it.
	 * They are set up by the tuplestore_begin_xxx routines.
	 *
	 * (Although tuplestore.c currently only supports heap tuples, I've copied
	 * this part of tuplesort.c so that extension to other kinds of objects
	 * will be easy if it's ever needed.)
	 *
	 * Function to copy a supplied input tuple into palloc'd space. (NB: we
	 * assume that a single pfree() is enough to release the tuple later, so
	 * the representation must be "flat" in one palloc chunk.) state-&gt;availMem
	 * must be decreased by the amount of space used.
	 */</comment>
	<function_decl><type><name>void</name>	   <modifier>*</modifier></type>(<modifier>*</modifier><name>copytup</name>) <parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*
	 * Function to write a stored tuple onto tape.  The representation of the
	 * tuple on tape need not be the same as it is in memory; requirements on
	 * the tape representation are given below.  After writing the tuple,
	 * pfree() it, and increase state-&gt;availMem by the amount of memory space
	 * thereby released.
	 */</comment>
	<function_decl><type><name>void</name></type>		(<modifier>*</modifier><name>writetup</name>) <parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*
	 * Function to read a stored tuple from tape back into memory. 'len' is
	 * the already-read length of the stored tuple.  Create and return a
	 * palloc'd copy, and decrease state-&gt;availMem by the amount of memory
	 * space consumed.
	 */</comment>
	<function_decl><type><name>void</name>	   <modifier>*</modifier></type>(<modifier>*</modifier><name>readtup</name>) <parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>

	<comment type="block">/*
	 * This array holds pointers to tuples in memory if we are in state INMEM.
	 * In states WRITEFILE and READFILE it's not used.
	 *
	 * When memtupdeleted &gt; 0, the first memtupdeleted pointers are already
	 * released due to a tuplestore_trim() operation, but we haven't expended
	 * the effort to slide the remaining pointers down.  These unused pointers
	 * are set to NULL to catch any invalid accesses.  Note that memtupcount
	 * includes the deleted pointers.
	 */</comment>
	<decl_stmt><decl><type><name>void</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>memtuples</name></decl>;</decl_stmt>		<comment type="block">/* array of pointers to palloc'd tuples */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>memtupdeleted</name></decl>;</decl_stmt>	<comment type="block">/* the first N slots are currently unused */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>memtupcount</name></decl>;</decl_stmt>	<comment type="block">/* number of tuples currently present */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>memtupsize</name></decl>;</decl_stmt>		<comment type="block">/* allocated length of memtuples array */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>growmemtuples</name></decl>;</decl_stmt>	<comment type="block">/* memtuples' growth still underway? */</comment>

	<comment type="block">/*
	 * These variables are used to keep track of the current positions.
	 *
	 * In state WRITEFILE, the current file seek position is the write point;
	 * in state READFILE, the write position is remembered in writepos_xxx.
	 * (The write position is the same as EOF, but since BufFileSeek doesn't
	 * currently implement SEEK_END, we have to remember it explicitly.)
	 */</comment>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>readptrs</name></decl>;</decl_stmt>	<comment type="block">/* array of read pointers */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>activeptr</name></decl>;</decl_stmt>		<comment type="block">/* index of the active read pointer */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>readptrcount</name></decl>;</decl_stmt>	<comment type="block">/* number of pointers currently valid */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>readptrsize</name></decl>;</decl_stmt>	<comment type="block">/* allocated length of readptrs array */</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>writepos_file</name></decl>;</decl_stmt>	<comment type="block">/* file# (valid if READFILE state) */</comment>
	<decl_stmt><decl><type><name>off_t</name></type>		<name>writepos_offset</name></decl>;</decl_stmt>	<comment type="block">/* offset (valid if READFILE state) */</comment>

    <comment type="block">/*
     * CDB: EXPLAIN ANALYZE reporting interface and statistics.
     */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>Instrumentation</name></name> <modifier>*</modifier></type><name>instrument</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type>        <name>availMemMin</name></decl>;</decl_stmt>    <comment type="block">/* availMem low water mark (bytes) */</comment>
	<decl_stmt><decl><type><name>int64</name></type>       <name>spilledBytes</name></decl>;</decl_stmt>   <comment type="block">/* memory used for spilled tuples */</comment>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>COPYTUP</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>tup</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((*(state)-&gt;copytup) (state, tup))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITETUP</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>tup</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((*(state)-&gt;writetup) (state, tup))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>READTUP</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>len</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((*(state)-&gt;readtup) (state, len))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>LACKMEM</name><parameter_list>(<parameter><type><name>state</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((state)-&gt;availMem &lt; 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USEMEM</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>amt</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((state)-&gt;availMem -= (amt))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREEMEM</name><parameter_list>(<parameter><type><name>state</name></type></parameter>,<parameter><type><name>amt</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>do { \
		if ((state)-&gt;availMemMin &gt; (state)-&gt;availMem) \
			(state)-&gt;availMemMin = (state)-&gt;availMem; \
		(state)-&gt;availMem += (amt); \
	} while(0)</cpp:value></cpp:define>

<comment type="block">/*--------------------
 *
 * NOTES about on-tape representation of tuples:
 *
 * We require the first "unsigned int" of a stored tuple to be the total size
 * on-tape of the tuple, including itself (so it is never zero).
 * The remainder of the stored tuple
 * may or may not match the in-memory representation of the tuple ---
 * any conversion needed is the job of the writetup and readtup routines.
 *
 * If state-&gt;backward is true, then the stored representation of
 * the tuple must be followed by another "unsigned int" that is a copy of the
 * length --- so the total tape space used is actually sizeof(unsigned int)
 * more than the stored length value.  This allows read-backwards.  When
 * state-&gt;backward is not set, the write/read routines may omit the extra
 * length word.
 *
 * writetup is expected to write both length words as well as the tuple
 * data.  When readtup is called, the tape is positioned just after the
 * front length word; readtup must read the tuple data and advance past
 * the back length word (if present).
 *
 * The write/read routines can make use of the tuple description data
 * stored in the Tuplestorestate record, if needed. They are also expected
 * to adjust state-&gt;availMem by the amount of memory space (not tape space!)
 * released or consumed.  There is no error return from either writetup
 * or readtup; they should ereport() on failure.
 *
 *
 * NOTES about memory consumption calculations:
 *
 * We count space allocated for tuples against the maxKBytes limit,
 * plus the space used by the variable-size array memtuples.
 * Fixed-size space (primarily the BufFile I/O buffer) is not counted.
 * We don't worry about the size of the read pointer array, either.
 *
 * Note that we count actual space used (as shown by GetMemoryChunkSpace)
 * rather than the originally-requested size.  This is important since
 * palloc can add substantial overhead.  It's not a complete answer since
 * we won't count any wasted space in palloc allocation blocks, but it's
 * a lot better than what we were doing before 7.3.
 *
 *--------------------
 */</comment>


<function_decl><type><specifier>static</specifier> <name>Tuplestorestate</name> <modifier>*</modifier></type><name>tuplestore_begin_common</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>,
												<parameter><decl><type><name>bool</name></type> <name>interXact</name></decl></parameter>,
												<parameter><decl><type><name>int</name></type> <name>maxKBytes</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>tuplestore_puttuple_common</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumptuples</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type> <name>getlen</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>eofOK</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>copytup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>writetup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>readtup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>


<function><type><name>char</name> <modifier>*</modifier></type>
<name>tuplestore_get_buffilename</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr> ?</condition><then> <expr><call><name>pstrdup</name><argument_list>(<argument><expr><call><name>BufFileGetFilename</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		tuplestore_begin_xxx
 *
 * Initialize for a tuple store operation.
 */</comment>
<function><type><specifier>static</specifier> <name>Tuplestorestate</name> <modifier>*</modifier></type>
<name>tuplestore_begin_common</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>interXact</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxKBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>Tuplestorestate</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Tuplestorestate</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_INMEM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eflags</name></name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>interXact</name></name> <operator>=</operator> <name>interXact</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>truncated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>=</operator> <name>maxKBytes</name> <operator>*</operator> <literal type="number">1024L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>availMem</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>availMemMin</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>availMem</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>resowner</name></name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Initial size of array must be more than ALLOCSET_SEPARATE_THRESHOLD;
	 * see comments in grow_memtuples().
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">16384</literal> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>,
							<argument><expr><name>ALLOCSET_SEPARATE_THRESHOLD</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrsize</name></name> <operator>=</operator> <literal type="number">8</literal></expr>;</expr_stmt>		<comment type="block">/* arbitrary */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name></name> <operator>=</operator> <operator>(</operator><name>TSReadPointer</name> <operator>*</operator><operator>)</operator>
		<call><name>palloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readptrsize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSReadPointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>eflags</name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>eof_reached</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>current</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_begin_heap
 *
 * Create a new tuplestore; other types of tuple stores (other than
 * "heap" tuple stores, for heap tuples) are possible, but not presently
 * implemented.
 *
 * randomAccess: if true, both forward and backward accesses to the
 * tuple store are allowed.
 *
 * interXact: if true, the files used for on-disk storage persist beyond the
 * end of the current transaction.  NOTE: It's the caller's responsibility to
 * create such a tuplestore in a memory context and resource owner that will
 * also survive transaction boundaries, and to ensure the tuplestore is closed
 * when it's no longer wanted.
 *
 * maxKBytes: how much data to store in memory (any data beyond this
 * amount is paged to disk).  When in doubt, use work_mem.
 */</comment>
<function><type><name>Tuplestorestate</name> <modifier>*</modifier></type>
<name>tuplestore_begin_heap</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>randomAccess</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>interXact</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>maxKBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This interpretation of the meaning of randomAccess is compatible with
	 * the pre-8.3 behavior of tuplestores.
	 */</comment>
	<expr_stmt><expr><name>eflags</name> <operator>=</operator> <ternary><condition><expr><name>randomAccess</name></expr> ?</condition><then>
		<expr><operator>(</operator><name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_REWIND</name><operator>)</operator></expr> </then><else>:
		<expr><operator>(</operator><name>EXEC_FLAG_REWIND</name><operator>)</operator></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>tuplestore_begin_common</name><argument_list>(<argument><expr><name>eflags</name></expr></argument>, <argument><expr><name>interXact</name></expr></argument>, <argument><expr><name>maxKBytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>copytup</name></name> <operator>=</operator> <name>copytup_heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>writetup</name></name> <operator>=</operator> <name>writetup_heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readtup</name></name> <operator>=</operator> <name>readtup_heap</name></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_set_eflags
 *
 * Set the capability flags for read pointer 0 at a finer grain than is
 * allowed by tuplestore_begin_xxx.  This must be called before inserting
 * any data into the tuplestore.
 *
 * eflags is a bitmask following the meanings used for executor node
 * startup flags (see executor.h).  tuplestore pays attention to these bits:
 *		EXEC_FLAG_REWIND		need rewind to start
 *		EXEC_FLAG_BACKWARD		need backward fetch
 * If tuplestore_set_eflags is not called, REWIND is allowed, and BACKWARD
 * is set per "randomAccess" in the tuplestore_begin_xxx call.
 *
 * NOTE: setting BACKWARD without REWIND means the pointer can read backwards,
 * but not further than the truncation point (the furthest-back read pointer
 * position at the time of the last tuplestore_trim call).
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_set_eflags</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>TSS_INMEM</name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too late to call tuplestore_set_eflags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>eflags</name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eflags</name></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eflags</name></name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_alloc_read_pointer - allocate another read pointer.
 *
 * Returns the pointer's index.
 *
 * The new pointer initially copies the position of read pointer 0.
 * It can have its own eflags, but if any data has been inserted into
 * the tuplestore, these eflags must not represent an increase in
 * requirements.
 */</comment>
<function><type><name>int</name></type>
<name>tuplestore_alloc_read_pointer</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>eflags</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check for possible increase of requirements */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>TSS_INMEM</name> <operator>||</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>eflags</name></name> <operator>|</operator> <name>eflags</name><operator>)</operator> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>eflags</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too late to require new tuplestore eflags"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Make room for another read pointer if needed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrsize</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>newcnt</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>readptrsize</name></name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name></name> <operator>=</operator> <operator>(</operator><name>TSReadPointer</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name></name></expr></argument>, <argument><expr><name>newcnt</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TSReadPointer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrsize</name></name> <operator>=</operator> <name>newcnt</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* And set it up */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>]</index></name><operator>.</operator><name>eflags</name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eflags</name></name> <operator>|=</operator> <name>eflags</name></expr>;</expr_stmt>

	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name><operator>++</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_clear
 *
 *	Delete all the contents of a tuplestore, and reset its read pointers
 *	to the start.
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_clear</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>readptr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_INMEM</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>truncated</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>readptr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrs</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>;</condition> <incr><expr><name>readptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_end
 *
 *	Release resources and clean up.
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_end</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * CDB: Report statistics to EXPLAIN ANALYZE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>instrument</name></name> <operator>&amp;&amp;</operator> <name><name>state</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>need_cdb</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>  <name>nbytes</name></decl>;</decl_stmt>

		<comment type="block">/* How close did we come to the work_mem limit? */</comment>
		<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>              <comment type="block">/* update low-water mark */</comment>
		<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>availMemMin</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>workmemused</name></name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>workmemused</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* How much work_mem would be enough to hold all tuples in memory? */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>spilledBytes</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>availMem</name></name> <operator>+</operator> <name><name>state</name><operator>-&gt;</operator><name>spilledBytes</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>workmemwanted</name></name> <operator>=</operator>
				<call><name>Max</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>workmemwanted</name></name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>instrument</name><operator>-&gt;</operator><name>workfileCreated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BufFileClose</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>share_status</name></name> <operator>==</operator> <name>TSHARE_WRITER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>BufFileDeleteShared</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>fileset</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>shared_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>work_set</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>workfile_mgr_close_set</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>work_set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>shared_filename</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>shared_filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_select_read_pointer - make the specified read pointer active
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_select_read_pointer</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>readptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>oldptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ptr</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ptr</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* No work if already active */</comment>
	<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>readptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name>ptr</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldptr</name> <operator>=</operator> <operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>]</index></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_INMEM</name></expr>:</case>
		<case>case <expr><name>TSS_WRITEFILE</name></expr>:</case>
			<comment type="block">/* no work */</comment>
			<break>break;</break>
		<case>case <expr><name>TSS_READFILE</name></expr>:</case>

			<comment type="block">/*
			 * First, save the current read position in the pointer about to
			 * become inactive.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>oldptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>BufFileTell</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>oldptr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>oldptr</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * We have to make the temp file's seek position equal to the
			 * logical position of the new read pointer.  In eof_reached
			 * state, that's the EOF, which we have available from the saved
			 * write position.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>writepos_file</name></name></expr></argument>,
								<argument><expr><name><name>state</name><operator>-&gt;</operator><name>writepos_offset</name></name></expr></argument>,
								<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
								<argument><expr><name><name>readptr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>,
								<argument><expr><name><name>readptr</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,
								<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplestore state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_tuple_count
 *
 * Returns the number of tuples added since creation or the last
 * tuplestore_clear().
 */</comment>
<function><type><name>int64</name></type>
<name>tuplestore_tuple_count</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_ateof
 *
 * Returns the active read pointer's eof_reached state.
 */</comment>
<function><type><name>bool</name></type>
<name>tuplestore_ateof</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>]</index></name><operator>.</operator><name>eof_reached</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Grow the memtuples[] array, if possible within our memory constraint.  We
 * must not exceed INT_MAX tuples in memory or the caller-provided memory
 * limit.  Return true if we were able to enlarge the array, false if not.
 *
 * Normally, at each increment we double the size of the array.  When doing
 * that would exceed a limit, we attempt one last, smaller increase (and then
 * clear the growmemtuples flag so we don't try any more).  That allows us to
 * use memory as fully as permitted; sticking to the pure doubling rule could
 * result in almost half going unused.  Because availMem moves around with
 * tuple addition/removal, we need some rule to prevent making repeated small
 * increases in memtupsize, which would just be useless thrashing.  The
 * growmemtuples flag accomplishes that and also prevents useless
 * recalculations in this function.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>grow_memtuples</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>newmemtupsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>memtupsize</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>memNowUsed</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>availMem</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Forget it if we've already maxed out memtuples, per comment above */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Select new value of memtupsize */</comment>
	<if_stmt><if>if <condition>(<expr><name>memNowUsed</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>availMem</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We've used no more than half of allowedMem; double our usage,
		 * clamping at INT_MAX tuples.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>memtupsize</name> <operator>&lt;</operator> <name>INT_MAX</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <name>memtupsize</name> <operator>*</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * This will be the last increment of memtupsize.  Abandon doubling
		 * strategy and instead increase as much as we safely can.
		 *
		 * To stay within allowedMem, we can't increase memtupsize by more
		 * than availMem / sizeof(void *) elements. In practice, we want to
		 * increase it by considerably less, because we need to leave some
		 * space for the tuples to which the new array slots will refer.  We
		 * assume the new tuples will be about the same size as the tuples
		 * we've already seen, and thus we can extrapolate from the space
		 * consumption so far to estimate an appropriate new size for the
		 * memtuples array.  The optimal value might be higher or lower than
		 * this estimate, but it's hard to know that in advance.  We again
		 * clamp at INT_MAX tuples.
		 *
		 * This calculation is safe against enlarging the array so much that
		 * LACKMEM becomes true, because the memory currently used includes
		 * the present array; thus, there would be enough allowedMem for the
		 * new array elements even if no other memory were currently used.
		 *
		 * We do the arithmetic in float8, because otherwise the product of
		 * memtupsize and allowedMem could overflow.  Any inaccuracy in the
		 * result should be insignificant; but even if we computed a
		 * completely insane result, the checks below will prevent anything
		 * really bad from happening.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>grow_ratio</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>grow_ratio</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>allowedMem</name></name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>memNowUsed</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>memtupsize</name> <operator>*</operator> <name>grow_ratio</name> <operator>&lt;</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>memtupsize</name> <operator>*</operator> <name>grow_ratio</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <name>INT_MAX</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* We won't make any further enlargement attempts */</comment>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Must enlarge array by at least one element, else report failure */</comment>
	<if_stmt><if>if <condition>(<expr><name>newmemtupsize</name> <operator>&lt;=</operator> <name>memtupsize</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>noalloc</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * On a 32-bit machine, allowedMem could exceed MaxAllocHugeSize.  Clamp
	 * to ensure our request won't be rejected.  Note that we can easily
	 * exhaust address space before facing this outcome.  (This is presently
	 * impossible due to guc.c's MAX_KILOBYTES limitation on work_mem, but
	 * don't rely on that at this distance.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Size</name><operator>)</operator> <name>newmemtupsize</name> <operator>&gt;=</operator> <name>MaxAllocHugeSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>newmemtupsize</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>MaxAllocHugeSize</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>	<comment type="block">/* can't grow any more */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We need to be sure that we do not cause LACKMEM to become true, else
	 * the space management algorithm will go nuts.  The code above should
	 * never generate a dangerous request, but to be safe, check explicitly
	 * that the array growth fits within availMem.  (We could still cause
	 * LACKMEM if the memory chunk overhead associated with the memtuples
	 * array were to increase.  That shouldn't happen because we chose the
	 * initial array size large enough to ensure that palloc will be treating
	 * both old and new arrays as separate chunks.  But we'll check LACKMEM
	 * explicitly below just in case.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>availMem</name></name> <operator>&lt;</operator> <operator>(</operator><name>int64</name><operator>)</operator> <operator>(</operator><operator>(</operator><name>newmemtupsize</name> <operator>-</operator> <name>memtupsize</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>noalloc</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* OK, do it */</comment>
	<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>=</operator> <name>newmemtupsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>*</operator><operator>)</operator>
		<call><name>repalloc_huge</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>,
					  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>LACKMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected out-of-memory situation in tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>true</name></expr>;</return>

<label><name>noalloc</name>:</label>
	<comment type="block">/* If for any reason we didn't realloc, shut off future attempts */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>growmemtuples</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Accept one tuple and append it to the tuplestore.
 *
 * Note that the input tuple is always copied; the caller need not save it.
 *
 * If the active read pointer is currently "at EOF", it remains so (the read
 * pointer implicitly advances along with the write pointer); otherwise the
 * read pointer is unchanged.  Non-active read pointers do not move, which
 * means they are certain to not be "at EOF" immediately after puttuple.
 * This curious-seeming behavior is for the convenience of nodeMaterial.c and
 * nodeCtescan.c, which would otherwise need to do extra pointer repositioning
 * steps.
 *
 * tuplestore_puttupleslot() is a convenience routine to collect data from
 * a TupleTableSlot without an extra copy operation.
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_puttupleslot</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Form a MinimalTuple in working memory
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>ExecCopySlotMinimalTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_puttuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * "Standard" case to copy from a HeapTuple.  This is actually now somewhat
 * deprecated, but not worth getting rid of in view of the number of callers.
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_puttuple</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Copy the tuple.  (Must do this even in WRITEFILE case.  Note that
	 * COPYTUP includes USEMEM, so we needn't do that here.)
	 */</comment>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>COPYTUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_puttuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Similar to tuplestore_puttuple(), but work from values + nulls arrays.
 * This avoids an extra tuple-construction operation.
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_putvalues</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tdesc</name></decl></parameter>,
					 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isnull</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcxt</name> <init>= <expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_minimal_tuple</name><argument_list>(<argument><expr><name>tdesc</name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>tuplestore_puttuple_common</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>tuplestore_puttuple_common</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tuple</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>readptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot write new tuples to frozen tuplestore"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name><operator>++</operator></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_INMEM</name></expr>:</case>

			<comment type="block">/*
			 * Update read pointers as needed; see API spec above.
			 */</comment>
			<expr_stmt><expr><name>readptr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrs</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>;</condition> <incr><expr><name>readptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * Grow the array as needed.  Note that we try to grow the array
			 * when there is still one free slot remaining --- if we fail,
			 * there'll still be room to store the incoming tuple, and then
			 * we'll switch to tape-based operation.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>grow_memtuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Stash the tuple in the in-memory array */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>tuple</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Done if we still fit in available memory and have array slots.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupsize</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>LACKMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Nope; time to switch to tape-based operation.  Make sure that
			 * the temp file(s) are created in suitable temp tablespaces.
			 */</comment>
			<expr_stmt><expr><call><name>PrepareTempTablespaces</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* associate the file with the store's resource owner */</comment>
			<expr_stmt><expr><name>oldowner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>char</name></type> <name><name>tmpprefix</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tmpprefix</name></expr></argument>, <argument><expr><literal type="number">50</literal></expr></argument>, <argument><expr><literal type="string">"slice%d_tuplestore"</literal></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name> <operator>=</operator> <call><name>BufFileCreateTemp</name><argument_list>(<argument><expr><name>tmpprefix</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>interXact</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Freeze the decision about whether trailing length words will be
			 * used.  We can't change this choice once data is on tape, even
			 * though callers might drop the requirement.
			 */</comment>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_BACKWARD</name><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_WRITEFILE</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>dumptuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSS_WRITEFILE</name></expr>:</case>

			<comment type="block">/*
			 * Update read pointers as needed; see API spec above. Note:
			 * BufFileTell is quite cheap, so not worth trying to avoid
			 * multiple calls.
			 */</comment>
			<expr_stmt><expr><name>readptr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrs</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>;</condition> <incr><expr><name>readptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>BufFileTell</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>readptr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>readptr</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>WRITETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSS_READFILE</name></expr>:</case>

			<comment type="block">/*
			 * Switch from reading to writing.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>]</index></name><operator>.</operator><name>eof_reached</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>BufFileTell</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>]</index></name><operator>.</operator><name>file</name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>]</index></name><operator>.</operator><name>offset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
							<argument><expr><name><name>state</name><operator>-&gt;</operator><name>writepos_file</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>writepos_offset</name></name></expr></argument>,
							<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_WRITEFILE</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * Update read pointers as needed; see API spec above.
			 */</comment>
			<expr_stmt><expr><name>readptr</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrs</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>;</condition> <incr><expr><name>readptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>&amp;&amp;</operator> <name>i</name> <operator>!=</operator> <name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>writepos_file</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>writepos_offset</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>

			<expr_stmt><expr><call><name>WRITETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplestore state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch the next tuple in either forward or back direction.
 * Returns NULL if no more tuples.  If should_free is set, the
 * caller must pfree the returned tuple when done with it.
 *
 * Backward scan is only allowed if randomAccess was set true or
 * EXEC_FLAG_BACKWARD was specified to tuplestore_set_eflags().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>tuplestore_gettuple</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>,
					<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>should_free</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>readptr</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>tup</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>forward</name> <operator>||</operator> <operator>(</operator><name><name>readptr</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_BACKWARD</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_INMEM</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>should_free</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* We have another tuple, so return it */</comment>
					<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name><operator>++</operator></expr>]</index></name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * if all tuples are fetched already then we return last
				 * tuple, else tuple before last returned.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>truncated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<return>return <expr><name>NULL</name></expr>;</return>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name><operator>--</operator></expr>;</expr_stmt> <comment type="block">/* last returned tuple */</comment>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>truncated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<return>return <expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</return>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>TSS_WRITEFILE</name></expr>:</case>
			<comment type="block">/* Skip state change if we'll just return NULL */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>&amp;&amp;</operator> <name>forward</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Switch from writing to reading.
			 */</comment>
			<expr_stmt><expr><call><name>BufFileTell</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>writepos_file</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>writepos_offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
				<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
								<argument><expr><name><name>readptr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>readptr</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,
								<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_READFILE</name></expr>;</expr_stmt>
			<comment type="block">/* FALLTHROUGH */</comment>

		<case>case <expr><name>TSS_READFILE</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>should_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>tuplen</name> <operator>=</operator> <call><name>getlen</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>READTUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* CDB XXX XXX XXX XXX */</comment>
					<comment type="block">/* MPP-1347: EXPLAIN ANALYZE shows runaway memory usage.
					 * Readtup does a usemem, but the free happens in
					 * ExecStoreTuple.  Do a free so state-&gt;availMem
					 * doesn't go massively negative to screw up
					 * stats.  It would be better to interrogate the
					 * heap for actual memory usage than use this
					 * homemade accounting.
					 */</comment>
					<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<comment type="block">/* CDB XXX XXX XXX XXX */</comment>
					<return>return <expr><name>tup</name></expr>;</return>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Backward.
			 *
			 * if all tuples are fetched already then we return last tuple,
			 * else tuple before last returned.
			 *
			 * Back up to fetch previously-returned tuple's ending length
			 * word. If seek fails, assume we are at start of file.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>-</operator><operator>(</operator><name>long</name><operator>)</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator></expr></argument>,
							<argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* even a failed backwards fetch gets you out of eof state */</comment>
				<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>truncated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>NULL</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>getlen</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
				<comment type="block">/* We will return the tuple returned before returning NULL */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Back up to get ending length word of tuple before it.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
								<argument><expr><operator>-</operator><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>tuplen</name> <operator>+</operator> <literal type="number">2</literal> <operator>*</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>)</operator></expr></argument>,
								<argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/*
					 * If that fails, presumably the prev tuple is the first
					 * in the file.  Back up so that it becomes next to read
					 * in forward direction (not obviously right, but that is
					 * what in-memory case does).
					 */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
									<argument><expr><operator>-</operator><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>tuplen</name> <operator>+</operator> sizeof<operator>(</operator><name>unsigned</name> <name>int</name><operator>)</operator><operator>)</operator></expr></argument>,
									<argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>truncated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><name>NULL</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>tuplen</name> <operator>=</operator> <call><name>getlen</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Now we have the length of the prior tuple, back up and read it.
			 * Note: READTUP expects we are positioned after the initial
			 * length word of the tuple, so back up to that point.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
							<argument><expr><operator>-</operator><operator>(</operator><name>long</name><operator>)</operator> <name>tuplen</name></expr></argument>,
							<argument><expr><name>SEEK_CUR</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>READTUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>tup</name></expr>;</return>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplestore state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>		<comment type="block">/* keep compiler quiet */</comment>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_gettupleslot - exported function to fetch a MinimalTuple
 *
 * If successful, put tuple in slot and return true; else, clear the slot
 * and return false.
 *
 * If copy is true, the slot receives a copied tuple (allocated in current
 * memory context) that will stay valid regardless of future manipulations of
 * the tuplestore's state.  If copy is false, the slot may just receive a
 * pointer to a tuple held within the tuplestore.  The latter is more
 * efficient but the slot contents may be corrupted if additional writes to
 * the tuplestore occur.  (If using tuplestore_trim, see comments therein.)
 */</comment>
<function><type><name>bool</name></type>
<name>tuplestore_gettupleslot</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>,
						<parameter><decl><type><name>bool</name></type> <name>copy</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>tuplestore_gettuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tuple</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>copy</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>should_free</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_copy_minimal_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>should_free</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ExecStoreMinimalTuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ExecClearTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_advance - exported function to adjust position without fetching
 *
 * We could optimize this case to avoid palloc/pfree overhead, but for the
 * moment it doesn't seem worthwhile.
 */</comment>
<function><type><name>bool</name></type>
<name>tuplestore_advance</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>should_free</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>tuplestore_gettuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tuple</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Advance over N tuples in either forward or back direction,
 * without returning any data.  N&lt;=0 is a no-op.
 * Returns true if successful, false if ran out of tuples.
 */</comment>
<function><type><name>bool</name></type>
<name>tuplestore_skiptuples</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>ntuples</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>forward</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>readptr</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>forward</name> <operator>||</operator> <operator>(</operator><name><name>readptr</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_BACKWARD</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ntuples</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_INMEM</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>forward</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>-</operator> <name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>&gt;=</operator> <name>ntuples</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>+=</operator> <name>ntuples</name></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>ntuples</name><operator>--</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>-</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name> <operator>&gt;</operator> <name>ntuples</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>-=</operator> <name>ntuples</name></expr>;</expr_stmt>
					<return>return <expr><name>true</name></expr>;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>truncated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* We don't currently try hard to optimize other cases */</comment>
			<while>while <condition>(<expr><name>ntuples</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>should_free</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>tuplestore_gettuple</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>forward</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>should_free</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>tuple</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>should_free</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></while>
			<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * dumptuples - remove tuples from memory and write to tape
 *
 * As a side effect, we must convert each read pointer's position from
 * "current" to file/offset format.  But eof_reached pointers don't
 * need to change state.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dumptuples</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name></expr>;</init><condition>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>readptr</name> <init>= <expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>;</condition> <incr><expr><name>readptr</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>BufFileTell</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>readptr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>readptr</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>WRITETUP</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_rescan		- rewind the active read pointer to start
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_rescan</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>readptr</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>readptr</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_REWIND</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>truncated</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_INMEM</name></expr>:</case>
			<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>current</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSS_WRITEFILE</name></expr>:</case>
			<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>file</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>offset</name></name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>TSS_READFILE</name></expr>:</case>
			<expr_stmt><expr><name><name>readptr</name><operator>-&gt;</operator><name>eof_reached</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0L</literal></expr></argument>, <argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplestore state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_copy_read_pointer - copy a read pointer's state to another
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_copy_read_pointer</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>srcptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>destptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>sptr</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name>srcptr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSReadPointer</name> <modifier>*</modifier></type><name>dptr</name> <init>= <expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name>destptr</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>srcptr</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>srcptr</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>destptr</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>destptr</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assigning to self is a no-op */</comment>
	<if_stmt><if>if <condition>(<expr><name>srcptr</name> <operator>==</operator> <name>destptr</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>dptr</name><operator>-&gt;</operator><name>eflags</name></name> <operator>!=</operator> <name><name>sptr</name><operator>-&gt;</operator><name>eflags</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Possible change of overall eflags, so copy and then recompute */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>dptr</name> <operator>=</operator> <operator>*</operator><name>sptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>eflags</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>eflags</name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>eflags</name> <operator>|=</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eflags</name></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>eflags</name></name> <operator>=</operator> <name>eflags</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>dptr</name> <operator>=</operator> <operator>*</operator><name>sptr</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<switch>switch <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TSS_INMEM</name></expr>:</case>
		<case>case <expr><name>TSS_WRITEFILE</name></expr>:</case>
			<comment type="block">/* no work */</comment>
			<break>break;</break>
		<case>case <expr><name>TSS_READFILE</name></expr>:</case>

			<comment type="block">/*
			 * This case is a bit tricky since the active read pointer's
			 * position corresponds to the seek point, not what is in its
			 * variables.  Assigning to the active requires a seek, and
			 * assigning from the active requires a tell, except when
			 * eof_reached.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>destptr</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>dptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>writepos_file</name></name></expr></argument>,
									<argument><expr><name><name>state</name><operator>-&gt;</operator><name>writepos_offset</name></name></expr></argument>,
									<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><call><name>BufFileSeek</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
									<argument><expr><name><name>dptr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>, <argument><expr><name><name>dptr</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>,
									<argument><expr><name>SEEK_SET</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not seek in tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>srcptr</name> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>activeptr</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>dptr</name><operator>-&gt;</operator><name>eof_reached</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>BufFileTell</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>dptr</name><operator>-&gt;</operator><name>file</name></name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name><name>dptr</name><operator>-&gt;</operator><name>offset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid tuplestore state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_trim	- remove all no-longer-needed tuples
 *
 * Calling this function authorizes the tuplestore to delete all tuples
 * before the oldest read pointer, if no read pointer is marked as requiring
 * REWIND capability.
 *
 * Note: this is obviously safe if no pointer has BACKWARD capability either.
 * If a pointer is marked as BACKWARD but not REWIND capable, it means that
 * the pointer can be moved backward but not before the oldest other read
 * pointer.
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_trim</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nremove</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Truncation is disallowed if any read pointer requires rewind
	 * capability.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>eflags</name></name> <operator>&amp;</operator> <name>EXEC_FLAG_REWIND</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cannot trim tuplestore if another process might be reading it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>frozen</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We don't bother trimming temp files since it usually would mean more
	 * work than just letting them sit in kernel buffers until they age out.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>!=</operator> <name>TSS_INMEM</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Find the oldest read pointer */</comment>
	<expr_stmt><expr><name>oldest</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eof_reached</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>oldest</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>oldest</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Note: you might think we could remove all the tuples before the oldest
	 * "current", since that one is the next to be returned.  However, since
	 * tuplestore_gettuple returns a direct pointer to our internal copy of
	 * the tuple, it's likely that the caller has still got the tuple just
	 * before "current" referenced in a slot. So we keep one extra tuple
	 * before the oldest "current".  (Strictly speaking, we could require such
	 * callers to use the "copy" flag to tuplestore_gettupleslot, but for
	 * efficiency we allow this one case to not use "copy".)
	 */</comment>
	<expr_stmt><expr><name>nremove</name> <operator>=</operator> <name>oldest</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nremove</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* nothing to do */</comment>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nremove</name> <operator>&gt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nremove</name> <operator>&lt;=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release no-longer-needed tuples */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nremove</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name> <operator>=</operator> <name>nremove</name></expr>;</expr_stmt>

	<comment type="block">/* mark tuplestore as truncated (used for Assert crosschecks only) */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>truncated</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If nremove is less than 1/8th memtupcount, just stop here, leaving the
	 * "deleted" slots as NULL.  This prevents us from expending O(N^2) time
	 * repeatedly memmove-ing a large pointer array.  The worst case space
	 * wastage is pretty small, since it's just pointers and not whole tuples.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nremove</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>/</operator> <literal type="number">8</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Slide the array down and readjust pointers.
	 *
	 * In mergejoin's current usage, it's demonstrable that there will always
	 * be exactly one non-removed tuple; so optimize that case.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nremove</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>memtuples</name><index>[<expr><name>nremove</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>memtuples</name></name> <operator>+</operator> <name>nremove</name></expr></argument>,
				<argument><expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>-</operator> <name>nremove</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupdeleted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>memtupcount</name></name> <operator>-=</operator> <name>nremove</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>readptrcount</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>eof_reached</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>current</name> <operator>-=</operator> <name>nremove</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_in_memory
 *
 * Returns true if the tuplestore has not spilled to disk.
 *
 * XXX exposing this is a violation of modularity ... should get rid of it.
 */</comment>
<function><type><name>bool</name></type>
<name>tuplestore_in_memory</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TSS_INMEM</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Tape interface routines
 */</comment>

<function><type><specifier>static</specifier> <name>unsigned</name> <name>int</name></type>
<name>getlen</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>eofOK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>nbytes</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nbytes</name> <operator>=</operator> <call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>len</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>==</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>len</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nbytes</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator> <operator>!</operator><name>eofOK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Routines specialized for HeapTuple case
 *
 * The stored form is actually a MinimalTuple, but for largely historical
 * reasons we allow COPYTUP to work from a HeapTuple.
 *
 * Since MinimalTuple already has length in its first word, we don't need
 * to write that separately.
 */</comment>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>copytup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>minimal_tuple_from_heap_tuple</name><argument_list>(<argument><expr><operator>(</operator><name>HeapTuple</name><operator>)</operator> <name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writetup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><operator>(</operator><name>MinimalTuple</name><operator>)</operator> <name>tup</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the part of the MinimalTuple we'll write: */</comment>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tupbody</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>MINIMAL_TUPLE_DATA_OFFSET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tupbodylen</name> <init>= <expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>-</operator> <name>MINIMAL_TUPLE_DATA_OFFSET</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* total on-disk footprint: */</comment>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name> <init>= <expr><name>tupbodylen</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tuplen</name></expr></argument>,
					 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tupbody</name></expr></argument>,
					 <argument><expr><name>tupbodylen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>tupbodylen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>backward</name></name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* need trailing length word? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufFileWrite</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tuplen</name></expr></argument>,
						 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not write to tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>Size</name></type>		<name>memsize</name> <init>= <expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>spilledBytes</name></name> <operator>+=</operator> <name>memsize</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FREEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><name>memsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>heap_free_minimal_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>readtup_heap</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tupbodylen</name> <init>= <expr><name>len</name> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>tuplen</name> <init>= <expr><name>tupbodylen</name> <operator>+</operator> <name>MINIMAL_TUPLE_DATA_OFFSET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MinimalTuple</name></type> <name>tuple</name> <init>= <expr><operator>(</operator><name>MinimalTuple</name><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tupbody</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>tuple</name> <operator>+</operator> <name>MINIMAL_TUPLE_DATA_OFFSET</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>USEMEM</name><argument_list>(<argument><expr><name>state</name></expr></argument>, <argument><expr><call><name>GetMemoryChunkSpace</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* read in the tuple proper */</comment>
	<expr_stmt><expr><name><name>tuple</name><operator>-&gt;</operator><name>t_len</name></name> <operator>=</operator> <name>tuplen</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tupbody</name></expr></argument>,
					<argument><expr><name>tupbodylen</name></expr></argument>)</argument_list></call> <operator>!=</operator> <operator>(</operator><name>size_t</name><operator>)</operator> <name>tupbodylen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>state</name><operator>-&gt;</operator><name>backward</name></name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* need trailing length word? */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>BufFileRead</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>tuplen</name></expr></argument>,
						<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>!=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>tuplen</name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not read from tuplestore temporary file: %m"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>tuple</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_set_instrument
 *
 * May be called after tuplestore_begin_xxx() to enable reporting of
 * statistics and events for EXPLAIN ANALYZE.
 *
 * The 'instr' ptr is retained in the 'state' object.  The caller must
 * ensure that it remains valid for the life of the Tuplestorestate object.
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_set_instrument</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>,
						  <parameter><decl><type><name><name>struct</name> <name>Instrumentation</name></name> <modifier>*</modifier></type><name>instrument</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>instrument</name></name> <operator>=</operator> <name>instrument</name></expr>;</expr_stmt>
</block_content>}</block></function>                               <comment type="block">/* tuplestore_set_instrument */</comment>


<comment type="block">/* Extra GPDB functions for sharing tuplestores across processes */</comment>

<comment type="block">/*
 * tuplestore_make_shared
 *
 * Make a tuplestore available for sharing later. This must be called
 * immediately after tuplestore_begin_heap().
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_make_shared</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>SharedFileSet</name> <modifier>*</modifier></type><name>fileset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>work_set</name></name> <operator>=</operator> <call><name>workfile_mgr_create_set</name><argument_list>(<argument><expr><literal type="string">"SharedTupleStore"</literal></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>true</name></expr></argument> <comment type="block">/* hold pin */</comment>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>==</operator> <name>TSS_INMEM</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>tuples</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>share_status</name></name> <operator>==</operator> <name>TSHARE_NOT_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>share_status</name></name> <operator>=</operator> <name>TSHARE_WRITER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fileset</name></name> <operator>=</operator> <name>fileset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>shared_filename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Switch to tape-based operation, like in tuplestore_puttuple_common().
	 * We could delay this until tuplestore_freeze(), but we know we'll have
	 * to write everything to the file anyway, so let's not waste memory
	 * buffering the tuples in the meanwhile.
	 */</comment>
	<expr_stmt><expr><call><name>PrepareTempTablespaces</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* associate the file with the store's resource owner */</comment>
	<expr_stmt><expr><name>oldowner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name><name>state</name><operator>-&gt;</operator><name>resowner</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name> <operator>=</operator> <call><name>BufFileCreateShared</name><argument_list>(<argument><expr><name>fileset</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>work_set</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * For now, be conservative and always use trailing length words for
	 * cross-process tuplestores. It's important that the writer and the
	 * reader processes agree on this, and forcing it to true is the
	 * simplest way to achieve that.
	 */</comment>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_WRITEFILE</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>writetup_forbidden</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cannot write to tuplestore, it is already frozen"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_freeze
 *
 * Flush the current buffer to disk, and forbid further inserts. This
 * prepares the tuplestore for reading from a different process.
 */</comment>
<function><type><name>void</name></type>
<name>tuplestore_freeze</name><parameter_list>(<parameter><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>share_status</name></name> <operator>==</operator> <name>TSHARE_WRITER</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>state</name><operator>-&gt;</operator><name>frozen</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dumptuples</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>BufFileExportShared</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>frozen</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * tuplestore_open_shared
 *
 * Open a shared tuplestore that has been populated in another process
 * for reading.
 */</comment>
<function><type><name>Tuplestorestate</name> <modifier>*</modifier></type>
<name>tuplestore_open_shared</name><parameter_list>(<parameter><decl><type><name>SharedFileSet</name> <modifier>*</modifier></type><name>fileset</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Tuplestorestate</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>eflags</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>eflags</name> <operator>=</operator> <name>EXEC_FLAG_BACKWARD</name> <operator>|</operator> <name>EXEC_FLAG_REWIND</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <call><name>tuplestore_begin_common</name><argument_list>(<argument><expr><name>eflags</name></expr></argument>,
									<argument><expr><name>false</name></expr></argument> <comment type="block">/* interXact, ignored because we open existing files */</comment>,
									<argument><expr><literal type="number">10</literal></expr></argument> <comment type="block">/* no need for memory buffers */</comment>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>backward</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>copytup</name></name> <operator>=</operator> <name>copytup_heap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>writetup</name></name> <operator>=</operator> <name>writetup_forbidden</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readtup</name></name> <operator>=</operator> <name>readtup_heap</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>myfile</name></name> <operator>=</operator> <call><name>BufFileOpenShared</name><argument_list>(<argument><expr><name>fileset</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>file</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>readptrs</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>offset</name> <operator>=</operator> <literal type="number">0L</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>status</name></name> <operator>=</operator> <name>TSS_READFILE</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>share_status</name></name> <operator>=</operator> <name>TSHARE_READER</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>frozen</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>fileset</name></name> <operator>=</operator> <name>fileset</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>shared_filename</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>state</name></expr>;</return>
</block_content>}</block></function>
</unit>
