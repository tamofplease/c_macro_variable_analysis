<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/hyperloglog/gp_hyperloglog.c"><comment type="block">/*
 * Copyright 2012, Tomas Vondra (tv@fuzzy.cz). All rights reserved.
 * Copyright 2015, Conversant, Inc. All rights reserved.
 * Copyright 2018, VMware, Inc. or its affiliates. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this list of
 * conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice, this list
 * of conditions and the following disclaimer in the documentation and/or other materials
 * provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY TOMAS VONDRA, CONVERSANT INC, VMWARE, INC. OF ITS AFFILIATES.
 * AND ANY OTHER CONTRIBUTORS (THE "AUTHORS") ''AS IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT,
 * INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR
 * BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
 * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * Authors and should not be interpreted as representing official policies, either expressed
 * or implied, of the Authors.
 */</comment>

<comment type="block">/*
 * 07/26/2018
 *
 * We have updated, removed and modified the content of this file.
 *
 * 	1. We have removed some function definitions in as we did not need
 * 	them for implementing incremental analyze.
 * 	2. We modified utility function definitions as most of them are used in the
 * 	code internally and not exposed to the user.Function parameters are
 * 	no longer as the type of `PG_FUNCTION_ARGS` and extracted in the
 * 	function body, but only passed by the caller as it is.
 *	3. We kept the definitions of user facing functions that are necessary for
 * 	full scan incremental analyze.
 * 	4. We abondoned the sparse represenation of the hyperloglog and for
 *  simplicity this version only supports dense represenation.
 */</comment>


<comment type="block">/* This file contains internal functions and several functions exposed to the
 * outside via gp_hyperloglog.h. The functions are for the manipulation/creation/
 * evaluation of GpHLLCounters that are necessary for implementing incremental
 * analyze in GPDB. This file is modified from its original content and we removed
 * the code that was unnecessary for our purpose.
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdlib.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;assert.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;string.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/base64.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/pg_lzcompress.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/bytea.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hyperloglog/gp_hyperloglog.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GPHLLDATARAWSIZE</name><parameter_list>(<parameter><type><name>hloglog</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(POW2(hloglog-&gt;b))</cpp:value></cpp:define>

<comment type="block">/* ------------- function declarations for local functions --------------- */</comment>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>gp_hll_estimate_dense</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>gp_error_estimate</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>E</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GpHLLCounter</name></type> <name>gp_hll_add_hash_dense</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>hash</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GpHLLCounter</name></type> <name>gp_hll_compress_dense</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GpHLLCounter</name></type> <name>gp_hll_compress_dense_unpacked</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GpHLLCounter</name></type> <name>gp_hll_decompress_unpacked</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GpHLLCounter</name></type> <name>gp_hll_decompress_dense</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GpHLLCounter</name></type> <name>gp_hll_decompress_dense_unpacked</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ---------------------- function definitions --------------------------- */</comment>

<function><type><name>GpHLLCounter</name></type>
<name>gp_hll_unpack</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list><block>{<block_content>

	<decl_stmt><decl><type><name>char</name></type> <name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>data_rawsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>htemp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>UNPACKED</name> <operator>||</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>UNPACKED_UNPACKED</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* use decompress to handle compressed unpacking */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>gp_hll_decompress_unpacked</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* set format to unpacked*/</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>PACKED_UNPACKED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>UNPACKED_UNPACKED</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>PACKED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>UNPACKED</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Allocate and zero an array large enough to hold all the decompressed
	 * bins
	 */</comment>
	<expr_stmt><expr><name>data_rawsize</name> <operator>=</operator> <call><name>GPHLLDATARAWSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>htemp</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>data_rawsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>htemp</name></expr></argument>, <argument><expr><name>hloglog</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>data_rawsize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
		<expr_stmt><expr><call><name>GP_HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>htemp</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name>hloglog</name> <operator>=</operator> <name>htemp</name></expr>;</expr_stmt>

	<comment type="block">/* set the varsize to the appropriate length  */</comment>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>data_rawsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>GpHLLCounter</name></type>
<name>gp_hll_decompress_unpacked</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* make sure the data is compressed */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>hloglog</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>hloglog</name> <operator>=</operator> <call><name>gp_hll_decompress_dense_unpacked</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Decompresses dense counters */</comment>
<function><type><specifier>static</specifier> <name>GpHLLCounter</name></type>
<name>gp_hll_decompress_dense_unpacked</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type> <name>data_rawsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>htemp</name></decl>;</decl_stmt>

	<comment type="block">/* reset b to positive value for calcs and to indicate data is
	* decompressed */</comment>
	<expr_stmt><expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>*</operator> <operator>(</operator><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>UNPACKED</name></expr>;</expr_stmt>

	<comment type="block">/* allocate and zero an array large enough to hold all the decompressed
	* bins */</comment>
	<expr_stmt><expr><name>data_rawsize</name> <operator>=</operator> <call><name>GPHLLDATARAWSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>htemp</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>data_rawsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>htemp</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>data_rawsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>htemp</name></expr></argument>, <argument><expr><name>hloglog</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* decompress the data */</comment>
	<expr_stmt><expr><call><name>pglz_decompress</name><argument_list>(<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>htemp</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>data_rawsize</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hloglog</name> <operator>=</operator> <name>htemp</name></expr>;</expr_stmt>

	<comment type="block">/* set the varsize to the appropriate length  */</comment>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>data_rawsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* Allocate HLL estimator that can handle the desired cartinality and
 * precision.
 * 
 * parameters:
 *      ndistinct   - cardinality the estimator should handle
 *      error       - requested error rate (0 - 1, where 0 means 'exact')
 * 
 * returns:
 *      instance of HLL estimator (throws ERROR in case of failure)
 */</comment>
<function><type><name>GpHLLCounter</name></type>
<name>gp_hll_create</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>ndistinct</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>error</name></decl></parameter>, <parameter><decl><type><name>uint8_t</name></type> <name>format</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <decl_stmt><decl><type><name>float</name></type> <name>m</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>p</name></decl>;</decl_stmt>
    
    <comment type="block">/* target error rate needs to be between 0 and 1 */</comment>
    <if_stmt><if>if <condition>(<expr><name>error</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>error</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid error rate requested - only values in (0,1) allowed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>MIN_BINBITS</name> <operator>&gt;=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>ceil</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><name>ndistinct</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <name>MAX_BINBITS</name> <operator>&lt;=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>ceil</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><name>ndistinct</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"invalid ndstinct - must be between 257 and 1.1579 * 10^77"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt> 

    <comment type="block">/* the counter is allocated as part of this memory block  */</comment>
    <expr_stmt><expr><name>length</name> <operator>=</operator> <call><name>gp_hll_get_size</name><argument_list>(<argument><expr><name>ndistinct</name></expr></argument>, <argument><expr><name>error</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>p</name> <operator>=</operator> <operator>(</operator><name>GpHLLCounter</name><operator>)</operator><call><name>palloc0</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set the counter struct version */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>version</name></name> <operator>=</operator> <name>STRUCT_VERSION</name></expr>;</expr_stmt>

	<comment type="block">/* set the format to 0 for bitpacked*/</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>format</name></expr>;</expr_stmt>

    <comment type="block">/* what is the minimum number of bins to achieve the requested error rate?
     *  we'll increase this to the nearest power of two later */</comment>
    <expr_stmt><expr><name>m</name> <operator>=</operator> <name>ERROR_CONST</name> <operator>/</operator> <operator>(</operator><name>error</name> <operator>*</operator> <name>error</name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* so how many bits do we need to index the bins (round up to nearest
     * power of two) */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>ceil</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* set the number of bits per bin */</comment>
    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>binbits</name></name> <operator>=</operator> <operator>(</operator><name>uint8_t</name><operator>)</operator><call><name>ceil</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><name>ndistinct</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>idx</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>b</name></name> <operator>&lt;</operator> <name>MIN_INDEX_BITS</name></expr>)</condition><block type="pseudo"><block_content>   <comment type="block">/* we want at least 2^4 (=16) bins */</comment>
        <expr_stmt><expr><name><name>p</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <name>MIN_INDEX_BITS</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name><name>p</name><operator>-&gt;</operator><name>b</name></name> <operator>&gt;</operator> <name>MAX_INDEX_BITS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"number of index bits exceeds MAX_INDEX_BITS (requested %d)"</literal></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>p</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/* Performs a simple 'copy' of the counter, i.e. allocates a new counter and
 * copies the state from the supplied one. */</comment>
<function><type><name>GpHLLCounter</name></type>
<name>gp_hll_copy</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>counter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    
    <decl_stmt><decl><type><name>size_t</name></type> <name>length</name> <init>= <expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>counter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>copy</name> <init>= <expr><operator>(</operator><name>GpHLLCounter</name><operator>)</operator><call><name>palloc</name><argument_list>(<argument><expr><name>length</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
    
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><name>counter</name></expr></argument>, <argument><expr><name>length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <return>return <expr><name>copy</name></expr>;</return>

</block_content>}</block></function>

<comment type="block">/* Merges the two estimators. Either modifies the first estimator in place
 * (inplace=true), or creates a new copy and returns that (inplace=false).
 * Modification in place is very handy in aggregates, when we really want to
 * modify the aggregate state in place.
 * 
 * Merging is only possible if the counters share the same parameters (number
 * of bins, bin size, ...). If the counters don't match, this throws an ERROR.
 *  */</comment>
<function><type><name>GpHLLCounter</name></type>
<name>gp_hll_merge</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>counter1</name></decl></parameter>, <parameter><decl><type><name>GpHLLCounter</name></type> <name>counter2</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>result</name> <init>= <expr><name>counter1</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>upper_bound</name> <init>= <expr><call><name>POW2</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check compatibility first */</comment>
	<comment type="line">//if (counter1-&gt;b != counter2-&gt;b &amp;&amp; -1*counter1-&gt;b != counter2-&gt;b)</comment>
	<comment type="line">//elog(ERROR, "index size of estimators differs (%d != %d)", counter1-&gt;b, counter2-&gt;b);</comment>
	<comment type="line">//else if (counter1-&gt;binbits != counter2-&gt;binbits)</comment>
	<comment type="line">//elog(ERROR, "bin size of estimators differs (%d != %d)", counter1-&gt;binbits, counter2-&gt;binbits);</comment>


	<comment type="block">/* Keep the maximum register value for each bin */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>upper_bound</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">1</literal></expr></incr>)</control><block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>counter2</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>&gt;</operator> <name><name>result</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr> ?</condition><then> <expr><name><name>counter2</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr> </then><else>: <expr><name><name>result</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>i</name></expr>]</index></name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Computes size of the structure, depending on the requested error rate and
 * ndistinct. */</comment>
<function><type><name>int</name></type> 
<name>gp_hll_get_size</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>ndistinct</name></decl></parameter>, <parameter><decl><type><name>float</name></type> <name>error</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <decl_stmt><decl><type><name>int</name></type> <name>b</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>float</name></type> <name>m</name></decl>;</decl_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>error</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>error</name> <operator>&gt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid error rate requested"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <expr_stmt><expr><name>m</name> <operator>=</operator> <name>ERROR_CONST</name> <operator>/</operator> <operator>(</operator><name>error</name> <operator>*</operator> <name>error</name><operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>b</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ceil</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><name>m</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    
    <if_stmt><if>if <condition>(<expr><name>b</name> <operator>&lt;</operator> <name>MIN_INDEX_BITS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><name>b</name> <operator>=</operator> <name>MIN_INDEX_BITS</name></expr>;</expr_stmt></block_content></block></if>
    <if type="elseif">else if <condition>(<expr><name>b</name> <operator>&gt;</operator> <name>MAX_INDEX_BITS</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"number of index bits exceeds MAX_INDEX_BITS (requested %d)"</literal></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    
    <comment type="block">/* The size is the sum of the struct overhead and the bytes the used to 
     * store the buckets. Which is the product of the number of buckets and
     *  the (bits per bucket)/ 8 where 8 is the amount of bits per byte.
     *  
     *  size_in_bytes = struct_overhead + num_buckets*(bits_per_bucket/8)
     *
     * */</comment>  
    <return>return <expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><call><name>ceil</name><argument_list>(<argument><expr><call><name>POW2</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>ceil</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><call><name>log2</name><argument_list>(<argument><expr><name>ndistinct</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">8.0</literal><operator>)</operator></expr>;</return>

</block_content>}</block></function>

<comment type="block">/* Hyperloglog estimate header function */</comment>
<function><type><name>double</name></type> 
<name>gp_hll_estimate</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>E</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    
	<expr_stmt><expr><name>E</name> <operator>=</operator> <call><name>gp_hll_estimate_dense</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>E</name></expr>;</return>
</block_content>}</block></function>
<comment type="block">/*
 * Computes the HLL estimate, as described in the paper.
 * 
 * In short it does these steps:
 * 
 * 1) sums the data in counters (1/2^m[i])
 * 2) computes the raw estimate E
 * 3) corrects the estimate for low values
 * 
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>gp_hll_estimate_dense</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>H</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>E</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>j</name></decl>, <decl><type ref="prev"/><name>V</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>m</name> <init>= <expr><call><name>POW2</name><argument_list>(<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* compute the sum for the harmonic mean */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name> <operator>&lt;=</operator> <name>MAX_PRECOMPUTED_EXPONENTS_BINWIDTH</name></expr>)</condition><block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>m</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
			<expr_stmt><expr><name>H</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>hloglog</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else <block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>m</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
			<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>&lt;=</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&amp;&amp;</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>j</name></expr>]</index></name> <operator>&lt;</operator> <name>NUM_OF_PRECOMPUTED_EXPONENTS</name></expr>)</condition><block>{<block_content>
				<expr_stmt><expr><name>H</name> <operator>+=</operator> <name><name>PE</name><index>[<expr><operator>(</operator><name>int</name><operator>)</operator><name><name>hloglog</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>j</name></expr>]</index></name></expr>]</index></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else <block>{<block_content>
				<expr_stmt><expr><name>H</name> <operator>+=</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">0.5</literal></expr></argument>, <argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* multiple by constants to turn the mean into an estimate */</comment>
	<expr_stmt><expr><name>E</name> <operator>=</operator> <name><name>alpham</name><index>[<expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name></expr>]</index></name> <operator>/</operator> <name>H</name></expr>;</expr_stmt>

	<comment type="block">/* correct for hyperloglog's low cardinality bias by either using linear
	*  counting or error estimation */</comment>
	<if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;=</operator> <operator>(</operator><literal type="number">5.0</literal> <operator>*</operator> <name>m</name><operator>)</operator></expr>)</condition> <block>{<block_content>

		<comment type="block">/* account for hloglog low cardinality bias */</comment>
		<expr_stmt><expr><name>E</name> <operator>=</operator> <name>E</name> <operator>-</operator> <call><name>gp_error_estimate</name><argument_list>(<argument><expr><name>E</name></expr></argument>, <argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* search for empty registers for linear counting */</comment>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>m</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name><index>[<expr><name>j</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
				<expr_stmt><expr><name>V</name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Don't use linear counting if there are no empty registers since we
		* don't to divide by 0 */</comment>
		<if_stmt><if>if <condition>(<expr><name>V</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block>{<block_content>
			<expr_stmt><expr><name>H</name> <operator>=</operator> <name>m</name> <operator>*</operator> <call><name>log</name><argument_list>(<argument><expr><name>m</name> <operator>/</operator> <operator>(</operator><name>float</name><operator>)</operator><name>V</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else <block>{<block_content>
			<expr_stmt><expr><name>H</name> <operator>=</operator> <name>E</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<comment type="block">/* if the estimated cardinality is below the threshold for a specific
		* accuracy return the linear counting result otherwise use the error
		* corrected version */</comment>
		<if_stmt><if>if <condition>(<expr><name>H</name> <operator>&lt;=</operator> <name><name>threshold</name><index>[<expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name></expr>]</index></name></expr>)</condition> <block>{<block_content>
			<expr_stmt><expr><name>E</name> <operator>=</operator> <name>H</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>E</name></expr>;</return>

</block_content>}</block></function>


<comment type="block">/* Estimates the error from hyperloglog's low cardinality bias and by taking
 * a simple linear regression of the nearest 6 points */</comment>
<function><type><specifier>static</specifier> <name>double</name></type> 
<name>gp_error_estimate</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>E</name></decl></parameter>,<parameter><decl><type><name>int</name></type> <name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>double</name></type> <name>avg</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>beta</name></decl>,<decl><type ref="prev"/><name>alpha</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>double</name></type> <name>sx</name></decl>,<decl><type ref="prev"/><name>sxx</name></decl>,<decl><type ref="prev"/><name>sxy</name></decl>,<decl><type ref="prev"/><name>sy</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>idx</name></decl>, <decl><type ref="prev"/><name>max</name><init>=<expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

    <comment type="block">/* get the number of interpoloation points for that precision */</comment>
    <if_stmt><if>if <condition>(<expr><name>b</name> <operator>&gt;</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <name>b</name> <operator>&lt;=</operator> <literal type="number">18</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>max</name> <operator>=</operator> <name>MAX_INTERPOLATION_POINTS</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">5</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>max</name> <operator>=</operator> <name>PRECISION_5_MAX_INTERPOLATION_POINTS</name></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name>b</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>max</name> <operator>=</operator> <name>PRECISION_4_MAX_INTERPOLATION_POINTS</name></expr>;</expr_stmt>
    </block_content>}</block></if> <else>else <block>{<block_content>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"ERROR: parameter b (%d) is out of range (4-18)"</literal></expr></argument>,<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></else></if_stmt>

    <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>max</name></expr>;</expr_stmt>

    <comment type="block">/* find the index of the first interpolation point greater than the 
     * uncorrected estimate */</comment>
    <for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>max</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <if_stmt><if>if <condition>(<expr><name>E</name> <operator>&lt;</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
            <break>break;</break>
        </block_content>}</block></if></if_stmt>
    </block_content>}</block></for>

    <comment type="block">/* make sure array indexes will be inbounds when getting 6 nearest data
     * points */</comment>
    <if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&lt;</operator> <literal type="number">3</literal></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
    </block_content>}</block></if> <if type="elseif">else if <condition>( <expr><name>idx</name> <operator>&gt;</operator> <name>max</name> <operator>-</operator> <literal type="number">2</literal></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><name>idx</name> <operator>=</operator> <name>max</name> <operator>-</operator> <literal type="number">2</literal></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* calculate the alpha and beta needed to interpolate the error correction
     * for E */</comment>
    <expr_stmt><expr><name>sx</name> <operator>=</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sxx</name> <operator>=</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>*</operator><name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>*</operator><name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name><operator>*</operator><name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>*</operator><name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>*</operator><name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name><operator>*</operator><name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt> 
    <expr_stmt><expr><name>sy</name> <operator>=</operator> <name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name> <operator>+</operator> <name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>sxy</name> <operator>=</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name><operator>*</operator><name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name><operator>*</operator><name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>+</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name><operator>*</operator><name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name><operator>*</operator><name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name><operator>*</operator><name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">2</literal></expr>]</index></name> <operator>+</operator> <name><name>rawEstimateData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name><operator>*</operator><name><name>biasData</name><index>[<expr><name>b</name><operator>-</operator><literal type="number">4</literal></expr>]</index><index>[<expr><name>idx</name><operator>-</operator><literal type="number">3</literal></expr>]</index></name></expr>;</expr_stmt>
    <expr_stmt><expr><name>beta</name> <operator>=</operator> <operator>(</operator><literal type="number">6.0</literal><operator>*</operator><name>sxy</name> <operator>-</operator> <name>sx</name><operator>*</operator><name>sy</name> <operator>)</operator> <operator>/</operator> <operator>(</operator> <literal type="number">6.0</literal><operator>*</operator><name>sxx</name> <operator>-</operator> <name>sx</name><operator>*</operator><name>sx</name> <operator>)</operator></expr>;</expr_stmt>
    <expr_stmt><expr><name>alpha</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal><operator>/</operator><literal type="number">6.0</literal><operator>)</operator><operator>*</operator><name>sy</name> <operator>-</operator> <name>beta</name><operator>*</operator><operator>(</operator><literal type="number">1.0</literal><operator>/</operator><literal type="number">6.0</literal><operator>)</operator><operator>*</operator><name>sx</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>avg</name> <operator>=</operator> <name>alpha</name> <operator>+</operator> <name>E</name><operator>*</operator><name>beta</name></expr>;</expr_stmt>

    <return>return <expr><name>avg</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add element header function */</comment>
<function><type><name>GpHLLCounter</name></type>
<name>gp_hll_add_element</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>element</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>elen</name></decl></parameter>)</parameter_list>
<block>{<block_content>

    <decl_stmt><decl><type><name>uint64_t</name></type> <name>hash</name></decl>;</decl_stmt>

    <comment type="block">/* compute the hash */</comment>
    <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>GpMurmurHash64A</name><argument_list>(<argument><expr><name>element</name></expr></argument>, <argument><expr><name>elen</name></expr></argument>, <argument><expr><name>HASH_SEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>    

    <comment type="block">/* add the hash to the estimator */</comment>
    <expr_stmt><expr><name>hloglog</name> <operator>=</operator> <call><name>gp_hll_add_hash_dense</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>, <argument><expr><name>hash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Add the appropriate values to a dense encoded counter for a given hash */</comment>
<function><type><specifier>static</specifier> <name>GpHLLCounter</name></type>
<name>gp_hll_add_hash_dense</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>, <parameter><decl><type><name>uint64_t</name></type> <name>hash</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>idx</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint8_t</name></type> <name>rho</name></decl>,<decl><type ref="prev"/><name>entry</name></decl>,<decl><type ref="prev"/><name>addn</name></decl>;</decl_stmt>

    <comment type="block">/* get idx (keep only the first 'b' bits) */</comment>
    <expr_stmt><expr><name>idx</name>  <operator>=</operator> <name>hash</name> <operator>&gt;&gt;</operator> <operator>(</operator><name>HASH_LENGTH</name> <operator>-</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* rho needs to be independent from 'idx' */</comment>
    <expr_stmt><expr><name>rho</name> <operator>=</operator> <call><name>__builtin_clzll</name><argument_list>(<argument><expr><name>hash</name> <operator>&lt;&lt;</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

    <comment type="block">/* We only have (64 - hloglog-&gt;b) bits leftover after the index bits
     * however the chance that we need more is 2^-(64 - hloglog-&gt;b) which
     * is very small. So we only compute more when needed. To do this we
     * rehash the original hash and take the rho of the new hash and add it
     * to the (64 - hloglog-&gt;b) bits. We can repeat this for rho up to 255.
     * We can't go any higher since integer values &gt;255 take more than 1 byte
     * which is currently supported nor really necessary due to 2^(2^8) ~ 
     * 1.16E77 a number so large its not feasible to have that many unique 
     * elements. */</comment>
	<if_stmt><if>if <condition>(<expr><name>rho</name> <operator>==</operator> <name>HASH_LENGTH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>addn</name> <operator>=</operator> <name>HASH_LENGTH</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rho</name> <operator>=</operator> <operator>(</operator><name>HASH_LENGTH</name> <operator>-</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name><operator>)</operator></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>addn</name> <operator>==</operator> <name>HASH_LENGTH</name> <operator>&amp;&amp;</operator> <name>rho</name> <operator>&lt;</operator> <call><name>POW2</name><argument_list>(<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
		    <expr_stmt><expr><name>hash</name> <operator>=</operator> <call><name>GpMurmurHash64A</name><argument_list>(<argument><expr><operator>(</operator><specifier>const</specifier> <name>char</name> <operator>*</operator> <operator>)</operator><operator>&amp;</operator><name>hash</name></expr></argument>, <argument><expr><name>HASH_LENGTH</name><operator>/</operator><literal type="number">8</literal></expr></argument>, <argument><expr><name>HASH_SEED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
            <comment type="block">/* zero length runs should be 1 so counter gets set */</comment>
		    <expr_stmt><expr><name>addn</name> <operator>=</operator> <call><name>__builtin_clzll</name><argument_list>(<argument><expr><name>hash</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		    <expr_stmt><expr><name>rho</name> <operator>+=</operator> <name>addn</name></expr>;</expr_stmt>
		</block_content>}</block></while>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* keep the highest value */</comment>
    <expr_stmt><expr><call><name>GP_HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>idx</name></expr></argument>,<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>rho</name> <operator>&gt;</operator> <name>entry</name></expr>)</condition> <block>{<block_content>
        <expr_stmt><expr><call><name>GP_HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>idx</name></expr></argument>,<argument><expr><name>rho</name></expr></argument>,<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    
    <return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compress header function */</comment>
<function><type><name>GpHLLCounter</name></type>
<name>gp_hll_compress</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<comment type="block">/* make sure the data isn't compressed already */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
		<return>return <expr><name>hloglog</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>idx</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>PACKED</name></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>hloglog</name> <operator>=</operator> <call><name>gp_hll_compress_dense</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>idx</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>UNPACKED</name></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>hloglog</name> <operator>=</operator> <call><name>gp_hll_compress_dense_unpacked</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>UNPACKED_UNPACKED</name></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>UNPACKED</name></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>==</operator> <name>PACKED_UNPACKED</name></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><name>hloglog</name> <operator>=</operator> <call><name>gp_hll_unpack</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compresses dense encoded counters using lz compression */</comment>
<function><type><specifier>static</specifier> <name>GpHLLCounter</name></type>
<name>gp_hll_compress_dense</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>char</name></type> <name>entry</name></decl>,<decl><type ref="prev"><modifier>*</modifier></type><name>data</name></decl>;</decl_stmt>    
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>, <decl><type ref="prev"/><name>len</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>data_rawsize</name></decl>;</decl_stmt>

    <comment type="block">/* make sure the dest struct has enough space for an unsuccessful 
     * compression and a 4 bytes of overflow since lz might not recognize its
     * over until then preventing segfaults */</comment>
    <expr_stmt><expr><name>data_rawsize</name> <operator>=</operator> <call><name>GPHLLDATARAWSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>data_rawsize</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>data_rawsize</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dest</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>data_rawsize</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>data</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>data_rawsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>data_rawsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>data_rawsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* put all registers in a normal array  i.e. remove dense packing so
     * lz compression can work optimally */</comment>
    <for>for<control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>data_rawsize</name></expr> ;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>GP_HLL_DENSE_GET_REGISTER</name><argument_list>(<argument><expr><name>entry</name></expr></argument>,<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name><name>data</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>entry</name></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* lz_compress the normalized array and copy that data into hloglog-&gt;data
     * if any compression was achieved */</comment>
    <expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pglz_compress</name><argument_list>(<argument><expr><name>data</name></expr></argument>,<argument><expr><name>data_rawsize</name></expr></argument>,<argument><expr><name>dest</name></expr></argument>,<argument><expr><name>PGLZ_strategy_always</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <operator>(</operator><name>data_rawsize</name> <operator>*</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name> <operator>/</operator><literal type="number">8</literal><operator>)</operator></expr> )</condition><block>{<block_content>
	<comment type="block">/* free allocated memory and return unaltered array */</comment>
    	<if_stmt><if>if <condition>(<expr><name>dest</name></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    	</block_content>}</block></if></if_stmt>
    	<if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block>{<block_content>
            <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    	</block_content>}</block></if></if_stmt>
    	<return>return <expr><name>hloglog</name></expr>;</return>
    </block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LZ compression failed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"LZ compression return value: %d"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>dest</name></expr></argument>,<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* resize the counter to only encompass the compressed data and the struct
     *  overhead*/</comment>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* invert the b value so it being &lt; 0 can be used as a compression flag */</comment>
    <expr_stmt><expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>*</operator> <operator>(</operator><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* free allocated memory */</comment>
    <if_stmt><if>if <condition>(<expr><name>dest</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>data</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <comment type="block">/* return the compressed counter */</comment>
    <return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Compresses dense encoded counters using lz compression */</comment>
<function><type><specifier>static</specifier> <name>GpHLLCounter</name></type>
<name>gp_hll_compress_dense_unpacked</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type> <name>data_rawsize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>

	<comment type="block">/* make sure the dest struct has enough space for an unsuccessful
	* compression and a 4 bytes of overflow since lz might not recognize its
	* over until then preventing segfaults */</comment>
	<expr_stmt><expr><name>data_rawsize</name> <operator>=</operator> <call><name>GPHLLDATARAWSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>data_rawsize</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>data_rawsize</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>


	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>data_rawsize</name> <operator>+</operator> <literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>


	<comment type="block">/* lz_compress the normalized array and copy that data into hloglog-&gt;data
	* if any compression was achieved */</comment>
	<expr_stmt><expr><name>len</name>  <operator>=</operator> <call><name>pglz_compress</name><argument_list>(<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>data_rawsize</name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>PGLZ_strategy_always</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <operator>(</operator><name>data_rawsize</name> <operator>*</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name> <operator>/</operator> <literal type="number">8</literal><operator>)</operator></expr>)</condition><block>{<block_content>
		<comment type="block">/* free allocated memory and return unaltered array */</comment>
		<if_stmt><if>if <condition>(<expr><name>dest</name></expr>)</condition><block>{<block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<return>return <expr><name>hloglog</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"LZ compression failed"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"LZ compression return value: %d"</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>dest</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* resize the counter to only encompass the compressed data and the struct
	*  overhead*/</comment>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* invert the b value so it being &lt; 0 can be used as a compression flag */</comment>
	<expr_stmt><expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>*</operator> <operator>(</operator><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>hloglog</name><operator>-&gt;</operator><name>format</name></name> <operator>=</operator> <name>PACKED</name></expr>;</expr_stmt>

	<comment type="block">/* free allocated memory */</comment>
	<if_stmt><if>if <condition>(<expr><name>dest</name></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* return the compressed counter */</comment>
	<return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/* Decompress header function */</comment>
<function><type><name>GpHLLCounter</name></type>
<name>gp_hll_decompress</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
     <comment type="block">/* make sure the data is compressed */</comment>
    <if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition> <block>{<block_content>
        <return>return <expr><name>hloglog</name></expr>;</return>
    </block_content>}</block></if></if_stmt>
    
    <expr_stmt><expr><name>hloglog</name> <operator>=</operator> <call><name>gp_hll_decompress_dense</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Decompresses dense counters */</comment>
<function><type><specifier>static</specifier> <name>GpHLLCounter</name></type>
<name>gp_hll_decompress_dense</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
    <decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>dest</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>Size</name></type> <name>data_rawsize</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>htemp</name></decl>;</decl_stmt>

    <comment type="block">/* reset b to positive value for calcs and to indicate data is
     * decompressed */</comment>
    <expr_stmt><expr><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal> <operator>*</operator> <operator>(</operator><name><name>hloglog</name><operator>-&gt;</operator><name>b</name></name><operator>)</operator></expr>;</expr_stmt>

    <comment type="block">/* allocate and zero an array large enough to hold all the decompressed 
     * bins */</comment>
    <expr_stmt><expr><name>data_rawsize</name> <operator>=</operator> <call><name>GPHLLDATARAWSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>dest</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><name>data_rawsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>dest</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
                <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>,</operator>
                 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Failed on request of size %zu."</literal></expr></argument>, <argument><expr><name>data_rawsize</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

    <expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>dest</name></expr></argument>,<argument><expr><literal type="number">0</literal></expr></argument>,<argument><expr><name>data_rawsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* decompress the data */</comment>
    <expr_stmt><expr><call><name>pglz_decompress</name><argument_list>(<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>)</argument_list></call> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof></expr></argument>,
					<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>data_rawsize</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <comment type="block">/* copy the struct internals but not the data into a counter with enough 
     * space for the uncompressed data  */</comment>
    <expr_stmt><expr><name>htemp</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ceil</name><argument_list>(<argument><expr><operator>(</operator><name>data_rawsize</name> <operator>*</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name> <operator>/</operator> <literal type="number">8.0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>htemp</name></expr></argument>,<argument><expr><name>hloglog</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name>hloglog</name> <operator>=</operator> <name>htemp</name></expr>;</expr_stmt>

    <comment type="block">/* set the registers to the appropriate value based on the decompressed
     * data */</comment>
    <for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name><operator>&lt;</operator><name>data_rawsize</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block>{<block_content>
        <expr_stmt><expr><call><name>GP_HLL_DENSE_SET_REGISTER</name><argument_list>(<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>data</name></name></expr></argument>,<argument><expr><name>i</name></expr></argument>,<argument><expr><name><name>dest</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></for>

    <comment type="block">/* set the varsize to the appropriate length  */</comment>
    <expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>hloglog</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpHLLData</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <operator>(</operator><name>int</name><operator>)</operator><call><name>ceil</name><argument_list>(<argument><expr><operator>(</operator><name>data_rawsize</name> <operator>*</operator> <name><name>hloglog</name><operator>-&gt;</operator><name>binbits</name></name> <operator>/</operator> <literal type="number">8.0</literal><operator>)</operator></expr></argument>)</argument_list></call></expr></argument> )</argument_list></call></expr>;</expr_stmt>
    

    <comment type="block">/* free allocated memory */</comment>
    <if_stmt><if>if <condition>(<expr><name>dest</name></expr>)</condition><block>{<block_content>
        <expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    </block_content>}</block></if></if_stmt>

    <return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ---------------------- function definitions --------------------------- */</comment>

<function><type><name>GpHLLCounter</name></type>
<name>gp_hyperloglog_add_item</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hllcounter</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>element</name></decl></parameter>, <parameter><decl><type><name>int16</name></type> <name>typlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>typbyval</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name>typalign</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hyperloglog</name></decl>;</decl_stmt>
	
	<comment type="block">/* requires the estimator to be already created */</comment>
	<if_stmt><if>if <condition>(<expr><name>hllcounter</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"hyperloglog counter must not be NULL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	
	<comment type="block">/* estimator (we know it's not a NULL value) */</comment>
	<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <operator>(</operator><name>GpHLLCounter</name><operator>)</operator> <name>hllcounter</name></expr>;</expr_stmt>
	
	<comment type="block">/* TODO The requests for type info shouldn't be a problem (thanks to
	 * lsyscache), but if it turns out to have a noticeable impact it's
	 * possible to cache that between the calls (in the estimator).
	 *
	 * I have noticed no measurable effect from either option. */</comment>
	
	<comment type="block">/* decompress if needed */</comment>
	<if_stmt><if>if<condition>(<expr><name><name>hyperloglog</name><operator>-&gt;</operator><name>b</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <call><name>gp_hll_decompress</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	
	<comment type="block">/* it this a varlena type, passed by reference or by value ? */</comment>
	<if_stmt><if>if <condition>(<expr><name>typlen</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* varlena */</comment>
		<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <call><name>gp_hll_add_element</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>element</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>typbyval</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* fixed-length, passed by value */</comment>
		<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <call><name>gp_hll_add_element</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><operator>&amp;</operator><name>element</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* fixed-length, passed by reference */</comment>
		<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <call><name>gp_hll_add_element</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>*</operator><operator>)</operator><name>element</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	
	<return>return <expr><name>hyperloglog</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>double</name></type>
<name>gp_hyperloglog_estimate</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hyperloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>estimate</name></decl>;</decl_stmt>
	
	<comment type="block">/* unpack if needed */</comment>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hyperloglog_unpacked</name> <init>= <expr><call><name>gp_hll_unpack</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>estimate</name> <operator>=</operator> <call><name>gp_hll_estimate</name><argument_list>(<argument><expr><name>hyperloglog_unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free unpacked counter */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hyperloglog_unpacked</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* return the updated bytea */</comment>
	<return>return <expr><name>estimate</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>GpHLLCounter</name></type>
<name>gp_hyperloglog_merge_counters</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>counter1</name></decl></parameter>, <parameter><decl><type><name>GpHLLCounter</name></type> <name>counter2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>counter1</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>counter2</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if both counters are null return null */</comment>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>counter1</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* if first counter is null just copy the second estimator into the
		 * first one */</comment>
		<return>return <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name>counter2</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>counter2</name> <operator>==</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
		<comment type="block">/* if second counter is null just return the first estimator */</comment>
		<return>return <expr><call><name>gp_hll_copy</name><argument_list>(<argument><expr><name>counter1</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* ok, we already have the estimator - merge the second one into it */</comment>
		<comment type="block">/* unpack if needed */</comment>
		<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>counter1_new</name> <init>= <expr><call><name>gp_hll_unpack</name><argument_list>(<argument><expr><name>counter1</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>counter2_new</name> <init>= <expr><call><name>gp_hll_unpack</name><argument_list>(<argument><expr><name>counter2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* perform the merge */</comment>
		<expr_stmt><expr><name>counter1_new</name> <operator>=</operator> <call><name>gp_hll_merge</name><argument_list>(<argument><expr><name>counter1_new</name></expr></argument>, <argument><expr><name>counter2_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*  counter2_new is not required any more */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>counter2_new</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* return the updated GpHLLCounter */</comment>
		<return>return <expr><name>counter1_new</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<function><type><name>GpHLLCounter</name></type>
<name>gp_hyperloglog_init_def</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hyperloglog</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <call><name>gp_hll_create</name><argument_list>(<argument><expr><name>DEFAULT_NDISTINCT</name></expr></argument>, <argument><expr><name>DEFAULT_ERROR</name></expr></argument>, <argument><expr><name>PACKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<return>return <expr><name>hyperloglog</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>gp_hyperloglog_len</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hyperloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>VARSIZE_ANY</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* GpMurmurHash64A produces the fastest 64 bit hash of the MurmurHash 
 * implementations and is ~ 20x faster than md5. This version produces the
 * same hash for the same key and seed in both big and little endian systems
 * */</comment>
<function><type><name>uint64_t</name></type> 
<name>GpMurmurHash64A</name> <parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>int</name></type> <name>seed</name></decl></parameter>)</parameter_list> 
<block>{<block_content>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint64_t</name></type> <name>m</name> <init>= <expr><literal type="number">0xc6a4a7935bd1e995</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>int</name></type> <name>r</name> <init>= <expr><literal type="number">47</literal></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>uint64_t</name></type> <name>h</name> <init>= <expr><name>seed</name> <operator>^</operator> <operator>(</operator><name>len</name> <operator>*</operator> <name>m</name><operator>)</operator></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><operator>(</operator><specifier>const</specifier> <name>uint8_t</name> <operator>*</operator><operator>)</operator><name>key</name></expr></init></decl>;</decl_stmt>
    <decl_stmt><decl><type><specifier>const</specifier> <name>uint8_t</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>data</name> <operator>+</operator> <operator>(</operator><name>len</name><operator>-</operator><operator>(</operator><name>len</name><operator>&amp;</operator><literal type="number">7</literal><operator>)</operator><operator>)</operator></expr></init></decl>;</decl_stmt>

    <while>while<condition>(<expr><name>data</name> <operator>!=</operator> <name>end</name></expr>)</condition> <block>{<block_content>
        <decl_stmt><decl><type><name>uint64_t</name></type> <name>k</name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>(</operator><name>BYTE_ORDER</name> <operator>==</operator> <name>LITTLE_ENDIAN</name><operator>)</operator></expr></cpp:if>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>*</operator><operator>(</operator><operator>(</operator><name>uint64_t</name><operator>*</operator><operator>)</operator><name>data</name><operator>)</operator></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
        <expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>|=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator> <name><name>data</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">56</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

        <expr_stmt><expr><name>k</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>^=</operator> <name>k</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>k</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>^=</operator> <name>k</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
        <expr_stmt><expr><name>data</name> <operator>+=</operator> <literal type="number">8</literal></expr>;</expr_stmt>
    </block_content>}</block></while>

    <switch>switch<condition>(<expr><name>len</name> <operator>&amp;</operator> <literal type="number">7</literal></expr>)</condition> <block>{<block_content>
        <case>case <expr><literal type="number">7</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">48</literal></expr>;</expr_stmt>
		<comment type="block">/* fallthrough */</comment>
        <case>case <expr><literal type="number">6</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">40</literal></expr>;</expr_stmt>
		<comment type="block">/* fallthrough */</comment>
        <case>case <expr><literal type="number">5</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">32</literal></expr>;</expr_stmt>
		<comment type="block">/* fallthrough */</comment>
        <case>case <expr><literal type="number">4</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">24</literal></expr>;</expr_stmt>
		<comment type="block">/* fallthrough */</comment>
        <case>case <expr><literal type="number">3</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">16</literal></expr>;</expr_stmt>
		<comment type="block">/* fallthrough */</comment>
        <case>case <expr><literal type="number">2</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&lt;&lt;</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		<comment type="block">/* fallthrough */</comment>
        <case>case <expr><literal type="number">1</literal></expr>:</case> <expr_stmt><expr><name>h</name> <operator>^=</operator> <operator>(</operator><name>uint64_t</name><operator>)</operator><name><name>data</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
        <expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
    </block_content>}</block></switch><empty_stmt>;</empty_stmt>

    <expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name> <operator>*=</operator> <name>m</name></expr>;</expr_stmt>
    <expr_stmt><expr><name>h</name> <operator>^=</operator> <name>h</name> <operator>&gt;&gt;</operator> <name>r</name></expr>;</expr_stmt>

    <return>return <expr><name>h</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* PG_GETARG macros for GpHLLCounter's that does version checking */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_GETARG_HLL_P</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pg_check_hll_version((GpHLLCounter) PG_GETARG_BYTEA_P(n))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_GETARG_HLL_P_COPY</name><parameter_list>(<parameter><type><name>n</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>pg_check_hll_version((GpHLLCounter) PG_GETARG_BYTEA_P_COPY(n))</cpp:value></cpp:define>

<comment type="block">/* shoot for 2^64 distinct items and 0.8125% error rate by default */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_NDISTINCT</name></cpp:macro>   <cpp:value>1ULL &lt;&lt; 63</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_ERROR</name></cpp:macro>       <cpp:value>0.008125</cpp:value></cpp:define>

<comment type="block">/* Use the PG_FUNCTION_INFO_V1 macro to pass functions to postgres */</comment>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gp_hyperloglog_add_item_agg_default</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gp_hyperloglog_merge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gp_hyperloglog_get_estimate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gp_hyperloglog_in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gp_hyperloglog_out</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<expr_stmt><expr><call><name>PG_FUNCTION_INFO_V1</name><argument_list>(<argument><expr><name>gp_hyperloglog_comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<comment type="block">/* ------------- function declarations for local functions --------------- */</comment>
<function_decl><type><specifier>extern</specifier> <name>Datum</name></type> <name>gp_hyperloglog_add_item_agg_default</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>Datum</name></type> <name>gp_hyperloglog_get_estimate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name></type> <name>gp_hyperloglog_merge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>Datum</name></type> <name>gp_hyperloglog_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>extern</specifier> <name>Datum</name></type> <name>gp_hyperloglog_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>extern</specifier> <name>Datum</name></type> <name>gp_hyperloglog_comp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GpHLLCounter</name></type> <name>pg_check_hll_version</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* ---------------------- function definitions --------------------------- */</comment>
<function><type><specifier>static</specifier> <name>GpHLLCounter</name></type>
<name>pg_check_hll_version</name><parameter_list>(<parameter><decl><type><name>GpHLLCounter</name></type> <name>hloglog</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>hloglog</name><operator>-&gt;</operator><name>version</name></name> <operator>!=</operator> <name>STRUCT_VERSION</name></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,<argument><expr><literal type="string">"ERROR: The stored counter is version %u while the library is version %u. Please change library version or use upgrade function to upgrade the counter"</literal></expr></argument>,<argument><expr><name><name>hloglog</name><operator>-&gt;</operator><name>version</name></name></expr></argument>,<argument><expr><name>STRUCT_VERSION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>hloglog</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gp_hyperloglog_add_item_agg_default</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hyperloglog</name></decl>;</decl_stmt>

	<comment type="block">/* info for anyelement */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>         <name>element_type</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>       <name>element</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>       <name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>        <name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name>typalign</name></decl>;</decl_stmt>

	<comment type="block">/* Create a new estimator (with default error rate and ndistinct) or reuse
	 * the existing one. Return null if both counter and element args are null.
	 * This prevents excess empty counter creation */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <call><name>gp_hll_create</name><argument_list>(<argument><expr><name>DEFAULT_NDISTINCT</name></expr></argument>, <argument><expr><name>DEFAULT_ERROR</name></expr></argument>, <argument><expr><name>PACKED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if> <else>else <block>{<block_content>
		<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <call><name>PG_GETARG_HLL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* add the item to the estimator (skip NULLs) */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>

		<comment type="block">/* TODO The requests for type info shouldn't be a problem (thanks to
		 * lsyscache), but if it turns out to have a noticeable impact it's
		 * possible to cache that between the calls (in the estimator).
		 *
		 * I have noticed no measurable effect from either option. */</comment>

		<comment type="block">/* get type information for the second parameter (anyelement item) */</comment>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <call><name>gp_hyperloglog_add_item</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>, <argument><expr><name>element</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>, <argument><expr><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* return the updated bytea */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gp_hyperloglog_merge</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>counter1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>counter2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>counter1_merged</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block>{<block_content>
		<comment type="block">/* if both counters are null return null */</comment>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* if first counter is null just copy the second estimator into the
		 * first one */</comment>
		<expr_stmt><expr><name>counter1_merged</name> <operator>=</operator> <call><name>PG_GETARG_HLL_P_COPY</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if> <if type="elseif">else if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition> <block>{<block_content>
		<comment type="block">/* if second counter is null just return the first estimator */</comment>
		<expr_stmt><expr><name>counter1_merged</name> <operator>=</operator> <call><name>PG_GETARG_HLL_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if> <else>else <block>{<block_content>
		<comment type="block">/* ok, we already have the estimator - merge the second one into it */</comment>
		<expr_stmt><expr><name>counter1</name> <operator>=</operator> <call><name>PG_GETARG_HLL_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>counter2</name> <operator>=</operator> <call><name>PG_GETARG_HLL_P_COPY</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>counter1_merged</name> <operator>=</operator> <call><name>gp_hyperloglog_merge_counters</name><argument_list>(<argument><expr><name>counter1</name></expr></argument>, <argument><expr><name>counter2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>counter1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>counter2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* return the updated bytea */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>counter1_merged</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gp_hyperloglog_get_estimate</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>estimate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hyperloglog</name> <init>= <expr><call><name>PG_GETARG_HLL_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>estimate</name> <operator>=</operator> <call><name>gp_hyperloglog_estimate</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* free the hll counter copy */</comment>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* return the updated bytea */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>estimate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gp_hyperloglog_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int16</name></type>   <name>datalen</name></decl>, <decl><type ref="prev"/><name>resultlen</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>     <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>    <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_BYTEA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>datalen</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultlen</name> <operator>=</operator> <call><name>pg_b64_enc_len</name><argument_list>(<argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>resultlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_b64_encode</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>,<argument><expr><name>datalen</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make this FATAL 'cause we've trodden on memory ... */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <name>resultlen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"overflow - encode estimate too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>result</name><index>[<expr><name>res</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gp_hyperloglog_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>      <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>data</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>      <name>datalen</name></decl>, <decl><type ref="prev"/><name>resultlen</name></decl>, <decl><type ref="prev"/><name>res</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>datalen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>resultlen</name> <operator>=</operator> <call><name>pg_b64_dec_len</name><argument_list>(<argument><expr><name>datalen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>resultlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>pg_b64_decode</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>datalen</name></expr></argument>, <argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make this FATAL 'cause we've trodden on memory ... */</comment>
	<if_stmt><if>if <condition>(<expr><name>res</name> <operator>&gt;</operator> <name>resultlen</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"overflow - decode estimate too small"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>gp_hyperloglog_comp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GpHLLCounter</name></type> <name>hyperloglog</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> )</condition><block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator>  <call><name>PG_GETARG_HLL_P_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>hyperloglog</name> <operator>=</operator> <call><name>gp_hll_compress</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><name>hyperloglog</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

</unit>
