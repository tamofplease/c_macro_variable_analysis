<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/resource_manager/memquota.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * memquota.c
 *	  Routines related to memory quota for queries.
 *
 * Portions Copyright (c) 2010, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/utils/resource_manager/memquota.c
 * 
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbllize.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/execdesc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resource_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/heapam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/pquery.h"</cpp:file></cpp:include>

<decl_stmt><decl><type><name>ResManagerMemoryPolicy</name></type>		<name>gp_resmanager_memory_policy_default</name> <init>= <expr><name>RESMANAGER_MEMORY_POLICY_NONE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>						<name>gp_log_resmanager_memory_default</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>							<name>gp_resmanager_memory_policy_auto_fixed_mem_default</name> <init>= <expr><literal type="number">100</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>						<name>gp_resmanager_print_operator_memory_limits_default</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>ResManagerMemoryPolicy</name>		<modifier>*</modifier></type><name>gp_resmanager_memory_policy</name> <init>= <expr><operator>&amp;</operator><name>gp_resmanager_memory_policy_default</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name>						<modifier>*</modifier></type><name>gp_log_resmanager_memory</name> <init>= <expr><operator>&amp;</operator><name>gp_log_resmanager_memory_default</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name>							<modifier>*</modifier></type><name>gp_resmanager_memory_policy_auto_fixed_mem</name> <init>= <expr><operator>&amp;</operator><name>gp_resmanager_memory_policy_auto_fixed_mem_default</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name>						<modifier>*</modifier></type><name>gp_resmanager_print_operator_memory_limits</name> <init>= <expr><operator>&amp;</operator><name>gp_resmanager_print_operator_memory_limits_default</name></expr></init></decl>;</decl_stmt>

<comment type="block" format="doxygen">/**
 * Policy Auto. This contains information that will be used by Policy AUTO
 */</comment>
<typedef>typedef <type><struct>struct <name>PolicyAutoContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt> <comment type="block">/* Required prefix for plan_tree_walker/mutator */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>numNonMemIntensiveOperators</name></decl>;</decl_stmt> <comment type="block">/* number of non-blocking operators */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>numMemIntensiveOperators</name></decl>;</decl_stmt> <comment type="block">/* number of blocking operators */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>queryMemKB</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedStmt</name></decl>;</decl_stmt> <comment type="block">/* pointer to the planned statement */</comment>
}</block></struct></type> <name>PolicyAutoContext</name>;</typedef>

<comment type="block" format="doxygen">/**
 * Forward declarations.
 */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>autoIncOpMemForResGroup</name><parameter_list>(<parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>opMemKB</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numOps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>PolicyAutoPrelimWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PolicyAutoContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type>	<name>PolicyAutoAssignWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PolicyAutoContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsAggMemoryIntensive</name><parameter_list>(<parameter><decl><type><name>Agg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>IsMemoryIntensiveOperator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>;</function_decl>

<struct_decl>struct <name>OperatorGroupNode</name>;</struct_decl>

<comment type="block">/*
 * OperatorGroupNode
 *    Store the information regarding an operator group.
 */</comment>
<typedef>typedef <type><struct>struct <name>OperatorGroupNode</name>
<block>{
	<comment type="block">/* The id for this group */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>groupId</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The number of non-memory-intensive operators and memory-intensive
	 * operators in the group.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>numNonMemIntenseOps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>numMemIntenseOps</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The maximal number of non-memory-intensive and memory-intensive
	 * operators in all child groups of this group which might be active
	 * concurrently.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>maxNumConcNonMemIntenseOps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>maxNumConcMemIntenseOps</name></decl>;</decl_stmt>

	<comment type="block">/* The list of child groups */</comment>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>childGroups</name></decl>;</decl_stmt>

	<comment type="block">/* The parent group */</comment>
	<decl_stmt><decl><type><name><name>struct</name> <name>OperatorGroupNode</name></name> <modifier>*</modifier></type><name>parentGroup</name></decl>;</decl_stmt>

	<comment type="block">/* The memory limit for this group and its child groups */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>groupMemKB</name></decl>;</decl_stmt>
}</block></struct></type> <name>OperatorGroupNode</name>;</typedef>

<comment type="block">/*
 * PolicyEagerFreeContext
 *   Store the intemediate states during the tree walking for the optimize
 * memory distribution policy.
 */</comment>
<typedef>typedef <type><struct>struct <name>PolicyEagerFreeContext</name>
<block>{
	<decl_stmt><decl><type><name>plan_tree_base_prefix</name></type> <name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>groupTree</name></decl>;</decl_stmt> <comment type="block">/* the root of the group tree */</comment>
	<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>groupNode</name></decl>;</decl_stmt> <comment type="block">/* the current group node in the group tree */</comment>
	<decl_stmt><decl><type><name>uint32</name></type> <name>nextGroupId</name></decl>;</decl_stmt> <comment type="block">/* the group id for a new group node */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>queryMemKB</name></decl>;</decl_stmt> <comment type="block">/* the query memory limit */</comment>
	<decl_stmt><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>plannedStmt</name></decl>;</decl_stmt> <comment type="block">/* pointer to the planned statement */</comment>
}</block></struct></type> <name>PolicyEagerFreeContext</name>;</typedef>

<comment type="block">/*
 * Does the expression contain any ordered or DISTINCT aggregates?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>contain_ordered_aggs_walker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>Aggref</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Aggref</name>	   <modifier>*</modifier></type><name>aggref</name> <init>= <expr><operator>(</operator><name>Aggref</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>aggref</name><operator>-&gt;</operator><name>aggorder</name></name> <operator>||</operator> <name><name>aggref</name><operator>-&gt;</operator><name>aggdistinct</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>expression_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>contain_ordered_aggs_walker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Automatically increase operator memory buffer in resource group mode.
 *
 * In resource group if the operator memory buffer is too small for the
 * operators we still allow the query to execute by temporarily increasing the
 * buffer size, each operator will be assigned 100KB memory no matter it is
 * memory intensive or not.  The query can execute as long as there is enough
 * resource group shared memory, the performance might not be best as 100KB is
 * rather small for memory intensive operators.  If there is no enought shared
 * memory it will run into OOM error on operators.
 *
 * @param opMemKB the original operator memory buffer size, will be in-place
 *        updated if not large enough
 * @param numOps the number of operators, both memory intensive and
 *        non-intensive
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>autoIncOpMemForResGroup</name><parameter_list>(<parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>opMemKB</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>numOps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>perOpMemKB</name></decl>;</decl_stmt>		<comment type="block">/* per-operator buffer size */</comment>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>minOpMemKB</name></decl>;</decl_stmt>		<comment type="block">/* minimal buffer size for all the operators */</comment>

	<comment type="block">/* Only adjust operator memory buffer for resource group */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResGroupEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The buffer reserved for a memory intensive operator is the same as
	 * non-intensive ones, by default it is 100KB
	 */</comment>
	<expr_stmt><expr><name>perOpMemKB</name> <operator>=</operator> <operator>*</operator><name>gp_resmanager_memory_policy_auto_fixed_mem</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>minOpMemKB</name> <operator>=</operator> <name>perOpMemKB</name> <operator>*</operator> <name>numOps</name></expr>;</expr_stmt>

	<comment type="block">/* No need to change operator memory buffer if already large enough */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>opMemKB</name> <operator>&gt;=</operator> <name>minOpMemKB</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"No enough operator memory for current query."</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Current query contains %d operators, "</literal>
					   <literal type="string">"the minimal operator memory requirement is "</literal> <name>INT64_FORMAT</name> <literal type="string">" KB, "</literal>
					   <literal type="string">"however there is only "</literal> <name>INT64_FORMAT</name> <literal type="string">" KB reserved.  "</literal>
					   <literal type="string">"Temporarily increased the operator memory to execute the query."</literal></expr></argument>,
					   <argument><expr><name>numOps</name></expr></argument>, <argument><expr><name>minOpMemKB</name></expr></argument>, <argument><expr><operator>*</operator><name>opMemKB</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Consider increase memory_spill_ratio for better performance."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust the buffer */</comment>
	<expr_stmt><expr><operator>*</operator><name>opMemKB</name> <operator>=</operator> <name>minOpMemKB</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Is an agg operator memory intensive? The following cases mean it is:
 * 1. If agg strategy is hashed
 * 2. If targetlist or qual contains a DQA
 * 3. If there is an ordered aggregated.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsAggMemoryIntensive</name><parameter_list>(<parameter><decl><type><name>Agg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Case 1 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cases 2 &amp; 3 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>contain_ordered_aggs_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>targetlist</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>contain_ordered_aggs_walker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>agg</name><operator>-&gt;</operator><name>plan</name><operator>.</operator><name>qual</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsAggBlockingOperator
 *    Return true if an Agg node is a blocking operator.
 *
 * Agg is a blocking operator when it is
 * 1. Scalar Agg
 * 2. Second stage HashAgg when streaming is on.
 * 3. First and Second stage HashAgg when streaming is off.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsAggBlockingOperator</name><parameter_list>(<parameter><decl><type><name>Agg</name> <modifier>*</modifier></type><name>agg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_PLAIN</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>(</operator><name><name>agg</name><operator>-&gt;</operator><name>aggstrategy</name></name> <operator>==</operator> <name>AGG_HASHED</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>agg</name><operator>-&gt;</operator><name>streaming</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * isMaterialBlockingOperator
 *     Return true if a Material node is a blocking operator.
 *
 * Material node is a blocking operator when cdb_strict is on.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsMaterialBlockingOperator</name><parameter_list>(<parameter><decl><type><name>Material</name> <modifier>*</modifier></type><name>material</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>material</name><operator>-&gt;</operator><name>cdb_strict</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IsBlockingOperator
 *     Return true when the given plan node is a blocking operator.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsBlockingOperator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
		<case>case <expr><name>T_Hash</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>

		<case>case <expr><name>T_Material</name></expr>:</case>
			<return>return <expr><call><name>IsMaterialBlockingOperator</name><argument_list>(<argument><expr><operator>(</operator><name>Material</name> <operator>*</operator><operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>T_Agg</name></expr>:</case>
			<return>return <expr><call><name>IsAggBlockingOperator</name><argument_list>(<argument><expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator><name>node</name></expr></argument>)</argument_list></call></expr>;</return>

		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Is a result node memory intensive? It is if it contains function calls.
 */</comment>
<function><type><name>bool</name></type>
<name>IsResultMemoryIntensive</name><parameter_list>(<parameter><decl><type><name>Result</name> <modifier>*</modifier></type><name>res</name></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>funcNodes</name> <init>= <expr><call><name>extract_nodes</name><argument_list>(<argument><expr><name>NULL</name></expr></argument> <comment type="block">/* glob */</comment>,
			<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>res</name><operator>)</operator><operator>-&gt;</operator><name>targetlist</name></expr></argument>, <argument><expr><name>T_FuncExpr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>nFuncExpr</name> <init>= <expr><call><name>list_length</name><argument_list>(<argument><expr><name>funcNodes</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Shallow free of the funcNodes list */</comment>
	<expr_stmt><expr><call><name>list_free</name><argument_list>(<argument><expr><name>funcNodes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>funcNodes</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>nFuncExpr</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No function expressions, not memory intensive */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Is an operator memory intensive?
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsMemoryIntensiveOperator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch<condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>T_Material</name></expr>:</case>
		<case>case <expr><name>T_Sort</name></expr>:</case>
		<case>case <expr><name>T_ShareInputScan</name></expr>:</case>
		<case>case <expr><name>T_Hash</name></expr>:</case>
		<case>case <expr><name>T_BitmapIndexScan</name></expr>:</case>
		<case>case <expr><name>T_WindowAgg</name></expr>:</case>
		<case>case <expr><name>T_TableFunctionScan</name></expr>:</case>
		<case>case <expr><name>T_FunctionScan</name></expr>:</case>
			<return>return <expr><name>true</name></expr>;</return>
		<case>case <expr><name>T_Agg</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Agg</name> <modifier>*</modifier></type><name>agg</name> <init>= <expr><operator>(</operator><name>Agg</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<return>return <expr><call><name>IsAggMemoryIntensive</name><argument_list>(<argument><expr><name>agg</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>T_Result</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Result</name> <modifier>*</modifier></type><name>res</name> <init>= <expr><operator>(</operator><name>Result</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>
				<return>return <expr><call><name>IsResultMemoryIntensive</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</return>
			</block_content>}</block>
		<default>default:</default>
			<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * IsRootOperatorInGroup
 *    Return true if the given node is the root operator in an operator group.
 *
 * A node can be a root operator in a group if it satisfies the following three
 * conditions:
 * (1) a Plan node.
 * (2) a Blocking operator.
 * (3) not rescan required (no external parameters).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>IsRootOperatorInGroup</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IsBlockingOperator</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>node</name><operator>)</operator><operator>)</operator><operator>-&gt;</operator><name>extParam</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * This walker counts the number of memory intensive and non-memory intensive operators
 * in a plan.
 */</comment>

<function><type><specifier>static</specifier> <name>bool</name></type> <name>PolicyAutoPrelimWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PolicyAutoContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IsMemoryIntensiveOperator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>plannedStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>numMemIntensiveOperators</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>numNonMemIntensiveOperators</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PolicyAutoPrelimWalker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * This walker assigns specific amount of memory to each operator in a plan.
 * It allocates a fixed size to each non-memory intensive operator and distributes
 * the rest among memory intensive operators.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type> <name>PolicyAutoAssignWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PolicyAutoContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name></type> <name>nonMemIntenseOpMemKB</name> <init>= <expr><operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>gp_resmanager_memory_policy_auto_fixed_mem</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>planNode</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

		<comment type="block" format="doxygen">/**
		 * If the operator is not a memory intensive operator, give it fixed amount of memory.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsMemoryIntensiveOperator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>plannedStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>planNode</name><operator>-&gt;</operator><name>operatorMemKB</name></name> <operator>=</operator> <name>nonMemIntenseOpMemKB</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>planNode</name><operator>-&gt;</operator><name>operatorMemKB</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>queryMemKB</name></name>
					<operator>-</operator> <operator>(</operator><name>double</name><operator>)</operator> <name><name>context</name><operator>-&gt;</operator><name>numNonMemIntensiveOperators</name></name> <operator>*</operator> <name>nonMemIntenseOpMemKB</name><operator>)</operator>
					<operator>/</operator> <name><name>context</name><operator>-&gt;</operator><name>numMemIntensiveOperators</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>planNode</name><operator>-&gt;</operator><name>operatorMemKB</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>LogResManagerMemory</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>GP_RESMANAGER_MEMORY_LOG_LEVEL</name></expr></argument>, <argument><expr><literal type="string">"assigning plan node memory = %dKB"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name> <operator>)</operator><name><name>planNode</name><operator>-&gt;</operator><name>operatorMemKB</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PolicyAutoAssignWalker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/**
 * Main entry point for memory quota policy AUTO. It counts how many operators
 * there are in a plan. It walks the plan again and allocates a fixed amount to every non-memory intensive operators.
 * It distributes the rest of the memory available to other operators.
 */</comment>
<function><type><name>void</name></type> <name>PolicyAutoAssignOperatorMemoryKB</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>memAvailableBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolicyAutoContext</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>exec_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>queryMemKB</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><name>memAvailableBytes</name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>numMemIntensiveOperators</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>numNonMemIntensiveOperators</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>plannedStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			 <expr><call><name>PolicyAutoPrelimWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>numMemIntensiveOperators</name></name> <operator>+</operator> <name><name>ctx</name><operator>.</operator><name>numNonMemIntensiveOperators</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure there is enough operator memory in resource group mode.
	 */</comment>
	<expr_stmt><expr><call><name>autoIncOpMemForResGroup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>queryMemKB</name></name></expr></argument>,
							<argument><expr><name><name>ctx</name><operator>.</operator><name>numNonMemIntensiveOperators</name></name> <operator>+</operator>
							<name><name>ctx</name><operator>.</operator><name>numMemIntensiveOperators</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>queryMemKB</name></name> <operator>&lt;=</operator> <name><name>ctx</name><operator>.</operator><name>numNonMemIntensiveOperators</name></name> <operator>*</operator> <operator>(</operator><operator>*</operator><name>gp_resmanager_memory_policy_auto_fixed_mem</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>ERRMSG_GP_INSUFFICIENT_STATEMENT_MEMORY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><name>result</name> <operator>=</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			 <call><name>PolicyAutoAssignWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * What should be query mem such that memory intensive operators get a certain
 * minimum amount of memory.  Return value is in bytes.
 */</comment>
<function><type><name>uint64</name></type>
<name>PolicyAutoStatementMemForNoSpill</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>minOperatorMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>minOperatorMem</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name></type> <name>nonMemIntenseOpMem</name> <init>= <expr><operator>(</operator><operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><operator>*</operator><name>gp_resmanager_memory_policy_auto_fixed_mem</name><operator>)</operator> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>PolicyAutoContext</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>exec_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>queryMemKB</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><name><name>stmt</name><operator>-&gt;</operator><name>query_mem</name></name> <operator>/</operator> <literal type="number">1024</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>numMemIntensiveOperators</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>numNonMemIntensiveOperators</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>plannedStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><call><name>PolicyAutoPrelimWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>numMemIntensiveOperators</name></name> <operator>+</operator> <name><name>ctx</name><operator>.</operator><name>numNonMemIntensiveOperators</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Right now, the inverse is straightforward.
	 * TODO: Siva - employ binary search to find the right value.
	 */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>requiredStatementMem</name> <init>= <expr><name><name>ctx</name><operator>.</operator><name>numNonMemIntensiveOperators</name></name> <operator>*</operator> <name>nonMemIntenseOpMem</name>
									<operator>+</operator> <name><name>ctx</name><operator>.</operator><name>numMemIntensiveOperators</name></name> <operator>*</operator> <name>minOperatorMem</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><name>requiredStatementMem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CreateOperatorGroup
 *    create a new operator group with a specified id.
 */</comment>
<function><type><specifier>static</specifier> <name>OperatorGroupNode</name> <modifier>*</modifier></type>
<name>CreateOperatorGroupNode</name><parameter_list>(<parameter><decl><type><name>uint32</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>parentGroup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>node</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>OperatorGroupNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>groupId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>parentGroup</name></name> <operator>=</operator> <name>parentGroup</name></expr>;</expr_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * IncrementOperatorCount
 *    Increment the count of operators in the current group based
 * on the type of the operator.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>IncrementOperatorCount</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>groupNode</name></decl></parameter>, <parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>node</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>groupNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsMemoryIntensiveOperator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>groupNode</name><operator>-&gt;</operator><name>numMemIntenseOps</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>groupNode</name><operator>-&gt;</operator><name>numNonMemIntenseOps</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GetParentOperatorNode
 *    Return the parent operator group for a given group.
 */</comment>
<function><type><specifier>static</specifier> <name>OperatorGroupNode</name> <modifier>*</modifier></type>
<name>GetParentOperatorGroup</name><parameter_list>(<parameter><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>groupNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>groupNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>groupNode</name><operator>-&gt;</operator><name>parentGroup</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * CreateOperatorGroupForOperator
 *    create an operator group for a given operator node if the given operator node
 * is a potential root of an operator group.
 */</comment>
<function><type><specifier>static</specifier> <name>OperatorGroupNode</name> <modifier>*</modifier></type>
<name>CreateOperatorGroupForOperator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							   <parameter><decl><type><name>PolicyEagerFreeContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>groupNode</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the group tree has not been built, we create the first operator
	 * group here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>groupTree</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>groupNode</name> <operator>=</operator> <call><name>CreateOperatorGroupNode</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nextGroupId</name></name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>groupNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>groupTree</name></name> <operator>=</operator> <name>groupNode</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>groupTree</name><operator>-&gt;</operator><name>groupMemKB</name></name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>queryMemKB</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextGroupId</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * If this node is a potential root of an operator group, this means that
	 * the current group ends, and a new group starts. we create a new operator
	 * group.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsRootOperatorInGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>groupNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>parentGroupNode</name> <init>= <expr><name>groupNode</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name>groupNode</name> <operator>=</operator> <call><name>CreateOperatorGroupNode</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>nextGroupId</name></name></expr></argument>, <argument><expr><name>groupNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>parentGroupNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>parentGroupNode</name><operator>-&gt;</operator><name>childGroups</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>parentGroupNode</name><operator>-&gt;</operator><name>childGroups</name></name></expr></argument>, <argument><expr><name>groupNode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextGroupId</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>groupNode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FindOperatorGroupForOperator
 *   find the operator group for a given operator node that is the root operator
 * of the returning group.
 */</comment>
<function><type><specifier>static</specifier> <name>OperatorGroupNode</name> <modifier>*</modifier></type>
<name>FindOperatorGroupForOperator</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>,
							 <parameter><decl><type><name>PolicyEagerFreeContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupTree</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>groupNode</name> <init>= <expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If this is the beginning of the walk (or the current group is NULL),
	 * this operator node belongs to the first operator group.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>groupNode</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>groupNode</name> <operator>=</operator> <name><name>context</name><operator>-&gt;</operator><name>groupTree</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextGroupId</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/*
	 * If this operator is a potential root of an operator group, this means
	 * the current group ends, and a new group start. We find the group that
	 * has this node as its root.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><call><name>IsRootOperatorInGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>childGroup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;groupNode-&gt;childGroups</argument>)</argument_list></macro>
		<block>{<block_content>
			<expr_stmt><expr><name>childGroup</name> <operator>=</operator> <operator>(</operator><name>OperatorGroupNode</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>childGroup</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name><name>context</name><operator>-&gt;</operator><name>nextGroupId</name></name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>childGroup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>groupNode</name> <operator>=</operator> <name>childGroup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>nextGroupId</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>groupNode</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ComputeAvgMemKBForMemIntenseOp
 *    Compute the average memory limit for each memory-intensive operators
 * in a given group.
 *
 * If there is no memory-intensive operators in this group, return 0.
 */</comment>
<function><type><specifier>static</specifier> <name>uint64</name></type>
<name>ComputeAvgMemKBForMemIntenseOp</name><parameter_list>(<parameter><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>groupNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>groupNode</name><operator>-&gt;</operator><name>numMemIntenseOps</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name></type> <name>nonMemIntenseOpMemKB</name> <init>= <expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><operator>*</operator><name>gp_resmanager_memory_policy_auto_fixed_mem</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<return>return <expr><operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name><name>groupNode</name><operator>-&gt;</operator><name>groupMemKB</name></name> <operator>-</operator>
			 <operator>(</operator><name>double</name><operator>)</operator><name><name>groupNode</name><operator>-&gt;</operator><name>numNonMemIntenseOps</name></name> <operator>*</operator> <name>nonMemIntenseOpMemKB</name><operator>)</operator> <operator>/</operator>
			<name><name>groupNode</name><operator>-&gt;</operator><name>numMemIntenseOps</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ComputeMemLimitForChildGroups
 *    compute the query memory limit for all child groups of a given
 * parent group if it has not been computed before.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ComputeMemLimitForChildGroups</name><parameter_list>(<parameter><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>parentGroupNode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>parentGroupNode</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint64</name></type> <name>totalNumMemIntenseOps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>totalNumNonMemIntenseOps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parentGroupNode-&gt;childGroups</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>childGroup</name> <init>= <expr><operator>(</operator><name>OperatorGroupNode</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the memory limit has been computed, then we are done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>childGroup</name><operator>-&gt;</operator><name>groupMemKB</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>totalNumMemIntenseOps</name> <operator>+=</operator>
			<call><name>Max</name><argument_list>(<argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>maxNumConcMemIntenseOps</name></name></expr></argument>, <argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>numMemIntenseOps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>totalNumNonMemIntenseOps</name> <operator>+=</operator>
			<call><name>Max</name><argument_list>(<argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>maxNumConcNonMemIntenseOps</name></name></expr></argument>, <argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>numNonMemIntenseOps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name></type> <name>nonMemIntenseOpMemKB</name> <init>= <expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><operator>*</operator><name>gp_resmanager_memory_policy_auto_fixed_mem</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>parentGroupNode-&gt;childGroups</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>childGroup</name> <init>= <expr><operator>(</operator><name>OperatorGroupNode</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>groupMemKB</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>parentGroupNode</name><operator>-&gt;</operator><name>groupMemKB</name></name> <operator>&lt;</operator> <name>totalNumNonMemIntenseOps</name> <operator>*</operator> <name>nonMemIntenseOpMemKB</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient memory reserved for statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<decl_stmt><decl><type><name>double</name></type> <name>memIntenseOpMemKB</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>totalNumMemIntenseOps</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>memIntenseOpMemKB</name> <operator>=</operator>
				<operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><operator>(</operator><name><name>parentGroupNode</name><operator>-&gt;</operator><name>groupMemKB</name></name> <operator>-</operator>
						  <name>totalNumNonMemIntenseOps</name> <operator>*</operator> <name>nonMemIntenseOpMemKB</name><operator>)</operator><operator>)</operator> <operator>/</operator>
				<operator>(</operator><operator>(</operator><name>double</name><operator>)</operator><name>totalNumMemIntenseOps</name><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parentGroupNode</name><operator>-&gt;</operator><name>groupMemKB</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * MPP-23130
		 * In memory policy eager free, scaleFactor is used to balance memory allocated to
		 * each child group based on the number of memory-intensive and non-memory-intensive
		 * operators they have. The calculation of scaleFactor is as follows:
		 * scaleFactor = (memIntensiveOpMem *
		 *               Max(childGroup-&gt;maxNumConcMemIntenseOps, childGroup-&gt;numMemIntenseOps)
		 *              + nonMemIntenseOpMemKB *
		 *               Max(childGroup-&gt;maxNumConcNonMemIntenseOps, childGroup-&gt;numNonMemIntenseOps))
		 *               / parentGroupNode-&gt;groupMemKB
		 * Child group's memory: childGroup-&gt;groupMemKB = scaleFactor * parentGroupNode-&gt;groupMemKB,
		 * which is the denominator of the scaleFactor formula.
		 */</comment>
		<expr_stmt><expr><name><name>childGroup</name><operator>-&gt;</operator><name>groupMemKB</name></name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>(</operator><name>memIntenseOpMemKB</name> <operator>*</operator>
				  	  	  	  	  	  	  <call><name>Max</name><argument_list>(<argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>maxNumConcMemIntenseOps</name></name></expr></argument>, <argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>numMemIntenseOps</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
				  	  	  	  	  	  	  <name>nonMemIntenseOpMemKB</name> <operator>*</operator>
				  	  	  	  	  	  	  <call><name>Max</name><argument_list>(<argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>maxNumConcNonMemIntenseOps</name></name></expr></argument>, <argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>numNonMemIntenseOps</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * PolicyEagerFreePrelimWalker
 *    Walk the plan tree to build a group tree by dividing the plan tree
 * into several groups, each of which has a block operator as its border
 * node (except for the leaves of the leave groups). At the same time,
 * we collect some stats information about operators in each group.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PolicyEagerFreePrelimWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PolicyEagerFreeContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>parentGroupNode</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>isTopPlanNode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>context</name><operator>-&gt;</operator><name>groupTree</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>isTopPlanNode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name> <operator>=</operator> <call><name>CreateOperatorGroupForOperator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>IncrementOperatorCount</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>plannedStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We also increment the parent group's counter if this node
		 * is the root node in a new group.
		 */</comment>
		<expr_stmt><expr><name>parentGroupNode</name> <operator>=</operator> <call><name>GetParentOperatorGroup</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>IsRootOperatorInGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>parentGroupNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>IncrementOperatorCount</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>parentGroupNode</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>plannedStmt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PolicyEagerFreePrelimWalker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this node is the top node in a group, at this point, we should have all info about
	 * its child groups. We then calculate the maximum number of potential concurrently
	 * active memory-intensive operators and non-memory-intensive operators in all
	 * child groups.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isTopPlanNode</name> <operator>||</operator> <call><name>IsRootOperatorInGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>uint64</name></type> <name>maxNumConcNonMemIntenseOps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>uint64</name></type> <name>maxNumConcMemIntenseOps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>context-&gt;groupNode-&gt;childGroups</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>childGroup</name> <init>= <expr><operator>(</operator><name>OperatorGroupNode</name> <operator>*</operator><operator>)</operator><call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>maxNumConcNonMemIntenseOps</name> <operator>+=</operator>
				<call><name>Max</name><argument_list>(<argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>maxNumConcNonMemIntenseOps</name></name></expr></argument>, <argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>numNonMemIntenseOps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>maxNumConcMemIntenseOps</name> <operator>+=</operator>
				<call><name>Max</name><argument_list>(<argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>maxNumConcMemIntenseOps</name></name></expr></argument>, <argument><expr><name><name>childGroup</name><operator>-&gt;</operator><name>numMemIntenseOps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name><operator>-&gt;</operator><name>maxNumConcNonMemIntenseOps</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			   <name><name>context</name><operator>-&gt;</operator><name>groupNode</name><operator>-&gt;</operator><name>maxNumConcMemIntenseOps</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name><operator>-&gt;</operator><name>maxNumConcNonMemIntenseOps</name></name> <operator>=</operator> <name>maxNumConcNonMemIntenseOps</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name><operator>-&gt;</operator><name>maxNumConcMemIntenseOps</name></name> <operator>=</operator> <name>maxNumConcMemIntenseOps</name></expr>;</expr_stmt>

		<comment type="block">/* Reset the groupNode to point to its parentGroupNode */</comment>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name> <operator>=</operator> <call><name>GetParentOperatorGroup</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PolicyEagerFreeAssignWalker
 *    Walk the plan tree and assign the memory to each plan node.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>PolicyEagerFreeAssignWalker</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>PolicyEagerFreeContext</name> <modifier>*</modifier></type><name>context</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>node</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name></type> <name>nonMemIntenseOpMemKB</name> <init>= <expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><operator>*</operator><name>gp_resmanager_memory_policy_auto_fixed_mem</name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>is_plan_node</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Plan</name> <modifier>*</modifier></type><name>planNode</name> <init>= <expr><operator>(</operator><name>Plan</name> <operator>*</operator><operator>)</operator><name>node</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name> <operator>=</operator> <call><name>FindOperatorGroupForOperator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is the root node in a group, compute the new query limit for
		 * all child groups of the parent group.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsRootOperatorInGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>GetParentOperatorGroup</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ComputeMemLimitForChildGroups</name><argument_list>(<argument><expr><call><name>GetParentOperatorGroup</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsMemoryIntensiveOperator</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>context</name><operator>-&gt;</operator><name>plannedStmt</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>planNode</name><operator>-&gt;</operator><name>operatorMemKB</name></name> <operator>=</operator> <name>nonMemIntenseOpMemKB</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Evenly distribute the remaining memory among all memory-intensive
			 * operators.
			 */</comment>
			<decl_stmt><decl><type><name>uint64</name></type> <name>memKB</name> <init>= <expr><call><name>ComputeAvgMemKBForMemIntenseOp</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>planNode</name><operator>-&gt;</operator><name>operatorMemKB</name></name> <operator>=</operator> <name>memKB</name></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>OperatorGroupNode</name> <modifier>*</modifier></type><name>parentGroupNode</name> <init>= <expr><call><name>GetParentOperatorGroup</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If this is the root node in the group, we also calculate the memory
			 * for this node as it appears in the parent group. The final memory limit
			 * for this node is the minimal value of the two.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsRootOperatorInGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<name>parentGroupNode</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>uint64</name></type> <name>memKBInParentGroup</name> <init>= <expr><call><name>ComputeAvgMemKBForMemIntenseOp</name><argument_list>(<argument><expr><name>parentGroupNode</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>memKBInParentGroup</name> <operator>&lt;</operator> <name><name>planNode</name><operator>-&gt;</operator><name>operatorMemKB</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>planNode</name><operator>-&gt;</operator><name>operatorMemKB</name></name> <operator>=</operator> <name>memKBInParentGroup</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name>plan_tree_walker</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>PolicyEagerFreeAssignWalker</name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this node is the root in a group, we reset some values in the context.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsRootOperatorInGroup</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name> <operator>=</operator> <call><name>GetParentOperatorGroup</name><argument_list>(<argument><expr><name><name>context</name><operator>-&gt;</operator><name>groupNode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * PolicyEagerFreeAssignOperatorMemoryKB
 *    Main entry point for memory quota OPTIMIZE. This function distributes the memory
 * among all operators in a more optimized way than the AUTO policy.
 *
 * This function considers not all memory-intensive operators will be active concurrently,
 * and distributes the memory accordingly.
 */</comment>
<function><type><name>void</name></type>
<name>PolicyEagerFreeAssignOperatorMemoryKB</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name> <modifier>*</modifier></type><name>stmt</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>memAvailableBytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PolicyEagerFreeContext</name></type> <name>ctx</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>exec_init_plan_tree_base</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>base</name></name></expr></argument>, <argument><expr><name>stmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>groupTree</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>groupNode</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>nextGroupId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>queryMemKB</name></name> <operator>=</operator> <name>memAvailableBytes</name> <operator>/</operator> <literal type="number">1024</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>plannedStmt</name></name> <operator>=</operator> <name>stmt</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>=
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr><call><name>PolicyEagerFreePrelimWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Reset groupNode and nextGroupId so that we can start from the
	 * beginning of the group tree.
	 */</comment>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>groupNode</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctx</name><operator>.</operator><name>nextGroupId</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure there is enough operator memory in resource group mode.
	 */</comment>
	<expr_stmt><expr><call><name>autoIncOpMemForResGroup</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>.</operator><name>groupTree</name><operator>-&gt;</operator><name>groupMemKB</name></name></expr></argument>,
							<argument><expr><call><name>Max</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>groupTree</name><operator>-&gt;</operator><name>numNonMemIntenseOps</name></name></expr></argument>,
								<argument><expr><name><name>ctx</name><operator>.</operator><name>groupTree</name><operator>-&gt;</operator><name>maxNumConcNonMemIntenseOps</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
							<call><name>Max</name><argument_list>(<argument><expr><name><name>ctx</name><operator>.</operator><name>groupTree</name><operator>-&gt;</operator><name>numMemIntenseOps</name></name></expr></argument>,
								<argument><expr><name><name>ctx</name><operator>.</operator><name>groupTree</name><operator>-&gt;</operator><name>maxNumConcMemIntenseOps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check if memory exceeds the limit in the root group
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>uint64</name></type> <name>nonMemIntenseOpMemKB</name> <init>= <expr><operator>(</operator><name>uint64</name><operator>)</operator><operator>(</operator><operator>*</operator><name>gp_resmanager_memory_policy_auto_fixed_mem</name><operator>)</operator></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>ctx</name><operator>.</operator><name>groupTree</name><operator>-&gt;</operator><name>groupMemKB</name></name> <operator>&lt;</operator> <name><name>ctx</name><operator>.</operator><name>groupTree</name><operator>-&gt;</operator><name>numNonMemIntenseOps</name></name> <operator>*</operator> <name>nonMemIntenseOpMemKB</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
			<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient memory reserved for statement"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
	<expr_stmt><expr><name>result</name> <operator>=</operator>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<call><name>PolicyEagerFreeAssignWalker</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>stmt</name><operator>-&gt;</operator><name>planTree</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the amount of memory reserved for the query
 */</comment>
<function><type><name>int64</name></type>
<name>ResourceManagerGetQueryMemoryLimit</name><parameter_list>(<parameter><decl><type><name>PlannedStmt</name><modifier>*</modifier></type> <name>stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Returns QD's query_mem if we are on the QE, for re-calculating QE's query_mem */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>stmt</name><operator>-&gt;</operator><name>query_mem</name></name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* no limits in single user mode. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>gp_session_id</name> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ActivePortal</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsResQueueEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ResourceQueueGetQueryMemoryLimit</name><argument_list>(<argument><expr><name>stmt</name></expr></argument>, <argument><expr><name><name>ActivePortal</name><operator>-&gt;</operator><name>queueId</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>IsResGroupActivated</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>ResourceGroupGetQueryMemoryLimit</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
