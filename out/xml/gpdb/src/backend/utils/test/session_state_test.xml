<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/test/session_state_test.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdarg.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stddef.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;setjmp.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cmockery.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"../session_state.c"</cpp:file></cpp:include>

<comment type="block">/*
 * This sets up an expected exception that will be rethrown for
 * verification using PG_TRY(), PG_CATCH() and PG_END_TRY() macros
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EXPECT_EXCEPTION</name><parameter_list>()</parameter_list></cpp:macro>     \
	<cpp:value>expect_any(ExceptionalCondition,conditionName); \
	expect_any(ExceptionalCondition,errorType); \
	expect_any(ExceptionalCondition,fileName); \
	expect_any(ExceptionalCondition,lineNumber); \
    will_be_called_with_sideeffect(ExceptionalCondition, &amp;_ExceptionalCondition, NULL);\

#define EXPECT_EREPORT(LOG_LEVEL)     \
	expect_any(errstart, elevel); \
	expect_any(errstart, domain); \
	if (LOG_LEVEL &lt; ERROR) \
	{ \
    	will_return(errstart, false); \
	} \
    else \
    { \
    	will_return_with_sideeffect(errstart, false, &amp;_ExceptionalCondition, NULL);\
    } \

#undef PG_RE_THROW</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_RE_THROW</name><parameter_list>()</parameter_list></cpp:macro> <cpp:value>siglongjmp(*PG_exception_stack, 1)</cpp:value></cpp:define>

<comment type="block">/*
 * This method will emulate the real ExceptionalCondition
 * function by re-throwing the exception, essentially falling
 * back to the next available PG_CATCH();
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>_ExceptionalCondition</name><parameter_list>()</parameter_list>
<block>{<block_content>
     <expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Creates a SessionStateArray of the specified number of entry */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>CreateSessionStateArray</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>numEntries</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>MaxBackends</name> <operator>=</operator> <name>numEntries</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>NULL</name> <operator>==</operator> <name>AllSessionStateEntries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SessionStateArray</name> <modifier>*</modifier></type><name>fakeSessionStateArray</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>fakeSessionStateArray</name> <operator>=</operator> <call><name>malloc</name><argument_list>(<argument><expr><call><name>SessionState_ShmemSize</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>will_return</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><name>fakeSessionStateArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>will_assign_value</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><name>foundPtr</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><name>foundPtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SessionState_ShmemInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The lookup should always work, whether under postmaster or not */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>AllSessionStateEntries</name> <operator>==</operator> <name>fakeSessionStateArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/* Frees a previously created SessionStateArray */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DestroySessionStateArray</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>AllSessionStateEntries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>AllSessionStateEntries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>AllSessionStateEntries</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Acquires a SessionState entry for the specified sessionid. If an existing entry
 * is found, this method reuses that entry
 */</comment>
<function><type><specifier>static</specifier> <name>SessionState</name> <modifier>*</modifier></type>
<name>AcquireSessionState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sessionId</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>loglevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>will_be_called_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>will_be_called_count</name><argument_list>(<argument><expr><name>LWLockRelease</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockRelease</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Keep the assertions happy */</comment>
	<expr_stmt><expr><name>gp_session_id</name> <operator>=</operator> <name>sessionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sessionStateInited</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>MySessionState</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXPECT_EREPORT</name><argument_list>(<argument><expr><name>loglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SessionState_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>SessionState</name> <operator>*</operator><operator>)</operator> <name>MySessionState</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Releases a SessionState entry for the specified sessionId */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ReleaseSessionState</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sessionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* We call shutdown twice */</comment>
	<expr_stmt><expr><call><name>will_be_called_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>will_be_called_count</name><argument_list>(<argument><expr><name>LWLockRelease</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockRelease</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>gp_session_id</name> <operator>=</operator> <name>sessionId</name></expr>;</expr_stmt>
	<comment type="block">/* First find the previously allocated session state */</comment>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>foundSessionState</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><name>sessionId</name></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>foundSessionState</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>==</operator> <name>sessionId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * It was pre-allocated and we incremented the pinCount
	 * for finding it
	 */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>foundSessionState</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Satisfy assertion */</comment>
	<expr_stmt><expr><name>sessionStateInited</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXPECT_EREPORT</name><argument_list>(<argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Undo for our search pinCount */</comment>
	<expr_stmt><expr><call><name>SessionState_Shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The pinCount should not drop to 0 as we just undid our own increment */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>foundSessionState</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>&gt;=</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>MySessionState</name> <operator>=</operator> <name>foundSessionState</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sessionStateInited</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/*
	 * If we are releasing this SessionState permanently, we need to ensure
	 * that RunawayCleaner_RunawayCleanupDoneForSession() will be called
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>foundSessionState</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>will_be_called</name><argument_list>(<argument><expr><name>RunawayCleaner_RunawayCleanupDoneForSession</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>EXPECT_EREPORT</name><argument_list>(<argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Undo one more to truly undo previously acquired one */</comment>
	<expr_stmt><expr><call><name>SessionState_Shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if SessionState_ShmemInit does nothing under postmaster.
 * Note, it is *only* expected to re-attach with an existing array.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test__SessionState_ShmemInit__NoOpUnderPostmaster</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>AllSessionStateEntries</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>static</specifier> <name>SessionStateArray</name></type> <name>fakeSessionStateArray</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<comment type="block">/* Initilize with some non-zero values */</comment>
	<expr_stmt><expr><name><name>fakeSessionStateArray</name><operator>.</operator><name>maxSession</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fakeSessionStateArray</name><operator>.</operator><name>numSession</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fakeSessionStateArray</name><operator>.</operator><name>freeList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fakeSessionStateArray</name><operator>.</operator><name>usedList</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>will_return</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fakeSessionStateArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>will_assign_value</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><name>foundPtr</name></expr></argument>, <argument><expr><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><name>name</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>ShmemInitStruct</name></expr></argument>, <argument><expr><name>foundPtr</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SessionState_ShmemInit</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The lookup should always work, whether under postmaster or not */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>AllSessionStateEntries</name> <operator>==</operator> <operator>&amp;</operator><name>fakeSessionStateArray</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All the struct properties should be unchanged */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>maxSession</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>numSession</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>freeList</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Undo the assignment for next test */</comment>
	<expr_stmt><expr><name>AllSessionStateEntries</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if SessionState_ShmemInit initializes the SessionState entries
 * when postmaster
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test__SessionState_ShmemInit__InitializesWhenPostmaster</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>IsUnderPostmaster</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* The intention is that MAX_BACKENDS here would match the value in guc.c */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_BACKENDS</name></cpp:macro> <cpp:value>0x7fffff</cpp:value></cpp:define>

	<decl_stmt><decl><type><name>int</name></type> <name><name>allMaxBackends</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">100</literal></expr>, <expr><name>MAX_BACKENDS</name></expr>}</block></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>allMaxBackends</name></expr></argument>)</argument_list></sizeof> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CreateSessionStateArray</name><argument_list>(<argument><expr><name><name>allMaxBackends</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* All the struct properties should be unchanged */</comment>
		<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>maxSession</name></name> <operator>==</operator> <name>MaxBackends</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>numSession</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>freeList</name></name> <operator>==</operator> <name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name></name> <operator>&amp;&amp;</operator>
				<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>prev</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>MaxBackends</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>cur</name> <init>= <expr><operator>(</operator><name>SessionState</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><name>j</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>==</operator> <name>INVALID_SESSION_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>cleanupCountdown</name></name> <operator>==</operator> <name>CLEANUP_COUNTDOWN_BEFORE_RUNAWAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>runawayStatus</name></name> <operator>==</operator> <name>RunawayStatus_NotRunaway</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>activeProcessCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>idle_start</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>sessionVmem</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>spinLock</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>cur</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>prev</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>DestroySessionStateArray</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if SessionState_ShmemInit initializes the usedList and freeList
 * properly
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test__SessionState_ShmemInit__LinkedListSanity</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only 3 entries to test the linked list sanity */</comment>
	<expr_stmt><expr><call><name>CreateSessionStateArray</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>freeList</name></name> <operator>==</operator>  <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>==</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>==</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DestroySessionStateArray</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if SessionState_Init initializes a SessionState entry after acquiring
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test__SessionState_Init__AcquiresAndInitializes</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only 2 entry to test initialization */</comment>
	<expr_stmt><expr><call><name>CreateSessionStateArray</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>theEntry</name> <init>= <expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>freeList</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>theEntry</name><operator>-&gt;</operator><name>activeProcessCount</name></name> <operator>=</operator> <literal type="number">1234</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>theEntry</name><operator>-&gt;</operator><name>idle_start</name></name> <operator>=</operator> <literal type="number">1234</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>theEntry</name><operator>-&gt;</operator><name>cleanupCountdown</name></name> <operator>=</operator> <literal type="number">1234</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>theEntry</name><operator>-&gt;</operator><name>runawayStatus</name></name> <operator>=</operator> <name>RunawayStatus_PrimaryRunawaySession</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>theEntry</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>=</operator> <literal type="number">1234</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>theEntry</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>=</operator> <literal type="number">1234</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>theEntry</name><operator>-&gt;</operator><name>sessionVmem</name></name> <operator>=</operator> <literal type="number">1234</literal></expr>;</expr_stmt>
	<comment type="block">/* Mark it as acquired and see if it is released */</comment>
	<expr_stmt><expr><call><name>SpinLockAcquire</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>theEntry</name><operator>-&gt;</operator><name>spinLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>theEntry</name><operator>-&gt;</operator><name>spinLock</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These should be new */</comment>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>first</name> <operator>==</operator> <name>theEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>theEntry</name><operator>-&gt;</operator><name>activeProcessCount</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>theEntry</name><operator>-&gt;</operator><name>idle_start</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>theEntry</name><operator>-&gt;</operator><name>cleanupCountdown</name></name> <operator>==</operator> <name>CLEANUP_COUNTDOWN_BEFORE_RUNAWAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>theEntry</name><operator>-&gt;</operator><name>runawayStatus</name></name> <operator>==</operator> <name>RunawayStatus_NotRunaway</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>theEntry</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>theEntry</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>theEntry</name><operator>-&gt;</operator><name>sessionVmem</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>theEntry</name><operator>-&gt;</operator><name>spinLock</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DestroySessionStateArray</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Checks if SessionState_Init initializes the global variables
 * such as MySessionState and sessionStateInited properly
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test__SessionState_Init__TestSideffects</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only 2 entry to test initialization */</comment>
	<expr_stmt><expr><call><name>CreateSessionStateArray</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>will_be_called_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>will_be_called_count</name><argument_list>(<argument><expr><name>LWLockRelease</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockRelease</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>MySessionState</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>sessionStateInited</name> <operator>==</operator> <name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EXPECT_EREPORT</name><argument_list>(<argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SessionState_Init</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>NULL</name> <operator>!=</operator> <name>MySessionState</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>sessionStateInited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DestroySessionStateArray</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Checks if SessionState_Init acquires a new entry as well as
 * reuse an existing entry whenever possible
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test__SessionState_Init__AcquiresWithReuse</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only 3 entries to test the reuse */</comment>
	<expr_stmt><expr><call><name>CreateSessionStateArray</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These should be new */</comment>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>second</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>third</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>first</name> <operator>!=</operator> <name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>first</name> <operator>!=</operator> <name>third</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>second</name> <operator>!=</operator> <name>third</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>reuseFirst</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>reuseFirst</name> <operator>==</operator> <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>reuseFirst</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name></name> <operator>==</operator> <name>third</name> <operator>&amp;&amp;</operator>
			<name><name>third</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>second</name> <operator>&amp;&amp;</operator> <name><name>second</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DestroySessionStateArray</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if SessionState_Init fails when no more SessionState entry
 * is available to satisfy a new request
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test__SessionState_Init__FailsIfNoFreeSessionStateEntry</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only 3 entries to exhaust the entries */</comment>
	<expr_stmt><expr><call><name>CreateSessionStateArray</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These should be new */</comment>
	<expr_stmt><expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* No more SessionState entry to satisfy this request */</comment>
		<expr_stmt><expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>, <argument><expr><name>FATAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>assert_false</name><argument_list>(<argument><expr><literal type="string">"No ereport(FATAL, ...) was called"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>

	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DestroySessionStateArray</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if SessionState_Shutdown decrements pinCount and releases
 * SessionState entry as appropriate. The usedList, freeList and
 * sessions array are also checked for sanity
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test__SessionState_Shutdown__ReleaseSessionEntry</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only 3 entries to test the reuse */</comment>
	<expr_stmt><expr><call><name>CreateSessionStateArray</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These should be new */</comment>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>second</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>third</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>first</name> <operator>!=</operator> <name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>second</name> <operator>!=</operator> <name>third</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>reuseFirst</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>reuseFirst</name> <operator>==</operator> <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>reuseFirst</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name></name> <operator>==</operator> <name>third</name> <operator>&amp;&amp;</operator>
			<name><name>third</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>second</name> <operator>&amp;&amp;</operator> <name><name>second</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The entire linked list has been reversed as we shift from freeList to usedList*/</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>==</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>==</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* The last entry is at the head of the usedList */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name>third</name> <operator>==</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* All 3 entries are consumed */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>freeList</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release 1 entry */</comment>
	<expr_stmt><expr><call><name>ReleaseSessionState</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>freeList</name></name> <operator>==</operator> <name>second</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>numSession</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Entry 1 had 2 pinCount. So, we need 2 release call. */</comment>
	<expr_stmt><expr><call><name>ReleaseSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>numSession</name></name> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Only 1 free entry */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>freeList</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>numSession</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Only 1 used entry */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release entry for session 3 */</comment>
	<expr_stmt><expr><call><name>ReleaseSessionState</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>numSession</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Based on free ordering, now we have session 2 at the tail of freeList, preceeded by
	 * session 1 and preceded by session 3. Note, the indexing starts at 0, while session
	 * id starts at 1
	 */</comment>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>==</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>&amp;&amp;</operator>
			<name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name><operator>.</operator><name>next</name> <operator>==</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>freeList</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>sessions</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>DestroySessionStateArray</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Checks if SessionState_Shutdown marks the session clean when the pinCount
 * drops to 0 (i.e., releasing the entry back to the freeList)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>test__SessionState_Shutdown__MarksSessionCleanUponRelease</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Only 3 entries to test the reuse */</comment>
	<expr_stmt><expr><call><name>CreateSessionStateArray</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* These should be new */</comment>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>first</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>reuseFirst</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>reuseAgain</name> <init>= <expr><call><name>AcquireSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name>reuseFirst</name> <operator>==</operator> <name>first</name> <operator>&amp;&amp;</operator> <name>reuseAgain</name> <operator>==</operator> <name>first</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>reuseFirst</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>==</operator> <literal type="number">3</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Entry 1 had 2 pinCount. So, we need 3 release call. */</comment>
	<expr_stmt><expr><call><name>ReleaseSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>reuseFirst</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>numSession</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseSessionState</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>reuseFirst</name><operator>-&gt;</operator><name>pinCount</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>numSession</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>will_be_called_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>will_be_called_count</name><argument_list>(<argument><expr><name>LWLockRelease</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockAcquire</name></expr></argument>, <argument><expr><name>mode</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>expect_any_count</name><argument_list>(<argument><expr><name>LWLockRelease</name></expr></argument>, <argument><expr><name>lock</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Bypass assertion */</comment>
	<expr_stmt><expr><name>MySessionState</name> <operator>=</operator> <name>first</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>sessionStateInited</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>will_be_called</name><argument_list>(<argument><expr><name>RunawayCleaner_RunawayCleanupDoneForSession</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EXPECT_EREPORT</name><argument_list>(<argument><expr><name>gp_sessionstate_loglevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* This will finally release the entry */</comment>
	<expr_stmt><expr><call><name>SessionState_Shutdown</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>assert_true</name><argument_list>(<argument><expr><name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>numSession</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DestroySessionStateArray</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int</name></type>
<name>main</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>argc</name></decl></parameter>, <parameter><decl><type><name>char</name><modifier>*</modifier></type> <name><name>argv</name><index>[]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>cmockery_parse_arguments</name><argument_list>(<argument><expr><name>argc</name></expr></argument>, <argument><expr><name>argv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * Initializing the gp_sessionstate_loglevel to make sure it is not
	 * set to some random value
	 */</comment>
	<expr_stmt><expr><name>gp_sessionstate_loglevel</name> <operator>=</operator> <name>LOG</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>UnitTest</name></type> <name><name>tests</name><index>[]</index></name> <init>= <expr><block>{
		<expr><call><name>unit_test</name><argument_list>(<argument><expr><name>test__SessionState_ShmemInit__NoOpUnderPostmaster</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>unit_test</name><argument_list>(<argument><expr><name>test__SessionState_ShmemInit__InitializesWhenPostmaster</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>unit_test</name><argument_list>(<argument><expr><name>test__SessionState_ShmemInit__LinkedListSanity</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>unit_test</name><argument_list>(<argument><expr><name>test__SessionState_Init__TestSideffects</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>unit_test</name><argument_list>(<argument><expr><name>test__SessionState_Init__AcquiresWithReuse</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>unit_test</name><argument_list>(<argument><expr><name>test__SessionState_Init__AcquiresAndInitializes</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>unit_test</name><argument_list>(<argument><expr><name>test__SessionState_Init__FailsIfNoFreeSessionStateEntry</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>unit_test</name><argument_list>(<argument><expr><name>test__SessionState_Shutdown__ReleaseSessionEntry</name></expr></argument>)</argument_list></call></expr>,
		<expr><call><name>unit_test</name><argument_list>(<argument><expr><name>test__SessionState_Shutdown__MarksSessionCleanUponRelease</name></expr></argument>)</argument_list></call></expr>,
	}</block></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>run_tests</name><argument_list>(<argument><expr><name>tests</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
