<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/resgroup/cgroup-ops-linux-v1.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * cgroup-ops-linux-v1.c
 *	  OS dependent resource group operations - cgroup implementation
 *
 * Copyright (c) 2017 VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/utils/resgroup/cgroup-ops-linux-v1.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cgroup-ops-v1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/vmem_tracker.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__linux__</name></cpp:ifndef>
<cpp:error>#<cpp:directive>error</cpp:directive>  cgroup is only available on linux</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sched.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mntent.h&gt;</cpp:file></cpp:include>

<decl_stmt><decl><type><specifier>static</specifier> <name>CGroupSystemInfo</name></type> <name>cgroupSystemInfoAlpha</name> <init>= <expr><block>{
		<expr><literal type="number">0</literal></expr>,
		<expr><literal type="string">""</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Interfaces for OS dependent operations.
 *
 * Resource group relies on OS dependent group implementation to manage
 * resources like cpu usage, such as cgroup on Linux system.
 * We call it OS group in below function description.
 *
 * So far these operations are mainly for CPU rate limitation and accounting.
 */</comment>


<comment type="block">/*
 * cgroup memory permission is only mandatory on 6.x and main;
 * on 5.x we need to make it optional to provide backward compatibilities.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CGROUP_MEMORY_IS_OPTIONAL</name></cpp:macro> <cpp:value>(GP_VERSION_NUM &lt; 60000)</cpp:value></cpp:define>
<comment type="block">/*
 * cpuset permission is only mandatory on 6.x and main;
 * on 5.x we need to make it optional to provide backward compatibilities.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CGROUP_CPUSET_IS_OPTIONAL</name></cpp:macro> <cpp:value>(GP_VERSION_NUM &lt; 60000)</cpp:value></cpp:define>


<typedef>typedef <type><name><name>struct</name> <name>PermItem</name></name></type> <name>PermItem</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>PermList</name></name></type> <name>PermList</name>;</typedef>

<struct>struct <name>PermItem</name>
<block>{
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>comp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>			<modifier>*</modifier></type><name>prop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>					<name>perm</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>PermList</name>
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>PermItem</name>	<modifier>*</modifier></type><name>items</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>optional</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>			<modifier>*</modifier></type><name>presult</name></decl>;</decl_stmt>
}</block>;</struct>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>foreach_perm_list</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>lists</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>for ((i) = 0; (lists)[(i)].items; (i)++)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>foreach_perm_item</name><parameter_list>(<parameter><type><name>i</name></type></parameter>, <parameter><type><name>items</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>for ((i) = 0; (items)[(i)].comp != CGROUP_COMPONENT_UNKNOWN; (i)++)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>foreach_comp_type</name><parameter_list>(<parameter><type><name>comp</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>for ((comp) = CGROUP_COMPONENT_FIRST; \
		 (comp) &lt; CGROUP_COMPONENT_COUNT; \
		 (comp)++)</cpp:value></cpp:define>


<comment type="block">/* The functions current file used */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>detect_component_dirs_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_component_dirs_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>perm_list_check_alpha</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PermList</name> <modifier>*</modifier></type><name>permlist</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>report</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_permission_alpha</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>report</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>check_cpuset_permission_alpha</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>report</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>check_component_hierarchy_alpha</name><parameter_list>()</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_cpu_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>init_cpuset_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>create_default_cpuset_group_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>get_cfs_period_us_alpha</name><parameter_list>(<parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * currentGroupIdInCGroup &amp; oldCaps are used for reducing redundant
 * file operations
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type> <name>currentGroupIdInCGroup</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>system_cfs_quota_us</name> <init>= <expr><operator>-</operator><literal type="number">1LL</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int64</name></type> <name>parent_cfs_quota_us</name> <init>= <expr><operator>-</operator><literal type="number">1LL</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * These checks should keep in sync with gpMgmt/bin/gpcheckresgroupimpl
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PermItem</name></type> <name><name>perm_items_cpu</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPU</name></expr>, <expr><literal type="string">""</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name> <operator>|</operator> <name>X_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPU</name></expr>, <expr><literal type="string">"cgroup.procs"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPU</name></expr>, <expr><literal type="string">"cpu.cfs_period_us"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPU</name></expr>, <expr><literal type="string">"cpu.cfs_quota_us"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPU</name></expr>, <expr><literal type="string">"cpu.shares"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_UNKNOWN</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PermItem</name></type> <name><name>perm_items_cpu_acct</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPUACCT</name></expr>, <expr><literal type="string">""</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name> <operator>|</operator> <name>X_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPUACCT</name></expr>, <expr><literal type="string">"cgroup.procs"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPUACCT</name></expr>, <expr><literal type="string">"cpuacct.usage"</literal></expr>, <expr><name>R_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPUACCT</name></expr>, <expr><literal type="string">"cpuacct.stat"</literal></expr>, <expr><name>R_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_UNKNOWN</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PermItem</name></type> <name><name>perm_items_cpuset</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPUSET</name></expr>, <expr><literal type="string">""</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name> <operator>|</operator> <name>X_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPUSET</name></expr>, <expr><literal type="string">"cgroup.procs"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPUSET</name></expr>, <expr><literal type="string">"cpuset.cpus"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_CPUSET</name></expr>, <expr><literal type="string">"cpuset.mems"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_UNKNOWN</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PermItem</name></type> <name><name>perm_items_memory</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{ <expr><name>CGROUP_COMPONENT_MEMORY</name></expr>, <expr><literal type="string">""</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name> <operator>|</operator> <name>X_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_MEMORY</name></expr>, <expr><literal type="string">"memory.limit_in_bytes"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_MEMORY</name></expr>, <expr><literal type="string">"memory.usage_in_bytes"</literal></expr>, <expr><name>R_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_UNKNOWN</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PermItem</name></type> <name><name>perm_items_swap</name><index>[]</index></name> <init>=
<expr><block>{
	<expr><block>{ <expr><name>CGROUP_COMPONENT_MEMORY</name></expr>, <expr><literal type="string">""</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name> <operator>|</operator> <name>X_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_MEMORY</name></expr>, <expr><literal type="string">"memory.memsw.limit_in_bytes"</literal></expr>, <expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_MEMORY</name></expr>, <expr><literal type="string">"memory.memsw.usage_in_bytes"</literal></expr>, <expr><name>R_OK</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>CGROUP_COMPONENT_UNKNOWN</name></expr>, <expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * just for cpuset check, same as the cpuset Permlist in permlists
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PermList</name></type> <name>cpusetPermList</name> <init>=
<expr><block>{
	<expr><name>perm_items_cpuset</name></expr>,
	<expr><name>CGROUP_CPUSET_IS_OPTIONAL</name></expr>,
	<expr><operator>&amp;</operator><name>gp_resource_group_enable_cgroup_cpuset</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Permission groups.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>PermList</name></type> <name><name>permlists</name><index>[]</index></name> <init>=
<expr><block>{
	<comment type="block">/*
	 * swap permissions are optional.
	 *
	 * cgroup/memory/memory.memsw.* is only available if
	 * - CONFIG_MEMCG_SWAP_ENABLED=on in kernel config, or
	 * - swapaccount=1 in kernel cmdline.
	 *
	 * Without these interfaces the swap usage can not be limited or accounted
	 * via cgroup.
	 */</comment>
	<expr><block>{ <expr><name>perm_items_swap</name></expr>, <expr><name>true</name></expr>, <expr><operator>&amp;</operator><name>gp_resource_group_enable_cgroup_swap</name></expr> }</block></expr>,

	<comment type="block">/*
	 * memory permissions can be mandatory or optional depends on the switch.
	 *
	 * resgroup memory auditor is introduced in 6.0 devel and backport
	 * to 5.x branch since 5.6.1.  To provide backward compatibilities' memory
	 * permissions are optional on 5.x branch.
	 */</comment>
	<expr><block>{ <expr><name>perm_items_memory</name></expr>, <expr><name>CGROUP_MEMORY_IS_OPTIONAL</name></expr>,
		<expr><operator>&amp;</operator><name>gp_resource_group_enable_cgroup_memory</name></expr> }</block></expr>,

	<comment type="block">/* cpu/cpuacct permissions are mandatory */</comment>
	<expr><block>{ <expr><name>perm_items_cpu</name></expr>, <expr><name>false</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,
	<expr><block>{ <expr><name>perm_items_cpu_acct</name></expr>, <expr><name>false</name></expr>, <expr><name>NULL</name></expr> }</block></expr>,

	<comment type="block">/*
	 * cpuset permissions can be mandatory or optional depends on the switch.
	 *
	 * resgroup cpuset is introduced in 6.0 devel and backport
	 * to 5.x branch since 5.6.1.  To provide backward compatibilities cpuset
	 * permissions are optional on 5.x branch.
	 */</comment>
	<expr><block>{ <expr><name>perm_items_cpuset</name></expr>, <expr><name>CGROUP_CPUSET_IS_OPTIONAL</name></expr>,
		<expr><operator>&amp;</operator><name>gp_resource_group_enable_cgroup_cpuset</name></expr>}</block></expr>,

	<expr><block>{ <expr><name>NULL</name></expr>, <expr><name>false</name></expr>, <expr><name>NULL</name></expr> }</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>getcgroupname_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>probecgroup_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>checkcgroup_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initcgroup_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>adjustgucs_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>createcgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>attachcgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_cpuset_enabled</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>detachcgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd_dir</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>destroycgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>migrate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>lockcgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unlockcgroup_v1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setcpulimit_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cpu_rate_limit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setmemorylimitbychunks_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>memory_limit_chunks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setmemorylimit_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>memory_limit</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int64</name></type> <name>getcpuusage_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>getmemoryusage_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>getmemorylimitchunks_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>getcpuset_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setcpuset_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpuset</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float</name></type> <name>convertcpuusage_v1</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>usage</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>duration</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Detect gpdb cgroup component dirs.
 *
 * Take cpu for example, by default we expect gpdb dir to locate at
 * cgroup/cpu/gpdb.  But we'll also check for the cgroup dirs of init process
 * (pid 1), e.g. cgroup/cpu/custom, then we'll look for gpdb dir at
 * cgroup/cpu/custom/gpdb, if it's found and has good permissions, it can be
 * used instead of the default one.
 *
 * If any of the gpdb cgroup component dir can not be found under init process'
 * cgroup dirs or has bad permissions we'll fallback all the gpdb cgroup
 * component dirs to the default ones.
 *
 * NOTE: This auto detection will look for memory &amp; cpuset gpdb dirs even on
 * 5X.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>detect_component_dirs_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>	   <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maskAll</name> <init>= <expr><operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>CGROUP_COMPONENT_COUNT</name><operator>)</operator> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>maskDetected</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"/proc/1/cgroup"</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fallback</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * format: id:comps:path, e.g.:
	 *
	 *     10:cpuset:/
	 *     4:cpu,cpuacct:/
	 *     1:name=systemd:/init.scope
	 *     0::/init.scope
	 */</comment>
	<while>while <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%*d:%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name><name>components</name><index>[<expr><name>CGROUP_COMPONENT_COUNT</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ncomps</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>sep</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/* buf is stored with "comps:path" */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* ignore empty comp */</comment>

		<comment type="block">/* split comps */</comment>
		<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><name>sep</name> <operator>!=</operator> <literal type="char">':'</literal></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name>tmp</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>strpbrk</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">":,="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>sep</name> <operator>=</operator> <operator>*</operator><name>tmp</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tmp</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* for name=comp case there is nothing to do with the name */</comment>
			<if_stmt><if>if <condition>(<expr><name>sep</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>component</name> <operator>=</operator> <call><name>getComponentType</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>component</name> <operator>==</operator> <name>CGROUP_COMPONENT_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* not used by us */</comment>

			<comment type="block">/*
			 * push the comp to the comps stack, but if the stack is already
			 * full (which is unlikely to happen in real world), simply ignore
			 * it.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ncomps</name> <operator>&lt;</operator> <name>CGROUP_COMPONENT_COUNT</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>components</name><index>[<expr><name>ncomps</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>component</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* now ptr point to the path */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_CGROUP_PATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* if the path is "/" then use empty string "" instead of it */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">"/"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>ptr</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* validate and set path for the comps */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>ncomps</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>component</name> <operator>=</operator> <name><name>components</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>setComponentDir</name><argument_list>(<argument><expr><name>component</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>validateComponentDir</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fallback</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* dir missing or bad permissions */</comment>

			<if_stmt><if>if <condition>(<expr><name>maskDetected</name> <operator>&amp;</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>component</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<goto>goto <name>fallback</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* comp are detected more than once */</comment>

			<expr_stmt><expr><name>maskDetected</name> <operator>|=</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>component</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>maskDetected</name> <operator>!=</operator> <name>maskAll</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fallback</name>;</goto></block_content></block></if></if_stmt> <comment type="block">/* not all the comps are detected */</comment>

	<comment type="block">/*
	 * Dump the comp dirs for debugging?  No!
	 * This function is executed before timezone initialization, logs are
	 * forbidden.
	 */</comment>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return;</return>

<label><name>fallback</name>:</label>
	<comment type="block">/* set the fallback dirs for all the comps */</comment>
	<macro><name>foreach_comp_type</name><argument_list>(<argument>component</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>setComponentDir</name><argument_list>(<argument><expr><name>component</name></expr></argument>, <argument><expr><name>FALLBACK_COMP_DIR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>f</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Dump comp dirs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_component_dirs_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<macro><name>foreach_comp_type</name><argument_list>(<argument>component</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"gpdb dir for cgroup component \"%s\": %s"</literal></expr></argument>,
			 <argument><expr><call><name>getComponentName</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Check a list of permissions on group.
 *
 * - if all the permissions are met then return true;
 * - otherwise:
 *   - raise an error if report is true and permlist is not optional;
 *   - or return false;
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>perm_list_check_alpha</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PermList</name> <modifier>*</modifier></type><name>permlist</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>report</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <name>CGROUP_ROOT_ID</name> <operator>&amp;&amp;</operator> <name><name>permlist</name><operator>-&gt;</operator><name>presult</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name><name>permlist</name><operator>-&gt;</operator><name>presult</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<macro><name>foreach_perm_item</name><argument_list>(<argument>i</argument>, <argument>permlist-&gt;items</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name><name>permlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>comp</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	<modifier>*</modifier></type><name>prop</name> <init>= <expr><name><name>permlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>prop</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>perm</name> <init>= <expr><name><name>permlist</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>perm</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildPathSafe</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>prop</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Buffer is not large enough for the path */</comment>

			<if_stmt><if>if <condition>(<expr><name>report</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>permlist</name><operator>-&gt;</operator><name>optional</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CGROUP_CONFIG_ERROR</name><argument_list>(<argument><expr><literal type="string">"invalid %s name '%s': %m"</literal></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>prop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"file"</literal></expr> </then><else>: <expr><literal type="string">"directory"</literal></expr></else></ternary></expr></argument>,
									<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>perm</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* No such file or directory / Permission denied */</comment>

			<if_stmt><if>if <condition>(<expr><name>report</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>permlist</name><operator>-&gt;</operator><name>optional</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>CGROUP_CONFIG_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't access %s '%s': %m"</literal></expr></argument>,
									<argument><expr><ternary><condition><expr><name><name>prop</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"file"</literal></expr> </then><else>: <expr><literal type="string">"directory"</literal></expr></else></ternary></expr></argument>,
									<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <name>CGROUP_ROOT_ID</name> <operator>&amp;&amp;</operator> <name><name>permlist</name><operator>-&gt;</operator><name>presult</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name><name>permlist</name><operator>-&gt;</operator><name>presult</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check permissions on group's cgroup dir &amp; interface files.
 *
 * - if report is true then raise an error if any mandatory permission
 *   is not met;
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_permission_alpha</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>report</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<macro><name>foreach_perm_list</name><argument_list>(<argument>i</argument>, <argument>permlists</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>PermList</name> <modifier>*</modifier></type><name>permList</name> <init>= <expr><operator>&amp;</operator><name><name>permlists</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>perm_list_check_alpha</name><argument_list>(<argument><expr><name>permList</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>report</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>permList</name><operator>-&gt;</operator><name>optional</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Same as check_permission, just check cpuset dir &amp; interface files.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>check_cpuset_permission_alpha</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>report</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>perm_list_check_alpha</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cpusetPermList</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>report</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>cpusetPermList</name><operator>.</operator><name>optional</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check the mount hierarchy of cpu and cpuset subsystem.
 *
 * Raise an error if cpu and cpuset are mounted on the same hierarchy.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>check_component_hierarchy_alpha</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name>       <modifier>*</modifier></type><name>f</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>        <name><name>buf</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>f</name> <operator>=</operator> <call><name>fopen</name><argument_list>(<argument><expr><literal type="string">"/proc/1/cgroup"</literal></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>f</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CGROUP_CONFIG_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't check component mount hierarchy \
					file '/proc/1/cgroup' doesn't exist"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * format: id:comps:path, e.g.:
	 *
	 * 10:cpuset:/
	 * 4:cpu,cpuacct:/
	 * 1:name=systemd:/init.scope
	 * 0::/init.scope
	 */</comment>
	<while>while <condition>(<expr><call><name>fscanf</name><argument_list>(<argument><expr><name>f</name></expr></argument>, <argument><expr><literal type="string">"%*d:%s"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>EOF</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>ptr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>       <modifier>*</modifier></type><name>tmp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>        <name>sep</name> <init>= <expr><literal type="char">'\0'</literal></expr></init></decl>;</decl_stmt>
		<comment type="block">/* mark if the line has already contained cpu or cpuset component */</comment>
		<decl_stmt><decl><type><name>int</name></type>        <name>markComp</name> <init>= <expr><name>CGROUP_COMPONENT_UNKNOWN</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* buf is stored with "comps:path" */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>buf</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* ignore empty comp */</comment>

		<comment type="block">/* split comps */</comment>
		<for>for <control>(<init><expr><name>ptr</name> <operator>=</operator> <name>buf</name></expr>;</init> <condition><expr><name>sep</name> <operator>!=</operator> <literal type="char">':'</literal></expr>;</condition> <incr><expr><name>ptr</name> <operator>=</operator> <name>tmp</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>strpbrk</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><literal type="string">":,="</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><name>sep</name> <operator>=</operator> <operator>*</operator><name>tmp</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tmp</name><operator>++</operator> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

			<comment type="block">/* for name=comp case there is nothing to do with the name */</comment>
			<if_stmt><if>if <condition>(<expr><name>sep</name> <operator>==</operator> <literal type="char">'='</literal></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>component</name> <operator>=</operator> <call><name>getComponentType</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>component</name> <operator>==</operator> <name>CGROUP_COMPONENT_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt> <comment type="block">/* not used by us */</comment>
			
			<if_stmt><if>if <condition>(<expr><name>component</name> <operator>==</operator> <name>CGROUP_COMPONENT_CPU</name> <operator>||</operator> <name>component</name> <operator>==</operator> <name>CGROUP_COMPONENT_CPUSET</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>markComp</name> <operator>==</operator> <name>CGROUP_COMPONENT_UNKNOWN</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>markComp</name> <operator>=</operator> <name>component</name></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>markComp</name> <operator>!=</operator> <name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>CGROUP_CONFIG_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't mount 'cpu' and 'cpuset' on the same hierarchy"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return;</return>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>fclose</name><argument_list>(<argument><expr><name>f</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Init gpdb cpu settings.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_cpu_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_CPU</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>cfs_quota_us</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>shares</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * CGroup promises that cfs_quota_us will never be 0, however on centos6
	 * we ever noticed that it has the value 0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>parent_cfs_quota_us</name> <operator>&lt;=</operator> <literal type="number">0LL</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * parent cgroup is unlimited, calculate gpdb's limitation based on
		 * system hardware configuration.
		 *
		 * cfs_quota_us := parent.cfs_period_us * ncores * gp_resource_group_cpu_limit
		 */</comment>
		<expr_stmt><expr><name>cfs_quota_us</name> <operator>=</operator> <name>system_cfs_quota_us</name> <operator>*</operator> <name>gp_resource_group_cpu_limit</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * parent cgroup is also limited, then calculate gpdb's limitation
		 * based on it.
		 *
		 * cfs_quota_us := parent.cfs_quota_us * gp_resource_group_cpu_limit
		 */</comment>
		<expr_stmt><expr><name>cfs_quota_us</name> <operator>=</operator> <name>parent_cfs_quota_us</name> <operator>*</operator> <name>gp_resource_group_cpu_limit</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>,
			   <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpu.cfs_quota_us"</literal></expr></argument>, <argument><expr><name>cfs_quota_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * shares := parent.shares * gp_resource_group_cpu_priority
	 *
	 * We used to set a large shares (like 1024 * 50, the maximum possible
	 * value), it has very bad effect on overall system performance,
	 * especially on 1-core or 2-core low-end systems.
	 */</comment>
	<expr_stmt><expr><name>shares</name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_PARENT</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpu.shares"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>shares</name> <operator>=</operator> <name>shares</name> <operator>*</operator> <name>gp_resource_group_cpu_priority</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpu.shares"</literal></expr></argument>, <argument><expr><name>shares</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Init gpdb cpuset settings.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>init_cpuset_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_CPUSET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>buffer</name><index>[<expr><name>MaxCpuSetLength</name></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get cpuset.mems and cpuset.cpus values from cgroup cpuset root path,
	 * and set them to cpuset/gpdb/cpuset.mems and cpuset/gpdb/cpuset.cpus
	 * to make sure that gpdb directory configuration is same as its
	 * parent directory
	 */</comment>

	<expr_stmt><expr><call><name>readStr</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_PARENT</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.mems"</literal></expr></argument>,
			<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>writeStr</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.mems"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>readStr</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_PARENT</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.cpus"</literal></expr></argument>,
			<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>writeStr</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.cpus"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>create_default_cpuset_group_alpha</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int64</name></type>
<name>get_cfs_period_us_alpha</name><parameter_list>(<parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>cfs_period_us</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * calculate cpu rate limit of system.
	 *
	 * Ideally the cpu quota is calculated from parent information:
	 *
	 * system_cfs_quota_us := parent.cfs_period_us * ncores.
	 *
	 * However, on centos6 we found parent.cfs_period_us can be 0 and is not
	 * writable.  In the other side, gpdb.cfs_period_us should be equal to
	 * parent.cfs_period_us because sub dirs inherit parent properties by
	 * default, so we read it instead.
	 */</comment>
	<expr_stmt><expr><name>cfs_period_us</name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>,
							  <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpu.cfs_period_us"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>cfs_period_us</name> <operator>==</operator> <literal type="number">0LL</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * if gpdb.cfs_period_us is also 0 try to correct it by setting the
		 * default value 100000 (100ms).
		 */</comment>
		<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>,
				   <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpu.cfs_period_us"</literal></expr></argument>, <argument><expr><name>DEFAULT_CPU_PERIOD_US</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* read again to verify the effect */</comment>
		<expr_stmt><expr><name>cfs_period_us</name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>,
								  <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpu.cfs_period_us"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cfs_period_us</name> <operator>&lt;=</operator> <literal type="number">0LL</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CGROUP_CONFIG_ERROR</name><argument_list>(<argument><expr><literal type="string">"invalid cpu.cfs_period_us value: "</literal>
								<name>INT64_FORMAT</name></expr></argument>,
								<argument><expr><name>cfs_period_us</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>cfs_period_us</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Return the name for the OS group implementation */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getcgroupname_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><literal type="string">"cgroup"</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Probe the configuration for the OS group implementation.
 *
 * Return true if everything is OK, or false is some requirements are not
 * satisfied.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>probecgroup_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Ignore the error even if cgroup mount point can not be successfully
	 * probed, the error will be reported in checkcgroup() later.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>getCgroupMountDir</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>detect_component_dirs_alpha</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>check_permission_alpha</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Check whether the OS group implementation is available and usable */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>checkcgroup_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_CPU</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>cfs_period_us</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only have to do these checks and initialization once on each host,
	 * so only let postmaster do the job.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>IsUnderPostmaster</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should have already detected for cgroup mount point in probecgroup(),
	 * it was not an error if the detection failed at that step.  But once
	 * we call checkcgroup() we know we want to make use of cgroup then we must
	 * know the mount point, otherwise it's a critical error.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>cgroupSystemInfoAlpha</name><operator>.</operator><name>cgroup_dir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CGROUP_CONFIG_ERROR</name><argument_list>(<argument><expr><literal type="string">"can not find cgroup mount point"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check again, this time we will fail on unmet requirements.
	 */</comment>
	<expr_stmt><expr><call><name>check_permission_alpha</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
 	 * Check if cpu and cpuset subsystems are mounted on the same hierarchy.
 	 * We do not allow they mount on the same hierarchy, because writing pid
 	 * to DEFAULT_CPUSET_GROUP_ID in attachcgroup will cause the
 	 * removal of the pid in group BASEDIR_GPDB, which will make cpu usage
 	 * out of control.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>CGROUP_CPUSET_IS_OPTIONAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>check_component_hierarchy_alpha</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Dump the cgroup comp dirs to logs.
	 * Check detect_component_dirs() to know why this is not done in that function.
	 */</comment>
	<expr_stmt><expr><call><name>dump_component_dirs_alpha</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get some necessary system information.
	 * We can not do them in probecgroup() as failure is not allowed in that one.
	 */</comment>

	<comment type="block">/* get system cpu cores */</comment>
	<expr_stmt><expr><name><name>cgroupSystemInfoAlpha</name><operator>.</operator><name>ncores</name></name> <operator>=</operator> <call><name>getCPUCores</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cfs_period_us</name> <operator>=</operator> <call><name>get_cfs_period_us_alpha</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>system_cfs_quota_us</name> <operator>=</operator> <name>cfs_period_us</name> <operator>*</operator> <name><name>cgroupSystemInfoAlpha</name><operator>.</operator><name>ncores</name></name></expr>;</expr_stmt>

	<comment type="block">/* read cpu rate limit of parent cgroup */</comment>
	<expr_stmt><expr><name>parent_cfs_quota_us</name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_PARENT</name></expr></argument>,
									<argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpu.cfs_quota_us"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Initialize the OS group */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initcgroup_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>init_cpu_alpha</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>init_cpuset_alpha</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * After basic controller inited, we need to create the SYSTEM CGROUP
	 * which will control the postmaster and auxiliary process, such as
	 * BgWriter, SysLogger.
	 *
	 * We need to add it to the system cgroup before the postmaster fork
	 * the child process to limit the resource usage of the parent process
	 * and all child processes.
	 */</comment>
	<expr_stmt><expr><call><name>createcgroup_v1</name><argument_list>(<argument><expr><name>GPDB_SYSTEM_CGROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>attachcgroup_v1</name><argument_list>(<argument><expr><name>GPDB_SYSTEM_CGROUP</name></expr></argument>, <argument><expr><name>PostmasterPid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Adjust GUCs for this OS group implementation */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>adjustgucs_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * cgroup cpu limitation works best when all processes have equal
	 * priorities, so we force all the segments and postmaster to
	 * work with nice=0.
	 *
	 * this function should be called before GUCs are dispatched to segments.
	 */</comment>
	<expr_stmt><expr><name>gp_segworker_relative_priority</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the OS group for group.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>createcgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>createDir</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_CPU</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>createDir</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_CPUACCT</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name>gp_resource_group_enable_cgroup_memory</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>createDir</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_MEMORY</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>gp_resource_group_enable_cgroup_cpuset</name> <operator>&amp;&amp;</operator>
		 <operator>!</operator><call><name>createDir</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_CPUSET</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CGROUP_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't create cgroup for resource group '%d': %m"</literal></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * although the group dir is created the interface files may not be
	 * created yet, so we check them repeatedly until everything is ready.
	 */</comment>
	<while>while <condition>(<expr><operator>++</operator><name>retry</name> <operator>&lt;=</operator> <name>MAX_RETRY</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>check_permission_alpha</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><name>retry</name> <operator>&gt;</operator> <name>MAX_RETRY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * still not ready after MAX_RETRY retries, might be a real error,
		 * raise the error.
		 */</comment>
		<expr_stmt><expr><call><name>check_permission_alpha</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Initialize cpuset.mems and cpuset.cpus values as its parent directory
		 */</comment>
		<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_CPUSET</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>MaxCpuSetLength</name></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>readStr</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.mems"</literal></expr></argument>,
				<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>writeStr</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.mems"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>readStr</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.cpus"</literal></expr></argument>,
				<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>writeStr</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.cpus"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Create the OS group for default cpuset group.
 * default cpuset group is a special group, only take effect in cpuset
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>create_default_cpuset_group_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_CPUSET</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>retry</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>createDir</name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>component</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CGROUP_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't create cpuset cgroup for resgroup '%d': %m"</literal></expr></argument>,
					 <argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * although the group dir is created the interface files may not be
	 * created yet, so we check them repeatedly until everything is ready.
	 */</comment>
	<while>while <condition>(<expr><operator>++</operator><name>retry</name> <operator>&lt;=</operator> <name>MAX_RETRY</name> <operator>&amp;&amp;</operator>
		   <operator>!</operator><call><name>check_cpuset_permission_alpha</name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>

	<if_stmt><if>if <condition>(<expr><name>retry</name> <operator>&gt;</operator> <name>MAX_RETRY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * still not ready after MAX_RETRY retries, might be a real error,
		 * raise the error.
		 */</comment>
		<expr_stmt><expr><call><name>check_cpuset_permission_alpha</name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initialize cpuset.mems and cpuset.cpus in default group as its
	 * parent directory
	 */</comment>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><name>MaxCpuSetLength</name></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>readStr</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.mems"</literal></expr></argument>,
			<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>writeStr</name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.mems"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>readStr</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.cpus"</literal></expr></argument>,
			<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>writeStr</name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.cpus"</literal></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Assign a process to the OS group. A process can only be assigned to one
 * OS group, if it's already running under other OS group then it'll be moved
 * out that OS group.
 *
 * pid is the process id.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>attachcgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_cpuset_enabled</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * needn't write to file if the pid has already been written in.
	 * Unless it has not been written or the group has changed or
	 * cpu control mechanism has changed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>IsUnderPostmaster</name> <operator>&amp;&amp;</operator> <name>group</name> <operator>==</operator> <name>currentGroupIdInCGroup</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_CPU</name></expr></argument>,
			   <argument><expr><literal type="string">"cgroup.procs"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_CPUACCT</name></expr></argument>,
			   <argument><expr><literal type="string">"cgroup.procs"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>is_cpuset_enabled</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>,
					   <argument><expr><name>CGROUP_COMPONENT_CPUSET</name></expr></argument>, <argument><expr><literal type="string">"cgroup.procs"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* add pid to default group */</comment>
			<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>,
					   <argument><expr><name>CGROUP_COMPONENT_CPUSET</name></expr></argument>, <argument><expr><literal type="string">"cgroup.procs"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Do not assign the process to cgroup/memory for now.
	 */</comment>

	<expr_stmt><expr><name>currentGroupIdInCGroup</name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * un-assign all the processes from a cgroup.
 *
 * These processes will be moved to the gpdb default cgroup.
 *
 * This function must be called with the gpdb toplevel dir locked,
 * fd_dir is the fd for this lock, on any failure fd_dir will be closed
 * (and unlocked implicitly) then an error is raised.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>detachcgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd_dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> 	<name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> 	<name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name> 	<modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> 	<name>buf_size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> 	<name>buf_len</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>fdr</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fdw</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>const</specifier> <name>size_t</name></type> <name>buf_delta_size</name> <init>= <expr><literal type="number">512</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check an operation result on path.
	 *
	 * Operation can be open(), close(), read(), write(), etc., which must
	 * set the errno on error.
	 *
	 * - condition describes the expected result of the operation;
	 * - action is the cleanup action on failure, such as closing the fd,
	 *   multiple actions can be specified by putting them in brackets,
	 *   such as (op1, op2);
	 * - message describes what's failed;
	 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>__CHECK</name><parameter_list>(<parameter><type><name>condition</name></type></parameter>, <parameter><type><name>action</name></type></parameter>, <parameter><type><name>message</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { \
	if (!(condition)) \
	{ \
		<comment type="block">/* save errno in case it's changed in actions */</comment> \
		int err = errno; \
		action; \
		CGROUP_ERROR(message ": %s: %s", path, strerror(err)); \
	} \
} while (0)</cpp:value></cpp:define>

	<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cgroup.procs"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fdr</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>__CHECK</name><argument_list>(<argument><expr><name>fdr</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd_dir</name></expr></argument>)</argument_list></call> <operator>)</operator></expr></argument>, <argument><expr><literal type="string">"can't open file for read"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf_len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf_size</name> <operator>=</operator> <name>buf_delta_size</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><name>fdr</name></expr></argument>, <argument><expr><name>buf</name> <operator>+</operator> <name>buf_len</name></expr></argument>, <argument><expr><name>buf_delta_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>__CHECK</name><argument_list>(<argument><expr><name>n</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator> <call><name>close</name><argument_list>(<argument><expr><name>fdr</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd_dir</name></expr></argument>)</argument_list></call> <operator>)</operator></expr></argument>, <argument><expr><literal type="string">"can't read from file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>buf_len</name> <operator>+=</operator> <name>n</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <name>buf_delta_size</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>buf_size</name> <operator>+=</operator> <name>buf_delta_size</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buf_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fdr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>buf_len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>GPDB_DEFAULT_CGROUP</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cgroup.procs"</literal></expr></argument>,
			  <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fdw</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_WRONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>__CHECK</name><argument_list>(<argument><expr><name>fdw</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd_dir</name></expr></argument>)</argument_list></call> <operator>)</operator></expr></argument>, <argument><expr><literal type="string">"can't open file for write"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>end</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>long</name></type> <name>pid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * as required by cgroup, only one pid can be migrated in each single
	 * write() call, so we have to parse the pids from the buffer first,
	 * then write them one by one.
	 */</comment>
	<while>while <condition>(<expr><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>pid</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>end</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>__CHECK</name><argument_list>(<argument><expr><name>pid</name> <operator>!=</operator> <name>LONG_MIN</name> <operator>&amp;&amp;</operator> <name>pid</name> <operator>!=</operator> <name>LONG_MAX</name></expr></argument>,
				<argument><expr><operator>(</operator> <call><name>close</name><argument_list>(<argument><expr><name>fdw</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd_dir</name></expr></argument>)</argument_list></call> <operator>)</operator></expr></argument>,
				<argument><expr><literal type="string">"can't parse pid"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>ptr</name> <operator>==</operator> <name>end</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>char</name></type> <name><name>str</name><index>[<expr><literal type="number">22</literal></expr>]</index></name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>n</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name>fdw</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>n</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"failed to migrate pid to gpdb root cgroup: pid=%ld: %m"</literal></expr></argument>,
				 <argument><expr><name>pid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>__CHECK</name><argument_list>(<argument><expr><name>n</name> <operator>==</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>,
					<argument><expr><operator>(</operator> <call><name>close</name><argument_list>(<argument><expr><name>fdw</name></expr></argument>)</argument_list></call><operator>,</operator> <call><name>close</name><argument_list>(<argument><expr><name>fd_dir</name></expr></argument>)</argument_list></call> <operator>)</operator></expr></argument>,
					<argument><expr><literal type="string">"can't write to file"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>ptr</name> <operator>=</operator> <name>end</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fdw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>__CHECK</name></cpp:undef>
</block_content>}</block></function>


<comment type="block">/*
 * Destroy the OS cgroup.
 *
 * One OS group can not be dropped if there are processes running under it,
 * if migrate is true these processes will be moved out automatically.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>destroycgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>migrate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>deleteDir</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_CPU</name></expr></argument>, <argument><expr><literal type="string">"cpu.shares"</literal></expr></argument>, <argument><expr><name>migrate</name></expr></argument>, <argument><expr><name>detachcgroup_v1</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>deleteDir</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_CPUACCT</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>migrate</name></expr></argument>, <argument><expr><name>detachcgroup_v1</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><name>gp_resource_group_enable_cgroup_cpuset</name> <operator>&amp;&amp;</operator>
		 <operator>!</operator><call><name>deleteDir</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_CPUSET</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>migrate</name></expr></argument>, <argument><expr><name>detachcgroup_v1</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>gp_resource_group_enable_cgroup_memory</name> <operator>&amp;&amp;</operator>
		 <operator>!</operator><call><name>deleteDir</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>CGROUP_COMPONENT_MEMORY</name></expr></argument>, <argument><expr><literal type="string">"memory.limit_in_bytes"</literal></expr></argument>, <argument><expr><name>migrate</name></expr></argument>, <argument><expr><name>detachcgroup_v1</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CGROUP_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't remove cgroup for resource group '%d': %m"</literal></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Lock the OS group. While the group is locked it won't be removed by other
 * processes.
 *
 * This function would block if block is true, otherwise it returns with -1
 * immediately.
 *
 * On success, it returns a fd to the OS group, pass it to unlockcgroup_v1()
 * to unlock it.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>lockcgroup_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>lockDir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>block</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Unblock an OS group.
 *
 * fd is the value returned by lockcgroup_v1().
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlockcgroup_v1</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>fd</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the cpu rate limit for the OS group.
 *
 * cpu_rate_limit should be within [0, 100].
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setcpulimit_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cpu_rate_limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_CPU</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* group.shares := gpdb.shares * cpu_rate_limit */</comment>

	<decl_stmt><decl><type><name>int64</name></type> <name>shares</name> <init>= <expr><call><name>readInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>,
							 <argument><expr><literal type="string">"cpu.shares"</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>,
			   <argument><expr><literal type="string">"cpu.shares"</literal></expr></argument>, <argument><expr><name>shares</name> <operator>*</operator> <name>cpu_rate_limit</name> <operator>/</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set cpu.cfs_quota_us if hard CPU enforcement is enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_resource_group_cpu_ceiling_enforcement</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type> <name>periods</name> <init>= <expr><call><name>get_cfs_period_us_alpha</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpu.cfs_quota_us"</literal></expr></argument>,
				   <argument><expr><name>periods</name> <operator>*</operator> <name><name>cgroupSystemInfoAlpha</name><operator>.</operator><name>ncores</name></name> <operator>*</operator> <name>cpu_rate_limit</name> <operator>/</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpu.cfs_quota_us"</literal></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Set the memory limit for the OS group by value.
 *
 * memory_limit is the limit value in chunks
 *
 * If cgroup supports memory swap, we will write the same limit to
 * memory.memsw.limit and memory.limit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setmemorylimitbychunks_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>memory_limit_chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_MEMORY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>memory_limit_in_bytes</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_memory</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>memory_limit_in_bytes</name> <operator>=</operator> <call><name>VmemTracker_ConvertVmemChunksToBytes</name><argument_list>(<argument><expr><name>memory_limit_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Is swap interfaces enabled? */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_swap</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No, then we only need to setup the memory limit */</comment>
		<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"memory.limit_in_bytes"</literal></expr></argument>,
				   <argument><expr><name>memory_limit_in_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Yes, then we have to setup both the memory and mem+swap limits */</comment>

		<decl_stmt><decl><type><name>int64</name></type> <name>memory_limit_in_bytes_old</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Memory limit should always &lt;= mem+swap limit, then the limits
		 * must be set in a proper order depending on the relation between
		 * new and old limits.
		 */</comment>
		<expr_stmt><expr><name>memory_limit_in_bytes_old</name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>,
											  <argument><expr><literal type="string">"memory.limit_in_bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>memory_limit_in_bytes</name> <operator>&gt;</operator> <name>memory_limit_in_bytes_old</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* When new value &gt; old memory limit, write mem+swap limit first */</comment>
			<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>,
					   <argument><expr><literal type="string">"memory.memsw.limit_in_bytes"</literal></expr></argument>, <argument><expr><name>memory_limit_in_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>,
					   <argument><expr><literal type="string">"memory.limit_in_bytes"</literal></expr></argument>, <argument><expr><name>memory_limit_in_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>memory_limit_in_bytes</name> <operator>&lt;</operator> <name>memory_limit_in_bytes_old</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* When new value &lt; old memory limit,  write memory limit first */</comment>
			<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>,
			<argument><expr><literal type="string">"memory.limit_in_bytes"</literal></expr></argument>, <argument><expr><name>memory_limit_in_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>,
					   <argument><expr><literal type="string">"memory.memsw.limit_in_bytes"</literal></expr></argument>, <argument><expr><name>memory_limit_in_bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the memory limit for the OS group by rate.
 *
 * memory_limit should be within [0, 100].
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setmemorylimit_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>memory_limit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_MEMORY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>memory_limit_in_chunks</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>memory_limit_in_chunks</name> <operator>=</operator> <call><name>ResGroupGetVmemLimitChunks</name><argument_list>()</argument_list></call> <operator>*</operator> <name>memory_limit</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>memory_limit_in_chunks</name> <operator>*=</operator> <call><name>ResGroupGetHostPrimaryCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>lockcgroup_v1</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>setmemorylimitbychunks_v1</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>memory_limit_in_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>unlockcgroup_v1</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Get the cpu usage of the OS group, that is the total cpu time obtained
 * by this OS group, in nano seconds.
 */</comment>
<function><type><specifier>static</specifier> <name>int64</name></type>
<name>getcpuusage_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_CPUACCT</name></expr></init></decl>;</decl_stmt>

	<return>return <expr><call><name>readInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuacct.usage"</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* get cgroup ram and swap (in Byte) */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_cgroup_memory_info</name><parameter_list>(<parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>cgram</name></decl></parameter>, <parameter><decl><type><name>uint64</name> <modifier>*</modifier></type><name>cgmemsw</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_MEMORY</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>cgram</name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_PARENT</name></expr></argument>,
					   <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"memory.limit_in_bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_resource_group_enable_cgroup_swap</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>cgmemsw</name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_PARENT</name></expr></argument>,
							 <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"memory.memsw.limit_in_bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"swap memory is unlimited"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>cgmemsw</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <operator>-</operator><literal type="number">1LL</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* get total ram and total swap (in Byte) from sysinfo */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>get_memory_info</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>ram</name></decl></parameter>, <parameter><decl><type><name>unsigned</name> <name>long</name> <modifier>*</modifier></type><name>swap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>sysinfo</name></name></type> <name>info</name></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>sysinfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't get memory information: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>ram</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>totalram</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>swap</name> <operator>=</operator> <name><name>info</name><operator>.</operator><name>totalswap</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* get vm.overcommit_ratio */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>getOvercommitRatio</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>ratio</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>data</name><index>[<expr><name>MAX_INT_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>datasize</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name> <init>= <expr><literal type="string">"/proc/sys/vm/overcommit_ratio"</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>readData</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>ratio</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid number '%s' in '%s'"</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ratio</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>gettotalmemory_v1</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>long</name></type> <name>ram</name></decl>, <decl><type ref="prev"/><name>swap</name></decl>, <decl><type ref="prev"/><name>total</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>overcommitRatio</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>cgram</name></decl>, <decl><type ref="prev"/><name>cgmemsw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>memsw</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type> <name>outTotal</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>overcommitRatio</name> <operator>=</operator> <call><name>getOvercommitRatio</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_memory_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ram</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>swap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Get sysinfo total ram and swap size. */</comment>
	<expr_stmt><expr><name>memsw</name> <operator>=</operator> <name>ram</name> <operator>+</operator> <name>swap</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>outTotal</name> <operator>=</operator> <name>swap</name> <operator>+</operator> <name>ram</name> <operator>*</operator> <name>overcommitRatio</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_cgroup_memory_info</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cgram</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cgmemsw</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ram</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>ram</name></expr></argument>, <argument><expr><name>cgram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/*
	 * In the case that total ram and swap read from sysinfo is larger than
	 * from cgroup, ram and swap must both be limited, otherwise swap must
	 * not be limited(we can safely use the value from sysinfo as swap size).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>cgmemsw</name> <operator>&lt;</operator> <name>memsw</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>swap</name> <operator>=</operator> <name>cgmemsw</name> <operator>-</operator> <name>ram</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/*
	 * If it is in container, the total memory is limited by both the total
	 * memoery outside and the memsw of the container.
	 */</comment>
	<expr_stmt><expr><name>total</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>outTotal</name></expr></argument>, <argument><expr><name>swap</name> <operator>+</operator> <name>ram</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>total</name> <operator>&gt;&gt;</operator> <name>BITS_IN_MB</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the memory usage of the OS group
 *
 * memory usage is returned in chunks
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>getmemoryusage_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_MEMORY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> 	<name>memory_usage_in_bytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> 	<modifier>*</modifier></type><name>filename</name></decl>;</decl_stmt>

	<comment type="block">/* Report 0 if cgroup memory is not enabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_memory</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>filename</name> <operator>=</operator> <ternary><condition><expr><name>gp_resource_group_enable_cgroup_swap</name></expr>
		?</condition><then> <expr><literal type="string">"memory.memsw.usage_in_bytes"</literal></expr>
		</then><else>: <expr><literal type="string">"memory.usage_in_bytes"</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>memory_usage_in_bytes</name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>VmemTracker_ConvertVmemBytesToChunks</name><argument_list>(<argument><expr><name>memory_usage_in_bytes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the memory limit of the OS group
 *
 * memory limit is returned in chunks
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>getmemorylimitchunks_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_MEMORY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>memory_limit_in_bytes</name></decl>;</decl_stmt>

	<comment type="block">/* Report unlimited (max int32) if cgroup memory is not enabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_memory</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>int32</name><operator>)</operator> <operator>(</operator><operator>(</operator><literal type="number">1U</literal> <operator>&lt;&lt;</operator> <literal type="number">31</literal><operator>)</operator> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>memory_limit_in_bytes</name> <operator>=</operator> <call><name>readInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>,
									  <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"memory.limit_in_bytes"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>VmemTracker_ConvertVmemBytesToChunks</name><argument_list>(<argument><expr><name>memory_limit_in_bytes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get the cpuset of the OS group.
 * @param group: the destination group
 * @param cpuset: the str to be set
 * @param len: the upper limit of the str
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>getcpuset_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_CPUSET</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>readStr</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.cpus"</literal></expr></argument>, <argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Set the cpuset for the OS group.
 * @param group: the destination group
 * @param cpuset: the value to be set
 * The syntax of CPUSET is a combination of the tuples, each tuple represents
 * one core number or the core numbers interval, separated by comma.
 * E.g. 0,1,2-3.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setcpuset_v1</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpuset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_CPUSET</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return ;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>writeStr</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">"cpuset.cpus"</literal></expr></argument>, <argument><expr><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Convert the cpu usage to percentage within the duration.
 *
 * usage is the delta of getcpuusage() of a duration,
 * duration is in micro seconds.
 *
 * When fully consuming one cpu core the return value will be 100.0 .
 */</comment>
<function><type><specifier>static</specifier> <name>float</name></type>
<name>convertcpuusage_v1</name><parameter_list>(<parameter><decl><type><name>int64</name></type> <name>usage</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>duration</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float</name></type>		<name>percent</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>usage</name> <operator>&gt;=</operator> <literal type="number">0LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>duration</name> <operator>&gt;</operator> <literal type="number">0LL</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* There should always be at least one core on the system */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cgroupSystemInfoAlpha</name><operator>.</operator><name>ncores</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Usage is the cpu time (nano seconds) obtained by this group in the time
	 * duration (micro seconds), so cpu time on one core can be calculated as:
	 *
	 *     usage / 1000 / duration / ncores
	 *
	 * To convert it to percentage we should multiple 100%:
	 *
	 *     usage / 1000 / duration / ncores * 100%
	 *   = usage / 10 / duration / ncores
	 */</comment>
	<expr_stmt><expr><name>percent</name> <operator>=</operator> <name>usage</name> <operator>/</operator> <literal type="number">10.0</literal> <operator>/</operator> <name>duration</name> <operator>/</operator> <name><name>cgroupSystemInfoAlpha</name><operator>.</operator><name>ncores</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now we have the system level percentage, however when running in a
	 * container with limited cpu quota we need to further scale it with
	 * parent.  Suppose parent has 50% cpu quota and gpdb is consuming all of
	 * it, then we want gpdb to report the cpu usage as 100% instead of 50%.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>parent_cfs_quota_us</name> <operator>&gt;</operator> <literal type="number">0LL</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Parent cgroup is also limited, scale the percentage to the one in
		 * parent cgroup.  Do not change the expression to `percent *= ...`,
		 * that will lose the precision.
		 */</comment>
		<expr_stmt><expr><name>percent</name> <operator>=</operator> <name>percent</name> <operator>*</operator> <name>system_cfs_quota_us</name> <operator>/</operator> <name>parent_cfs_quota_us</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>percent</name></expr>;</return>
</block_content>}</block></function>

<decl_stmt><decl><type><specifier>static</specifier> <name>CGroupOpsRoutine</name></type> <name>cGroupOpsRoutineAlpha</name> <init>= <expr><block>{
		<expr><operator>.</operator><name>getcgroupname</name> <operator>=</operator> <name>getcgroupname_v1</name></expr>,
		<expr><operator>.</operator><name>probecgroup</name> <operator>=</operator> <name>probecgroup_v1</name></expr>,
		<expr><operator>.</operator><name>checkcgroup</name> <operator>=</operator> <name>checkcgroup_v1</name></expr>,
		<expr><operator>.</operator><name>initcgroup</name> <operator>=</operator> <name>initcgroup_v1</name></expr>,
		<expr><operator>.</operator><name>adjustgucs</name> <operator>=</operator> <name>adjustgucs_v1</name></expr>,
		<expr><operator>.</operator><name>createcgroup</name> <operator>=</operator> <name>createcgroup_v1</name></expr>,
		<expr><operator>.</operator><name>destroycgroup</name> <operator>=</operator> <name>destroycgroup_v1</name></expr>,

		<expr><operator>.</operator><name>attachcgroup</name> <operator>=</operator> <name>attachcgroup_v1</name></expr>,
		<expr><operator>.</operator><name>detachcgroup</name> <operator>=</operator> <name>detachcgroup_v1</name></expr>,

		<expr><operator>.</operator><name>lockcgroup</name> <operator>=</operator> <name>lockcgroup_v1</name></expr>,
		<expr><operator>.</operator><name>unlockcgroup</name> <operator>=</operator> <name>unlockcgroup_v1</name></expr>,

		<expr><operator>.</operator><name>setcpulimit</name> <operator>=</operator> <name>setcpulimit_v1</name></expr>,
		<expr><operator>.</operator><name>getcpuusage</name> <operator>=</operator> <name>getcpuusage_v1</name></expr>,
		<expr><operator>.</operator><name>getcpuset</name> <operator>=</operator> <name>getcpuset_v1</name></expr>,
		<expr><operator>.</operator><name>setcpuset</name> <operator>=</operator> <name>setcpuset_v1</name></expr>,

		<expr><operator>.</operator><name>gettotalmemory</name> <operator>=</operator> <name>gettotalmemory_v1</name></expr>,
		<expr><operator>.</operator><name>getmemoryusage</name> <operator>=</operator> <name>getmemoryusage_v1</name></expr>,
		<expr><operator>.</operator><name>setmemorylimit</name> <operator>=</operator> <name>setmemorylimit_v1</name></expr>,
		<expr><operator>.</operator><name>getmemorylimitchunks</name> <operator>=</operator> <name>getmemorylimitchunks_v1</name></expr>,
		<expr><operator>.</operator><name>setmemorylimitbychunks</name> <operator>=</operator> <name>setmemorylimitbychunks_v1</name></expr>,

		<expr><operator>.</operator><name>convertcpuusage</name> <operator>=</operator> <name>convertcpuusage_v1</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<function><type><name>CGroupOpsRoutine</name> <modifier>*</modifier></type><name>get_group_routine_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>cGroupOpsRoutineAlpha</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>CGroupSystemInfo</name> <modifier>*</modifier></type><name>get_cgroup_sysinfo_alpha</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>&amp;</operator><name>cgroupSystemInfoAlpha</name></expr>;</return>
</block_content>}</block></function>
</unit>
