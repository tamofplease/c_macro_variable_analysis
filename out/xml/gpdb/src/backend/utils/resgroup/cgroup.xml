<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/resgroup/cgroup.c"><cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/vmem_tracker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>__linux__</name></cpp:ifndef>
<cpp:error>#<cpp:directive>error</cpp:directive>  cgroup is only available on linux</cpp:error>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sched.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/file.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/param.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/stat.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;sys/sysinfo.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;stdio.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;mntent.h&gt;</cpp:file></cpp:include>

<comment type="block">/* cgroup component names. */</comment>
<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name><name>component_names</name><index>[<expr><name>CGROUP_COMPONENT_COUNT</name></expr>]</index></name> <init>=
<expr><block>{
	<expr><literal type="string">"cpu"</literal></expr>, <expr><literal type="string">"cpuacct"</literal></expr>, <expr><literal type="string">"memory"</literal></expr>, <expr><literal type="string">"cpuset"</literal></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* cgroup component dirs. */</comment>
<decl_stmt><decl><type><name>char</name></type> <name><name>component_dirs</name><index>[<expr><name>CGROUP_COMPONENT_COUNT</name></expr>]</index><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name> <init>=
<expr><block>{
	<expr><name>FALLBACK_COMP_DIR</name></expr>, <expr><name>FALLBACK_COMP_DIR</name></expr>, <expr><name>FALLBACK_COMP_DIR</name></expr>, <expr><name>FALLBACK_COMP_DIR</name></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Get the name of cgroup controller component.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getComponentName</name><parameter_list>(<parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>component</name> <operator>&gt;</operator> <name>CGROUP_COMPONENT_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>component</name> <operator>&lt;</operator> <name>CGROUP_COMPONENT_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>component_names</name><index>[<expr><name>component</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get the component type from the cgroup controller name.
 */</comment>
<function><type><name>CGroupComponentType</name></type>
<name>getComponentType</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>component</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>component</name> <operator>&lt;</operator> <name>CGROUP_COMPONENT_COUNT</name></expr>;</condition> <incr><expr><name>component</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>name</name></expr></argument>, <argument><expr><call><name>getComponentName</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>component</name></expr>;</return></block_content></block></if></if_stmt></block_content></block></for>

	<return>return <expr><name>CGROUP_COMPONENT_UNKNOWN</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get the directory of component.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>getComponentDir</name><parameter_list>(<parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>component</name> <operator>&gt;</operator> <name>CGROUP_COMPONENT_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>component</name> <operator>&lt;</operator> <name>CGROUP_COMPONENT_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>component_dirs</name><index>[<expr><name>component</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the component dir of component.
 */</comment>
<function><type><name>void</name></type>
<name>setComponentDir</name><parameter_list>(<parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>component</name> <operator>&gt;</operator> <name>CGROUP_COMPONENT_UNKNOWN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>component</name> <operator>&lt;</operator> <name>CGROUP_COMPONENT_COUNT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>dir</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <name>MAX_CGROUP_PATHLEN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>component_dirs</name><index>[<expr><name>component</name></expr>]</index></name></expr></argument>, <argument><expr><name>dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build path string with parameters.
 *
 * Will raise an exception if the path buffer is not large enough.
 *
 * Examples (path and path_size are omitted):
 *
 * - buildPath(ROOT, PARENT, CPU, ""     ): /sys/fs/cgroup/cpu
 * - buildPath(ROOT, PARENT, CPU, "tasks"): /sys/fs/cgroup/cpu/tasks
 * - buildPath(ROOT, GPDB  , CPU, "tasks"): /sys/fs/cgroup/cpu/gpdb/tasks
 *
 * - buildPath(ROOT, PARENT, ALL, "     "): /sys/fs/cgroup/
 * - buildPath(ROOT, PARENT, ALL, "tasks"): /sys/fs/cgroup/tasks
 * - buildPath(ROOT, GPDB  , ALL, "tasks"): /sys/fs/cgroup/gpdb/tasks
 *
 * - buildPath(6437, GPDB  , CPU, "tasks"): /sys/fs/cgroup/cpu/gpdb/6437/tasks
 * - buildPath(6437, GPDB  , ALL, "tasks"): /sys/fs/cgroup/gpdb/6437/tasks
 */</comment>
<function><type><name>void</name></type>
<name>buildPath</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>,
		  <parameter><decl><type><name>BaseDirType</name></type> <name>base</name></decl></parameter>,
		  <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>,
		  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
		  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
		  <parameter><decl><type><name>size_t</name></type> <name>path_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>result</name> <init>= <expr><call><name>buildPathSafe</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CGROUP_CONFIG_ERROR</name><argument_list>(<argument><expr><literal type="string">"invalid %s name '%s': %m"</literal></expr></argument>,
							<argument><expr><ternary><condition><expr><name><name>filename</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><literal type="string">"file"</literal></expr> </then><else>: <expr><literal type="string">"directory"</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Build path string with parameters.
 *
 * Return false if the path buffer is not large enough, errno will also be set.
 */</comment>
<function><type><name>bool</name></type>
<name>buildPathSafe</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>,
			  <parameter><decl><type><name>BaseDirType</name></type> <name>base</name></decl></parameter>,
			  <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>,
			  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
			  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
			  <parameter><decl><type><name>size_t</name></type> <name>path_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>component_name</name> <init>= <expr><call><name>getComponentName</name><argument_list>(<argument><expr><name>component</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>component_dir</name> <init>= <expr><name>component_name</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>base_dir</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>group_dir</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>base</name> <operator>==</operator> <name>BASEDIR_GPDB</name> <operator>||</operator> <name>base</name> <operator>==</operator> <name>BASEDIR_PARENT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>base</name> <operator>==</operator> <name>BASEDIR_GPDB</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>base_dir</name> <operator>=</operator> <literal type="string">"/gpdb"</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>base_dir</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* add group name to the path */</comment>
	<if_stmt><if>if <condition>(<expr><name>group</name> <operator>!=</operator> <name>CGROUP_ROOT_ID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>group_dir</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>group_dir</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"/%u"</literal></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* We are sure group_dir is large enough */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>len</name> <operator>&lt;</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>group_dir</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>component</name> <operator>!=</operator> <name>CGROUP_COMPONENT_PLAIN</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * for cgroup v1, we need add the component name to the path,
		 * such as "/gpdb/cpu/...", "/gpdb/cpuset/...".
		 */</comment>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>, <argument><expr><literal type="string">"%s/%s%s%s/%s"</literal></expr></argument>,
					   <argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>, <argument><expr><name>component_dir</name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>, <argument><expr><name>group_dir</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * for cgroup v2, we just have the top level and child level,
		 * don't need to care about the component.
		 */</comment>
		<expr_stmt><expr><name>base_dir</name> <operator>=</operator> <ternary><condition><expr><name>base</name> <operator>==</operator> <name>BASEDIR_GPDB</name></expr> ?</condition><then> <expr><literal type="string">"gpdb"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>, <argument><expr><literal type="string">"%s/%s%s/%s"</literal></expr></argument>,
					   <argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>, <argument><expr><name>base_dir</name></expr></argument>, <argument><expr><name>group_dir</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>path_size</name> <operator>||</operator> <name>len</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>ENAMETOOLONG</name></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Validate a component dir.
 *
 * Return true if it exists and has right permissions,
 * otherwise return false.
 */</comment>
<function><type><name>bool</name></type>
<name>validateComponentDir</name><parameter_list>(<parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type>		<name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>buildPathSafe</name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>,
					   <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>R_OK</name> <operator>|</operator> <name>W_OK</name> <operator>|</operator> <name>X_OK</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Lock a dir
 */</comment>
<function><type><name>int</name></type>
<name>lockDir</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>block</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>fd_dir</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>fd_dir</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd_dir</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ENOENT</name></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* the dir doesn't exist, nothing to do */</comment>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>CGROUP_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't open dir to lock: %s: %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>flags</name> <init>= <expr><name>LOCK_EX</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>block</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>flags</name> <operator>|=</operator> <name>LOCK_NB</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><call><name>flock</name><argument_list>(<argument><expr><name>fd_dir</name></expr></argument>, <argument><expr><name>flags</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * EAGAIN is not described in flock(2),
		 * however it does appear in practice.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>EAGAIN</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * In block mode all errors should be reported;
		 * In non block mode only report errors != EWOULDBLOCK.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>block</name> <operator>||</operator> <name>err</name> <operator>!=</operator> <name>EWOULDBLOCK</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>CGROUP_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't lock dir: %s: %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Even if we acquired the lock the dir may still been removed by other
	 * processes, e.g.:
	 *
	 * 1: open()
	 * 1: flock() -- process 1 acquire the lock
	 *
	 * 2: open()
	 * 2: flock() -- blocked by process 1
	 *
	 * 1: rmdir()
	 * 1: close() -- process 1 released the lock
	 *
	 * 2:flock() will now return w/o error as process 2 still has a valid
	 * fd (reference) on the target dir, and process 2 does acquire the lock
	 * successfully. However, as the dir is already removed so process 2
	 * shouldn't make any further operation (rmdir(), etc.) on the dir.
	 *
	 * So we check for the existence of the dir again and give up if it's
	 * already removed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>access</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>F_OK</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* the dir is already removed by other process, nothing to do */</comment>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>fd_dir</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Create cgroup dir
 */</comment>
<function><type><name>bool</name></type>
<name>createDir</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>mkdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><literal type="number">0755</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EEXIST</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Read at most datasize bytes from a file.
 */</comment>
<function><type><name>size_t</name></type>
<name>readData</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>datasize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_RDONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't open file '%s': %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name> <init>= <expr><call><name>read</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* save errno before close() */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't read data from file '%s': %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write datasize bytes to a file.
 */</comment>
<function><type><name>void</name></type>
<name>writeData</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>datasize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name> <init>= <expr><call><name>open</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>O_WRONLY</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't open file '%s': %m"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>ssize_t</name></type> <name>ret</name> <init>= <expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>datasize</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* save errno before close */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't write data to file '%s': %s"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>ret</name> <operator>!=</operator> <name>datasize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"can't write all data to file '%s'"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read an int64 value from a cgroup interface file.
 */</comment>
<function><type><name>int64</name></type>
<name>readInt64</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>BaseDirType</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>,
		  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>x</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>data</name><index>[<expr><name>MAX_INT_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>data_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>readData</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>sscanf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CGROUP_ERROR</name><argument_list>(<argument><expr><literal type="string">"invalid number '%s'"</literal></expr></argument>, <argument><expr><name>data</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>x</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write an int64 value to a cgroup interface file.
 */</comment>
<function><type><name>void</name></type>
<name>writeInt64</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>BaseDirType</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>,
		   <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int64</name></type> <name>x</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>data</name><index>[<expr><name>MAX_INT_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>data_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>, <argument><expr><literal type="string">"%lld"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name> <name>long</name><operator>)</operator> <name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>writeData</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read a string value from a cgroup interface file.
 */</comment>
<function><type><name>void</name></type>
<name>readStr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>BaseDirType</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>,
		<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>data</name><index>[<expr><name>MAX_INT_STRING_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>data_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>data</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>readData</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>data_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write a string value to a cgroup interface file.
 */</comment>
<function><type><name>void</name></type>
<name>writeStr</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>BaseDirType</name></type> <name>base</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>,
		 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>strValue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>base</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>writeData</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>strValue</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>strValue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<function><type><name>bool</name></type>
<name>deleteDir</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>unassign</name></decl></parameter>,
		  <parameter><function_decl><type><name>void</name></type> (<modifier>*</modifier><name>detachcgroup</name>) <parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>group</name></decl></parameter>, <parameter><decl><type><name>CGroupComponentType</name></type> <name>component</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>fd_dir</name></decl></parameter>)</parameter_list></function_decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>char</name></type> <name><name>path</name><index>[<expr><name>MAX_CGROUP_PATHLEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>size_t</name></type> <name>path_size</name> <init>= <expr><sizeof>sizeof<argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>retry</name> <init>= <expr><ternary><condition><expr><name>unassign</name></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name>MAX_RETRY</name> <operator>-</operator> <literal type="number">1</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd_dir</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>buildPath</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>path_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * To prevent race condition between multiple processes we require a dir
	 * to be removed with the lock acquired first.
	 */</comment>
	<expr_stmt><expr><name>fd_dir</name> <operator>=</operator> <call><name>lockDir</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the dir is already removed */</comment>
	<if_stmt><if>if <condition>(<expr><name>fd_dir</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Reset the corresponding control file to zero
	 * RG_FIXME: Can we remove this?
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>writeInt64</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>BASEDIR_GPDB</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>++</operator><name>retry</name> <operator>&lt;=</operator> <name>MAX_RETRY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>unassign</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>detachcgroup</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>fd_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>rmdir</name><argument_list>(<argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type> <name>err</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>err</name> <operator>==</operator> <name>EBUSY</name> <operator>&amp;&amp;</operator> <name>unassign</name> <operator>&amp;&amp;</operator> <name>retry</name> <operator>&lt;</operator> <name>MAX_RETRY</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"can't remove dir, will retry: %s: %s"</literal></expr></argument>,
					 <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * we don't check for ENOENT again as we already acquired the lock
			 * on this dir and the dir still exist at that time, so if then
			 * it's removed by other processes then it's a bug.
			 */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"can't remove dir, ignore the error: %s: %s"</literal></expr></argument>,
				 <argument><expr><name>path</name></expr></argument>, <argument><expr><call><name>strerror</name><argument_list>(<argument><expr><name>err</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<break>break;</break>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><name>retry</name> <operator>&lt;=</operator> <name>MAX_RETRY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"cgroup dir '%s' removed"</literal></expr></argument>, <argument><expr><name>path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* close() also releases the lock */</comment>
	<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd_dir</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<function><type><name>int</name></type>
<name>getCPUCores</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>cpucores</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * cpuset ops requires _GNU_SOURCE to be defined,
	 * and _GNU_SOURCE is forced on in src/template/linux,
	 * so we assume these ops are always available on linux.
	 */</comment>
	<decl_stmt><decl><type><name>cpu_set_t</name></type> <name>cpuset</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>sched_getaffinity</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cpuset</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CGROUP_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't get cpu cores: %m"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>CPU_SETSIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>CPU_ISSET</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cpuset</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cpucores</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>cpucores</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CGROUP_ERROR</name><argument_list>(<argument><expr><literal type="string">"can't get cpu cores"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>cpucores</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Get the mount directory of cgroup, the basic method is to read the file "/proc/self/mounts".
 * Normally, cgroup version 1 will return "/sys/fs/cgroup/xxx", so we need remove the "xxx", but
 * version 2 do not need this.
 */</comment>
<function><type><name>bool</name></type>
<name>getCgroupMountDir</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name><name>struct</name> <name>mntent</name></name> <modifier>*</modifier></type><name>me</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type><name>fp</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>,<argument><expr><literal type="char">'\0'</literal></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fp</name> <operator>=</operator> <call><name>setmntent</name><argument_list>(<argument><expr><name>PROC_MOUNTS</name></expr></argument>, <argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>fp</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>CGROUP_CONFIG_ERROR</name><argument_list>(<argument><expr><literal type="string">"can not open '%s' for read"</literal></expr></argument>, <argument><expr><name>PROC_MOUNTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>me</name> <operator>=</operator> <call><name>getmntent</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type> <name>p</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_version_two</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* For version 1, we need to find the mnt_type equals to "cgroup" */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>mnt_type</name></name></expr></argument>, <argument><expr><literal type="string">"cgroup"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>mnt_dir</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CGROUP_CONFIG_ERROR</name><argument_list>(<argument><expr><literal type="string">"cgroup mount point parse error: %s"</literal></expr></argument>, <argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* For version 2, we need to find the mnt_type equals to "cgroup2" */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>me</name><operator>-&gt;</operator><name>mnt_type</name></name></expr></argument>, <argument><expr><literal type="string">"cgroup2"</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>strncpy</name><argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>, <argument><expr><name><name>me</name><operator>-&gt;</operator><name>mnt_dir</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<break>break;</break>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>endmntent</name><argument_list>(<argument><expr><name>fp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cgroupSystemInfo</name><operator>-&gt;</operator><name>cgroup_dir</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
</unit>
