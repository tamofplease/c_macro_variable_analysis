<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/resgroup/resgroup.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * resgroup.c
 *	  GPDB resource group management code.
 *
 *
 * TERMS:
 *
 * - FIXED QUOTA: the minimal memory quota reserved for a slot. This quota
 *   is promised to be available during the lifecycle of the slot.
 *
 * - SHARED QUOTA: the preemptive memory quota shared by all the slots
 *   in a resource group. When a slot want to use more memory than its
 *   FIXED QUOTA it can attempt to allocate from this SHARED QUOTA, however
 *   this allocation is possible to fail depending on the actual usage.
 *
 * - MEM POOL: the global memory quota pool shared by all the resource groups.
 *   Overuse in this pool is strictly forbidden. A resource group must
 *   acquire from this pool to have enough memory quota for its slots'
 *   FIXED QUOTA and SHARED QUOTA, and should release overused quota to
 *   this pool as soon as possible.
 *
 * - SLOT POOL: the global slot pool shared by all the resource groups.
 *   A resource group must acquire a free slot in this pool for a new
 *   transaction to run in it.
 *
 * Portions Copyright (c) 2006-2010, Greenplum inc.
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	    src/backend/utils/resgroup/resgroup.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq-fe.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/genam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_authid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_resgroupcapability.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgang.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdispatchresult.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbdisp_query.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/memquota.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/resgroupcmds.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgstat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"port/atomics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/latch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/pg_shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resgroup.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resource_manager.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/session_state.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/vmem_tracker.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cgroup-ops-v1.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/cgroup-ops-dummy.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>InvalidSlotId</name></cpp:macro>	<cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESGROUP_MAX_SLOTS</name></cpp:macro>	<cpp:value>(MaxConnections)</cpp:value></cpp:define>

<comment type="block">/*
 * A hard memory limit in by pass mode, in chunks
 * More chunks are reserved on QD than on QE because planner and orca
 * may need more memory to generate and optimize the plan.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESGROUP_BYPASS_MODE_MEMORY_LIMIT_ON_QD</name></cpp:macro>	<cpp:value>30</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RESGROUP_BYPASS_MODE_MEMORY_LIMIT_ON_QE</name></cpp:macro>	<cpp:value>10</cpp:value></cpp:define>

<comment type="block">/*
 * GUC variables.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>							<name>gp_resgroup_memory_policy</name> <init>= <expr><name>RESMANAGER_MEMORY_POLICY_NONE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>						<name>gp_log_resgroup_memory</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>							<name>gp_resgroup_memory_policy_auto_fixed_mem</name></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>						<name>gp_resgroup_print_operator_memory_limits</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>						<name>gp_resgroup_debug_wait_queue</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>							<name>memory_spill_ratio</name> <init>= <expr><literal type="number">20</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>int</name></type>							<name>gp_resource_group_queuing_timeout</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Data structures
 */</comment>

<typedef>typedef <type><name><name>struct</name> <name>ResGroupInfo</name></name></type>				<name>ResGroupInfo</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>ResGroupHashEntry</name></name></type>		<name>ResGroupHashEntry</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>ResGroupProcData</name></name></type>			<name>ResGroupProcData</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>ResGroupSlotData</name></name></type>			<name>ResGroupSlotData</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>ResGroupData</name></name></type>				<name>ResGroupData</name>;</typedef>
<typedef>typedef <type><name><name>struct</name> <name>ResGroupControl</name></name></type>			<name>ResGroupControl</name>;</typedef>

<comment type="block">/*
 * Resource group info.
 *
 * This records the group and groupId for a transaction.
 * When group-&gt;groupId != groupId, it means the group
 * has been dropped.
 */</comment>
<struct>struct <name>ResGroupInfo</name>
<block>{
	<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				<name>groupId</name></decl>;</decl_stmt>
}</block>;</struct>

<struct>struct <name>ResGroupHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>		<name>groupId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>index</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Per proc resource group information.
 *
 * Config snapshot and runtime accounting information in current proc.
 */</comment>
<struct>struct <name>ResGroupProcData</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>		<name>groupId</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type>	<name>memUsage</name></decl>;</decl_stmt>			<comment type="block">/* memory usage of current proc */</comment>
	<comment type="block">/* 
	 * Record current bypass memory limit for each bypass queries.
	 * For bypass mode, memUsage of current process could accumulate in a session.
	 * So should limit the memory usage for each query instead of the whole session.
	 */</comment>
	<decl_stmt><decl><type><name>int32</name></type>	<name>bypassMemoryLimit</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ResGroupCaps</name></type>	<name>caps</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Per slot resource group information.
 *
 * Resource group have 'concurrency' number of slots.
 * Each transaction acquires a slot on master before running.
 * The information shared by QE processes on each segments are stored
 * in this structure.
 */</comment>
<struct>struct <name>ResGroupSlotData</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>				<name>groupId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>		<comment type="block">/* pointer to the group */</comment>

	<decl_stmt><decl><type><name>int32</name></type>			<name>memQuota</name></decl>;</decl_stmt>	<comment type="block">/* memory quota of current slot */</comment>
	<decl_stmt><decl><type><name>int32</name></type>			<name>memUsage</name></decl>;</decl_stmt>	<comment type="block">/* total memory usage of procs belongs to this slot */</comment>
	<decl_stmt><decl><type><name>int</name></type>				<name>nProcs</name></decl>;</decl_stmt>		<comment type="block">/* number of procs in this slot */</comment>

	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ResGroupCaps</name></type>	<name>caps</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/*
 * Resource group operations for memory.
 *
 * Groups with different memory auditor will have different
 * operations.
 */</comment>
<typedef>typedef <type><struct>struct <name>ResGroupMemOperations</name>
<block>{
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>group_mem_on_create</name>) <parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>group_mem_on_alter</name>) <parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>group_mem_on_drop</name>) <parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>group_mem_on_notify</name>) <parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
	<function_decl><type><name>void</name></type> (<modifier>*</modifier><name>group_mem_on_dump</name>) <parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
}</block></struct></type> <name>ResGroupMemOperations</name>;</typedef>

<comment type="block">/*
 * Resource group information.
 */</comment>
<struct>struct <name>ResGroupData</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>groupId</name></decl>;</decl_stmt>		<comment type="block">/* Id for this group */</comment>

	<comment type="block">/*
	 * memGap is calculated as:
	 * 	(memory limit (before alter) - memory expected (after alter))
	 *
	 * It stands for how many memory (in chunks) this group should
	 * give back to MEM POOL.
	 */</comment>
	<decl_stmt><decl><type><name>int32</name></type>       <name>memGap</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int32</name></type>		<name>memExpected</name></decl>;</decl_stmt>		<comment type="block">/* expected memory chunks according to current caps */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>memQuotaGranted</name></decl>;</decl_stmt>	<comment type="block">/* memory chunks for quota part */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>memSharedGranted</name></decl>;</decl_stmt>	<comment type="block">/* memory chunks for shared part */</comment>

	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int32</name></type>	<name>memQuotaUsed</name></decl>;</decl_stmt>	<comment type="block">/* memory chunks assigned to all the running slots */</comment>

	<comment type="block">/*
	 * memory usage of this group, should always equal to the
	 * sum of session memory(session_state-&gt;sessionVmem) that
	 * belongs to this group
	 */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int32</name></type>	<name>memUsage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int32</name></type>	<name>memSharedUsage</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type>			<name>nRunning</name></decl>;</decl_stmt>		<comment type="block">/* number of running trans */</comment>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type>	<name>nRunningBypassed</name></decl>;</decl_stmt>		<comment type="block">/* number of running trans in bypass mode */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalExecuted</name></decl>;</decl_stmt>	<comment type="block">/* total number of executed trans */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>totalQueued</name></decl>;</decl_stmt>	<comment type="block">/* total number of queued trans	*/</comment>
	<decl_stmt><decl><type><name>int64</name></type>	<name>totalQueuedTimeMs</name></decl>;</decl_stmt>	<comment type="block">/* total queue time, in milliseconds */</comment>
	<decl_stmt><decl><type><name>PROC_QUEUE</name></type>	<name>waitProcs</name></decl>;</decl_stmt>		<comment type="block">/* list of PGPROC objects waiting on this group */</comment>

	<comment type="block">/*
	 * operation functions for resource group
	 */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ResGroupMemOperations</name> <modifier>*</modifier></type><name>groupMemOps</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>lockedForDrop</name></decl>;</decl_stmt>  <comment type="block">/* true if resource group is dropped but not committed yet */</comment>

	<decl_stmt><decl><type><name>ResGroupCaps</name></type>	<name>caps</name></decl>;</decl_stmt>		<comment type="block">/* capabilities of this group */</comment>
}</block>;</struct>

<struct>struct <name>ResGroupControl</name>
<block>{
	<decl_stmt><decl><type><name>int32</name></type>			<name>totalChunks</name></decl>;</decl_stmt>			<comment type="block">/* total memory chunks on this segment */</comment>
	<comment type="block">/* 
	 * Safe memory threshold:
	 * if remained global shared memory is less than this threshold,
	 * then the resource group memory usage is in red zone.
	 * Note that safeChunksThreshold100 is 100 times bigger than the real safe chunks.
	 * This is used to avoid rounding problem caused by runaway_detector_activation_percent
	 */</comment>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>safeChunksThreshold100</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_atomic_uint32</name></type> <name>freeChunks</name></decl>;</decl_stmt>			<comment type="block">/* memory chunks not allocated to any group,
											will be used for the query which group share
											memory is not enough*/</comment>

	<decl_stmt><decl><type><name>int32</name></type>			<name>chunkSizeInBits</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> 			<name>segmentsOnMaster</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slots</name></decl>;</decl_stmt>		<comment type="block">/* slot pool shared by all resource groups */</comment>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>freeSlot</name></decl>;</decl_stmt>	<comment type="block">/* head of the free list */</comment>

	<decl_stmt><decl><type><name>HTAB</name>			<modifier>*</modifier></type><name>htbl</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * The hash table for resource groups in shared memory should only be populated
	 * once, so we add a flag here to implement this requirement.
	 */</comment>
	<decl_stmt><decl><type><name>bool</name></type>			<name>loaded</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>				<name>nGroups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name></type>	<name><name>groups</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
}</block>;</struct>

<decl_stmt><decl><type><name>bool</name></type> <name>gp_resource_group_enable_cgroup_memory</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>gp_resource_group_enable_cgroup_swap</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type> <name>gp_resource_group_enable_cgroup_cpuset</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>CGroupOpsRoutine</name> <modifier>*</modifier></type><name>cgroupOpsRoutine</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>CGroupSystemInfo</name> <modifier>*</modifier></type><name>cgroupSystemInfo</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* hooks */</comment>
<decl_stmt><decl><type><name>resgroup_assign_hook_type</name></type> <name>resgroup_assign_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* static variables */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>ResGroupControl</name> <modifier>*</modifier></type><name>pResGroupControl</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ResGroupProcData</name></type> <name>__self</name> <init>=
<expr><block>{
	<expr><name>InvalidOid</name></expr>,
}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>ResGroupProcData</name> <modifier>*</modifier></type><name>self</name> <init>= <expr><operator>&amp;</operator><name>__self</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* If we are waiting on a group, this points to the associated group */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>groupAwaited</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>groupWaitStart</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>TimestampTz</name></type> <name>groupWaitEnd</name></decl>;</decl_stmt>

<comment type="block">/* the resource group self is running in bypass mode */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>bypassedGroup</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<comment type="block">/* a fake slot used in bypass mode */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ResGroupSlotData</name></type> <name>bypassedSlot</name></decl>;</decl_stmt>

<comment type="block">/* static functions */</comment>

<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>groupApplyMemCaps</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>mempoolReserve</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>mempoolRelease</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupRebalanceQuota</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>,
								<parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>,
								<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>decideTotalChunks</name><parameter_list>(<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>totalChunks</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>chunkSizeInBits</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>groupGetMemExpected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>groupGetMemQuotaExpected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>groupGetMemSharedExpected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>groupGetMemSpillTotal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>slotGetMemQuotaExpected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>slotGetMemQuotaOnQE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>slotGetMemSpill</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>wakeupSlots</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>grant</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>notifyGroupsOnMem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>skipGroupId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>mempoolAutoRelease</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>mempoolAutoReserve</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>groupHashNew</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>groupHashFind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raise</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>groupHashRemove</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>waitOnGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isMoveQuery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>createGroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>removeGroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>AtProcExit_ResGroup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupWaitCancel</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isMoveQuery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>groupReserveMemQuota</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupReleaseMemQuota</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>groupIncMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>,
							  <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							  <parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>groupDecMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>,
							  <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							  <parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int32</name></type> <name>groupIncSlotMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupDecSlotMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>initSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>,
					 <parameter><decl><type><name>int32</name></type> <name>slotMemQuota</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>selfAttachResGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>selfDetachResGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>slotpoolInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slotpoolAllocSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>slotpoolFreeSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>groupGetSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupPutSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Oid</name></type> <name>decideResGroupId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>decideResGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupInfo</name> <modifier>*</modifier></type><name>pGroupInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>groupIncBypassedRef</name><parameter_list>(<parameter><decl><type><name>ResGroupInfo</name> <modifier>*</modifier></type><name>pGroupInfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupDecBypassedRef</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>groupAcquireSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupInfo</name> <modifier>*</modifier></type><name>pGroupInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isMoveQuery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupReleaseSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isMoveQuery</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>addTotalQueueDuration</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupSetMemorySpillRatio</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>groupDumpMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>selfValidateResGroupInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>selfIsAssigned</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>selfSetGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>selfUnsetGroup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>selfSetSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>selfUnsetSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>procIsWaiting</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>procWakeup</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>slotGetId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupWaitQueueValidate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupWaitProcValidate</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>head</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupWaitQueuePush</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>groupWaitQueuePop</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupWaitQueueErase</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>groupWaitQueueIsEmpty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>shouldBypassQuery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>lockResGroupForDrop</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unlockResGroupForDrop</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>groupIsDropped</name><parameter_list>(<parameter><decl><type><name>ResGroupInfo</name> <modifier>*</modifier></type><name>pGroupInfo</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resgroupDumpGroup</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resgroupDumpWaitQueue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resgroupDumpCaps</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>ResGroupCap</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resgroupDumpSlots</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>resgroupDumpFreeSlots</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sessionSetSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>sessionResetSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>sessionGetSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>bindGroupOperation</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupMemOnAlterForVmtracker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupMemOnDropForVmtracker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupMemOnNotifyForVmtracker</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupMemOnDumpForVmtracker</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupMemOnAlterForCgroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupMemOnDropForCgroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupMemOnNotifyForCgroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupMemOnDumpForCgroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupApplyCgroupMemInc</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>groupApplyCgroupMemDec</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cpusetOperation</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset1</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpuset2</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>sub</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>selfHasGroup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>selfHasSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>slotValidate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>slotIsInFreelist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>slotIsInUse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>groupIsNotDropped</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>groupWaitQueueFind</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_ASSERT_CHECKING */</comment>

<comment type="block">/*
 * Operations of memory for resource groups with vmtracker memory auditor.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ResGroupMemOperations</name></type> <name>resgroup_memory_operations_vmtracker</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>group_mem_on_create</name>	<operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>group_mem_on_alter</name>		<operator>=</operator> <name>groupMemOnAlterForVmtracker</name></expr>,
	<expr><operator>.</operator><name>group_mem_on_drop</name>		<operator>=</operator> <name>groupMemOnDropForVmtracker</name></expr>,
	<expr><operator>.</operator><name>group_mem_on_notify</name>	<operator>=</operator> <name>groupMemOnNotifyForVmtracker</name></expr>,
	<expr><operator>.</operator><name>group_mem_on_dump</name>		<operator>=</operator> <name>groupMemOnDumpForVmtracker</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Operations of memory for resource groups with cgroup memory auditor.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>ResGroupMemOperations</name></type> <name>resgroup_memory_operations_cgroup</name> <init>= <expr><block>{
	<expr><operator>.</operator><name>group_mem_on_create</name>	<operator>=</operator> <name>NULL</name></expr>,
	<expr><operator>.</operator><name>group_mem_on_alter</name>		<operator>=</operator> <name>groupMemOnAlterForCgroup</name></expr>,
	<expr><operator>.</operator><name>group_mem_on_drop</name>		<operator>=</operator> <name>groupMemOnDropForCgroup</name></expr>,
	<expr><operator>.</operator><name>group_mem_on_notify</name>	<operator>=</operator> <name>groupMemOnNotifyForCgroup</name></expr>,
	<expr><operator>.</operator><name>group_mem_on_dump</name>		<operator>=</operator> <name>groupMemOnDumpForCgroup</name></expr>,
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/*
 * Estimate size the resource group structures will need in
 * shared memory.
 */</comment>
<function><type><name>Size</name></type>
<name>ResGroupShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* The hash of groups. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>MaxResourceGroups</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResGroupHashEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The control structure. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResGroupControl</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResGroupData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The control structure. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>MaxResourceGroups</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResGroupData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* The slot pool. */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>RESGROUP_MAX_SLOTS</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResGroupSlotData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add a safety margin */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><name>size</name> <operator>/</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the global ResGroupControl struct of resource groups.
 */</comment>
<function><type><name>void</name></type>
<name>ResGroupControlInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>bool</name></type>        <name>found</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>HASHCTL</name></type>     <name>info</name></decl>;</decl_stmt>
    <decl_stmt><decl><type><name>int</name></type>         <name>hash_flags</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>pResGroupControl</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResGroupData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>+=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>MaxResourceGroups</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResGroupData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name>pResGroupControl</name> <operator>=</operator> <call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"global resource group control"</literal></expr></argument>,
                                       <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition><block type="pseudo"><block_content>
        <return>return;</return></block_content></block></if></if_stmt>
    <if_stmt><if>if <condition>(<expr><name>pResGroupControl</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>error_out</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/* Set key and entry sizes of hash table */</comment>
    <expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>info</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ResGroupHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>info</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>

    <expr_stmt><expr><name>hash_flags</name> <operator>=</operator> <operator>(</operator><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name><operator>)</operator></expr>;</expr_stmt>

    <expr_stmt><expr><call><name>LOG_RESGROUP_DEBUG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"creating hash table for %d resource groups"</literal></expr></argument>, <argument><expr><name>MaxResourceGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>htbl</name></name> <operator>=</operator> <call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"Resource Group Hash Table"</literal></expr></argument>,
                                           <argument><expr><name>MaxResourceGroups</name></expr></argument>,
                                           <argument><expr><name>MaxResourceGroups</name></expr></argument>,
                                           <argument><expr><operator>&amp;</operator><name>info</name></expr></argument>, <argument><expr><name>hash_flags</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

    <if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>htbl</name></name></expr>)</condition><block type="pseudo"><block_content>
        <goto>goto <name>error_out</name>;</goto></block_content></block></if></if_stmt>

    <comment type="block">/*
     * No need to acquire LWLock here, since this is expected to be called by
     * postmaster only
     */</comment>
    <expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>loaded</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
    <expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>nGroups</name></name> <operator>=</operator> <name>MaxResourceGroups</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>safeChunksThreshold100</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_init_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>chunkSizeInBits</name></name> <operator>=</operator> <name>BITS_IN_MB</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MaxResourceGroups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>groups</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>groupId</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>slotpoolInit</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>error_out</name>;</goto></block_content></block></if></if_stmt>

    <return>return;</return>

<label><name>error_out</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"not enough shared memory for resource group control"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a resource group entry from a hash table
 */</comment>
<function><type><name>void</name></type>
<name>AllocResGroupEntry</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>createGroup</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>group</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>initCgroup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>__linux__</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_version_two</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cgroupOpsRoutine</name> <operator>=</operator> <call><name>get_group_routine_alpha</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cgroupSystemInfo</name> <operator>=</operator> <call><name>get_cgroup_sysinfo_alpha</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name>cgroupOpsRoutine</name> <operator>=</operator> <call><name>get_cgroup_routine_dummy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cgroupSystemInfo</name> <operator>=</operator> <call><name>get_cgroup_sysinfo_dummy</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>bool</name></type> <name>probe_result</name> <init>= <expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>probecgroup</name></name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>probe_result</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"The control group is not well configured, please check your"</literal>
					<literal type="string">"system configuration."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>checkcgroup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>initcgroup</name></name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Load the resource groups in shared memory. Note this
 * can only be done after enough setup has been done. This uses
 * heap_open etc which in turn requires shared memory to be set up.
 */</comment>
<function><type><name>void</name></type>
<name>InitResGroups</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SysScanDesc</name></type>	<name>sscan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numGroups</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbComponentDatabaseInfo</name> <modifier>*</modifier></type><name>qdinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupCaps</name></type>		<name>caps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>			<name>relResGroup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>			<name>relResGroupCapability</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>cpuset</name><index>[<expr><name>MaxCpuSetLength</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>defaultCore</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>	<modifier>*</modifier></type><name>bmsUnused</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>AtProcExit_ResGroup</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * On master and segments, the first backend does the initialization.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>loaded</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>segmentsOnMaster</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>qdinfo</name> <operator>=</operator> <call><name>cdbcomponent_getComponentInfo</name><argument_list>(<argument><expr><name>MASTER_CONTENT_ID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>segmentsOnMaster</name></name> <operator>=</operator> <name><name>qdinfo</name><operator>-&gt;</operator><name>hostPrimaryCount</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>segmentsOnMaster</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The resgroup shared mem initialization must be serialized. Only the first session
	 * should do the init.
	 * Serialization is done by LW_EXCLUSIVE ResGroupLock. However, we must obtain all DB
	 * locks before obtaining LWlock to prevent deadlock.
	 */</comment>
	<expr_stmt><expr><name>relResGroup</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ResGroupRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>relResGroupCapability</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name>ResGroupCapabilityRelationId</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>loaded</name></name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>exit</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* These initialization must be done before createGroup() */</comment>
	<expr_stmt><expr><call><name>decideTotalChunks</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>chunkSizeInBits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>, <argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_write_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>safeChunksThreshold100</name></name></expr></argument>,
						<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name> <operator>*</operator> <operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name>runaway_detector_activation_percent</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insufficient memory available"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Increase gp_resource_group_memory_limit"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get cpuset from cpuset/gpdb, and transform it into bitset */</comment>
		<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>getcpuset</name></name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bmsUnused</name> <operator>=</operator> <call><name>CpusetToBitset</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* get the minimum core number, in case of the zero core is not exist */</comment>
		<expr_stmt><expr><name>defaultCore</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>bmsUnused</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultCore</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>numGroups</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sscan</name> <operator>=</operator> <call><name>systable_beginscan</name><argument_list>(<argument><expr><name>relResGroup</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tuple</name> <operator>=</operator> <call><name>systable_getnext</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>groupId</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Form_pg_resgroup</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>oid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>cpuRateLimit</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bmsCurrent</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>GetResGroupCapabilities</name><argument_list>(<argument><expr><name>relResGroupCapability</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cpuRateLimit</name> <operator>=</operator> <name><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>createGroup</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>group</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>createcgroup</name></name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setmemorylimit</name></name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name><name>caps</name><operator>.</operator><name>memLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<if_stmt><if>if <condition>(<expr><name><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name> <operator>!=</operator> <name>CPU_RATE_LIMIT_DISABLED</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setcpulimit</name></name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset</name> <init>= <expr><call><name>getCpuSetByRole</name><argument_list>(<argument><expr><name><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>bmsCurrent</name> <operator>=</operator> <call><name>CpusetToBitset</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bmsCommon</name> <init>= <expr><call><name>bms_intersect</name><argument_list>(<argument><expr><name>bmsCurrent</name></expr></argument>, <argument><expr><name>bmsUnused</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bmsMissing</name> <init>= <expr><call><name>bms_difference</name><argument_list>(<argument><expr><name>bmsCurrent</name></expr></argument>, <argument><expr><name>bmsCommon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * Do not call EnsureCpusetIsAvailable() here as resource group is
			 * not activated yet
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cgroup is not properly configured to use the cpuset feature"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Extra cgroup configurations are required to enable this feature, "</literal>
								 <literal type="string">"please refer to the Greenplum Documentations for details"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name> <operator>==</operator> <name>CPU_RATE_LIMIT_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>bmsMissing</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * write cpus to corresponding file
				 * if all the cores are available
				 */</comment>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset</name><init>= <expr><call><name>getCpuSetByRole</name><argument_list>(<argument><expr><name><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setcpuset</name></name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>bmsUnused</name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name>bmsUnused</name></expr></argument>, <argument><expr><name>bmsCurrent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>cpusetMissing</name><index>[<expr><name>MaxCpuSetLength</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * if some of the cores are unavailable, just set defaultCore
				 * to this group and send a warning message, so the system
				 * can startup, then DBA can fix it
				 */</comment>
				<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>defaultCore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setcpuset</name></name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>BitsetToCpuset</name><argument_list>(<argument><expr><name>bmsMissing</name></expr></argument>, <argument><expr><name>cpusetMissing</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cpu cores %s are unavailable on the system "</literal>
								<literal type="string">"in resource group %s"</literal></expr></argument>,
								<argument><expr><name>cpusetMissing</name></expr></argument>, <argument><expr><call><name>GetResGroupNameForId</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"using core %d for this resource group, "</literal>
								 <literal type="string">"please adjust the settings and restart"</literal></expr></argument>,
								 <argument><expr><name>defaultCore</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>numGroups</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>numGroups</name> <operator>&lt;=</operator> <name>MaxResourceGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>systable_endscan</name><argument_list>(<argument><expr><name>sscan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * set default cpuset
		 */</comment>

		<if_stmt><if>if <condition>(<expr><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>bmsUnused</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* no unused core, assign default core to default group */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>defaultCore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* assign all unused cores to default group */</comment>
			<expr_stmt><expr><call><name>BitsetToCpuset</name><argument_list>(<argument><expr><name>bmsUnused</name></expr></argument>, <argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cpuset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>CpusetIsEmpty</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setcpuset</name></name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>loaded</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LOG_RESGROUP_DEBUG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"initialized %d resource groups"</literal></expr></argument>, <argument><expr><name>numGroups</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>exit</name>:</label>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * release lock here to guarantee we have no lock held when acquiring
	 * resource group slot
	 */</comment>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relResGroup</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>relResGroupCapability</name></expr></argument>, <argument><expr><name>AccessShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check resource group status when DROP RESOURCE GROUP
 *
 * Errors out if there're running transactions, otherwise lock the resource group.
 * New transactions will be queued if the resource group is locked.
 */</comment>
<function><type><name>void</name></type>
<name>ResGroupCheckForDrop</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name> <operator>+</operator> <name><name>group</name><operator>-&gt;</operator><name>nRunningBypassed</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>nQuery</name> <init>= <expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name> <operator>+</operator> <name><name>group</name><operator>-&gt;</operator><name>nRunningBypassed</name></name> <operator>+</operator> <name><name>group</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>name</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DEPENDENT_OBJECTS_STILL_EXIST</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot drop resource group \"%s\""</literal></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">" The resource group is currently managing %d query(ies) and cannot be dropped.\n"</literal>
						 <literal type="string">"\tTerminate the queries first or try dropping the group later.\n"</literal>
						 <literal type="string">"\tThe view pg_stat_activity tracks the queries managed by resource groups."</literal></expr></argument>, <argument><expr><name>nQuery</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>lockResGroupForDrop</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Drop resource group call back function
 *
 * Wake up the backends in the wait queue when DROP RESOURCE GROUP finishes.
 * Unlock the resource group if the transaction is aborted.
 * Remove the resource group entry in shared memory if the transaction is committed.
 *
 * This function is called in the callback function of DROP RESOURCE GROUP.
 */</comment>
<function><type><name>void</name></type>
<name>ResGroupDropFinish</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResourceGroupCallbackContext</name> <modifier>*</modifier></type><name>callbackCtx</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>isCommit</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type>	<name>savedInterruptHoldoffCount</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>savedInterruptHoldoffCount</name> <operator>=</operator> <name>InterruptHoldoffCount</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>wakeupSlots</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>unlockResGroupForDrop</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>isCommit</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>migrate</name></decl>;</decl_stmt>

			<comment type="block">/* Only migrate processes out of vmtracker groups */</comment>
			<expr_stmt><expr><name>migrate</name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memAuditor</name></name> <operator>==</operator> <name>RESGROUP_MEMORY_AUDITOR_VMTRACKER</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>removeGroup</name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CpusetIsEmpty</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* reset default group, add cpu cores to it */</comment>
					<decl_stmt><decl><type><name>char</name></type> <name><name>cpuset</name><index>[<expr><name>MaxCpuSetLength</name></expr>]</index></name></decl>;</decl_stmt>
					<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>getcpuset</name></name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>,
										  <argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>CpusetUnion</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setcpuset</name></name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>destroycgroup</name></name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name>migrate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>InterruptHoldoffCount</name> <operator>=</operator> <name>savedInterruptHoldoffCount</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>elog_demote</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unable to demote error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Remove the resource group entry in shared memory if the transaction is aborted.
 *
 * This function is called in the callback function of CREATE RESOURCE GROUP.
 */</comment>
<function><type><name>void</name></type>
<name>ResGroupCreateOnAbort</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResourceGroupCallbackContext</name> <modifier>*</modifier></type><name>callbackCtx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type> <name>savedInterruptHoldoffCount</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>savedInterruptHoldoffCount</name> <operator>=</operator> <name>InterruptHoldoffCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>removeGroup</name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* remove the os dependent part for this resource group */</comment>
		<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>destroycgroup</name></name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CpusetIsEmpty</name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* return cpu cores to default group */</comment>
			<decl_stmt><decl><type><name>char</name></type> <name><name>defaultGroupCpuset</name><index>[<expr><name>MaxCpuSetLength</name></expr>]</index></name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>getcpuset</name></name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>,
								  <argument><expr><name>defaultGroupCpuset</name></expr></argument>,
								  <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CpusetUnion</name><argument_list>(<argument><expr><name>defaultGroupCpuset</name></expr></argument>,
						<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>,
						<argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setcpuset</name></name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>defaultGroupCpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>InterruptHoldoffCount</name> <operator>=</operator> <name>savedInterruptHoldoffCount</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>elog_demote</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unable to demote error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Apply the new resgroup caps.
 */</comment>
<function><type><name>void</name></type>
<name>ResGroupAlterOnCommit</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResourceGroupCallbackContext</name> <modifier>*</modifier></type><name>callbackCtx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>int</name></type>	<name>savedInterruptHoldoffCount</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>savedInterruptHoldoffCount</name> <operator>=</operator> <name>InterruptHoldoffCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>caps</name></name> <operator>=</operator> <name><name>callbackCtx</name><operator>-&gt;</operator><name>caps</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>limittype</name></name> <operator>==</operator> <name>RESGROUP_LIMIT_TYPE_CPU</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setcpulimit</name></name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>,
										<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>limittype</name></name> <operator>==</operator> <name>RESGROUP_LIMIT_TYPE_CPUSET</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset</name> <init>= <expr><call><name>getCpuSetByRole</name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setcpuset</name></name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>,
									        <argument><expr><name>cpuset</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>limittype</name></name> <operator>!=</operator> <name>RESGROUP_LIMIT_TYPE_MEMORY_SPILL_RATIO</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<decl_stmt><decl><type><name>ResGroupCap</name></type>	<name>memLimitGap</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>limittype</name></name> <operator>==</operator> <name>RESGROUP_LIMIT_TYPE_MEMORY</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>memLimitGap</name> <operator>=</operator> <name><name>callbackCtx</name><operator>-&gt;</operator><name>oldCaps</name><operator>.</operator><name>memLimit</name></name> <operator>-</operator> <name><name>callbackCtx</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memLimit</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>+=</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name> <operator>*</operator> <name>memLimitGap</name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name><operator>-&gt;</operator><name>group_mem_on_alter</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name><operator>-&gt;</operator><name>group_mem_on_alter</name></name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>groupid</name></name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* reset default group if cpuset has changed */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>oldCaps</name><operator>.</operator><name>cpuset</name></name></expr></argument>, <argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type> <name><name>defaultCpusetGroup</name><index>[<expr><name>MaxCpuSetLength</name></expr>]</index></name></decl>;</decl_stmt>
			<comment type="block">/* get current default group value */</comment>
			<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>getcpuset</name></name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>,
								  <argument><expr><name>defaultCpusetGroup</name></expr></argument>,
								  <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Add old value to default group
			 * sub new value from default group */</comment>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset</name><init>= <expr><call><name>getCpuSetByRole</name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>oldcpuset</name> <init>= <expr><call><name>getCpuSetByRole</name><argument_list>(<argument><expr><name><name>callbackCtx</name><operator>-&gt;</operator><name>oldCaps</name><operator>.</operator><name>cpuset</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>CpusetUnion</name><argument_list>(<argument><expr><name>defaultCpusetGroup</name></expr></argument>,
						<argument><expr><name>oldcpuset</name></expr></argument>,
						<argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CpusetDifference</name><argument_list>(<argument><expr><name>defaultCpusetGroup</name></expr></argument>,
						<argument><expr><name>cpuset</name></expr></argument>,
						<argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setcpuset</name></name><argument_list>(<argument><expr><name>DEFAULT_CPUSET_GROUP_ID</name></expr></argument>, <argument><expr><name>defaultCpusetGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><name>InterruptHoldoffCount</name> <operator>=</operator> <name>savedInterruptHoldoffCount</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>elog_demote</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FlushErrorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"unable to demote error"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>bool</name></type>
<name>ResGroupIsAssigned</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get resource group id of my proc.
 *
 * Returns InvalidOid in any of below cases:
 * - resource group is not enabled;
 * - resource group is not activated (initialized);
 * - my proc is not running inside a transaction;
 * - my proc is not assigned a resource group yet;
 *
 * Otherwise a valid resource group id is returned.
 *
 * This function is not dead code although there is no consumer in the gpdb
 * code tree.  Some extensions require this to get the internal resource group
 * information.
 */</comment>
<function><type><name>Oid</name></type>
<name>GetMyResGroupId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32</name></type>
<name>ResGroupGetVmemLimitChunks</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsResGroupEnabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32</name></type>
<name>ResGroupGetVmemChunkSizeInBits</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsResGroupEnabled</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>chunkSizeInBits</name></name></expr>;</return>
</block_content>}</block></function>

<function><type><name>int32</name></type>
<name>ResGroupGetMaxChunksPerQuery</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>ceil</name><argument_list>(<argument><expr><name>gp_vmem_limit_per_query</name> <operator>/</operator>
				<operator>(</operator><literal type="number">1024.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1</literal> <operator>&lt;&lt;</operator> <operator>(</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>chunkSizeInBits</name></name> <operator>-</operator> <name>BITS_IN_MB</name><operator>)</operator><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *  Retrieve statistic information of type from resource group
 */</comment>
<function><type><name>Datum</name></type>
<name>ResGroupGetStat</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupStatType</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsResGroupActivated</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>type</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RES_GROUP_STAT_NRUNNING</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name> <operator>+</operator> <name><name>group</name><operator>-&gt;</operator><name>nRunningBypassed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RES_GROUP_STAT_NQUEUEING</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>waitProcs</name><operator>.</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RES_GROUP_STAT_TOTAL_EXECUTED</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>totalExecuted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RES_GROUP_STAT_TOTAL_QUEUED</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>totalQueued</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RES_GROUP_STAT_TOTAL_QUEUE_TIME</name></expr>:</case>
			<comment type="block">/*
			 * Turn milliseconds in totalQueuedTimeMs into an Interval.
			 *
			 * Note: we only use the 'time' field. The user can call
			 * justify_interval() if she wants.
			 */</comment>
			<expr_stmt><expr><name>interval</name> <operator>=</operator> <operator>(</operator><name>Interval</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Interval</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>totalQueuedTimeMs</name></name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>IntervalPGetDatum</name><argument_list>(<argument><expr><name>interval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>RES_GROUP_STAT_MEM_USAGE</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>CStringGetDatum</name><argument_list>(<argument><expr><call><name>groupDumpMemUsage</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid stat type %d"</literal></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the number of primary segments on this host
 */</comment>
<function><type><name>int</name></type>
<name>ResGroupGetHostPrimaryCount</name><parameter_list>()</parameter_list>
<block>{<block_content>
	<return>return <expr><operator>(</operator><ternary><condition><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr> ?</condition><then> <expr><name>host_primary_segment_count</name></expr> </then><else>: <expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>segmentsOnMaster</name></name></expr></else></ternary><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>groupDumpMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>memUsage</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>memUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name><operator>-&gt;</operator><name>group_mem_on_dump</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name><operator>-&gt;</operator><name>group_mem_on_dump</name></name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>memUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name><name>memUsage</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Dump memory information for current resource group.
 */</comment>
<function><type><name>void</name></type>
<name>ResGroupDumpMemoryInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>group</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Resource group memory information: "</literal>
				  <literal type="string">"current group id is %u, "</literal>
				  <literal type="string">"memLimit cap is %d, "</literal>
				  <literal type="string">"memSharedQuota cap is %d, "</literal>
				  <literal type="string">"memSpillRatio cap is %d, "</literal>
				  <literal type="string">"group expected memory limit is %d MB, "</literal>
				  <literal type="string">"memory quota granted in currenct group is %d MB, "</literal>
				  <literal type="string">"shared quota granted in current group is %d MB, "</literal>
				  <literal type="string">"memory assigned to all running slots is %d MB, "</literal>
				  <literal type="string">"memory usage in current group is %d MB, "</literal>
				  <literal type="string">"memory shared usage in current group is %d MB, "</literal>
				  <literal type="string">"memory quota in current slot is %d MB, "</literal>
				  <literal type="string">"memory usage in current slot is %d MB, "</literal>
				  <literal type="string">"memory usage in current proc is %d MB"</literal></expr></argument>,
				  <argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
				  <argument><expr><name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memLimit</name></name></expr></argument>,
				  <argument><expr><name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memSharedQuota</name></name></expr></argument>,
				  <argument><expr><name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memSpillRatio</name></name></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memExpected</name></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>write_log</name><argument_list>(<argument><expr><literal type="string">"Resource group memory information: "</literal>
				  <literal type="string">"memory usage in current proc is %d MB"</literal></expr></argument>,
				  <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reserve 'memoryChunks' number of chunks for current resource group.
 * It will first try to reserve memory from the resource group slot; if the slot
 * quota exceeded, it will reserve memory from the shared zone. It fails if the
 * shared quota is also exceeded, and no memory is reserved.
 *
 * 'overuseChunks' number of chunks can be overused for error handling,
 * in such a case waiverUsed is marked as true.
 */</comment>
<function><type><name>bool</name></type>
<name>ResGroupReserveMemory</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>memoryChunks</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>overuseChunks</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>waiverUsed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>				<name>overuseMem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Memories may be allocated before resource group is initialized,
	 * however,we need to track those memories once resource group is
	 * enabled, so we use IsResGroupEnabled() instead of
	 * IsResGroupActivated() here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResGroupEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>memoryChunks</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Bypass the limit check when we are not in a valid resource group.
	 * But will update the memory usage of this proc, and it will be added up
	 * when this proc is assigned to a valid resource group.
	 */</comment>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>+=</operator> <name>memoryChunks</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bypassedGroup</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Do not allow to allocate more than the per proc limit.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>&gt;</operator> <name><name>self</name><operator>-&gt;</operator><name>bypassMemoryLimit</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>-=</operator> <name>memoryChunks</name></expr>;</expr_stmt>
			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Set group &amp; slot to bypassed ones so we could follow the limitation
		 * checking logic as normal transactions.
		 */</comment>
		<expr_stmt><expr><name>group</name> <operator>=</operator> <name>bypassedGroup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name>bypassedSlot</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bypassedGroup</name> <operator>||</operator> <call><name>slotIsInUse</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add memoryChunks into group &amp; slot memory usage */</comment>
	<expr_stmt><expr><name>overuseMem</name> <operator>=</operator> <call><name>groupIncMemUsage</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>memoryChunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* then check whether there is over usage */</comment>
	<if_stmt><if>if <condition>(<expr><name>CritSectionCount</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>overuseMem</name> <operator>&gt;</operator> <name>overuseChunks</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* if the over usage is larger than allowed then revert the change */</comment>
			<expr_stmt><expr><call><name>groupDecMemUsage</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>memoryChunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* also revert in proc */</comment>
			<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>-=</operator> <name>memoryChunks</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>overuseChunks</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ResGroupDumpMemoryInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<return>return <expr><name>false</name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>overuseMem</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* the over usage is within the allowed threshold */</comment>
			<expr_stmt><expr><operator>*</operator><name>waiverUsed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release the memory of resource group
 */</comment>
<function><type><name>void</name></type>
<name>ResGroupReleaseMemory</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>memoryChunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResGroupEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>memoryChunks</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>memoryChunks</name> <operator>&lt;=</operator> <name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>-=</operator> <name>memoryChunks</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>bypassedGroup</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Set group &amp; slot to bypassed ones so we could follow the release
		 * logic as normal transactions.
		 */</comment>
		<expr_stmt><expr><name>group</name> <operator>=</operator> <name>bypassedGroup</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name>bypassedSlot</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bypassedGroup</name> <operator>||</operator> <call><name>slotIsInUse</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>groupDecMemUsage</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>memoryChunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>int64</name></type>
<name>ResourceGroupGetQueryMemoryLimit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>				<name>memSpill</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>bypassedGroup</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int64</name></type>		<name>bytesInMB</name> <init>= <expr><literal type="number">1</literal> <operator>&lt;&lt;</operator> <name>BITS_IN_MB</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int64</name></type>		<name>bytesInChunk</name> <init>= <expr><operator>(</operator><name>int64</name><operator>)</operator> <literal type="number">1</literal> <operator>&lt;&lt;</operator> <call><name>VmemTracker_GetChunkSizeInBits</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * In bypass mode there is a hard memory limit of
		 * RESGROUP_BYPASS_MODE_MEMORY_LIMIT_ON_QE chunk,
		 * we should make sure query_mem + misc mem &lt;= chunk.
		 */</comment>
		<return>return <expr><call><name>Min</name><argument_list>(<argument><expr><name>bytesInMB</name></expr></argument>,
				   <argument><expr><name>bytesInChunk</name> <operator>*</operator> <name>RESGROUP_BYPASS_MODE_MEMORY_LIMIT_ON_QE</name> <operator>/</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsResManagerMemoryPolicyNone</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>memSpill</name> <operator>=</operator> <call><name>slotGetMemSpill</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>caps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* memSpill is already converted to chunks */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>memSpill</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>memSpill</name> <operator>&lt;&lt;</operator> <call><name>VmemTracker_GetChunkSizeInBits</name><argument_list>()</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * removeGroup -- remove resource group from share memory and
 * reclaim the group's memory back to MEM POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>removeGroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashRemove</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name><operator>-&gt;</operator><name>group_mem_on_drop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name><operator>-&gt;</operator><name>group_mem_on_drop</name></name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>notifyGroupsOnMem</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * createGroup -- initialize the elements for a resource group.
 *
 * Notes:
 *	It is expected that the appropriate lightweight lock is held before
 *	calling this - unless we are the startup process.
 */</comment>
<function><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type>
<name>createGroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>			<name>chunks</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashNew</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>group</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>groupId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>caps</name></name> <operator>=</operator> <operator>*</operator><name>caps</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>nRunningBypassed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ProcQueueInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>waitProcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>totalExecuted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>totalQueued</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>totalQueuedTimeMs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memExpected</name></name> <operator>=</operator> <call><name>groupGetMemExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>mempoolReserve</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memExpected</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>groupRebalanceQuota</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>chunks</name></expr></argument>, <argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>bindGroupOperation</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>group</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Bind operation to resource group according to memory auditor.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>bindGroupOperation</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memAuditor</name></name> <operator>==</operator> <name>RESGROUP_MEMORY_AUDITOR_VMTRACKER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name></name> <operator>=</operator> <operator>&amp;</operator><name>resgroup_memory_operations_vmtracker</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memAuditor</name></name> <operator>==</operator> <name>RESGROUP_MEMORY_AUDITOR_CGROUP</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name></name> <operator>=</operator> <operator>&amp;</operator><name>resgroup_memory_operations_cgroup</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid memory auditor: %d"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memAuditor</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Add chunks into group and slot memory usage.
 *
 * Return the total over used chunks of global share
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>groupIncMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>			<name>slotMemUsage</name></decl>;</decl_stmt>	<comment type="block">/* the memory current slot has been used */</comment>
	<decl_stmt><decl><type><name>int32</name></type>			<name>sharedMemUsage</name></decl>;</decl_stmt>	<comment type="block">/* the total shared memory usage,
										sum of group share and global share */</comment>
	<decl_stmt><decl><type><name>int32</name></type>			<name>globalOveruse</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* the total over used chunks of global share*/</comment>

	<comment type="block">/* Add the chunks to memUsage in slot */</comment>
	<expr_stmt><expr><name>slotMemUsage</name> <operator>=</operator> <call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>,
										   <argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check whether shared memory should be added */</comment>
	<expr_stmt><expr><name>sharedMemUsage</name> <operator>=</operator> <name>slotMemUsage</name> <operator>-</operator> <name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sharedMemUsage</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Decide how many chunks should be counted as shared memory */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>deltaSharedMemUsage</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>sharedMemUsage</name></expr></argument>, <argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Add these chunks to memSharedUsage in group, 
		 * and record the old value*/</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>oldSharedUsage</name> <init>= <expr><call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator>
													   <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr></argument>,
													   <argument><expr><name>deltaSharedMemUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* the free space of group share */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>oldSharedFree</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>-</operator> <name>oldSharedUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Calculate the global over used chunks */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>deltaGlobalSharedMemUsage</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>deltaSharedMemUsage</name> <operator>-</operator> <name>oldSharedFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* freeChunks -= deltaGlobalSharedMemUsage and get the new value */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>newFreeChunks</name> <init>= <expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>,
													  <argument><expr><name>deltaGlobalSharedMemUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* calculate the total over used chunks of global share */</comment>
		<expr_stmt><expr><name>globalOveruse</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>-</operator> <name>newFreeChunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the chunks to memUsage in group */</comment>
	<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>,
							<argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>globalOveruse</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sub chunks from group ,slot memory usage and global shared memory.
 * return memory chunks of global shared released this time
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type> 
<name>groupDecMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>			<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>			<name>slotMemUsage</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>			<name>sharedMemUsage</name></decl>;</decl_stmt>

	<comment type="block">/* Sub chunks from memUsage in group */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>,
									<argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>value</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sub chunks from memUsage in slot */</comment>
	<expr_stmt><expr><name>slotMemUsage</name> <operator>=</operator> <call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>,
										   <argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotMemUsage</name> <operator>&gt;=</operator> <name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check whether shared memory should be subed */</comment>
	<expr_stmt><expr><name>sharedMemUsage</name> <operator>=</operator> <name>slotMemUsage</name> <operator>-</operator> <name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>sharedMemUsage</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Decide how many chunks should be counted as shared memory */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>deltaSharedMemUsage</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>sharedMemUsage</name></expr></argument>, <argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Sub chunks from memSharedUsage in group */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>oldSharedUsage</name> <init>= <expr><call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr></argument>,
										<argument><expr><name>deltaSharedMemUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* record the total global share usage of current group */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>grpTotalGlobalUsage</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>oldSharedUsage</name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* calculate the global share usage of current release */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>deltaGlobalSharedMemUsage</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>grpTotalGlobalUsage</name></expr></argument>, <argument><expr><name>deltaSharedMemUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* add chunks to global shared memory */</comment>
		<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>,
								<argument><expr><name>deltaGlobalSharedMemUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>deltaGlobalSharedMemUsage</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add the chunks of a slot in a group, it's used when move a query to a resource group
 *
 * Return the total over used chunks of global share
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>groupIncSlotMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>			<name>slotSharedMemUsage</name></decl>;</decl_stmt>	<comment type="block">/* the slot shared memory usage */</comment>
	<decl_stmt><decl><type><name>int32</name></type>			<name>globalOveruse</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* the total over used chunks of global share*/</comment>

	<comment type="block">/* Check whether shared memory should be added */</comment>
	<expr_stmt><expr><name>slotSharedMemUsage</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>-</operator> <name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slotSharedMemUsage</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Add these chunks to memSharedUsage in group,
		 * and record the old value*/</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>oldSharedUsage</name> <init>= <expr><call><name>pg_atomic_fetch_add_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator>
													   <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr></argument>,
													   <argument><expr><name>slotSharedMemUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* the free space of group share */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>oldSharedFree</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>-</operator> <name>oldSharedUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Calculate the global over used chunks */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>deltaGlobalSharedMemUsage</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>slotSharedMemUsage</name> <operator>-</operator> <name>oldSharedFree</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* freeChunks -= deltaGlobalSharedMemUsage and get the new value */</comment>
		<decl_stmt><decl><type><name>int32</name></type> <name>newFreeChunks</name> <init>= <expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>,
													  <argument><expr><name>deltaGlobalSharedMemUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* calculate the total over used chunks of global share */</comment>
		<expr_stmt><expr><name>globalOveruse</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>-</operator> <name>newFreeChunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Add the chunks to memUsage in group */</comment>
	<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>globalOveruse</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Deduct the chunks of a slot in a group, it's used when move a query to a resource group
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupDecSlotMemUsage</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>			<name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>			<name>slotSharedMemUsage</name></decl>;</decl_stmt>

	<comment type="block">/* Sub chunks from memUsage in group */</comment>
	<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>,
									<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>value</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check whether shared memory should be subed */</comment>
	<expr_stmt><expr><name>slotSharedMemUsage</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>-</operator> <name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slotSharedMemUsage</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Sub chunks from memSharedUsage in group */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>oldSharedUsage</name> <init>= <expr><call><name>pg_atomic_fetch_sub_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr></argument>,
			<argument><expr><name>slotSharedMemUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldSharedUsage</name> <operator>&gt;=</operator> <name>slotSharedMemUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* record the total global share usage of current group */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>grpTotalGlobalUsage</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>oldSharedUsage</name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* calculate the global share usage of current release */</comment>
	<decl_stmt><decl><type><name>int32</name></type> <name>deltaGlobalSharedMemUsage</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>grpTotalGlobalUsage</name></expr></argument>, <argument><expr><name>slotSharedMemUsage</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<comment type="block">/* add chunks to global shared memory */</comment>
	<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>,
			<argument><expr><name>deltaGlobalSharedMemUsage</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attach a process (QD or QE) to a slot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selfAttachResGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>selfSetGroup</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>selfSetSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>groupIncMemUsage</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>nProcs</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Detach a process (QD or QE) from a slot.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selfDetachResGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>groupDecMemUsage</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name><operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>nProcs</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>selfUnsetSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>selfUnsetGroup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the members of a slot
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>initSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>slotMemQuota</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>slotIsInUse</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>caps</name></name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name> <operator>=</operator> <name>slotMemQuota</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Alloc and initialize slot pool
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>slotpoolInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>numSlots</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>memSize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>numSlots</name> <operator>=</operator> <name>RESGROUP_MAX_SLOTS</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>memSize</name> <operator>=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><name>numSlots</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ResGroupSlotData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>slots</name></name> <operator>=</operator> <call><name>ShmemAlloc</name><argument_list>(<argument><expr><name>memSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>slots</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>slots</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>memSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* push all the slots into the list */</comment>
	<expr_stmt><expr><name>next</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>numSlots</name> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>next</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeSlot</name></name> <operator>=</operator> <name>next</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Alloc a slot from shared slot pool
 */</comment>
<function><type><specifier>static</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type>
<name>slotpoolAllocSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeSlot</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeSlot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeSlot</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Free a slot back to shared slot pool
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>slotpoolFreeSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>slotIsInUse</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>nProcs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>next</name></name> <operator>=</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeSlot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get a slot with memory quota granted.
 *
 * A slot can be got with this function if there is enough memory quota
 * available and the concurrency limit is not reached.
 *
 * On success the memory quota is marked as granted, nRunning is increased
 * and the slot's groupId is also set accordingly, the slot id is returned.
 *
 * On failure nothing is changed and InvalidSlotId is returned.
 */</comment>
<function><type><specifier>static</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type>
<name>groupGetSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupCaps</name>		<modifier>*</modifier></type><name>caps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>				<name>slotMemQuota</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>groupIsNotDropped</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>caps</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr>;</expr_stmt>

	<comment type="block">/* First check if the concurrency limit is reached */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name> <operator>&gt;=</operator> <name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>slotMemQuota</name> <operator>=</operator> <call><name>groupReserveMemQuota</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slotMemQuota</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Now actually get a free slot */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>slotpoolAllocSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>slotIsInUse</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>group</name></expr></argument>, <argument><expr><name>slotMemQuota</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name><operator>++</operator></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Put back the slot assigned to self.
 *
 * This will release a slot, its memory quota will be freed and
 * nRunning will be decreased.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupPutSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>released</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>slotIsInUse</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return the memory quota granted to this slot */</comment>
	<expr_stmt><expr><call><name>groupReleaseMemQuota</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Return the slot back to free list */</comment>
	<expr_stmt><expr><call><name>slotpoolFreeSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* And finally release the overused memory quota */</comment>
	<expr_stmt><expr><name>released</name> <operator>=</operator> <call><name>mempoolAutoRelease</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>released</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>notifyGroupsOnMem</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Once we have waken up other groups then the slot we just released
	 * might be reused, so we should not touch it anymore since now.
	 */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Reserve memory quota for a slot in group.
 *
 * If there is not enough free memory quota then return -1 and nothing
 * is changed; otherwise return the reserved quota size.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>groupReserveMemQuota</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupCaps</name>	<modifier>*</modifier></type><name>caps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>			<name>slotMemQuota</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>segmentsOnMaster</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>caps</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>mempoolAutoReserve</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Calculate the expected per slot quota */</comment>
	<expr_stmt><expr><name>slotMemQuota</name> <operator>=</operator> <call><name>slotGetMemQuotaExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotMemQuota</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>&lt;=</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>+</operator> <name>slotMemQuota</name> <operator>&gt;</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No enough memory quota available, give up */</comment>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>+=</operator> <name>slotMemQuota</name></expr>;</expr_stmt>

	<return>return <expr><name>slotMemQuota</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Release a slot's memory quota to group.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupReleaseMemQuota</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>-=</operator> <name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Pick a resource group for the current transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>Oid</name></type>
<name>decideResGroupId</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>groupId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>resgroup_assign_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>groupId</name> <operator>=</operator> <call><name>resgroup_assign_hook</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>groupId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>groupId</name> <operator>=</operator> <call><name>GetResGroupIdForRole</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>groupId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Decide the proper resource group for current role.
 *
 * An exception is thrown if current role is invalid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>decideResGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupInfo</name> <modifier>*</modifier></type><name>pGroupInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>				 <name>groupId</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pResGroupControl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>segmentsOnMaster</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* always find out the up-to-date resgroup id */</comment>
	<expr_stmt><expr><name>groupId</name> <operator>=</operator> <call><name>decideResGroupId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>group</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>groupId</name> <operator>=</operator> <ternary><condition><expr><call><name>superuser</name><argument_list>()</argument_list></call></expr> ?</condition><then> <expr><name>GPDB_ADMIN_CGROUP</name></expr> </then><else>: <expr><name>GPDB_DEFAULT_CGROUP</name></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>group</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pGroupInfo</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pGroupInfo</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>groupId</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Increase the bypassed ref count
 *
 * Return true if the operation is done, or false if the group is dropped.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>groupIncBypassedRef</name><parameter_list>(<parameter><decl><type><name>ResGroupInfo</name> <modifier>*</modifier></type><name>pGroupInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>pGroupInfo</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>			<name>result</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Has the group been dropped? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>groupIsDropped</name><argument_list>(<argument><expr><name>pGroupInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* Is the group locked for drop? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>end</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>nRunningBypassed</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>end</name>:</label>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Decrease the bypassed ref count
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupDecBypassedRef</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>(</operator><name>pg_atomic_uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>nRunningBypassed</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Acquire a resource group slot
 *
 * Call this function at the start of the transaction.
 * This function set current resource group in MyResGroupSharedInfo,
 * and current slot in MyProc-&gt;resSlot.
 */</comment>
<function><type><specifier>static</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type>
<name>groupAcquireSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupInfo</name> <modifier>*</modifier></type><name>pGroupInfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isMoveQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name>	 <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call> <operator>||</operator> <name>isMoveQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>group</name> <operator>=</operator> <name><name>pGroupInfo</name><operator>-&gt;</operator><name>group</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Has the group been dropped? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>groupIsDropped</name><argument_list>(<argument><expr><name>pGroupInfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* acquire a slot */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* try to get a slot directly */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>groupGetSlot</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* got one, lucky */</comment>
			<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>totalExecuted</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pgstat_report_resgroup</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>slot</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add into group wait queue (if not waiting yet).
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>proc_exit_inprogress</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>groupWaitQueuePush</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>totalQueued</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * wait on the queue
	 * slot will be assigned by the proc wakes me up
	 * if i am waken up by DROP RESOURCE GROUP statement, the
	 * resSlot will be NULL.
	 */</comment>
	<expr_stmt><expr><call><name>waitOnGroup</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>isMoveQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>resSlot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The waking process has granted us a valid slot.
	 * Update the statistic information of the resource group.
	 */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>(</operator><name>ResGroupSlotData</name> <operator>*</operator><operator>)</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>resSlot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>resSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>addTotalQueueDuration</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>totalExecuted</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pgstat_report_resgroup</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Wake up the backends in the wait queue when 'concurrency' is increased.
 * This function is called in the callback function of ALTER RESOURCE GROUP.
 *
 * Return TRUE if any memory quota or shared quota is returned to MEM POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>groupApplyMemCaps</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>				<name>reserved</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>				<name>released</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ResGroupCaps</name>	<modifier>*</modifier></type><name>caps</name> <init>= <expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memExpected</name></name> <operator>=</operator> <call><name>groupGetMemExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>released</name> <operator>=</operator> <call><name>mempoolAutoRelease</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>released</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * suppose rg1 has memory_limit=10, memory_shared_quota=40,
	 * and session1 is running in rg1.
	 *
	 * now we alter rg1 memory_limit to 40 in another session,
	 * apparently both memory quota and shared quota are expected to increase,
	 * however as our design is to let them increase on new queries,
	 * then for session1 it won't see memory shared quota being increased
	 * until new queries being executed in rg1.
	 *
	 * so we should try to acquire the new quota immediately.
	 */</comment>
	<expr_stmt><expr><name>reserved</name> <operator>=</operator> <call><name>mempoolAutoReserve</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>reserved</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>released</name> <operator>&gt;</operator> <name>reserved</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get quota from MEM POOL.
 *
 * chunks is the expected amount to get.
 *
 * return the actual got chunks, might be smaller than expectation.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>mempoolReserve</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>oldFreeChunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>newFreeChunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>reserved</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Compare And Save to avoid concurrency problem without using lock */</comment>
	<while>while <condition>(<expr><name>true</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldFreeChunks</name> <operator>=</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>reserved</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>Max</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>oldFreeChunks</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newFreeChunks</name> <operator>=</operator> <name>oldFreeChunks</name> <operator>-</operator> <name>reserved</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>reserved</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>pg_atomic_compare_exchange_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>,
										   <argument><expr><operator>(</operator><name>uint32</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>oldFreeChunks</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>uint32</name><operator>)</operator> <name>newFreeChunks</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/* also update the safeChunksThreshold which is used in runaway detector */</comment>
	<if_stmt><if>if <condition>(<expr><name>reserved</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>	<name>safeChunksThreshold100</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>		<name>safeChunksDelta100</name></decl>;</decl_stmt>
		
		<expr_stmt><expr><name>safeChunksThreshold100</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>safeChunksThreshold100</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>safeChunksDelta100</name> <operator>=</operator> <name>reserved</name> <operator>*</operator> <operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name>runaway_detector_activation_percent</name><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>safeChunksThreshold100</name> <operator>&lt;</operator> <name>safeChunksDelta100</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"safeChunksThreshold: %u should be positive after mempool reserved: %d"</literal></expr></argument>,
				 <argument><expr><name>safeChunksThreshold100</name></expr></argument>, <argument><expr><name>safeChunksDelta100</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>pg_atomic_sub_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>safeChunksThreshold100</name></name></expr></argument>, <argument><expr><name>safeChunksDelta100</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LOG_RESGROUP_DEBUG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"allocate %u out of %u chunks to group %d"</literal></expr></argument>,
					   <argument><expr><name>reserved</name></expr></argument>, <argument><expr><name>oldFreeChunks</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newFreeChunks</name> <operator>&lt;=</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>reserved</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return chunks to MEM POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>mempoolRelease</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>newFreeChunks</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>chunks</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>newFreeChunks</name> <operator>=</operator> <call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>,
											<argument><expr><name>chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* also update the safeChunksThreshold which is used in runaway detector */</comment>
	<expr_stmt><expr><call><name>pg_atomic_add_fetch_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>safeChunksThreshold100</name></name></expr></argument>,
							<argument><expr><name>chunks</name> <operator>*</operator> <operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name>runaway_detector_activation_percent</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LOG_RESGROUP_DEBUG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"free %u to pool(%u) chunks from group %d"</literal></expr></argument>,
					   <argument><expr><name>chunks</name></expr></argument>, <argument><expr><name>newFreeChunks</name> <operator>-</operator> <name>chunks</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newFreeChunks</name> <operator>&lt;=</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Assign the chunks we get from the MEM POOL to group and rebalance
 * them into the 'quota' and 'shared' part of the group, the amount
 * is calculated from caps.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupRebalanceQuota</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>chunks</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>delta</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>memQuotaGranted</name> <init>= <expr><call><name>groupGetMemQuotaExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>delta</name> <operator>=</operator> <name>memQuotaGranted</name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>delta</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>chunks</name></expr></argument>, <argument><expr><name>delta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>+=</operator> <name>delta</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>chunks</name> <operator>-=</operator> <name>delta</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>+=</operator> <name>chunks</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the total memory chunks of the segment
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>decideTotalChunks</name><parameter_list>(<parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>totalChunks</name></decl></parameter>, <parameter><decl><type><name>int32</name> <modifier>*</modifier></type><name>chunkSizeInBits</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>nsegments</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>tmptotalChunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>tmpchunkSizeInBits</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>nsegments</name> <operator>=</operator> <ternary><condition><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr> ?</condition><then> <expr><name>host_primary_segment_count</name></expr> </then><else>: <expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>segmentsOnMaster</name></name></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nsegments</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tmptotalChunks</name> <operator>=</operator> <call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>gettotalmemory</name></name><argument_list>()</argument_list></call> <operator>*</operator> <name>gp_resource_group_memory_limit</name> <operator>/</operator> <name>nsegments</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If vmem is larger than 16GB (i.e., 16K MB), we make the chunks bigger
	 * so that the vmem limit in chunks unit is not larger than 16K.
	 */</comment>
	<expr_stmt><expr><name>tmpchunkSizeInBits</name> <operator>=</operator> <name>BITS_IN_MB</name></expr>;</expr_stmt>
	<while>while<condition>(<expr><name>tmptotalChunks</name> <operator>&gt;</operator> <operator>(</operator><literal type="number">16</literal> <operator>*</operator> <literal type="number">1024</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tmpchunkSizeInBits</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>tmptotalChunks</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><operator>*</operator><name>totalChunks</name> <operator>=</operator> <name>tmptotalChunks</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>chunkSizeInBits</name> <operator>=</operator> <name>tmpchunkSizeInBits</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get total expected memory quota of a group in chunks
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>groupGetMemExpected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name> <operator>*</operator> <name><name>caps</name><operator>-&gt;</operator><name>memLimit</name></name> <operator>/</operator> <literal type="number">100</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get per-group expected memory quota in chunks
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>groupGetMemQuotaExpected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>slotGetMemQuotaExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call> <operator>*</operator> <name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>groupGetMemExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call> <operator>*</operator>
			<operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name><name>caps</name><operator>-&gt;</operator><name>memSharedQuota</name></name><operator>)</operator> <operator>/</operator> <literal type="number">100</literal></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get per-group expected memory shared quota in chunks
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>groupGetMemSharedExpected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>groupGetMemExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>groupGetMemQuotaExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get per-group expected memory spill in chunks
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>groupGetMemSpillTotal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>memory_spill_ratio</name> <operator>!=</operator> <name>RESGROUP_FALLBACK_MEMORY_SPILL_RATIO</name></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/* memSpill is in percentage mode */</comment>
		<return>return <expr><call><name>groupGetMemExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>memory_spill_ratio</name> <operator>/</operator> <literal type="number">100</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<comment type="block">/* memSpill is in fallback mode, return statement_mem instead */</comment>
		<return>return <expr><call><name>VmemTracker_ConvertVmemMBToChunks</name><argument_list>(<argument><expr><name>statement_mem</name> <operator>&gt;&gt;</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get per-slot expected memory quota in chunks
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>slotGetMemQuotaExpected</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><call><name>groupGetMemExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call> <operator>*</operator>
		<operator>(</operator><literal type="number">100</literal> <operator>-</operator> <name><name>caps</name><operator>-&gt;</operator><name>memSharedQuota</name></name><operator>)</operator> <operator>/</operator> <literal type="number">100</literal> <operator>/</operator>
		<name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get per-slot expected memory quota in chunks on QE.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>slotGetMemQuotaOnQE</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>nFreeSlots</name> <init>= <expr><name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * On QE the runtime status must also be considered as it might have
	 * different caps with QD.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nFreeSlots</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>Min</name><argument_list>(<argument><expr><call><name>slotGetMemQuotaExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr></argument>,
			   <argument><expr><operator>(</operator><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name><operator>)</operator> <operator>/</operator> <name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>Min</name><argument_list>(<argument><expr><call><name>slotGetMemQuotaExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><operator>(</operator><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name><operator>)</operator> <operator>/</operator> <name>nFreeSlots</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get per-slot expected memory spill in chunks
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>slotGetMemSpill</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>memory_spill_ratio</name> <operator>!=</operator> <name>RESGROUP_FALLBACK_MEMORY_SPILL_RATIO</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* memSpill is in percentage mode */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>groupGetMemSpillTotal</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call> <operator>/</operator> <name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * memSpill is in fallback mode, it is an absolute value, no need to
		 * divide by concurrency.
		 */</comment>
		<return>return <expr><call><name>groupGetMemSpillTotal</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to wake up pending slots in the group.
 *
 * - grant indicates whether to grant the proc a slot;
 * - release indicates whether to wake up the proc with the LWLock
 *   temporarily released;
 *
 * When grant is true we'll give up once no slot can be get,
 * e.g. due to lack of free slot or enough memory quota.
 *
 * When grant is false all the pending procs will be woken up.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>wakeupSlots</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>grant</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>groupWaitQueueIsEmpty</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>PGPROC</name>		<modifier>*</modifier></type><name>waitProc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>grant</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* try to get a slot for that proc */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>groupGetSlot</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* if can't get one then give up */</comment>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* wake up one process in the wait queue */</comment>
		<expr_stmt><expr><name>waitProc</name> <operator>=</operator> <call><name>groupWaitQueuePop</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>waitProc</name><operator>-&gt;</operator><name>resSlot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>procWakeup</name><argument_list>(<argument><expr><name>waitProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * When a group returns chunks to MEM POOL, we need to:
 * 1. For groups with vmtracker memory auditor, wake up the
 *    transactions waiting on them for memory quota.
 * 2. For groups with cgroup memory auditor, increase their
 *    memory limit if needed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>notifyGroupsOnMem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>skipGroupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>MaxResourceGroups</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name> <init>= <expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>skipGroupId</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name><operator>-&gt;</operator><name>group_mem_on_notify</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name><name>group</name><operator>-&gt;</operator><name>groupMemOps</name><operator>-&gt;</operator><name>group_mem_on_notify</name></name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Release overused memory quota to MEM POOL.
 *
 * Both overused shared and non-shared memory quota will be released.
 *
 * If there was enough non-shared memory quota for free slots,
 * then after this call there will still be enough non-shared memory quota.
 *
 * If this function is called after a slot is released, make sure that
 * group-&gt;nRunning is updated before this function.
 *
 * Return the total released quota in chunks, can be 0.
 *
 * XXX: Some examples.
 *
 * Suppose concurrency is 10, running is 4,
 * memory limit is 0.5, memory shared is 0.4
 *
 * assume currentSharedUsage is 0
 *
 * currentSharedStocks is 0.5*0.4 = 0.2
 * memQuotaGranted is 0.5*0.6 = 0.3
 * memStocksInuse is 0.5*0.4/10*6 = 0.12
 * memStocksFree is 0.3 - 0.12 = 0.18
 *
 * * memLimit: 0.5 -&gt; 0.4
 *   for memQuotaGranted we could free 0.18 - 0.4*0.6/10*6 = 0.18-0.144 = 0.036
 *       new memQuotaGranted is 0.3-0.036 = 0.264
 *       new memStocksFree is 0.18-0.036 = 0.144
 *   for memShared we could free currentSharedStocks - Max(currentSharedUsage, 0.4*0.4)=0.04
 *       new currentSharedStocks is 0.2-0.04 = 0.16
 *
 * * concurrency: 10 -&gt; 20
 *   for memQuotaGranted we could free 0.144 - 0.4*0.6/20*16 = 0.144 - 0.24*0.8 = -0.048
 *   for memShared we could free currentSharedStocks - Max(currentSharedUsage, 0.4*0.4)=0.00
 *
 * * memShared: 0.4 -&gt; 0.2
 *   for memQuotaGranted we could free 0.144 - 0.4*0.8/20*16 = 0.144 - 0.256 = -0.122
 *   for memShared we could free currentSharedUsage - Max(currentSharedUsage, 0.4*0.2)=0.08
 *       new currentSharedStocks is 0.16-0.08 = 0.08
 *
 * * memShared: 0.2 -&gt; 0.6
 *   for memQuotaGranted we could free 0.144 - 0.4*0.4/20*16 = 0.144 - 0.128 = 0.016
 *       new memQuotaGranted is 0.264 - 0.016 = 0.248
 *       new memStocksFree is 0.144 - 0.016 = 0.128
 *   for memShared we could free currentSharedUsage - Max(currentSharedUsage, 0.4*0.6) = -0.18
 *
 * * memLimit: 0.4 -&gt; 0.2
 *   for memQuotaGranted we could free 0.128 - 0.2*0.4/20*16 = 0.128 - 0.064 = 0.064
 *       new memQuotaGranted is 0.248-0.064 = 0.184
 *       new memStocksFree is 0.128 - 0.064 = 0.064
 *   for memShared we could free currentSharedStocks - Max(currentSharedUsage, 0.2*0.6) = -0.04
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>mempoolAutoRelease</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>memQuotaNeeded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>memQuotaToFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>memSharedNeeded</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>memSharedToFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nfreeSlots</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name> <init>= <expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* nfreeSlots is the number of free slots */</comment>
	<expr_stmt><expr><name>nfreeSlots</name> <operator>=</operator> <name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name></expr>;</expr_stmt>

	<comment type="block">/* the in use non-shared quota must be reserved */</comment>
	<expr_stmt><expr><name>memQuotaNeeded</name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name></expr>;</expr_stmt>

	<comment type="block">/* also should reserve enough non-shared quota for free slots */</comment>
	<expr_stmt><expr><name>memQuotaNeeded</name> <operator>+=</operator>
		<ternary><condition><expr><name>nfreeSlots</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><call><name>slotGetMemQuotaExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>nfreeSlots</name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>memQuotaToFree</name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>-</operator> <name>memQuotaNeeded</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>memQuotaToFree</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* release the over used non-shared quota to MEM POOL */</comment>
		<expr_stmt><expr><call><name>mempoolRelease</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>memQuotaToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>-=</operator> <name>memQuotaToFree</name></expr>;</expr_stmt> 
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>memSharedNeeded</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr></argument>,
						  <argument><expr><call><name>groupGetMemSharedExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>memSharedToFree</name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>-</operator> <name>memSharedNeeded</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>memSharedToFree</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* release the over used shared quota to MEM POOL */</comment>
		<expr_stmt><expr><call><name>mempoolRelease</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>memSharedToFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>-=</operator> <name>memSharedToFree</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>Max</name><argument_list>(<argument><expr><name>memQuotaToFree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>Max</name><argument_list>(<argument><expr><name>memSharedToFree</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to acquire enough quota &amp; shared quota for current group from MEM POOL,
 * the actual acquired quota depends on system loads.
 *
 * Return the reserved quota in chunks, can be 0.
 */</comment>
<function><type><specifier>static</specifier> <name>int32</name></type>
<name>mempoolAutoReserve</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>currentMemStocks</name> <init>= <expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>+</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>neededMemStocks</name> <init>= <expr><name><name>group</name><operator>-&gt;</operator><name>memExpected</name></name> <operator>-</operator> <name>currentMemStocks</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>chunks</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>neededMemStocks</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>chunks</name> <operator>=</operator> <call><name>mempoolReserve</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>neededMemStocks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>groupRebalanceQuota</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>chunks</name></expr></argument>, <argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>chunks</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Update the total queued time of this group */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>addTotalQueueDuration</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>group</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>totalQueuedTimeMs</name></name> <operator>+=</operator> <operator>(</operator><name>groupWaitEnd</name> <operator>-</operator> <name>groupWaitEnd</name><operator>)</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Release the resource group slot
 *
 * Call this function at the end of the transaction.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupReleaseSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isMoveQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call> <operator>||</operator> <name>isMoveQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>groupPutSlot</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We should wake up other pending queries on master nodes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<comment type="block">/*
		 * My slot is put back, then how many queuing queries should I wake up?
		 * Maybe zero, maybe one, maybe more, depends on how the resgroup's
		 * configuration were changed during our execution.
		 */</comment>
		<expr_stmt><expr><call><name>wakeupSlots</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Serialize the resource group information that need to dispatch to segment.
 */</comment>
<function><type><name>void</name></type>
<name>SerializeResGroupInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cpuset_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>itmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupCaps</name></type> <name>empty_caps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>caps</name> <operator>=</operator> <operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>caps</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ClearResGroupCaps</name><argument_list>(<argument><expr><operator>&amp;</operator><name>empty_caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>caps</name> <operator>=</operator> <operator>&amp;</operator><name>empty_caps</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>itmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>caps</name><operator>-&gt;</operator><name>cpuRateLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>caps</name><operator>-&gt;</operator><name>memLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>caps</name><operator>-&gt;</operator><name>memSharedQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>caps</name><operator>-&gt;</operator><name>memSpillRatio</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>caps</name><operator>-&gt;</operator><name>memAuditor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cpuset_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>caps</name><operator>-&gt;</operator><name>cpuset</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>itmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name>cpuset_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>caps</name><operator>-&gt;</operator><name>cpuset</name></name></expr></argument>, <argument><expr><name>cpuset_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>itmp</name> <operator>=</operator> <call><name>htonl</name><argument_list>(<argument><expr><name><name>bypassedSlot</name><operator>.</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Deserialize the resource group information dispatched by QD.
 */</comment>
<function><type><name>void</name></type>
<name>DeserializeResGroupInfo</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>ResGroupCaps</name></name> <modifier>*</modifier></type><name>capsOut</name></decl></parameter>,
						<parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>groupId</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>,
						<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>itmp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>int</name></type> <name>cpuset_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name>	<modifier>*</modifier></type><name>ptr</name> <init>= <expr><name>buf</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ClearResGroupCaps</name><argument_list>(<argument><expr><name>capsOut</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>groupId</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>capsOut</name><operator>-&gt;</operator><name>concurrency</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>capsOut</name><operator>-&gt;</operator><name>cpuRateLimit</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>capsOut</name><operator>-&gt;</operator><name>memLimit</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>capsOut</name><operator>-&gt;</operator><name>memSharedQuota</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>capsOut</name><operator>-&gt;</operator><name>memSpillRatio</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>capsOut</name><operator>-&gt;</operator><name>memAuditor</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>cpuset_len</name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cpuset_len</name> <operator>&gt;=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name><name>capsOut</name><operator>-&gt;</operator><name>cpuset</name></name></expr></argument>)</argument_list></sizeof></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"malformed serialized resource group info"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>capsOut</name><operator>-&gt;</operator><name>cpuset</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><name>cpuset_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <name>cpuset_len</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>capsOut</name><operator>-&gt;</operator><name>cpuset</name><index>[<expr><name>cpuset_len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>itmp</name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt> <expr_stmt><expr><name>ptr</name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>bypassedSlot</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <call><name>ntohl</name><argument_list>(<argument><expr><name>itmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>==</operator> <name>ptr</name> <operator>-</operator> <name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether resource group should be assigned on master.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldAssignResGroupOnMaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Bypass resource group when it's waiting for a resource group slot. e.g.
	 * MyProc was interrupted by SIGTERM while waiting for resource group slot.
	 * Some callbacks - RemoveTempRelationsCallback for example - open new
	 * transactions on proc exit. It can cause a double add of MyProc to the
	 * waiting queue (and its corruption).
	 *
	 * Also bypass resource group when it's exiting.
	 */</comment>
	<return>return <expr><call><name>IsResGroupActivated</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>proc_exit_inprogress</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether resource group should be un-assigned.
 * This will be called on both master and segments.
 */</comment>
<function><type><name>bool</name></type>
<name>ShouldUnassignResGroup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>IsResGroupActivated</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>IsNormalProcessingMode</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * On master, QD is assigned to a resource group at the beginning of a transaction.
 * It will first acquire a slot from the resource group, and then, it will get the
 * current capability snapshot, update the memory usage information, and add to
 * the corresponding cgroup.
 */</comment>
<function><type><name>void</name></type>
<name>AssignResGroupOnMaster</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupInfo</name></type>		<name>groupInfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * if query should be bypassed, do not assign a
	 * resource group, leave self unassigned
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>shouldBypassQuery</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Although we decide to bypass this query we should load the
		 * memory_spill_ratio setting from the resgroup, otherwise a
		 * `SHOW memory_spill_ratio` command will output the default value 20
		 * if it's the first query in the connection (make sure tab completion
		 * is not triggered otherwise it will run some implicit query before
		 * you execute the SHOW command).
		 *
		 * Also need to increase a bypassed ref count to prevent the group
		 * being dropped concurrently.
		 */</comment>
		<do>do <block>{<block_content>
			<expr_stmt><expr><call><name>decideResGroup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>groupInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><operator>!</operator><call><name>groupIncBypassedRef</name><argument_list>(<argument><expr><operator>&amp;</operator><name>groupInfo</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>

		<comment type="block">/* Record which resgroup we are running in */</comment>
		<expr_stmt><expr><name>bypassedGroup</name> <operator>=</operator> <name><name>groupInfo</name><operator>.</operator><name>group</name></name></expr>;</expr_stmt>

		<comment type="block">/* Update pg_stat_activity statistics */</comment>
		<expr_stmt><expr><name><name>bypassedGroup</name><operator>-&gt;</operator><name>totalExecuted</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_resgroup</name><argument_list>(<argument><expr><name><name>bypassedGroup</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize the fake slot */</comment>
		<expr_stmt><expr><name><name>bypassedSlot</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name><name>groupInfo</name><operator>.</operator><name>group</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bypassedSlot</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name><name>groupInfo</name><operator>.</operator><name>groupId</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bypassedSlot</name><operator>.</operator><name>memQuota</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bypassedSlot</name><operator>.</operator><name>memUsage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Attach self memory usage to resgroup */</comment>
		<expr_stmt><expr><call><name>groupIncMemUsage</name><argument_list>(<argument><expr><name>bypassedGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bypassedSlot</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/* Record the bypass memory limit of current query */</comment>
		<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>bypassMemoryLimit</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>+</operator> <name>RESGROUP_BYPASS_MODE_MEMORY_LIMIT_ON_QD</name></expr>;</expr_stmt>

		<comment type="block">/* Add into cgroup */</comment>
		<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>attachcgroup</name></name><argument_list>(<argument><expr><name><name>bypassedGroup</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>,
									  <argument><expr><name><name>bypassedGroup</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name> <operator>==</operator> <name>CPU_RATE_LIMIT_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>groupSetMemorySpillRatio</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>bypassedGroup</name><operator>-&gt;</operator><name>caps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<do>do <block>{<block_content>
			<expr_stmt><expr><call><name>decideResGroup</name><argument_list>(<argument><expr><operator>&amp;</operator><name>groupInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Acquire slot */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>groupAcquireSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>groupInfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>;</do>

		<comment type="block">/* Set resource group slot for current session */</comment>
		<expr_stmt><expr><call><name>sessionSetSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add proc memory accounting info into group and slot */</comment>
		<expr_stmt><expr><call><name>selfAttachResGroup</name><argument_list>(<argument><expr><name><name>groupInfo</name><operator>.</operator><name>group</name></name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Init self */</comment>
		<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>caps</name></name></expr>;</expr_stmt>

		<comment type="block">/* Don't error out before this line in this function */</comment>
		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"resgroup_assigned_on_master"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add into cgroup */</comment>
		<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>attachcgroup</name></name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>,
									  <argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name> <operator>==</operator> <name>CPU_RATE_LIMIT_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Set spill guc */</comment>
		<expr_stmt><expr><call><name>groupSetMemorySpillRatio</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>caps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnassignResGroup</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Detach from a resource group at the end of the transaction.
 */</comment>
<function><type><name>void</name></type>
<name>UnassignResGroup</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>releaseSlot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>bypassedGroup</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* bypass mode ref count is only maintained on qd */</comment>
		<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>groupDecBypassedRef</name><argument_list>(<argument><expr><name>bypassedGroup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Detach self memory usage from resgroup */</comment>
		<expr_stmt><expr><call><name>groupDecMemUsage</name><argument_list>(<argument><expr><name>bypassedGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bypassedSlot</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Reset the fake slot */</comment>
		<expr_stmt><expr><name><name>bypassedSlot</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bypassedSlot</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>bypassedGroup</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* Update pg_stat_activity statistics */</comment>
		<expr_stmt><expr><call><name>pgstat_report_resgroup</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"unassign_resgroup_start_entrydb"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Cleanup self */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LOG_RESGROUP_DEBUG</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"idle proc memory usage: %d"</literal></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Sub proc memory accounting info from group and slot */</comment>
	<expr_stmt><expr><call><name>selfDetachResGroup</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Release the slot if no reference. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>nProcs</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>releaseSlot</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>releaseSlot</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* release the memory left in the slot if there's entryDB */</comment>
			<expr_stmt><expr><call><name>groupDecSlotMemUsage</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>nProcs</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>groupReleaseSlot</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Reset resource group slot for current session. Note MySessionState
		 * could be reset as NULL in shmem_exit() before.
		 */</comment>
		<expr_stmt><expr><call><name>sessionResetSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"unassign_resgroup_end_qd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_resgroup</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * QEs are not assigned/unassigned to a resource group on segments for each
 * transaction, instead, they switch resource group when a new resource group
 * id or slot id is dispatched.
 */</comment>
<function><type><name>void</name></type>
<name>SwitchResGroupOnSegment</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>		<name>newGroupId</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupCaps</name></type>		<name>caps</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>DeserializeResGroupInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>caps</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>newGroupId</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * QD will dispatch the resgroup id via bypassedSlot.groupId
	 * in bypass mode.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>bypassedSlot</name><operator>.</operator><name>groupId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Are we already running in bypass mode? */</comment>
		<if_stmt><if>if <condition>(<expr><name>bypassedGroup</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>bypassedGroup</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name><name>bypassedSlot</name><operator>.</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Find out the resgroup by id */</comment>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>bypassedGroup</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name><name>bypassedSlot</name><operator>.</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bypassedGroup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Initialize the fake slot */</comment>
		<expr_stmt><expr><name><name>bypassedSlot</name><operator>.</operator><name>memQuota</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>bypassedSlot</name><operator>.</operator><name>memUsage</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* Attach self memory usage to resgroup */</comment>
		<expr_stmt><expr><call><name>groupIncMemUsage</name><argument_list>(<argument><expr><name>bypassedGroup</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>bypassedSlot</name></expr></argument>, <argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		
		<comment type="block">/* Record the bypass memory limit of current query */</comment>
		<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>bypassMemoryLimit</name></name> <operator>=</operator> <name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>+</operator> <name>RESGROUP_BYPASS_MODE_MEMORY_LIMIT_ON_QE</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>newGroupId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>UnassignResGroup</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* it's not the first dispatch in the same transaction */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>newGroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>concurrency</name></name> <operator>==</operator> <name><name>caps</name><operator>.</operator><name>concurrency</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name> <operator>==</operator> <name><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memLimit</name></name> <operator>==</operator> <name><name>caps</name><operator>.</operator><name>memLimit</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memSharedQuota</name></name> <operator>==</operator> <name><name>caps</name><operator>.</operator><name>memSharedQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memSpillRatio</name></name> <operator>==</operator> <name><name>caps</name><operator>.</operator><name>memSpillRatio</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memAuditor</name></name> <operator>==</operator> <name><name>caps</name><operator>.</operator><name>memAuditor</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>strcmp</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>, <argument><expr><name><name>caps</name><operator>.</operator><name>cpuset</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name>newGroupId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>group</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Init self */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>host_primary_segment_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>caps</name><operator>.</operator><name>concurrency</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name></name> <operator>=</operator> <name>caps</name></expr>;</expr_stmt>

	<comment type="block">/* Init slot */</comment>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>sessionGetSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>slotIsInUse</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>newGroupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* This is the first QE of this session, allocate a slot from slot pool */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>slotpoolAllocSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>slotIsInUse</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>sessionSetSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>mempoolAutoReserve</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name>group</name></expr></argument>,
				 <argument><expr><call><name>slotGetMemQuotaOnQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>caps</name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>+=</operator> <name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>&lt;=</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>selfAttachResGroup</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* finally, we can say we are in a valid resgroup */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Add into cgroup */</comment>
	<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>attachcgroup</name></name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>,
								  <argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name> <operator>==</operator> <name>CPU_RATE_LIMIT_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Wait on the queue of resource group
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>waitOnGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isMoveQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type> <name>timeout</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type> <name>curTime</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>old_status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>new_status</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name> <init>= <expr><name>MyProc</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>queueStr</name> <init>= <expr><literal type="string">" queuing"</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call> <operator>||</operator> <name>isMoveQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set ps status to waiting */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>old_status</name> <operator>=</operator> <call><name>get_real_act_ps_display</name><argument_list>(<argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>new_status</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>queueStr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>, <argument><expr><name>old_status</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>new_status</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>queueStr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* truncate off " queuing" */</comment>
		<expr_stmt><expr><name><name>new_status</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * The low bits of 'wait_event_info' argument to WaitLatch are
	 * not enough to store a full Oid, so we set groupId out-of-band,
	 * via the backend entry.
	 */</comment>
	<expr_stmt><expr><call><name>pgstat_report_resgroup</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Mark that we are waiting on resource group
	 *
	 * This is used for interrupt cleanup, similar to lockAwaited in ProcSleep
	 */</comment>
	<expr_stmt><expr><name>groupAwaited</name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>groupWaitStart</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Make sure we have released all locks before going to sleep, to eliminate
	 * deadlock situations
	 */</comment>
	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ResetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>gp_resource_group_queuing_timeout</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>curTime</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>timeout</name> <operator>=</operator> <name>gp_resource_group_queuing_timeout</name> <operator>-</operator> <operator>(</operator><name>curTime</name> <operator>-</operator> <name>groupWaitStart</name><operator>)</operator> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>timeout</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_QUERY_CANCELED</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"canceling statement due to resource group waiting timeout"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_TIMEOUT</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>,
						  <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>timeout</name></expr></argument>, <argument><expr><name>PG_WAIT_RESOURCE_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>WaitLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>, <argument><expr><name>WL_LATCH_SET</name> <operator>|</operator> <name>WL_POSTMASTER_DEATH</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
						  <argument><expr><name>PG_WAIT_RESOURCE_GROUP</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<comment type="block">/* reset ps status */</comment>
		<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>groupWaitCancel</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>groupAwaited</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* reset ps status */</comment>
	<if_stmt><if>if <condition>(<expr><name>update_process_title</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>new_status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * groupHashNew -- return a new (empty) group object to initialize.
 *
 * Notes
 *	The resource group lightweight lock (ResGroupLock) *must* be held for
 *	this operation.
 */</comment>
<function><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type>
<name>groupHashNew</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>groupId</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>nGroups</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>groups</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>groupId</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>i</name> <operator>&lt;</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>nGroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>ResGroupHashEntry</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>htbl</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>groupId</name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* caller should test that the group does not exist already */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>

	<return>return <expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * groupHashFind -- return the group for a given oid.
 *
 * If the group cannot be found, then NULL is returned if 'raise' is false,
 * otherwise an exception is thrown.
 *
 * Notes
 *	The resource group lightweight lock (ResGroupLock) *must* be held for
 *	this operation.
 */</comment>
<function><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type>
<name>groupHashFind</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>raise</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>				<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupHashEntry</name>	<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>ResGroupHashEntry</name> <operator>*</operator><operator>)</operator>
		<call><name>hash_search</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>htbl</name></name></expr></argument>, <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>groupId</name></expr></argument>, <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><ternary><condition><expr><name>raise</name></expr> ?</condition><then> <expr><name>ERROR</name></expr> </then><else>: <expr><name>LOG</name></expr></else></ternary></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot find resource group with Oid %d in shared memory"</literal></expr></argument>,
						<argument><expr><name>groupId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>nGroups</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>groups</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * groupHashRemove -- remove the group for a given oid.
 *
 * If the group cannot be found then an exception is thrown.
 *
 * Notes
 *	The resource group lightweight lock (ResGroupLock) *must* be held for
 *	this operation.
 */</comment>
<function><type><specifier>static</specifier> <name>ResGroupData</name> <modifier>*</modifier></type>
<name>groupHashRemove</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupHashEntry</name>	<modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>ResGroupHashEntry</name><operator>*</operator><operator>)</operator><call><name>hash_search</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>htbl</name></name></expr></argument>,
											<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>groupId</name></expr></argument>,
											<argument><expr><name>HASH_REMOVE</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATA_CORRUPTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot find resource group with Oid %d in shared memory to remove"</literal></expr></argument>,
						<argument><expr><name>groupId</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>group</name> <operator>=</operator> <operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>groups</name><index>[<expr><name><name>entry</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>

	<return>return <expr><name>group</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Process exit without waiting for slot or received SIGTERM */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtProcExit_ResGroup</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>groupWaitCancel</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Handle the interrupt cases when waiting on the queue
 *
 * The proc may wait on the queue for a slot, or wait for the
 * DROP transaction to finish. In the first case, at the same time
 * we get interrupted (SIGINT or SIGTERM), we could have been
 * granted a slot or not. In the second case, there's no running
 * transaction in the group. If the DROP transaction is finished
 * (commit or abort) at the same time as we get interrupted,
 * MyProc should have been removed from the wait queue, and the
 * ResGroupData entry may have been removed if the DROP is committed.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupWaitCancel</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>isMoveQuery</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if we weren't waiting on a group */</comment>
	<if_stmt><if>if <condition>(<expr><name>groupAwaited</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pgstat_report_wait_end</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>groupWaitEnd</name> <operator>=</operator> <call><name>GetCurrentTimestamp</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call> <operator>||</operator> <name>isMoveQuery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>group</name> <operator>=</operator> <name>groupAwaited</name></expr>;</expr_stmt>

	<comment type="block">/* We are sure to be interrupted in the for loop of waitOnGroup now */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>groupWaitQueueFind</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Still waiting on the queue when get interrupted, remove
		 * myself from the queue
		 */</comment>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>groupWaitQueueIsEmpty</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>groupWaitQueueErase</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>addTotalQueueDuration</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>MyProc</name><operator>-&gt;</operator><name>resSlot</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Woken up by a slot holder */</comment>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* First complete the slot's transfer from MyProc to self */</comment>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>resSlot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>resSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Similar as groupReleaseSlot(), how many pending queries to
		 * wake up depends on how many slots we can get.
		 */</comment>
		<expr_stmt><expr><call><name>groupReleaseSlot</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/*
		 * Reset resource group slot for current session. Note MySessionState
		 * could be reset as NULL in shmem_exit() before.
		 */</comment>
		<expr_stmt><expr><call><name>sessionResetSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>totalExecuted</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>addTotalQueueDuration</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * The transaction of DROP RESOURCE GROUP is finished,
		 * groupAcquireSlot will do the retry.
		 *
		 * The resource group pointed by self-&gt;group may have
		 * already been removed by here.
		 */</comment>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>MyProc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>groupAwaited</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupSetMemorySpillRatio</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>value</name><index>[<expr><literal type="number">64</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* No need to set memory_spill_ratio if it is already up-to-date */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>caps</name><operator>-&gt;</operator><name>memSpillRatio</name></name> <operator>==</operator> <name>memory_spill_ratio</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>caps</name><operator>-&gt;</operator><name>memSpillRatio</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"memory_spill_ratio"</literal></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_RESGROUP</name></expr></argument>,
			<argument><expr><name>GUC_ACTION_SET</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ResGroupGetMemInfo</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>memLimit</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>slotQuota</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>sharedQuota</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>ResGroupCaps</name> <modifier>*</modifier></type><name>caps</name> <init>= <expr><operator>&amp;</operator><name><name>self</name><operator>-&gt;</operator><name>caps</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>memLimit</name> <operator>=</operator> <call><name>groupGetMemExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>slotQuota</name> <operator>=</operator> <ternary><condition><expr><name><name>caps</name><operator>-&gt;</operator><name>concurrency</name></name></expr> ?</condition><then> <expr><call><name>slotGetMemQuotaExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><operator>-</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>sharedQuota</name> <operator>=</operator> <call><name>groupGetMemSharedExpected</name><argument_list>(<argument><expr><name>caps</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Validate the consistency of the resgroup information in self.
 *
 * This function checks the consistency of (group &amp; groupId).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selfValidateResGroupInfo</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>,
				<argument><expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether self is assigned.
 *
 * This is mostly equal to (selfHasSlot() &amp;&amp; selfHasGroup()),
 * however this function requires the slot and group to be in
 * a consistent status, they must both be set or unset,
 * so calling this function during the assign/unassign/switch process
 * might cause an error, use with caution.
 *
 * Even selfIsAssigned() is true it doesn't mean the assign/switch
 * process is completely done, for example the memory accounting
 * information might not been updated yet.
 *
 * This function doesn't check whether the assigned resgroup
 * is valid or dropped.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>selfIsAssigned</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>selfValidateResGroupInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name> <operator>==</operator> <name>NULL</name></expr></argument>,
			<argument><expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>,
			<argument><expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block">/*
 * Check whether self has been set a slot.
 *
 * We don't check whether a resgroup is set or not.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>selfHasSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether self has been set a resgroup.
 *
 * Consistency will be checked on the groupId and group pointer.
 *
 * We don't check whether the resgroup is valid or dropped.
 *
 * We don't check whether a slot is set or not.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>selfHasGroup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>,
				<argument><expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_ASSERT_CHECKING */</comment>

<comment type="block">/*
 * Set both the groupId and the group pointer in self.
 *
 * The group must not be dropped.
 *
 * Some over limitations are put to force the caller understand
 * what it's doing and what it wants:
 * - self must has not been set a resgroup;
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selfSetGroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>groupIsNotDropped</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unset both the groupId and the resgroup pointer in self.
 *
 * Some over limitations are put to force the caller understand
 * what it's doing and what it wants:
 * - self must has been set a resgroup;
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selfUnsetGroup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>selfHasGroup</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>selfHasSlot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the slot pointer in self.
 *
 * Some over limitations are put to force the caller understand
 * what it's doing and what it wants:
 * - self must has been set a resgroup;
 * - self must has not been set a slot before set;
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selfSetSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>selfHasGroup</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>selfHasSlot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>slotIsInUse</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unset the slot pointer in self.
 *
 * Some over limitations are put to force the caller understand
 * what it's doing and what it wants:
 * - self must has been set a resgroup;
 * - self must has been set a slot before unset;
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>selfUnsetSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>selfHasGroup</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>selfHasSlot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether proc is in some resgroup's wait queue.
 *
 * The LWLock is not required.
 *
 * This function does not check whether proc is in a specific resgroup's
 * wait queue. To make this check use groupWaitQueueFind().
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>procIsWaiting</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*------
	 * The typical asm instructions fow below C operation can be like this:
	 * ( gcc 4.8.5-11, x86_64-redhat-linux, -O0 )
	 *
     *     mov    -0x8(%rbp),%rax           ; load proc
     *     mov    0x8(%rax),%rax            ; load proc-&gt;links.next
     *     cmp    $0,%rax                   ; compare with NULL
     *     setne  %al                       ; store the result
	 *
	 * The operation is atomic, so a lock is not required here.
	 *------
	 */</comment>
	<return>return <expr><name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Notify a proc it's woken up.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>procWakeup</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetLatch</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>procLatch</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block">/*
 * Validate a slot's attributes.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>slotValidate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* further checks whether the slot is freed or idle */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>nProcs</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>slotIsInFreelist</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>, <argument><expr><name>slot</name> <operator>==</operator> <call><name>sessionGetSlot</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * A slot is in use if it has a valid groupId.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>slotIsInUse</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>slotValidate</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>slotIsInFreelist</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>current</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>current</name> <operator>=</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeSlot</name></name></expr>;</expr_stmt>

	<for>for <control>( <init>;</init> <condition><expr><name>current</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>current</name> <operator>=</operator> <name><name>current</name><operator>-&gt;</operator><name>next</name></name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>current</name> <operator>==</operator> <name>slot</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_ASSERT_CHECKING */</comment>

<comment type="block">/*
 * Get the slot id of the given slot.
 *
 * Return InvalidSlotId if slot is NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>slotGetId</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slotId</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>InvalidSlotId</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>slotId</name> <operator>=</operator> <name>slot</name> <operator>-</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>slots</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotId</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotId</name> <operator>&lt;</operator> <name>RESGROUP_MAX_SLOTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slotId</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>lockResGroupForDrop</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>nRunningBypassed</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>unlockResGroupForDrop</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>nRunningBypassed</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block">/*
 * Check whether a resgroup is dropped.
 *
 * A dropped resgroup has groupId == InvalidOid,
 * however there is also the case that the resgroup is first dropped
 * then the shm struct is reused by another newly created resgroup,
 * in such a case the groupId is not InvalidOid but the original
 * resgroup does is dropped.
 *
 * So this function is not always reliable, use with caution.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>groupIsNotDropped</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>group</name>
		<operator>&amp;&amp;</operator> <name><name>group</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>InvalidOid</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif> <comment type="block">/* USE_ASSERT_CHECKING */</comment>

<comment type="block">/*
 * Validate the consistency of the resgroup wait queue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupWaitQueueValidate</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PROC_QUEUE</name>	<modifier>*</modifier></type><name>waitQueue</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>waitQueue</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>waitProcs</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_resgroup_debug_wait_queue</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name> <operator>||</operator>
				<name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>prev</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"resource group wait queue is corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>nextProc</name> <init>= <expr><operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>prevProc</name> <init>= <expr><operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>nextProc</name><operator>-&gt;</operator><name>mppIsWriter</name></name> <operator>||</operator>
				<operator>!</operator><name><name>prevProc</name><operator>-&gt;</operator><name>mppIsWriter</name></name> <operator>||</operator>
				<name><name>nextProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>prev</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name> <operator>||</operator>
				<name><name>prevProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"resource group wait queue is corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>,
				<argument><expr><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name> <operator>&amp;&amp;</operator>
				<name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>prev</name></name> <operator>==</operator> <operator>&amp;</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupWaitProcValidate</name><parameter_list>(<parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>head</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>nextProc</name> <init>= <expr><operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>prevProc</name> <init>= <expr><operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>prev</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resgroup_debug_wait_queue</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>proc</name><operator>-&gt;</operator><name>mppIsWriter</name></name> <operator>||</operator>
		<operator>(</operator><operator>(</operator><name>PROC_QUEUE</name> <operator>*</operator><operator>)</operator><name>nextProc</name> <operator>!=</operator> <name>head</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>nextProc</name><operator>-&gt;</operator><name>mppIsWriter</name></name><operator>)</operator> <operator>||</operator>
		<operator>(</operator><operator>(</operator><name>PROC_QUEUE</name> <operator>*</operator><operator>)</operator><name>prevProc</name> <operator>!=</operator> <name>head</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>prevProc</name><operator>-&gt;</operator><name>mppIsWriter</name></name><operator>)</operator> <operator>||</operator>
		<name><name>nextProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>prev</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name> <operator>||</operator>
		<name><name>prevProc</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name> <operator>!=</operator> <operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"resource group wait queue is corrupted"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Push a proc to the resgroup wait queue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupWaitQueuePush</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROC_QUEUE</name>			<modifier>*</modifier></type><name>waitQueue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>				<modifier>*</modifier></type><name>headProc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>resSlot</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>groupWaitQueueValidate</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>waitQueue</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>waitProcs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>headProc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SHMQueueInsertBefore</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>headProc</name><operator>-&gt;</operator><name>links</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>groupWaitProcValidate</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>waitQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>groupWaitQueueFind</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Pop the top proc from the resgroup wait queue and return it.
 */</comment>
<function><type><specifier>static</specifier> <name>PGPROC</name> <modifier>*</modifier></type>
<name>groupWaitQueuePop</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROC_QUEUE</name>			<modifier>*</modifier></type><name>waitQueue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>				<modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>groupWaitQueueIsEmpty</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>groupWaitQueueValidate</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>waitQueue</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>waitProcs</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <name><name>waitQueue</name><operator>-&gt;</operator><name>links</name><operator>.</operator><name>next</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>groupWaitProcValidate</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>waitQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>groupWaitQueueFind</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>resSlot</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name><operator>--</operator></expr>;</expr_stmt>

	<return>return <expr><name>proc</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Erase proc from the resgroup wait queue.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupWaitQueueErase</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROC_QUEUE</name>			<modifier>*</modifier></type><name>waitQueue</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>groupWaitQueueIsEmpty</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>groupWaitQueueFind</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>resSlot</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>groupWaitQueueValidate</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>waitQueue</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>waitProcs</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>groupWaitProcValidate</name><argument_list>(<argument><expr><name>proc</name></expr></argument>, <argument><expr><name>waitQueue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SHMQueueDelete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the resgroup wait queue is empty.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>groupWaitQueueIsEmpty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>PROC_QUEUE</name>	<modifier>*</modifier></type><name>waitQueue</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>groupWaitQueueValidate</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>waitQueue</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>waitProcs</name></name></expr>;</expr_stmt>

	<return>return <expr><name><name>waitQueue</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
<comment type="block">/*
 * Find proc in group's wait queue.
 *
 * Return true if found or false if not found.
 *
 * This functions is expensive so should only be used in debugging logic,
 * in most cases procIsWaiting() shall be used.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>groupWaitQueueFind</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PROC_QUEUE</name>			<modifier>*</modifier></type><name>waitQueue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SHM_QUEUE</name>			<modifier>*</modifier></type><name>head</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>PGPROC</name>				<modifier>*</modifier></type><name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>				<name>offset</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>groupWaitQueueValidate</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>waitQueue</name> <operator>=</operator> <operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>waitProcs</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>head</name> <operator>=</operator> <operator>&amp;</operator><name><name>waitQueue</name><operator>-&gt;</operator><name>links</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>offset</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>iter</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><name>head</name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr>;</init> <condition><expr><name>iter</name></expr>;</condition>
		 <incr><expr><name>iter</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator> <call><name>SHMQueueNext</name><argument_list>(<argument><expr><name>head</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>iter</name><operator>-&gt;</operator><name>links</name></name></expr></argument>, <argument><expr><name>offset</name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>iter</name> <operator>==</operator> <name>proc</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif><comment type="block">/* USE_ASSERT_CHECKING */</comment>

<comment type="block">/*
 * Parse the query and check if this query should
 * bypass the management of resource group.
 *
 * Currently, only SET/RESET/SHOW command can be bypassed
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>shouldBypassQuery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_string</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpcontext</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name> <modifier>*</modifier></type><name>parsetree_list</name></decl>;</decl_stmt> 
	<decl_stmt><decl><type><name>ListCell</name> <modifier>*</modifier></type><name>parsetree_item</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name> <modifier>*</modifier></type><name>parsetree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>bypass</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>gp_resource_group_bypass</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>query_string</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Switch to appropriate context for constructing parsetrees.
	 *
	 * It is possible that MessageContext is NULL, for example in a bgworker:
	 *
	 *     debug_query_string = "select 1";
	 *     StartTransactionCommand();
	 *
	 * This is not the recommended order of setting debug_query_string, but we
	 * should not put a constraint on the order by resource group anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MessageContext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>MessageContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Create a temp memory context to prevent memory leaks */</comment>
		<expr_stmt><expr><name>tmpcontext</name> <operator>=</operator> <call><name>AllocSetContextCreate</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name></expr></argument>,
										   <argument><expr><literal type="string">"resgroup temporary context"</literal></expr></argument>,
										   <argument><expr><name>ALLOCSET_DEFAULT_MINSIZE</name></expr></argument>,
										   <argument><expr><name>ALLOCSET_DEFAULT_INITSIZE</name></expr></argument>,
										   <argument><expr><name>ALLOCSET_DEFAULT_MAXSIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>parsetree_list</name> <operator>=</operator> <call><name>pg_parse_query</name><argument_list>(<argument><expr><name>query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>parsetree_list</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Only bypass SET/RESET/SHOW command for now */</comment>
	<expr_stmt><expr><name>bypass</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>parsetree_item</argument>, <argument>parsetree_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>parsetree_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>T_RawStmt</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>parsetree</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RawStmt</name> <operator>*</operator><operator>)</operator><name>parsetree</name><operator>)</operator><operator>-&gt;</operator><name>stmt</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_VariableSetStmt</name> <operator>&amp;&amp;</operator>
			<call><name>nodeTag</name><argument_list>(<argument><expr><name>parsetree</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>T_VariableShowStmt</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>bypass</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>list_free_deep</name><argument_list>(<argument><expr><name>parsetree_list</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tmpcontext</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>MemoryContextDelete</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>bypass</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether the resource group has been dropped.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>groupIsDropped</name><parameter_list>(<parameter><decl><type><name>ResGroupInfo</name> <modifier>*</modifier></type><name>pGroupInfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pGroupInfo</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pGroupInfo</name><operator>-&gt;</operator><name>group</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>pGroupInfo</name><operator>-&gt;</operator><name>group</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name><name>pGroupInfo</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Debug helper functions
 */</comment>
<function><type><name>void</name></type>
<name>ResGroupDumpInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResGroupEnabled</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"{\"segid\":%d,"</literal></expr></argument>, <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* dump fields in pResGroupControl. */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"segmentsOnMaster\":%d,"</literal></expr></argument>, <argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>segmentsOnMaster</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"loaded\":%s,"</literal></expr></argument>, <argument><expr><ternary><condition><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>loaded</name></name></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"totalChunks\":%d,"</literal></expr></argument>, <argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>totalChunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"freeChunks\":%d,"</literal></expr></argument>, <argument><expr><call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"chunkSizeInBits\":%d,"</literal></expr></argument>, <argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>chunkSizeInBits</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/* dump each group */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"groups\":["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>nGroups</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>resgroupDumpGroup</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>groups</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>nGroups</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt> 
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"],"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
	<comment type="block">/* dump slots */</comment>
	<expr_stmt><expr><call><name>resgroupDumpSlots</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* dump freeslot links */</comment>
	<expr_stmt><expr><call><name>resgroupDumpFreeSlots</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> 
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>resgroupDumpGroup</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"group_id\":%u,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"nRunning\":%d,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"nRunningBypassed\":%d,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>nRunningBypassed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"locked_for_drop\":%d,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"memExpected\":%d,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memExpected</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"memQuotaGranted\":%d,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"memSharedGranted\":%d,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"memQuotaUsed\":%d,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"memUsage\":%d,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"memSharedUsage\":%d,"</literal></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>resgroupDumpWaitQueue</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>waitProcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>resgroupDumpCaps</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>ResGroupCap</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>resgroupDumpWaitQueue</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>PROC_QUEUE</name> <modifier>*</modifier></type><name>queue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PGPROC</name> <modifier>*</modifier></type><name>proc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"wait_queue\":{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"wait_queue_size\":%d,"</literal></expr></argument>, <argument><expr><name><name>queue</name><operator>-&gt;</operator><name>size</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"wait_queue_content\":["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator><call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>queue</name><operator>-&gt;</operator><name>links</name></name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name><name>queue</name><operator>-&gt;</operator><name>links</name></name></expr></argument>, 
								  <argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ShmemAddrIsValid</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"]},"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<while>while <condition>(<expr><name>proc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"pid\":%d,"</literal></expr></argument>, <argument><expr><name><name>proc</name><operator>-&gt;</operator><name>pid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"resWaiting\":%s,"</literal></expr></argument>,
						 <argument><expr><ternary><condition><expr><call><name>procIsWaiting</name><argument_list>(<argument><expr><name>proc</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"resSlot\":%d"</literal></expr></argument>, <argument><expr><call><name>slotGetId</name><argument_list>(<argument><expr><name><name>proc</name><operator>-&gt;</operator><name>resSlot</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc</name> <operator>=</operator> <operator>(</operator><name>PGPROC</name> <operator>*</operator><operator>)</operator><call><name>SHMQueueNext</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>queue</name><operator>-&gt;</operator><name>links</name></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name><name>proc</name><operator>-&gt;</operator><name>links</name></name></expr></argument>, 
							<argument><expr><call><name>offsetof</name><argument_list>(<argument><expr><name>PGPROC</name></expr></argument>, <argument><expr><name>links</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>proc</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"]},"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>resgroupDumpCaps</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>, <parameter><decl><type><name>ResGroupCap</name> <modifier>*</modifier></type><name>caps</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>i</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"caps\":["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>RESGROUP_LIMIT_TYPE_COUNT</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"{\"%d\":%d}"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name><name>caps</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>RESGROUP_LIMIT_TYPE_COUNT</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>resgroupDumpSlots</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>               <name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupSlotData</name><modifier>*</modifier></type> <name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"slots\":["</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>RESGROUP_MAX_SLOTS</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><operator>(</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"slotId\":%d,"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"groupId\":%u,"</literal></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"memQuota\":%d,"</literal></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"memUsage\":%d,"</literal></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"nProcs\":%d,"</literal></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>nProcs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"next\":%d,"</literal></expr></argument>, <argument><expr><call><name>slotGetId</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>resgroupDumpCaps</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>(</operator><name>ResGroupCap</name><operator>*</operator><operator>)</operator><operator>(</operator><operator>&amp;</operator><name><name>slot</name><operator>-&gt;</operator><name>caps</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <name>RESGROUP_MAX_SLOTS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>resgroupDumpFreeSlots</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name><modifier>*</modifier></type> <name>head</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name>head</name> <operator>=</operator> <name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeSlot</name></name></expr>;</expr_stmt>
	
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"free_slot_list\":{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"head\":%d"</literal></expr></argument>, <argument><expr><call><name>slotGetId</name><argument_list>(<argument><expr><name>head</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set resource group slot for current session.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sessionSetSlot</name><parameter_list>(<parameter><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>MySessionState</name><operator>-&gt;</operator><name>resGroupSlot</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * SessionStateLock is required since runaway detector will traverse
	 * the current session array and check corresponding resGroupSlot with
	 * shared lock on SessionStateLock.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SessionStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>MySessionState</name><operator>-&gt;</operator><name>resGroupSlot</name></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>slot</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SessionStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Reset resource group slot for current session to NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sessionResetSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * SessionStateLock is required since runaway detector will traverse
	 * the current session array and check corresponding resGroupSlot with
	 * shared lock on SessionStateLock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>MySessionState</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SessionStateLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>MySessionState</name><operator>-&gt;</operator><name>resGroupSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SessionStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get resource group slot of current session.
 */</comment>
<function><type><specifier>static</specifier> <name>ResGroupSlotData</name> <modifier>*</modifier></type>
<name>sessionGetSlot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>MySessionState</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>ResGroupSlotData</name> <operator>*</operator><operator>)</operator> <name><name>MySessionState</name><operator>-&gt;</operator><name>resGroupSlot</name></name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Operation for resource groups with vmtracker memory auditor
 * when alter its memory limit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupMemOnAlterForVmtracker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>shouldNotify</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>shouldNotify</name> <operator>=</operator> <call><name>groupApplyMemCaps</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>wakeupSlots</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>shouldNotify</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>notifyGroupsOnMem</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Operation for resource groups with vmtracker memory auditor
 * when reclaiming its memory back to MEM POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupMemOnDropForVmtracker</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mempoolRelease</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>+</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Operation for resource groups with vmtracker memory auditor
 * when memory in MEM POOL is increased.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupMemOnNotifyForVmtracker</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>			<name>delta</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>lockedForDrop</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>groupWaitQueueIsEmpty</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>delta</name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>memExpected</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>delta</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>wakeupSlots</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Operation for resource groups with vmtracker memory auditor
 * when dump memory statistics.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupMemOnDumpForVmtracker</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"used\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"available\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(
				<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>+</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"quota_used\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"quota_available\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(
				<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"quota_granted\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"quota_proposed\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(
				<argument><expr><call><name>groupGetMemQuotaExpected</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"shared_used\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"shared_available\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(
				<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"shared_granted\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"shared_proposed\":%d"</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(
				<argument><expr><call><name>groupGetMemSharedExpected</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Operation for resource groups with cgroup memory auditor
 * when alter its memory limit.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupMemOnAlterForCgroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If memGap is positive, it indicates this group should
	 * give back these many memory back to MEM POOL.
	 *
	 * If memGap is negative, it indicates this group should
	 * retrieve these many memory from MEM POOL.
	 *
	 * If memGap is zero, this group is holding the same memory
	 * as it expects.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>groupApplyCgroupMemDec</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>groupApplyCgroupMemInc</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Increase a resource group's cgroup memory limit
 *
 * This may not take effect immediately.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupApplyCgroupMemInc</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_MEMORY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>memory_limit_chunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>memory_inc_chunks</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>memory_inc_chunks</name> <operator>=</operator> <call><name>mempoolReserve</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>*</operator> <operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>memory_inc_chunks</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>lockcgroup</name></name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>memory_limit_chunks</name> <operator>=</operator> <call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>getmemorylimitchunks</name></name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setmemorylimitbychunks</name></name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>memory_limit_chunks</name> <operator>+</operator> <name>memory_inc_chunks</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>unlockcgroup</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>+=</operator> <name>memory_inc_chunks</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Decrease a resource group's cgroup memory limit
 *
 * This will take effect immediately for now.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupApplyCgroupMemDec</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CGroupComponentType</name></type> <name>component</name> <init>= <expr><name>CGROUP_COMPONENT_MEMORY</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>memory_limit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>memory_dec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>fd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>lockcgroup</name></name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>component</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>memory_limit</name> <operator>=</operator> <call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>getmemorylimitchunks</name></name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>memory_limit</name> <operator>&gt;</operator> <name><name>group</name><operator>-&gt;</operator><name>memGap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>memory_dec</name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>memGap</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>setmemorylimitbychunks</name></name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>memory_limit</name> <operator>-</operator> <name>memory_dec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>unlockcgroup</name></name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mempoolRelease</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>memory_dec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>notifyGroupsOnMem</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>-=</operator> <name>memory_dec</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Operation for resource groups with cgroup memory auditor
 * when reclaiming its memory back to MEM POOL.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupMemOnDropForCgroup</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>memory_expected</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>memory_expected</name> <operator>=</operator> <call><name>groupGetMemExpected</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>mempoolRelease</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>memory_expected</name> <operator>+</operator> <name><name>group</name><operator>-&gt;</operator><name>memGap</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Operation for resource groups with cgroup memory auditor
 * when memory in MEM POOL is increased.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupMemOnNotifyForCgroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMeInMode</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>memGap</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>groupApplyCgroupMemInc</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Operation for resource groups with cgroup memory auditor
 * when dump memory statistics.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>groupMemOnDumpForCgroup</name><parameter_list>(<parameter><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"{"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"used\":%d, "</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(
					<argument><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>getmemoryusage</name></name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>ResGroupGetHostPrimaryCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"\"limit_granted\":%d"</literal></expr></argument>,
			<argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(
					<argument><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>getmemorylimitchunks</name></name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>ResGroupGetHostPrimaryCount</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Parse cpuset to bitset
 * If cpuset is "1,3-5", Bitmapset 1,3,4,5 are set.
 */</comment>
<function><type><name>Bitmapset</name> <modifier>*</modifier></type>
<name>CpusetToBitset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpuset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>num1</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>num2</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<enum>enum <name>Status</name>
	<block>{
		<decl><name>Initial</name></decl>,
		<decl><name>Begin</name></decl>,
		<decl><name>Number</name></decl>,
		<decl><name>Interval</name></decl>,
		<decl><name>Number2</name></decl>
	}</block>;</enum>
	<decl_stmt><decl><type><name><name>enum</name> <name>Status</name></name></type>	<name>s</name> <init>= <expr><name>Initial</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Bitmapset</name>	<modifier>*</modifier></type><name>bms</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>cpuset</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>bms</name></expr>;</return></block_content></block></if></if_stmt>
	<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>len</name> <operator>&amp;&amp;</operator> <name><name>cpuset</name><index>[<expr><name>pos</name></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type> <name>c</name> <init>= <expr><name><name>cpuset</name><index>[<expr><name>pos</name><operator>++</operator></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>Initial</name> <operator>||</operator> <name>s</name> <operator>==</operator> <name>Begin</name></expr>)</condition>
			<block>{<block_content>
				<continue>continue;</continue>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <name>Interval</name></expr>)</condition>
			<block>{<block_content>
				<goto>goto <name>error_logic</name>;</goto>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <name>Number</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>bms</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>num1</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>Begin</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <name>Number2</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>num1</name> <operator>&gt;</operator> <name>num2</name></expr>)</condition>
				<block>{<block_content>
					<goto>goto <name>error_logic</name>;</goto>
				</block_content>}</block></if></if_stmt>
				<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>num1</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num2</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>bms</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></for>
				<expr_stmt><expr><name>num1</name> <operator>=</operator> <name>num2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>Begin</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>!=</operator> <name>Number</name></expr>)</condition>
			<block>{<block_content>
				<goto>goto <name>error_logic</name>;</goto>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>s</name> <operator>=</operator> <name>Interval</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>Initial</name> <operator>||</operator> <name>s</name> <operator>==</operator> <name>Begin</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>Number</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <name>Interval</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>s</name> <operator>=</operator> <name>Number2</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>Number</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>num1</name> <operator>=</operator> <name>num1</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <name>Number2</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>num2</name> <operator>=</operator> <name>num2</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><name>c</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<goto>goto <name>error_logic</name>;</goto>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>s</name> <operator>==</operator> <name>Number</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bms</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>num1</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <name>Number2</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>num1</name> <operator>&gt;</operator> <name>num2</name></expr>)</condition>
		<block>{<block_content>
			<goto>goto <name>error_logic</name>;</goto>
		</block_content>}</block></if></if_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>num1</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>num2</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>bms</name> <operator>=</operator> <call><name>bms_union</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><call><name>bms_make_singleton</name><argument_list>(<argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>s</name> <operator>==</operator> <name>Initial</name> <operator>||</operator> <name>s</name> <operator>==</operator> <name>Interval</name></expr>)</condition>
	<block>{<block_content>
		<goto>goto <name>error_logic</name>;</goto>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>bms</name></expr>;</return>
<label><name>error_logic</name>:</label>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check the value of cpuset is empty or not
 */</comment>
<function><type><name>bool</name></type> <name>CpusetIsEmpty</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpuset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>strcmp</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>DefaultCpuset</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set cpuset value to default value -1.
 */</comment>
<function><type><name>void</name></type> <name>SetCpusetEmpty</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cpusetSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>DefaultCpuset</name></expr></argument>, <argument><expr><name>cpusetSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transform non-empty bitset to cpuset.
 *
 * This function does not check the cpu cores are available or not.
 */</comment>
<function><type><name>void</name></type>
<name>BitsetToCpuset</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Bitmapset</name> <modifier>*</modifier></type><name>bms</name></decl></parameter>,
			   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>cpusetSize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>lastContinuousBit</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>	<name>intervalStart</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>buffer</name><index>[<expr><literal type="number">32</literal></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>bms</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>cpuset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>num</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>bms</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lastContinuousBit</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>intervalStart</name> <operator>=</operator> <name>lastContinuousBit</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>num</name> <operator>!=</operator> <name>lastContinuousBit</name> <operator>+</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>intervalStart</name> <operator>==</operator> <name>lastContinuousBit</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d,"</literal></expr></argument>, <argument><expr><name>intervalStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d-%d,"</literal></expr></argument>, <argument><expr><name>intervalStart</name></expr></argument>, <argument><expr><name>lastContinuousBit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>cpusetSize</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cpuset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return ;</return>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>cpuset</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>intervalStart</name> <operator>=</operator> <name>lastContinuousBit</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>lastContinuousBit</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>
	<if_stmt><if>if <condition>(<expr><name>intervalStart</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>intervalStart</name> <operator>==</operator> <name>lastContinuousBit</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>intervalStart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d-%d"</literal></expr></argument>, <argument><expr><name>intervalStart</name></expr></argument>, <argument><expr><name>lastContinuousBit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <name>cpusetSize</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>cpuset</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return ;</return>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>cpuset</name> <operator>+</operator> <name>len</name></expr></argument>, <argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* bms is non-empty, so it should never reach here */</comment>
		<expr_stmt><expr><call><name>pg_unreachable</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * calculate the result of cpuset1 plus/minus cpuset2 and save in place
 * if sub is true, the operation is minus
 * if sub is false, the operation is plus
 */</comment>
<function><type><name>void</name></type>
<name>cpusetOperation</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpuset2</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>sub</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type> <name><name>cpuset</name><index>[<expr><name>MaxCpuSetLength</name></expr>]</index></name> <init>= <expr><block>{<expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>defaultCore</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bms1</name> <init>= <expr><call><name>CpusetToBitset</name><argument_list>(<argument><expr><name>cpuset1</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bms2</name> <init>= <expr><call><name>CpusetToBitset</name><argument_list>(<argument><expr><name>cpuset2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sub</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bms1</name> <operator>=</operator> <call><name>bms_del_members</name><argument_list>(<argument><expr><name>bms1</name></expr></argument>, <argument><expr><name>bms2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>bms1</name> <operator>=</operator> <call><name>bms_add_members</name><argument_list>(<argument><expr><name>bms1</name></expr></argument>, <argument><expr><name>bms2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_empty</name><argument_list>(<argument><expr><name>bms1</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>BitsetToCpuset</name><argument_list>(<argument><expr><name>bms1</name></expr></argument>, <argument><expr><name>cpuset1</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Get cpuset from cpuset/gpdb, and transform it into bitset */</comment>
		<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>getcpuset</name></name><argument_list>(<argument><expr><name>CGROUP_ROOT_ID</name></expr></argument>, <argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name> <modifier>*</modifier></type><name>bmsDefault</name> <init>= <expr><call><name>CpusetToBitset</name><argument_list>(<argument><expr><name>cpuset</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<comment type="block">/* get the minimum core number, in case of the zero core is not exist */</comment>
		<expr_stmt><expr><name>defaultCore</name> <operator>=</operator> <call><name>bms_next_member</name><argument_list>(<argument><expr><name>bmsDefault</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>defaultCore</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cpuset1</name></expr></argument>, <argument><expr><name>MaxCpuSetLength</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>defaultCore</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * union cpuset2 to cpuset1
 */</comment>
<function><type><name>void</name></type>
<name>CpusetUnion</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpuset2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>cpusetOperation</name><argument_list>(<argument><expr><name>cpuset1</name></expr></argument>, <argument><expr><name>cpuset2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * subtract cpuset2 from cpuset1
 */</comment>
<function><type><name>void</name></type>
<name>CpusetDifference</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>cpuset1</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>cpuset2</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>cpusetOperation</name><argument_list>(<argument><expr><name>cpuset1</name></expr></argument>, <argument><expr><name>cpuset2</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ensure that cpuset is available.
 */</comment>
<function><type><name>bool</name></type>
<name>EnsureCpusetIsAvailable</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsResGroupActivated</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"resource group must be enabled to use cpuset feature"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>gp_resource_group_enable_cgroup_cpuset</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cgroup is not properly configured to use the cpuset feature"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Extra cgroup configurations are required to enable this feature, "</literal>
						 <literal type="string">"please refer to the Greenplum Documentations for details"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether current resource group's memory usage is in RedZone.
 */</comment>
<function><type><name>bool</name></type>
<name>IsGroupInRedZone</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>				<name>remainGlobalSharedMem</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>				<name>safeChunksThreshold100</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * IsGroupInRedZone is called frequently, we should put the
	 * condition which returns with higher probability in front.
	 * 
	 * safe: global shared memory is not in redzone
	 */</comment>
	<expr_stmt><expr><name>remainGlobalSharedMem</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>safeChunksThreshold100</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>safeChunksThreshold100</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>remainGlobalSharedMem</name> <operator>*</operator> <literal type="number">100</literal> <operator>&gt;=</operator> <name>safeChunksThreshold100</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>, <argument><expr><name>group</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>slot</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* safe: slot memory is not used up */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name> <operator>&gt;</operator> <name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* safe: group shared memory is not in redzone */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>&gt;</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* memory usage in this group is in RedZone */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/*
 * Dump memory information for current resource group.
 * This is the output of resource group runaway.
 */</comment>
<function><type><name>void</name></type>
<name>ResGroupGetMemoryRunawayInfo</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>slot</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>slot</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name>		<modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>self</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>				<name>remainGlobalSharedMem</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>				<name>safeChunksThreshold100</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>group</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>remainGlobalSharedMem</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>safeChunksThreshold100</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>safeChunksThreshold100</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
						 <argument><expr><literal type="string">"current group id is %u, "</literal>
						 <literal type="string">"group memory usage %d MB, "</literal>
						 <literal type="string">"group shared memory quota is %d MB, "</literal>
						 <literal type="string">"slot memory quota is %d MB, "</literal>
						 <literal type="string">"global freechunks memory is %u MB, "</literal>
						 <literal type="string">"global safe memory threshold is %u MB"</literal></expr></argument>,
						 <argument><expr><name><name>group</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>,
						 <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name>remainGlobalSharedMem</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name>safeChunksThreshold100</name> <operator>/</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>str</name></expr></argument>,
						 <argument><expr><literal type="string">"Resource group memory information: "</literal>
						 <literal type="string">"memory usage in current proc is %d MB"</literal></expr></argument>,
						 <argument><expr><call><name>VmemTracker_ConvertVmemChunksToMB</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>memUsage</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return group id for a session
 */</comment>
<function><type><name>Oid</name></type>
<name>SessionGetResGroupId</name><parameter_list>(<parameter><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>sessionSlot</name> <init>= <expr><operator>(</operator><name>ResGroupSlotData</name> <operator>*</operator><operator>)</operator><name><name>session</name><operator>-&gt;</operator><name>resGroupSlot</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sessionSlot</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>sessionSlot</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>InvalidOid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Return group global share memory for a session
 */</comment>
<function><type><name>int32</name></type>
<name>SessionGetResGroupGlobalShareMemUsage</name><parameter_list>(<parameter><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>session</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name>	<modifier>*</modifier></type><name>sessionSlot</name> <init>= <expr><operator>(</operator><name>ResGroupSlotData</name> <operator>*</operator><operator>)</operator><name><name>session</name><operator>-&gt;</operator><name>resGroupSlot</name></name></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>sessionSlot</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* lock not needed here, we just need esimated result */</comment>
		<decl_stmt><decl><type><name>ResGroupData</name>	<modifier>*</modifier></type><name>group</name> <init>= <expr><name><name>sessionSlot</name><operator>-&gt;</operator><name>group</name></name></expr></init></decl>;</decl_stmt>
		<return>return <expr><name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* session doesnot have group slot */</comment>
		<return>return <expr><literal type="number">0</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * move a proc to a resource group
 */</comment>
<function><type><name>void</name></type>
<name>HandleMoveResourceGroup</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>oldGroup</name></decl>;</decl_stmt>

	<comment type="block">/* transaction has finished */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>(</operator><name>ResGroupSlotData</name> <operator>*</operator><operator>)</operator><name><name>MyProc</name><operator>-&gt;</operator><name>movetoResSlot</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>group</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>group</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>movetoResSlot</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<comment type="block">/* unassign the old resource group and release the old slot */</comment>
		<expr_stmt><expr><call><name>UnassignResGroup</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>sessionSetSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Add proc memory accounting info into group and slot */</comment>
			<expr_stmt><expr><call><name>selfAttachResGroup</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Init self */</comment>
			<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>caps</name></name></expr>;</expr_stmt>

			<comment type="block">/* Add into cgroup */</comment>
			<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>attachcgroup</name></name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>,
										  <argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name> <operator>==</operator> <name>CPU_RATE_LIMIT_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<block>{<block_content>
			<expr_stmt><expr><call><name>UnassignResGroup</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pgstat_report_resgroup</name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type> <name>groupId</name> <init>= <expr><name><name>MyProc</name><operator>-&gt;</operator><name>movetoGroupId</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>movetoGroupId</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>sessionGetSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>selfUnsetSlot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>selfUnsetGroup</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>oldGroup</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>group</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>group</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>oldGroup</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * move the slot memory to the new group, only do it once
		 * if there're more than once slice.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name> <operator>!=</operator> <name>groupId</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* deduct the slot memory from the old group */</comment>
			<expr_stmt><expr><call><name>groupDecSlotMemUsage</name><argument_list>(<argument><expr><name>oldGroup</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oldGroup</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>-=</operator> <name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>oldGroup</name><operator>-&gt;</operator><name>nRunning</name></name><operator>--</operator></expr>;</expr_stmt>

			<comment type="block">/* reset the slot but don't touch the 'memUsage' */</comment>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name> <operator>=</operator> <name>groupId</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>group</name></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>caps</name></name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name> <operator>=</operator> <call><name>slotGetMemQuotaOnQE</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr></argument>, <argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* add the slot memory to the new group */</comment>
			<expr_stmt><expr><call><name>mempoolAutoReserve</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>groupIncSlotMemUsage</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>+=</operator> <name><name>slot</name><operator>-&gt;</operator><name>memQuota</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>group</name><operator>-&gt;</operator><name>nRunning</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>group</name><operator>-&gt;</operator><name>memQuotaUsed</name></name> <operator>&lt;=</operator> <name><name>group</name><operator>-&gt;</operator><name>memQuotaGranted</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* add the memory of entryDB to slot and group */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>selfAttachResGroup</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>selfSetGroup</name><argument_list>(<argument><expr><name>group</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>selfSetSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name></name> <operator>=</operator> <name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr>;</expr_stmt>

		<comment type="block">/* finally we can say we are in a valid resgroup */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>selfIsAssigned</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Add into cgroup */</comment>
		<expr_stmt><expr><call><name><name>cgroupOpsRoutine</name><operator>-&gt;</operator><name>attachcgroup</name></name><argument_list>(<argument><expr><name><name>self</name><operator>-&gt;</operator><name>groupId</name></name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>,
									  <argument><expr><name><name>self</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>cpuRateLimit</name></name> <operator>==</operator> <name>CPU_RATE_LIMIT_DISABLED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>hasEnoughMemory</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>memUsed</name></decl></parameter>, <parameter><decl><type><name>int32</name></type> <name>availMem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name>memUsed</name> <operator>&lt;</operator> <name>availMem</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check if there are enough memory to move the query to the destination group
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>moveQueryCheck</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sessionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CdbPgResults</name></type> <name>cdb_pgresults</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>sessionMem</name> <init>= <expr><call><name>ResGroupGetSessionMemUsage</name><argument_list>(<argument><expr><name>sessionId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type> <name>availMem</name> <init>= <expr><call><name>ResGroupGetGroupAvailableMem</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>sessionMem</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"the process to move has ended"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasEnoughMemory</name><argument_list>(<argument><expr><name>sessionMem</name></expr></argument>, <argument><expr><name>availMem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group %d doesn't have enough memory on master, expect:%d, available:%d"</literal></expr></argument>, <argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>sessionMem</name></expr></argument>, <argument><expr><name>availMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT session_mem, available_mem from pg_resgroup_check_move_query(%d, %d)"</literal></expr></argument>, <argument><expr><name>sessionId</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CdbDispatchCommand</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>DF_WITH_SNAPSHOT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>cdb_pgresults</name><operator>.</operator><name>numResults</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>i_session_mem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>i_available_mem</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name><name>struct</name> <name>pg_result</name></name> <modifier>*</modifier></type><name>pgresult</name> <init>= <expr><name><name>cdb_pgresults</name><operator>.</operator><name>pg_results</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>PGRES_TUPLES_OK</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"pg_resgroup_check_move_query: resultStatus not tuples_Ok: %s %s"</literal></expr></argument>,
				 <argument><expr><call><name>PQresStatus</name><argument_list>(<argument><expr><call><name>PQresultStatus</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>PQresultErrorMessage</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>PQntuples</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_session_mem</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><literal type="string">"session_mem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i_available_mem</name> <operator>=</operator> <call><name>PQfnumber</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><literal type="string">"available_mem"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_session_mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><call><name>PQgetisnull</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_available_mem</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sessionMem</name> <operator>=</operator> <call><name>pg_atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_session_mem</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>availMem</name> <operator>=</operator> <call><name>pg_atoi</name><argument_list>(<argument><expr><call><name>PQgetvalue</name><argument_list>(<argument><expr><name>pgresult</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>i_available_mem</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int32</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>sessionMem</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>hasEnoughMemory</name><argument_list>(<argument><expr><name>sessionMem</name></expr></argument>, <argument><expr><name>availMem</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"group %d doesn't have enough memory on segment, expect:%d, available:%d"</literal></expr></argument>, <argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>sessionMem</name></expr></argument>, <argument><expr><name>availMem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>cdbdisp_clearCdbPgResults</name><argument_list>(<argument><expr><operator>&amp;</operator><name>cdb_pgresults</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>ResGroupMoveQuery</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sessionId</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>groupName</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupInfo</name></type> <name>groupInfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>cmd</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>pResGroupControl</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pResGroupControl</name><operator>-&gt;</operator><name>segmentsOnMaster</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>group</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNDEFINED_OBJECT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid resource group id: %d"</literal></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>groupInfo</name><operator>.</operator><name>group</name></name> <operator>=</operator> <name>group</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>groupInfo</name><operator>.</operator><name>groupId</name></name> <operator>=</operator> <name>groupId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>groupAcquireSlot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>groupInfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot get slot in resource group %d"</literal></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>moveQueryCheck</name><argument_list>(<argument><expr><name>sessionId</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ResGroupSignalMoveQuery</name><argument_list>(<argument><expr><name>sessionId</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>groupId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>cmd</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"SELECT pg_resgroup_move_query(%d, %s)"</literal></expr></argument>,
				<argument><expr><name>sessionId</name></expr></argument>,
				<argument><expr><call><name>quote_literal_cstr</name><argument_list>(<argument><expr><name>groupName</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CdbDispatchCommand</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_CATCH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>groupReleaseSlot</name><argument_list>(<argument><expr><name>group</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>PG_END_TRY</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<comment type="block">/*
 * get resource group id by session id
 */</comment>
<function><type><name>Oid</name></type>
<name>ResGroupGetGroupIdBySessionId</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sessionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type> <name>groupId</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>curSessionState</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SessionStateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curSessionState</name> <operator>=</operator> <name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>curSessionState</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>curSessionState</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>==</operator> <name>sessionId</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>(</operator><name>ResGroupSlotData</name> <operator>*</operator><operator>)</operator><name><name>curSessionState</name><operator>-&gt;</operator><name>resGroupSlot</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>groupId</name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>groupId</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>curSessionState</name> <operator>=</operator> <name><name>curSessionState</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SessionStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>groupId</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get the memory usage of a session on one segment
 */</comment>
<function><type><name>int32</name></type>
<name>ResGroupGetSessionMemUsage</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sessionId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type> <name>memUsage</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SessionState</name> <modifier>*</modifier></type><name>curSessionState</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SessionStateLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>curSessionState</name> <operator>=</operator> <name><name>AllSessionStateEntries</name><operator>-&gt;</operator><name>usedList</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>curSessionState</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>curSessionState</name><operator>-&gt;</operator><name>sessionId</name></name> <operator>==</operator> <name>sessionId</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ResGroupSlotData</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><operator>(</operator><name>ResGroupSlotData</name> <operator>*</operator><operator>)</operator><name><name>curSessionState</name><operator>-&gt;</operator><name>resGroupSlot</name></name></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><name>memUsage</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>slot</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><name><name>slot</name><operator>-&gt;</operator><name>memUsage</name></name></expr></else></ternary></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>curSessionState</name> <operator>=</operator> <name><name>curSessionState</name><operator>-&gt;</operator><name>next</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SessionStateLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>memUsage</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get the memory available in one resource group
 */</comment>
<function><type><name>int32</name></type>
<name>ResGroupGetGroupAvailableMem</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>groupId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResGroupData</name> <modifier>*</modifier></type><name>group</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>availMem</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>group</name> <operator>=</operator> <call><name>groupHashFind</name><argument_list>(<argument><expr><name>groupId</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>group</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>group</name><operator>-&gt;</operator><name>caps</name><operator>.</operator><name>memLimit</name></name> <operator>==</operator> <name>RESGROUP_UNLIMITED_MEMORY_LIMIT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>availMem</name> <operator>=</operator> <operator>(</operator><name>uint32</name><operator>)</operator> <call><name>pg_atomic_read_u32</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>pResGroupControl</name><operator>-&gt;</operator><name>freeChunks</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>availMem</name> <operator>=</operator> <call><name>slotGetMemQuotaExpected</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>group</name><operator>-&gt;</operator><name>caps</name></name></expr></argument>)</argument_list></call> <operator>+</operator>
				   <name><name>group</name><operator>-&gt;</operator><name>memSharedGranted</name></name> <operator>-</operator> <name><name>group</name><operator>-&gt;</operator><name>memSharedUsage</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>ResGroupLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>availMem</name></expr>;</return>
</block_content>}</block></function>
</unit>
