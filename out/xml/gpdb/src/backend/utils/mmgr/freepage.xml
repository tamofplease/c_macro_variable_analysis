<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/mmgr/freepage.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * freepage.c
 *	  Management of free memory pages.
 *
 * The intention of this code is to provide infrastructure for memory
 * allocators written specifically for PostgreSQL.  At least in the case
 * of dynamic shared memory, we can't simply use malloc() or even
 * relatively thin wrappers like palloc() which sit on top of it, because
 * no allocator built into the operating system will deal with relative
 * pointers.  In the future, we may find other cases in which greater
 * control over our own memory management seems desirable.
 *
 * A FreePageManager keeps track of which 4kB pages of memory are currently
 * unused from the point of view of some higher-level memory allocator.
 * Unlike a user-facing allocator such as palloc(), a FreePageManager can
 * only allocate and free in units of whole pages, and freeing an
 * allocation can only be done given knowledge of its length in pages.
 *
 * Since a free page manager has only a fixed amount of dedicated memory,
 * and since there is no underlying allocator, it uses the free pages
 * it is given to manage to store its bookkeeping data.  It keeps multiple
 * freelists of runs of pages, sorted by the size of the run; the head of
 * each freelist is stored in the FreePageManager itself, and the first
 * page of each run contains a relative pointer to the next run. See
 * FreePageManagerGetInternal for more details on how the freelists are
 * managed.
 *
 * To avoid memory fragmentation, it's important to consolidate adjacent
 * spans of pages whenever possible; otherwise, large allocation requests
 * might not be satisfied even when sufficient contiguous space is
 * available.  Therefore, in addition to the freelists, we maintain an
 * in-memory btree of free page ranges ordered by page number.  If a
 * range being freed precedes or follows a range that is already free,
 * the existing range is extended; if it exactly bridges the gap between
 * free ranges, then the two existing ranges are consolidated with the
 * newly-freed range to form one great big range of free pages.
 *
 * When there is only one range of free pages, the btree is trivial and
 * is stored within the FreePageManager proper; otherwise, pages are
 * allocated from the area under management as needed.  Even in cases
 * where memory fragmentation is very severe, only a tiny fraction of
 * the pages under management are consumed by this btree.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/mmgr/freepage.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/freepage.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/relptr.h"</cpp:file></cpp:include>


<comment type="block">/* Magic numbers to identify various page types */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_PAGE_SPAN_LEADER_MAGIC</name></cpp:macro>		<cpp:value>0xea4020f0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_PAGE_LEAF_MAGIC</name></cpp:macro>			<cpp:value>0x98eae728</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FREE_PAGE_INTERNAL_MAGIC</name></cpp:macro>		<cpp:value>0x19aa32c9</cpp:value></cpp:define>

<comment type="block">/* Doubly linked list of spans of free pages; stored in first page of span. */</comment>
<struct>struct <name>FreePageSpanLeader</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>magic</name></decl>;</decl_stmt>			<comment type="block">/* always FREE_PAGE_SPAN_LEADER_MAGIC */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>npages</name></decl>;</decl_stmt>			<comment type="block">/* number of pages in span */</comment>
	<decl_stmt><decl><type><name>RelptrFreePageSpanLeader</name></type> <name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelptrFreePageSpanLeader</name></type> <name>next</name></decl>;</decl_stmt>
}</block>;</struct>

<comment type="block">/* Common header for btree leaf and internal pages. */</comment>
<typedef>typedef <type><struct>struct <name>FreePageBtreeHeader</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>magic</name></decl>;</decl_stmt>			<comment type="block">/* FREE_PAGE_LEAF_MAGIC or
								 * FREE_PAGE_INTERNAL_MAGIC */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nused</name></decl>;</decl_stmt>			<comment type="block">/* number of items used */</comment>
	<decl_stmt><decl><type><name>RelptrFreePageBtree</name></type> <name>parent</name></decl>;</decl_stmt> <comment type="block">/* uplink */</comment>
}</block></struct></type> <name>FreePageBtreeHeader</name>;</typedef>

<comment type="block">/* Internal key; points to next level of btree. */</comment>
<typedef>typedef <type><struct>struct <name>FreePageBtreeInternalKey</name>
<block>{
	<decl_stmt><decl><type><name>Size</name></type>		<name>first_page</name></decl>;</decl_stmt>		<comment type="block">/* low bound for keys on child page */</comment>
	<decl_stmt><decl><type><name>RelptrFreePageBtree</name></type> <name>child</name></decl>;</decl_stmt>	<comment type="block">/* downlink */</comment>
}</block></struct></type> <name>FreePageBtreeInternalKey</name>;</typedef>

<comment type="block">/* Leaf key; no payload data. */</comment>
<typedef>typedef <type><struct>struct <name>FreePageBtreeLeafKey</name>
<block>{
	<decl_stmt><decl><type><name>Size</name></type>		<name>first_page</name></decl>;</decl_stmt>		<comment type="block">/* first page in span */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>npages</name></decl>;</decl_stmt>			<comment type="block">/* number of pages in span */</comment>
}</block></struct></type> <name>FreePageBtreeLeafKey</name>;</typedef>

<comment type="block">/* Work out how many keys will fit on a page. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FPM_ITEMS_PER_INTERNAL_PAGE</name></cpp:macro> \
	<cpp:value>((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \
		sizeof(FreePageBtreeInternalKey))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FPM_ITEMS_PER_LEAF_PAGE</name></cpp:macro> \
	<cpp:value>((FPM_PAGE_SIZE - sizeof(FreePageBtreeHeader)) / \
		sizeof(FreePageBtreeLeafKey))</cpp:value></cpp:define>

<comment type="block">/* A btree page of either sort */</comment>
<struct>struct <name>FreePageBtree</name>
<block>{
	<decl_stmt><decl><type><name>FreePageBtreeHeader</name></type> <name>hdr</name></decl>;</decl_stmt>
	<union>union
	<block>{
		<decl_stmt><decl><type><name>FreePageBtreeInternalKey</name></type> <name><name>internal_key</name><index>[<expr><name>FPM_ITEMS_PER_INTERNAL_PAGE</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FreePageBtreeLeafKey</name></type> <name><name>leaf_key</name><index>[<expr><name>FPM_ITEMS_PER_LEAF_PAGE</name></expr>]</index></name></decl>;</decl_stmt>
	}</block>			<decl><name>u</name></decl>;</union>
}</block>;</struct>

<comment type="block">/* Results of a btree search */</comment>
<typedef>typedef <type><struct>struct <name>FreePageBtreeSearchResult</name>
<block>{
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name></type>	<name>split_pages</name></decl>;</decl_stmt>
}</block></struct></type> <name>FreePageBtreeSearchResult</name>;</typedef>

<comment type="block">/* Helper functions */</comment>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageBtreeAdjustAncestorKeys</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>,
											<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>FreePageBtreeCleanup</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FreePageBtree</name> <modifier>*</modifier></type><name>FreePageBtreeFindLeftSibling</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
												   <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FreePageBtree</name> <modifier>*</modifier></type><name>FreePageBtreeFindRightSibling</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>,
													<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>FreePageBtreeFirstKey</name><parameter_list>(<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FreePageBtree</name> <modifier>*</modifier></type><name>FreePageBtreeGetRecycled</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageBtreeInsertInternal</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>,
										<parameter><decl><type><name>Size</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageBtreeInsertLeaf</name><parameter_list>(<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>index</name></decl></parameter>,
									<parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageBtreeRecycle</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageBtreeRemove</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>,
								<parameter><decl><type><name>Size</name></type> <name>index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageBtreeRemovePage</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageBtreeSearch</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>,
								<parameter><decl><type><name>FreePageBtreeSearchResult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>FreePageBtreeSearchInternal</name><parameter_list>(<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>FreePageBtreeSearchLeaf</name><parameter_list>(<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FreePageBtree</name> <modifier>*</modifier></type><name>FreePageBtreeSplitPage</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>,
											 <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageBtreeUpdateParentPointers</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageManagerDumpBtree</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>,
									 <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageManagerDumpSpans</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>,
									 <parameter><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>span</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>expected_pages</name></decl></parameter>,
									 <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>FreePageManagerGetInternal</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>,
									   <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>first_page</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>FreePageManagerPutInternal</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>,
									   <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>soft</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePagePopSpanLeader</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>pageno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePagePushSpanLeader</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>,
								   <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>FreePageManagerLargestContiguous</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>FreePageManagerUpdateLargest</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>FPM_EXTRA_ASSERTS</name></expr></cpp:if>
<function_decl><type><specifier>static</specifier> <name>Size</name></type> <name>sum_free_pages</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Initialize a new, empty free page manager.
 *
 * 'fpm' should reference caller-provided memory large enough to contain a
 * FreePageManager.  We'll initialize it here.
 *
 * 'base' is the address to which all pointers are relative.  When managing
 * a dynamic shared memory segment, it should normally be the base of the
 * segment.  When managing backend-private memory, it can be either NULL or,
 * if managing a single contiguous extent of memory, the start of that extent.
 */</comment>
<function><type><name>void</name></type>
<name>FreePageManagerInitialize</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>f</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>self</name></name></expr></argument>, <argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FreePageBtree</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FreePageSpanLeader</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle_count</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages_dirty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FPM_EXTRA_ASSERTS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>FPM_NUM_FREELISTS</name></expr>;</condition> <incr><expr><name>f</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><operator>(</operator><name>FreePageSpanLeader</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a run of pages of the given length from the free page manager.
 * The return value indicates whether we were able to satisfy the request;
 * if true, the first page of the allocation is stored in *first_page.
 */</comment>
<function><type><name>bool</name></type>
<name>FreePageManagerGet</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>first_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>contiguous_pages</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>FreePageManagerGetInternal</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * It's a bit counterintuitive, but allocating pages can actually create
	 * opportunities for cleanup that create larger ranges.  We might pull a
	 * key out of the btree that enables the item at the head of the btree
	 * recycle list to be inserted; and then if there are more items behind it
	 * one of those might cause two currently-separated ranges to merge,
	 * creating a single range of contiguous pages larger than any that
	 * existed previously.  It might be worth trying to improve the cleanup
	 * algorithm to avoid such corner cases, but for now we just notice the
	 * condition and do the appropriate reporting.
	 */</comment>
	<expr_stmt><expr><name>contiguous_pages</name> <operator>=</operator> <call><name>FreePageBtreeCleanup</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name> <operator>&lt;</operator> <name>contiguous_pages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name> <operator>=</operator> <name>contiguous_pages</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * FreePageManagerGetInternal may have set contiguous_pages_dirty.
	 * Recompute contiguous_pages if so.
	 */</comment>
	<expr_stmt><expr><call><name>FreePageManagerUpdateLargest</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FPM_EXTRA_ASSERTS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><name>result</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>&gt;=</operator> <name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>-=</operator> <name>npages</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>==</operator> <call><name>sum_free_pages</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name> <operator>==</operator> <call><name>FreePageManagerLargestContiguous</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FPM_EXTRA_ASSERTS</name></cpp:ifdef>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sum_free_pages_recurse</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>sum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name> <operator>||</operator>
		   <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>++</operator><operator>*</operator><name>sum</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>


		<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>index</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sum_free_pages_recurse</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>sum_free_pages</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>recycle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>sum</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>list</name></decl>;</decl_stmt>

	<comment type="block">/* Count the spans by scanning the freelists. */</comment>
	<for>for <control>(<init><expr><name>list</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>list</name> <operator>&lt;</operator> <name>FPM_NUM_FREELISTS</name></expr>;</condition> <incr><expr><operator>++</operator><name>list</name></expr></incr>)</control>
	<block>{<block_content>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>relptr_is_null</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>list</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>candidate</name> <init>=
			<expr><call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>list</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name>sum</name> <operator>+=</operator> <name><name>candidate</name><operator>-&gt;</operator><name>npages</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>candidate</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>candidate</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><name>candidate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Count btree internal pages. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>sum_free_pages_recurse</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Count the recycle list. */</comment>
	<for>for <control>(<init><expr><name>recycle</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle</name></name></expr></argument>)</argument_list></call></expr>;</init>
		 <condition><expr><name>recycle</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>recycle</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>recycle</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>recycle</name><operator>-&gt;</operator><name>npages</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>sum</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>sum</name></expr>;</return>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/*
 * Compute the size of the largest run of pages that the user could
 * successfully get.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>FreePageManagerLargestContiguous</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>largest</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>base</name> <operator>=</operator> <call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>largest</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>relptr_is_null</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>FPM_NUM_FREELISTS</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>candidate</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>candidate</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>FPM_NUM_FREELISTS</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>candidate</name><operator>-&gt;</operator><name>npages</name></name> <operator>&gt;</operator> <name>largest</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>largest</name> <operator>=</operator> <name><name>candidate</name><operator>-&gt;</operator><name>npages</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>candidate</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>candidate</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>candidate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>f</name> <init>= <expr><name>FPM_NUM_FREELISTS</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<expr_stmt><expr><operator>--</operator><name>f</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>relptr_is_null</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>largest</name> <operator>=</operator> <name>f</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block> while <condition>(<expr><name>f</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>;</do>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>largest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recompute the size of the largest run of pages that the user could
 * successfully get, if it has been marked dirty.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageManagerUpdateLargest</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages_dirty</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name> <operator>=</operator> <call><name>FreePageManagerLargestContiguous</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages_dirty</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Transfer a run of pages to the free page manager.
 */</comment>
<function><type><name>void</name></type>
<name>FreePageManagerPut</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>contiguous_pages</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Record the new pages. */</comment>
	<expr_stmt><expr><name>contiguous_pages</name> <operator>=</operator>
		<call><name>FreePageManagerPutInternal</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the new range we inserted into the page manager was contiguous with
	 * an existing range, it may have opened up cleanup opportunities.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>contiguous_pages</name> <operator>&gt;</operator> <name>npages</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>cleanup_contiguous_pages</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>cleanup_contiguous_pages</name> <operator>=</operator> <call><name>FreePageBtreeCleanup</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>cleanup_contiguous_pages</name> <operator>&gt;</operator> <name>contiguous_pages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>contiguous_pages</name> <operator>=</operator> <name>cleanup_contiguous_pages</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* See if we now have a new largest chunk. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name> <operator>&lt;</operator> <name>contiguous_pages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name> <operator>=</operator> <name>contiguous_pages</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * The earlier call to FreePageManagerPutInternal may have set
	 * contiguous_pages_dirty if it needed to allocate internal pages, so
	 * recompute contiguous_pages if necessary.
	 */</comment>
	<expr_stmt><expr><call><name>FreePageManagerUpdateLargest</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FPM_EXTRA_ASSERTS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>+=</operator> <name>npages</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>free_pages</name></name> <operator>==</operator> <call><name>sum_free_pages</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name> <operator>==</operator> <call><name>FreePageManagerLargestContiguous</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Produce a debugging dump of the state of a free page manager.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>FreePageManagerDump</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>recycle</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dumped_any_freelist</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>f</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize output buffer. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Dump general stuff. */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"metadata: self %zu max contiguous pages = %zu\n"</literal></expr></argument>,
					 <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>self</name><operator>.</operator><name>relptr_off</name></name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Dump btree. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"btree depth %u:\n"</literal></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreePageManagerDumpBtree</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>root</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"singleton: %zu(%zu)\n"</literal></expr></argument>,
						 <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump btree recycle list. */</comment>
	<expr_stmt><expr><name>recycle</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>recycle</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"btree recycle:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreePageManagerDumpSpans</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>recycle</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Dump free lists. */</comment>
	<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>FPM_NUM_FREELISTS</name></expr>;</condition> <incr><expr><operator>++</operator><name>f</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>span</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>relptr_is_null</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>dumped_any_freelist</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"freelists:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dumped_any_freelist</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  %zu:"</literal></expr></argument>, <argument><expr><name>f</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreePageManagerDumpSpans</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>span</name></expr></argument>, <argument><expr><name>f</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* And return result to caller. */</comment>
	<return>return <expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * The first_page value stored at index zero in any non-root page must match
 * the first_page value stored in its parent at the index which points to that
 * page.  So when the value stored at index zero in a btree page changes, we've
 * got to walk up the tree adjusting ancestor keys until we reach an ancestor
 * where that key isn't index zero.  This function should be called after
 * updating the first key on the target page; it will propagate the change
 * upward as far as needed.
 *
 * We assume here that the first key on the page has not changed enough to
 * require changes in the ordering of keys on its ancestor pages.  Thus,
 * if we search the parent page for the first key greater than or equal to
 * the first key on the current page, the downlink to this page will be either
 * the exact index returned by the search (if the first key decreased)
 * or one less (if the first key increased).
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageBtreeAdjustAncestorKeys</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>first_page</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

	<comment type="block">/* This might be either a leaf or an internal page. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&lt;=</operator> <name>FPM_ITEMS_PER_LEAF_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first_page</name> <operator>=</operator> <name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&lt;=</operator> <name>FPM_ITEMS_PER_INTERNAL_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first_page</name> <operator>=</operator> <name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>child</name> <operator>=</operator> <name>btp</name></expr>;</expr_stmt>

	<comment type="block">/* Loop until we find an ancestor that does not require adjustment. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>s</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>child</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>s</name> <operator>=</operator> <call><name>FreePageBtreeSearchInternal</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Key is either at index s or index s-1; figure out which. */</comment>
		<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;=</operator> <name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>s</name> <operator>==</operator> <name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>--</operator><name>s</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>check</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>check</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>s</name></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>check</name> <operator>!=</operator> <name>child</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>s</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>--</operator><name>s</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<comment type="block">/* Debugging double-check. */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>check</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>check</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>parent</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>s</name></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>s</name> <operator>&lt;</operator> <name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>child</name> <operator>==</operator> <name>check</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/* Update the parent key. */</comment>
		<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>s</name></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>=</operator> <name>first_page</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If this is the first key in the parent, go up another level; else
		 * done.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>s</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>child</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Attempt to reclaim space from the free-page btree.  The return value is
 * the largest range of contiguous pages created by the cleanup operation.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>FreePageBtreeCleanup</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>max_contiguous_pages</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Attempt to shrink the depth of the btree. */</comment>
	<while>while <condition>(<expr><operator>!</operator><call><name>relptr_is_null</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* If the root contains only one key, reduce depth by one. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Shrink depth of tree by one. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>--</operator><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* If root is a leaf, convert only entry to singleton range. */</comment>
				<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FreePageBtree</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>npages</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>newroot</name></decl>;</decl_stmt>

				<comment type="block">/* If root is an internal page, make only child the root. */</comment>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>relptr_copy</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>newroot</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>newroot</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FreePageBtree</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><call><name>FreePageBtreeRecycle</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>==</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator>
				 <name><name>root</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>end_of_first</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>start_of_second</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>end_of_first</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>+</operator>
				<name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>npages</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>start_of_second</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>end_of_first</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>start_of_second</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Size</name></type>		<name>root_page</name> <init>= <expr><call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>end_of_first</name> <operator>==</operator> <name>root_page</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>FreePagePopSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>FreePagePopSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>npages</name> <operator>+</operator>
						<name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>npages</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>FreePageBtree</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr></argument>,
										   <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>max_contiguous_pages</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>max_contiguous_pages</name> <operator>=</operator> <name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Whether it worked or not, it's time to stop. */</comment>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Nothing more to do.  Stop. */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Attempt to free recycled btree pages.  We skip this if releasing the
	 * recycled page would require a btree page split, because the page we're
	 * trying to recycle would be consumed by the split, which would be
	 * counterproductive.
	 *
	 * We also currently only ever attempt to recycle the first page on the
	 * list; that could be made more aggressive, but it's not clear that the
	 * complexity would be worthwhile.
	 */</comment>
	<while>while <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle_count</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>first_page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>contiguous_pages</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>btp</name> <operator>=</operator> <call><name>FreePageBtreeGetRecycled</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>first_page</name> <operator>=</operator> <call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>contiguous_pages</name> <operator>=</operator> <call><name>FreePageManagerPutInternal</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>contiguous_pages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>FreePageBtreeRecycle</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>contiguous_pages</name> <operator>&gt;</operator> <name>max_contiguous_pages</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>max_contiguous_pages</name> <operator>=</operator> <name>contiguous_pages</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>max_contiguous_pages</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Consider consolidating the given page with its left or right sibling,
 * if it's fairly empty.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageBtreeConsolidate</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>max</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only try to consolidate pages that are less than a third full. We
	 * could be more aggressive about this, but that might risk performing
	 * consolidation only to end up splitting again shortly thereafter.  Since
	 * the btree should be very small compared to the space under management,
	 * our goal isn't so much to ensure that it always occupies the absolutely
	 * smallest possible number of pages as to reclaim pages before things get
	 * too egregiously out of hand.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>max</name> <operator>=</operator> <name>FPM_ITEMS_PER_LEAF_PAGE</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>max</name> <operator>=</operator> <name>FPM_ITEMS_PER_INTERNAL_PAGE</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&gt;=</operator> <name>max</name> <operator>/</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we can fit our right sibling's keys onto this page, consolidate.
	 */</comment>
	<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>FreePageBtreeFindRightSibling</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>np</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>+</operator> <name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&lt;=</operator> <name>max</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>np</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeLeafKey</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>+=</operator> <name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>np</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeInternalKey</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>+=</operator> <name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FreePageBtreeUpdateParentPointers</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>FreePageBtreeRemovePage</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we can fit our keys onto our left sibling's page, consolidate. In
	 * this case, we move our keys onto the other page rather than visca
	 * versa, to avoid having to adjust ancestor keys.
	 */</comment>
	<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>FreePageBtreeFindLeftSibling</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>np</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>+</operator> <name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&lt;=</operator> <name>max</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>np</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeLeafKey</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>+=</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>np</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
				   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeInternalKey</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>np</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>+=</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FreePageBtreeUpdateParentPointers</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>FreePageBtreeRemovePage</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Find the passed page's left sibling; that is, the page at the same level
 * of the tree whose keyspace immediately precedes ours.
 */</comment>
<function><type><specifier>static</specifier> <name>FreePageBtree</name> <modifier>*</modifier></type>
<name>FreePageBtreeFindLeftSibling</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>btp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>levels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Move up until we can move left. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>first_page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>first_page</name> <operator>=</operator> <call><name>FreePageBtreeFirstKey</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* we were passed the rightmost page */</comment>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>FreePageBtreeSearchInternal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>==</operator> <name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>levels</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Descend left. */</comment>
	<while>while <condition>(<expr><name>levels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>levels</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Find the passed page's right sibling; that is, the page at the same level
 * of the tree whose keyspace immediately follows ours.
 */</comment>
<function><type><specifier>static</specifier> <name>FreePageBtree</name> <modifier>*</modifier></type>
<name>FreePageBtreeFindRightSibling</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>btp</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>levels</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Move up until we can move right. */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>first_page</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>first_page</name> <operator>=</operator> <call><name>FreePageBtreeFirstKey</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>		<comment type="block">/* we were passed the rightmost page */</comment>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>FreePageBtreeSearchInternal</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name><name>p</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>==</operator> <name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>==</operator> <name><name>p</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>levels</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Descend left. */</comment>
	<while>while <condition>(<expr><name>levels</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>p</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>p</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>--</operator><name>levels</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the first key on a btree page.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>FreePageBtreeFirstKey</name><parameter_list>(<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get a page from the btree recycle list for use as a btree page.
 */</comment>
<function><type><specifier>static</specifier> <name>FreePageBtree</name> <modifier>*</modifier></type>
<name>FreePageBtreeGetRecycled</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>victim</name> <init>= <expr><call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>newhead</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>victim</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>newhead</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>victim</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>newhead</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relptr_copy</name><argument_list>(<argument><expr><name><name>newhead</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name><name>victim</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle</name></name></expr></argument>, <argument><expr><name>newhead</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>fpm_pointer_is_page_aligned</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>victim</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle_count</name></name><operator>--</operator></expr>;</expr_stmt>
	<return>return <expr><operator>(</operator><name>FreePageBtree</name> <operator>*</operator><operator>)</operator> <name>victim</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Insert an item into an internal page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageBtreeInsertInternal</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>index</name></decl></parameter>,
							<parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>child</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&lt;=</operator> <name>FPM_ITEMS_PER_INTERNAL_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;=</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeInternalKey</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <name>index</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>=</operator> <name>first_page</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>++</operator><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Insert an item into a leaf page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageBtreeInsertLeaf</name><parameter_list>(<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>index</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>,
						<parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&lt;=</operator> <name>FPM_ITEMS_PER_LEAF_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;=</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>,
			<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeLeafKey</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <name>index</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>=</operator> <name>first_page</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>npages</name> <operator>=</operator> <name>npages</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>++</operator><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Put a page on the btree recycle list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageBtreeRecycle</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>span</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>span</name> <operator>=</operator> <operator>(</operator><name>FreePageSpanLeader</name> <operator>*</operator><operator>)</operator> <call><name>fpm_page_to_pointer</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>FREE_PAGE_SPAN_LEADER_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FreePageSpanLeader</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>head</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>head</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle</name></name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle_count</name></name><operator>++</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove an item from the btree at the given position on the given page.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageBtreeRemove</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* When last item is removed, extirpate entire page from btree. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>FreePageBtreeRemovePage</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Physically remove the key from the page. */</comment>
	<expr_stmt><expr><operator>--</operator><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
				<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeLeafKey</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <operator>(</operator><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <name>index</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* If we just removed the first key, adjust ancestor keys. */</comment>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreePageBtreeAdjustAncestorKeys</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Consider whether to consolidate this page with a sibling. */</comment>
	<expr_stmt><expr><call><name>FreePageBtreeConsolidate</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove a page from the btree.  Caller is responsible for having relocated
 * any keys from this page that are still wanted.  The page is placed on the
 * recycled list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageBtreeRemovePage</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>first_page</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Find parent page. */</comment>
		<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We are removing the root page. */</comment>
			<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FreePageBtree</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the parent contains only one item, we need to remove it as well.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>FreePageBtreeRecycle</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>btp</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Find and remove the downlink. */</comment>
	<expr_stmt><expr><name>first_page</name> <operator>=</operator> <call><name>FreePageBtreeFirstKey</name><argument_list>(<argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>FreePageBtreeSearchLeaf</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;</operator> <name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeLeafKey</name></expr></argument>)</argument_list></sizeof>
					<operator>*</operator> <operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <name>index</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>FreePageBtreeSearchInternal</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;</operator> <name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&lt;</operator> <name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>memmove</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>,
					<argument><expr><operator>&amp;</operator><name><name>parent</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>,
					<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeInternalKey</name></expr></argument>)</argument_list></sizeof>
					<operator>*</operator> <operator>(</operator><name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-</operator> <name>index</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Recycle the page. */</comment>
	<expr_stmt><expr><call><name>FreePageBtreeRecycle</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Adjust ancestor keys if needed. */</comment>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreePageBtreeAdjustAncestorKeys</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Consider whether to consolidate the parent with a sibling. */</comment>
	<expr_stmt><expr><call><name>FreePageBtreeConsolidate</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Search the btree for an entry for the given first page and initialize
 * *result with the results of the search.  result-&gt;page and result-&gt;index
 * indicate either the position of an exact match or the position at which
 * the new key should be inserted.  result-&gt;found is true for an exact match,
 * otherwise false.  result-&gt;split_pages will contain the number of additional
 * btree pages that will be needed when performing a split to insert a key.
 * Except as described above, the contents of fields in the result object are
 * undefined on return.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageBtreeSearch</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>,
					<parameter><decl><type><name>FreePageBtreeSearchResult</name> <modifier>*</modifier></type><name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name> <init>= <expr><call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>split_pages</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* If the btree is empty, there's nothing to find. */</comment>
	<if_stmt><if>if <condition>(<expr><name>btp</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>found</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Descend until we hit a leaf. */</comment>
	<while>while <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>found_exact</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>FreePageBtreeSearchInternal</name><argument_list>(<argument><expr><name>btp</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>found_exact</name> <operator>=</operator> <name>index</name> <operator>&lt;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&amp;&amp;</operator>
			<name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>==</operator> <name>first_page</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we found an exact match we descend directly.  Otherwise, we
		 * descend into the child to the left if possible so that we can find
		 * the insertion point at that child's high end.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found_exact</name> <operator>&amp;&amp;</operator> <name>index</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>--</operator><name>index</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Track required split depth for leaf insert. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&gt;=</operator> <name>FPM_ITEMS_PER_INTERNAL_PAGE</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>==</operator> <name>FPM_ITEMS_PER_INTERNAL_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>split_pages</name></name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>split_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* Descend to appropriate child page. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>index</name> <operator>&lt;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>child</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>btp</name> <operator>=</operator> <name>child</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Track required split depth for leaf insert. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&gt;=</operator> <name>FPM_ITEMS_PER_LEAF_PAGE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>==</operator> <name>FPM_ITEMS_PER_INTERNAL_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>split_pages</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>split_pages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Search leaf page. */</comment>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>FreePageBtreeSearchLeaf</name><argument_list>(<argument><expr><name>btp</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Assemble results. */</comment>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>page</name></name> <operator>=</operator> <name>btp</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <name>index</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>result</name><operator>-&gt;</operator><name>found</name></name> <operator>=</operator> <name>index</name> <operator>&lt;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&amp;&amp;</operator>
		<name>first_page</name> <operator>==</operator> <name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>first_page</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Search an internal page for the first key greater than or equal to a given
 * page number.  Returns the index of that key, or one greater than the number
 * of keys on the page if none.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>FreePageBtreeSearchInternal</name><parameter_list>(<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>high</name> <init>= <expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>high</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>high</name> <operator>&lt;=</operator> <name>FPM_ITEMS_PER_INTERNAL_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>low</name> <operator>&lt;</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>mid</name> <init>= <expr><operator>(</operator><name>low</name> <operator>+</operator> <name>high</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>val</name> <init>= <expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>mid</name></expr>]</index></name><operator>.</operator><name>first_page</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>first_page</name> <operator>==</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>mid</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>first_page</name> <operator>&lt;</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>low</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Search a leaf page for the first key greater than or equal to a given
 * page number.  Returns the index of that key, or one greater than the number
 * of keys on the page if none.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>FreePageBtreeSearchLeaf</name><parameter_list>(<parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>low</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>high</name> <init>= <expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>high</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>high</name> <operator>&lt;=</operator> <name>FPM_ITEMS_PER_LEAF_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>low</name> <operator>&lt;</operator> <name>high</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>mid</name> <init>= <expr><operator>(</operator><name>low</name> <operator>+</operator> <name>high</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>val</name> <init>= <expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>mid</name></expr>]</index></name><operator>.</operator><name>first_page</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>first_page</name> <operator>==</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>mid</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>first_page</name> <operator>&lt;</operator> <name>val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>high</name> <operator>=</operator> <name>mid</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>low</name> <operator>=</operator> <name>mid</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>low</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Allocate a new btree page and move half the keys from the provided page
 * to the new page.  Caller is responsible for making sure that there's a
 * page available from fpm-&gt;btree_recycle.  Returns a pointer to the new page,
 * to which caller must add a downlink.
 */</comment>
<function><type><specifier>static</specifier> <name>FreePageBtree</name> <modifier>*</modifier></type>
<name>FreePageBtreeSplitPage</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>newsibling</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>newsibling</name> <operator>=</operator> <call><name>FreePageBtreeGetRecycled</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newsibling</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newsibling</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>=</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relptr_copy</name><argument_list>(<argument><expr><name><name>newsibling</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>, <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>-=</operator> <name><name>newsibling</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newsibling</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name></name></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>]</index></name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeLeafKey</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>newsibling</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>newsibling</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name></name></expr></argument>,
			   <argument><expr><operator>&amp;</operator><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>]</index></name></expr></argument>,
			   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>FreePageBtreeInternalKey</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name><name>newsibling</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreePageBtreeUpdateParentPointers</name><argument_list>(<argument><expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newsibling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>newsibling</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * When internal pages are split or merged, the parent pointers of their
 * children must be updated.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageBtreeUpdateParentPointers</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>base</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>child</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Debugging dump of btree data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageManagerDumpBtree</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>btp</name></decl></parameter>,
						 <parameter><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>parent</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>pageno</name> <init>= <expr><call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>check_parent</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>check_parent</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"  %zu@%d %c"</literal></expr></argument>, <argument><expr><name>pageno</name></expr></argument>, <argument><expr><name>level</name></expr></argument>,
					 <argument><expr><ternary><condition><expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr> ?</condition><then> <expr><literal type="char">'i'</literal></expr> </then><else>: <expr><literal type="char">'l'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>!=</operator> <name>check_parent</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" [actual parent %zu, expected %zu]"</literal></expr></argument>,
						 <argument><expr><call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>check_parent</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>index</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %zu-&gt;%zu"</literal></expr></argument>,
							 <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>first_page</name></expr></argument>,
							 <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name><name>child</name><operator>.</operator><name>relptr_off</name></name> <operator>/</operator> <name>FPM_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %zu(%zu)"</literal></expr></argument>,
							 <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>first_page</name></expr></argument>,
							 <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>index</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>btp</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>;</condition> <incr><expr><operator>++</operator><name>index</name></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>child</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>child</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>btp</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><name>index</name></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FreePageManagerDumpBtree</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>child</name></expr></argument>, <argument><expr><name>btp</name></expr></argument>, <argument><expr><name>level</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Debugging dump of free-span data.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePageManagerDumpSpans</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>span</name></decl></parameter>,
						 <parameter><decl><type><name>Size</name></type> <name>expected_pages</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>span</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name> <operator>!=</operator> <name>expected_pages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %zu(%zu)"</literal></expr></argument>, <argument><expr><call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %zu"</literal></expr></argument>, <argument><expr><call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>span</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This function allocates a run of pages of the given length from the free
 * page manager.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>FreePageManagerGetInternal</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>, <parameter><decl><type><name>Size</name> <modifier>*</modifier></type><name>first_page</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>victim</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtreeSearchResult</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>victim_page</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* placate compiler */</comment>
	<decl_stmt><decl><type><name>Size</name></type>		<name>f</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Search for a free span.
	 *
	 * Right now, we use a simple best-fit policy here, but it's possible for
	 * this to result in memory fragmentation if we're repeatedly asked to
	 * allocate chunks just a little smaller than what we have available.
	 * Hopefully, this is unlikely, because we expect most requests to be
	 * single pages or superblock-sized chunks -- but no policy can be optimal
	 * under all circumstances unless it has knowledge of future allocation
	 * patterns.
	 */</comment>
	<for>for <control>(<init><expr><name>f</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>npages</name></expr></argument>, <argument><expr><name>FPM_NUM_FREELISTS</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>f</name> <operator>&lt;</operator> <name>FPM_NUM_FREELISTS</name></expr>;</condition> <incr><expr><operator>++</operator><name>f</name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* Skip empty freelists. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>relptr_is_null</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * All of the freelists except the last one contain only items of a
		 * single size, so we just take the first one.  But the final free
		 * list contains everything too big for any of the other lists, so we
		 * need to search the list.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>f</name> <operator>&lt;</operator> <name>FPM_NUM_FREELISTS</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>victim</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>candidate</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>candidate</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<do>do
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>candidate</name><operator>-&gt;</operator><name>npages</name></name> <operator>&gt;=</operator> <name>npages</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>victim</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
													<name><name>victim</name><operator>-&gt;</operator><name>npages</name></name> <operator>&gt;</operator> <name><name>candidate</name><operator>-&gt;</operator><name>npages</name></name><operator>)</operator></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>victim</name> <operator>=</operator> <name>candidate</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>victim</name><operator>-&gt;</operator><name>npages</name></name> <operator>==</operator> <name>npages</name></expr>)</condition><block type="pseudo"><block_content>
						<break>break;</break></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><name>candidate</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>candidate</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><name>candidate</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>;</do>
		</block_content>}</block></else></if_stmt>
		<break>break;</break>
	</block_content>}</block></for>

	<comment type="block">/* If we didn't find an allocatable span, return failure. */</comment>
	<if_stmt><if>if <condition>(<expr><name>victim</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Remove span from free list. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>victim</name><operator>-&gt;</operator><name>magic</name></name> <operator>==</operator> <name>FREE_PAGE_SPAN_LEADER_MAGIC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>victim</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>victim</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relptr_copy</name><argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name><name>victim</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relptr_copy</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>victim</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>next</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relptr_copy</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name><name>victim</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>victim_page</name> <operator>=</operator> <call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>victim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Decide whether we might be invalidating contiguous_pages. */</comment>
	<if_stmt><if>if <condition>(<expr><name>f</name> <operator>==</operator> <name>FPM_NUM_FREELISTS</name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<name><name>victim</name><operator>-&gt;</operator><name>npages</name></name> <operator>==</operator> <name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The victim span came from the oversized freelist, and had the same
		 * size as the longest span.  There may or may not be another one of
		 * the same size, so contiguous_pages must be recomputed just to be
		 * safe.
		 */</comment>
		<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages_dirty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>f</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages</name></name> <operator>&amp;&amp;</operator>
			 <call><name>relptr_is_null</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The victim span came from a fixed sized freelist, and it was the
		 * list for spans of the same size as the current longest span, and
		 * the list is now empty after removing the victim.  So
		 * contiguous_pages must be recomputed without a doubt.
		 */</comment>
		<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>contiguous_pages_dirty</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we haven't initialized the btree yet, the victim must be the single
	 * span stored within the FreePageManager itself.  Otherwise, we need to
	 * update the btree.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>relptr_is_null</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>victim_page</name> <operator>==</operator> <name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>victim</name><operator>-&gt;</operator><name>npages</name></name> <operator>==</operator> <name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>victim</name><operator>-&gt;</operator><name>npages</name></name> <operator>&gt;=</operator> <name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name> <operator>+=</operator> <name>npages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>-=</operator> <name>npages</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr></argument>,
								   <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If the span we found is exactly the right size, remove it from the
		 * btree completely.  Otherwise, adjust the btree entry to reflect the
		 * still-unallocated portion of the span, and put that portion on the
		 * appropriate free list.
		 */</comment>
		<expr_stmt><expr><call><name>FreePageBtreeSearch</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>victim_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>found</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>victim</name><operator>-&gt;</operator><name>npages</name></name> <operator>==</operator> <name>npages</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreePageBtreeRemove</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>index</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>FreePageBtreeLeafKey</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>

			<comment type="block">/* Adjust btree to reflect remaining pages. */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>victim</name><operator>-&gt;</operator><name>npages</name></name> <operator>&gt;</operator> <name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>key</name> <operator>=</operator> <operator>&amp;</operator><name><name>result</name><operator>.</operator><name>page</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name><name>result</name><operator>.</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>key</name><operator>-&gt;</operator><name>npages</name></name> <operator>==</operator> <name><name>victim</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>first_page</name></name> <operator>+=</operator> <name>npages</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>npages</name></name> <operator>-=</operator> <name>npages</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>index</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>FreePageBtreeAdjustAncestorKeys</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Put the unallocated pages back on the appropriate free list. */</comment>
			<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>victim_page</name> <operator>+</operator> <name>npages</name></expr></argument>,
								   <argument><expr><name><name>victim</name><operator>-&gt;</operator><name>npages</name></name> <operator>-</operator> <name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Return results to caller. */</comment>
	<expr_stmt><expr><operator>*</operator><name>first_page</name> <operator>=</operator> <call><name>fpm_pointer_to_page</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>victim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Put a range of pages into the btree and freelists, consolidating it with
 * existing free spans just before and/or after it.  If 'soft' is true,
 * only perform the insertion if it can be done without allocating new btree
 * pages; if false, do it always.  Returns 0 if the soft flag caused the
 * insertion to be skipped, or otherwise the size of the contiguous span
 * created by the insertion.  This may be larger than npages if we're able
 * to consolidate with an adjacent range.
 */</comment>
<function><type><specifier>static</specifier> <name>Size</name></type>
<name>FreePageManagerPutInternal</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>,
						   <parameter><decl><type><name>bool</name></type> <name>soft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtreeSearchResult</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtreeLeafKey</name> <modifier>*</modifier></type><name>prevkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtreeLeafKey</name> <modifier>*</modifier></type><name>nextkey</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>np</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>nindex</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>npages</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* We can store a single free span without initializing the btree. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Don't have a span yet; store this one. */</comment>
			<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name> <operator>=</operator> <name>first_page</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>=</operator> <name>npages</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name> <operator>+</operator> <name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>==</operator>
				 <name>first_page</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* New span immediately follows sole existing span. */</comment>
			<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>+=</operator> <name>npages</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FreePagePopSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr></argument>,
								   <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>first_page</name> <operator>+</operator> <name>npages</name> <operator>==</operator> <name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* New span immediately precedes sole existing span. */</comment>
			<expr_stmt><expr><call><name>FreePagePopSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name> <operator>=</operator> <name>first_page</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>+=</operator> <name>npages</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr></argument>,
								   <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr>;</return>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Not contiguous; we need to initialize the btree. */</comment>
			<decl_stmt><decl><type><name>Size</name></type>		<name>root_page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>root</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>relptr_is_null</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>FreePageBtreeGetRecycled</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>soft</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if>		<comment type="block">/* Should not allocate if soft. */</comment>
			<if type="elseif">else if <condition>(<expr><call><name>FreePageManagerGetInternal</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>root_page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>root</name> <operator>=</operator> <operator>(</operator><name>FreePageBtree</name> <operator>*</operator><operator>)</operator> <call><name>fpm_page_to_pointer</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>root_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* We'd better be able to get a page from the existing range. */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"free page manager btree is corrupt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/* Create the btree and move the preexisting range into it. */</comment>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>FREE_PAGE_LEAF_MAGIC</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>root</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FreePageBtree</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>=</operator> <name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>npages</name> <operator>=</operator> <name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_first_page</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>singleton_npages</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<comment type="block">/*
			 * Corner case: it may be that the btree root took the very last
			 * free page.  In that case, the sole btree entry covers a zero
			 * page run, which is invalid.  Overwrite it with the entry we're
			 * trying to insert and get out.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>npages</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>=</operator> <name>first_page</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>npages</name> <operator>=</operator> <name>npages</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>npages</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Fall through to insert the new key. */</comment>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Search the btree. */</comment>
	<expr_stmt><expr><call><name>FreePageBtreeSearch</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>result</name><operator>.</operator><name>found</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>index</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>prevkey</name> <operator>=</operator> <operator>&amp;</operator><name><name>result</name><operator>.</operator><name>page</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name><name>result</name><operator>.</operator><name>index</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>index</name></name> <operator>&lt;</operator> <name><name>result</name><operator>.</operator><name>page</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>np</name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>page</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nindex</name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>index</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>nextkey</name> <operator>=</operator> <operator>&amp;</operator><name><name>result</name><operator>.</operator><name>page</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><name><name>result</name><operator>.</operator><name>index</name></name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>np</name> <operator>=</operator> <call><name>FreePageBtreeFindRightSibling</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nindex</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>np</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nextkey</name> <operator>=</operator> <operator>&amp;</operator><name><name>np</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Consolidate with the previous entry if possible. */</comment>
	<if_stmt><if>if <condition>(<expr><name>prevkey</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>prevkey</name><operator>-&gt;</operator><name>first_page</name></name> <operator>+</operator> <name><name>prevkey</name><operator>-&gt;</operator><name>npages</name></name> <operator>&gt;=</operator> <name>first_page</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>remove_next</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Size</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prevkey</name><operator>-&gt;</operator><name>first_page</name></name> <operator>+</operator> <name><name>prevkey</name><operator>-&gt;</operator><name>npages</name></name> <operator>==</operator> <name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prevkey</name><operator>-&gt;</operator><name>npages</name></name> <operator>=</operator> <operator>(</operator><name>first_page</name> <operator>-</operator> <name><name>prevkey</name><operator>-&gt;</operator><name>first_page</name></name><operator>)</operator> <operator>+</operator> <name>npages</name></expr>;</expr_stmt>

		<comment type="block">/* Check whether we can *also* consolidate with the following entry. */</comment>
		<if_stmt><if>if <condition>(<expr><name>nextkey</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
			<name><name>prevkey</name><operator>-&gt;</operator><name>first_page</name></name> <operator>+</operator> <name><name>prevkey</name><operator>-&gt;</operator><name>npages</name></name> <operator>&gt;=</operator> <name><name>nextkey</name><operator>-&gt;</operator><name>first_page</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prevkey</name><operator>-&gt;</operator><name>first_page</name></name> <operator>+</operator> <name><name>prevkey</name><operator>-&gt;</operator><name>npages</name></name> <operator>==</operator>
				   <name><name>nextkey</name><operator>-&gt;</operator><name>first_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>prevkey</name><operator>-&gt;</operator><name>npages</name></name> <operator>=</operator> <operator>(</operator><name><name>nextkey</name><operator>-&gt;</operator><name>first_page</name></name> <operator>-</operator> <name><name>prevkey</name><operator>-&gt;</operator><name>first_page</name></name><operator>)</operator>
				<operator>+</operator> <name><name>nextkey</name><operator>-&gt;</operator><name>npages</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FreePagePopSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>nextkey</name><operator>-&gt;</operator><name>first_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>remove_next</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Put the span on the correct freelist and save size. */</comment>
		<expr_stmt><expr><call><name>FreePagePopSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>prevkey</name><operator>-&gt;</operator><name>first_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>prevkey</name><operator>-&gt;</operator><name>first_page</name></name></expr></argument>, <argument><expr><name><name>prevkey</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>prevkey</name><operator>-&gt;</operator><name>npages</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we consolidated with both the preceding and following entries,
		 * we must remove the following entry.  We do this last, because
		 * removing an element from the btree may invalidate pointers we hold
		 * into the current data structure.
		 *
		 * NB: The btree is technically in an invalid state a this point
		 * because we've already updated prevkey to cover the same key space
		 * as nextkey.  FreePageBtreeRemove() shouldn't notice that, though.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>remove_next</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreePageBtreeRemove</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>np</name></expr></argument>, <argument><expr><name>nindex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Consolidate with the next entry if possible. */</comment>
	<if_stmt><if>if <condition>(<expr><name>nextkey</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>first_page</name> <operator>+</operator> <name>npages</name> <operator>&gt;=</operator> <name><name>nextkey</name><operator>-&gt;</operator><name>first_page</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>newpages</name></decl>;</decl_stmt>

		<comment type="block">/* Compute new size for span. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>first_page</name> <operator>+</operator> <name>npages</name> <operator>==</operator> <name><name>nextkey</name><operator>-&gt;</operator><name>first_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>newpages</name> <operator>=</operator> <operator>(</operator><name><name>nextkey</name><operator>-&gt;</operator><name>first_page</name></name> <operator>-</operator> <name>first_page</name><operator>)</operator> <operator>+</operator> <name><name>nextkey</name><operator>-&gt;</operator><name>npages</name></name></expr>;</expr_stmt>

		<comment type="block">/* Put span on correct free list. */</comment>
		<expr_stmt><expr><call><name>FreePagePopSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>nextkey</name><operator>-&gt;</operator><name>first_page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><name>newpages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Update key in place. */</comment>
		<expr_stmt><expr><name><name>nextkey</name><operator>-&gt;</operator><name>first_page</name></name> <operator>=</operator> <name>first_page</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nextkey</name><operator>-&gt;</operator><name>npages</name></name> <operator>=</operator> <name>newpages</name></expr>;</expr_stmt>

		<comment type="block">/* If reducing first key on page, ancestors might need adjustment. */</comment>
		<if_stmt><if>if <condition>(<expr><name>nindex</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>FreePageBtreeAdjustAncestorKeys</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name><name>nextkey</name><operator>-&gt;</operator><name>npages</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Split leaf page and as many of its ancestors as necessary. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>split_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * NB: We could consider various coping strategies here to avoid a
		 * split; most obviously, if np != result.page, we could target that
		 * page instead.   More complicated shuffling strategies could be
		 * possible as well; basically, unless every single leaf page is 100%
		 * full, we can jam this key in there if we try hard enough.  It's
		 * unlikely that trying that hard is worthwhile, but it's possible we
		 * might need to make more than no effort.  For now, we just do the
		 * easy thing, which is nothing.
		 */</comment>

		<comment type="block">/* If this is a soft insert, it's time to give up. */</comment>
		<if_stmt><if>if <condition>(<expr><name>soft</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Check whether we need to allocate more btree pages to split. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>split_pages</name></name> <operator>&gt;</operator> <name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle_count</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Size</name></type>		<name>pages_needed</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>recycle_page</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>i</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Allocate the required number of pages and split each one in
			 * turn.  This should never fail, because if we've got enough
			 * spans of free pages kicking around that we need additional
			 * storage space just to remember them all, then we should
			 * certainly have enough to expand the btree, which should only
			 * ever use a tiny number of pages compared to the number under
			 * management.  If it does, something's badly screwed up.
			 */</comment>
			<expr_stmt><expr><name>pages_needed</name> <operator>=</operator> <name><name>result</name><operator>.</operator><name>split_pages</name></name> <operator>-</operator> <name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle_count</name></name></expr>;</expr_stmt>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>pages_needed</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>FreePageManagerGetInternal</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>recycle_page</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>, <argument><expr><literal type="string">"free page manager btree is corrupt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>FreePageBtreeRecycle</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>recycle_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * The act of allocating pages to recycle may have invalidated the
			 * results of our previous btree reserch, so repeat it. (We could
			 * recheck whether any of our split-avoidance strategies that were
			 * not viable before now are, but it hardly seems worthwhile, so
			 * we don't bother. Consolidation can't be possible now if it
			 * wasn't previously.)
			 */</comment>
			<expr_stmt><expr><call><name>FreePageBtreeSearch</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * The act of allocating pages for use in constructing our btree
			 * should never cause any page to become more full, so the new
			 * split depth should be no greater than the old one, and perhaps
			 * less if we fortuitously allocated a chunk that freed up a slot
			 * on the page we need to update.
			 */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>split_pages</name></name> <operator>&lt;=</operator> <name><name>fpm</name><operator>-&gt;</operator><name>btree_recycle_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* If we still need to perform a split, do it. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>split_pages</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>split_target</name> <init>= <expr><name><name>result</name><operator>.</operator><name>page</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>child</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Size</name></type>		<name>key</name> <init>= <expr><name>first_page</name></expr></init></decl>;</decl_stmt>

			<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
			<block>{<block_content>
				<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>newsibling</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>parent</name></decl>;</decl_stmt>

				<comment type="block">/* Identify parent page, which must receive downlink. */</comment>
				<expr_stmt><expr><name>parent</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>split_target</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Split the page - downlink not added yet. */</comment>
				<expr_stmt><expr><name>newsibling</name> <operator>=</operator> <call><name>FreePageBtreeSplitPage</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>split_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * At this point in the loop, we're always carrying a pending
				 * insertion.  On the first pass, it's the actual key we're
				 * trying to insert; on subsequent passes, it's the downlink
				 * that needs to be added as a result of the split performed
				 * during the previous loop iteration.  Since we've just split
				 * the page, there's definitely room on one of the two
				 * resulting pages.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>child</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>insert_into</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>insert_into</name> <operator>=</operator> <ternary><condition><expr><name>key</name> <operator>&lt;</operator> <name><name>newsibling</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>leaf_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr> ?</condition><then>
						<expr><name>split_target</name></expr> </then><else>: <expr><name>newsibling</name></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>FreePageBtreeSearchLeaf</name><argument_list>(<argument><expr><name>insert_into</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>FreePageBtreeInsertLeaf</name><argument_list>(<argument><expr><name>insert_into</name></expr></argument>, <argument><expr><name>index</name></expr></argument>, <argument><expr><name>key</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>insert_into</name> <operator>==</operator> <name>split_target</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>FreePageBtreeAdjustAncestorKeys</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>split_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>insert_into</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>insert_into</name> <operator>=</operator>
						<ternary><condition><expr><name>key</name> <operator>&lt;</operator> <name><name>newsibling</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr> ?</condition><then>
						<expr><name>split_target</name></expr> </then><else>: <expr><name>newsibling</name></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>FreePageBtreeSearchInternal</name><argument_list>(<argument><expr><name>insert_into</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>FreePageBtreeInsertInternal</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>insert_into</name></expr></argument>, <argument><expr><name>index</name></expr></argument>,
												<argument><expr><name>key</name></expr></argument>, <argument><expr><name>child</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>child</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>, <argument><expr><name>insert_into</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>insert_into</name> <operator>==</operator> <name>split_target</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>FreePageBtreeAdjustAncestorKeys</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>split_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/* If the page we just split has no parent, split the root. */</comment>
				<if_stmt><if>if <condition>(<expr><name>parent</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>FreePageBtree</name> <modifier>*</modifier></type><name>newroot</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>newroot</name> <operator>=</operator> <call><name>FreePageBtreeGetRecycled</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newroot</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>magic</name></name> <operator>=</operator> <name>FREE_PAGE_INTERNAL_MAGIC</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newroot</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>newroot</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>,
								 <argument><expr><operator>(</operator><name>FreePageBtree</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newroot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>=</operator>
						<call><name>FreePageBtreeFirstKey</name><argument_list>(<argument><expr><name>split_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>newroot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>,
								 <argument><expr><name>split_target</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>split_target</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>, <argument><expr><name>newroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>newroot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>first_page</name> <operator>=</operator>
						<call><name>FreePageBtreeFirstKey</name><argument_list>(<argument><expr><name>newsibling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>newroot</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">1</literal></expr>]</index></name><operator>.</operator><name>child</name></expr></argument>,
								 <argument><expr><name>newsibling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>newsibling</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>, <argument><expr><name>newroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_root</name></name></expr></argument>, <argument><expr><name>newroot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>fpm</name><operator>-&gt;</operator><name>btree_depth</name></name><operator>++</operator></expr>;</expr_stmt>

					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* If the parent page isn't full, insert the downlink. */</comment>
				<expr_stmt><expr><name>key</name> <operator>=</operator> <name><name>newsibling</name><operator>-&gt;</operator><name>u</name><operator>.</operator><name>internal_key</name><index>[<expr><literal type="number">0</literal></expr>]</index></name><operator>.</operator><name>first_page</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>parent</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&lt;</operator> <name>FPM_ITEMS_PER_INTERNAL_PAGE</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Size</name></type>		<name>index</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>FreePageBtreeSearchInternal</name><argument_list>(<argument><expr><name>parent</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>FreePageBtreeInsertInternal</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>, <argument><expr><name>index</name></expr></argument>,
												<argument><expr><name>key</name></expr></argument>, <argument><expr><name>newsibling</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>newsibling</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>parent</name></name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>index</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>FreePageBtreeAdjustAncestorKeys</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>parent</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* The parent also needs to be split, so loop around. */</comment>
				<expr_stmt><expr><name>child</name> <operator>=</operator> <name>newsibling</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>split_target</name> <operator>=</operator> <name>parent</name></expr>;</expr_stmt>
			</block_content>}</block></for>

			<comment type="block">/*
			 * The loop above did the insert, so just need to update the free
			 * list, and we're done.
			 */</comment>
			<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<return>return <expr><name>npages</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Physically add the key to the page. */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>page</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>nused</name></name> <operator>&lt;</operator> <name>FPM_ITEMS_PER_LEAF_PAGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>FreePageBtreeInsertLeaf</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>page</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>index</name></name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If new first key on page, ancestors might need adjustment. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>result</name><operator>.</operator><name>index</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>FreePageBtreeAdjustAncestorKeys</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>page</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Put it on the free list. */</comment>
	<expr_stmt><expr><call><name>FreePagePushSpanLeader</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>, <argument><expr><name>npages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>npages</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove a FreePageSpanLeader from the linked-list that contains it, either
 * because we're changing the size of the span, or because we're allocating it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePagePopSpanLeader</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>pageno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>span</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>next</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>prev</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>span</name> <operator>=</operator> <operator>(</operator><name>FreePageSpanLeader</name> <operator>*</operator><operator>)</operator> <call><name>fpm_page_to_pointer</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>pageno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>next</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>prev</name> <operator>=</operator> <call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>next</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relptr_copy</name><argument_list>(<argument><expr><name><name>next</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>prev</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relptr_copy</name><argument_list>(<argument><expr><name><name>prev</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>Size</name></type>		<name>f</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name></expr></argument>, <argument><expr><name>FPM_NUM_FREELISTS</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name><operator>.</operator><name>relptr_off</name> <operator>==</operator> <name>pageno</name> <operator>*</operator> <name>FPM_PAGE_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>relptr_copy</name><argument_list>(<argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>next</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a new FreePageSpanLeader and put it on the appropriate free list.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>FreePagePushSpanLeader</name><parameter_list>(<parameter><decl><type><name>FreePageManager</name> <modifier>*</modifier></type><name>fpm</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>first_page</name></decl></parameter>, <parameter><decl><type><name>Size</name></type> <name>npages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>base</name> <init>= <expr><call><name>fpm_segment_base</name><argument_list>(<argument><expr><name>fpm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Size</name></type>		<name>f</name> <init>= <expr><call><name>Min</name><argument_list>(<argument><expr><name>npages</name></expr></argument>, <argument><expr><name>FPM_NUM_FREELISTS</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>head</name> <init>= <expr><call><name>relptr_access</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FreePageSpanLeader</name> <modifier>*</modifier></type><name>span</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>span</name> <operator>=</operator> <operator>(</operator><name>FreePageSpanLeader</name> <operator>*</operator><operator>)</operator> <call><name>fpm_page_to_pointer</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name>first_page</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>magic</name></name> <operator>=</operator> <name>FREE_PAGE_SPAN_LEADER_MAGIC</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>span</name><operator>-&gt;</operator><name>npages</name></name> <operator>=</operator> <name>npages</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><name>head</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>span</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><operator>(</operator><name>FreePageSpanLeader</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>head</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>head</name><operator>-&gt;</operator><name>prev</name></name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>relptr_store</name><argument_list>(<argument><expr><name>base</name></expr></argument>, <argument><expr><name><name>fpm</name><operator>-&gt;</operator><name>freelist</name><index>[<expr><name>f</name></expr>]</index></name></expr></argument>, <argument><expr><name>span</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
