<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/error/elog.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * elog.c
 *	  error logging and reporting
 *
 * Because of the extremely high rate at which log messages can be generated,
 * we need to be mindful of the performance cost of obtaining any information
 * that may be logged.  Also, it's important to keep in mind that this code may
 * get called from within an aborted transaction, in which case operations
 * such as syscache lookups are unsafe.
 *
 * Some notes about recursion and errors during error processing:
 *
 * We need to be robust about recursive-error scenarios --- for example,
 * if we run out of memory, it's important to be able to report that fact.
 * There are a number of considerations that go into this.
 *
 * First, distinguish between re-entrant use and actual recursion.  It
 * is possible for an error or warning message to be emitted while the
 * parameters for an error message are being computed.  In this case
 * errstart has been called for the outer message, and some field values
 * may have already been saved, but we are not actually recursing.  We handle
 * this by providing a (small) stack of ErrorData records.  The inner message
 * can be computed and sent without disturbing the state of the outer message.
 * (If the inner message is actually an error, this isn't very interesting
 * because control won't come back to the outer message generator ... but
 * if the inner message is only debug or log data, this is critical.)
 *
 * Second, actual recursion will occur if an error is reported by one of
 * the elog.c routines or something they call.  By far the most probable
 * scenario of this sort is "out of memory"; and it's also the nastiest
 * to handle because we'd likely also run out of memory while trying to
 * report this error!  Our escape hatch for this case is to reset the
 * ErrorContext to empty before trying to process the inner error.  Since
 * ErrorContext is guaranteed to have at least 8K of space in it (see mcxt.c),
 * we should be able to process an "out of memory" message successfully.
 * Since we lose the prior error state due to the reset, we won't be able
 * to return to processing the original error, but we wouldn't have anyway.
 * (NOTE: the escape hatch is not used for recursive situations where the
 * inner message is of less than ERROR severity; in that case we just
 * try to process it and return normally.  Usually this will work, but if
 * it ends up in infinite recursion, we will PANIC due to error stack
 * overflow.)
 *
 *
 * Portions Copyright (c) 2005-2009, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/error/elog.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;fcntl.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;time.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;signal.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;syslog.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_EXECINFO_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;execinfo.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/libpq.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqsignal.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/syslogger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tcop/tcopprot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>  <comment type="block">/* GpIdentity.segindex */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ps_status.h"</cpp:file></cpp:include>    <comment type="block">/* get_ps_display_username() */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbselect.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"pgtime.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>

<comment type="block">/*
 * dlfcn.h on OSX only has dladdr visible if _DARWIN_C_SOURCE is defined.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_DARWIN_C_SOURCE</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;dlfcn.h&gt;</cpp:file></cpp:include>

<comment type="block">/* In this module, access gettext() via err_gettext() */</comment>
<cpp:undef>#<cpp:directive>undef</cpp:directive> <name>_</name></cpp:undef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>_</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>err_gettext(x)</cpp:value></cpp:define>


<comment type="block">/* Global variables */</comment>
<decl_stmt><decl><type><name>ErrorContextCallback</name> <modifier>*</modifier></type><name>error_context_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>sigjmp_buf</name> <modifier>*</modifier></type><name>PG_exception_stack</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>extern</specifier> <name>bool</name></type> <name>redirection_done</name></decl>;</decl_stmt>

<comment type="block">/*
 * Hook for intercepting messages before they are sent to the server log.
 * Note that the hook will not get called for messages that are suppressed
 * by log_min_messages.  Also note that logging hooks implemented in preload
 * libraries will miss any log messages that are generated before the
 * library is loaded.
 */</comment>
<decl_stmt><decl><type><name>emit_log_hook_type</name></type> <name>emit_log_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* GUC parameters */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>Log_error_verbosity</name> <init>= <expr><name>PGERROR_VERBOSE</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>Log_line_prefix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt> <comment type="block">/* format for extra log line info */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>Log_destination</name> <init>= <expr><name>LOG_DESTINATION_STDERR</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>Log_destination_string</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>syslog_sequence_numbers</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>bool</name></type>		<name>syslog_split_messages</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>

<comment type="block">/*
 * Max string length to send to syslog().  Note that this doesn't count the
 * sequence-number prefix we add, and of course it doesn't count the prefix
 * added by syslog itself.  Solaris and sysklogd truncate the final message
 * at 1024 bytes, so this value leaves 124 bytes for those prefixes.  (Most
 * other syslog implementations seem to have limits of 2KB or so.)
 */</comment>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>PG_SYSLOG_LIMIT</name></cpp:ifndef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PG_SYSLOG_LIMIT</name></cpp:macro> <cpp:value>900</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>openlog_done</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>syslog_ident</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>syslog_facility</name> <init>= <expr><name>LOG_LOCAL0</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_syslog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<decl_stmt><decl><type><specifier>extern</specifier> <name>char</name> <modifier>*</modifier></type><name>event_source</name></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_eventlog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* We provide a small stack of ErrorData records for re-entrant cases */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ERRORDATA_STACK_SIZE</name></cpp:macro>  <cpp:value>10</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CMD_BUFFER_SIZE</name></cpp:macro>  <cpp:value>1024</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SYMBOL_SIZE</name></cpp:macro>      <cpp:value>512</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADDRESS_SIZE</name></cpp:macro>     <cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>STACK_DEPTH_MAX</name></cpp:macro>  <cpp:value>100</cpp:value></cpp:define>

<comment type="block">/*
 * Assembly code, gets the values of the frame pointer.
 * It only works for x86 processors.
 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call></expr></cpp:if>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASMFP</name></cpp:macro> <cpp:value>asm volatile ("movl %%ebp, %0" : "=g" (ulp));</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_PTR_FROM_VALUE</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((uint32)value)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_FRAME_POINTER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { uint64 ulp; ASMFP; x = ulp; } while (0)</cpp:value></cpp:define>
<cpp:elif>#<cpp:directive>elif</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:elif>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASMFP</name></cpp:macro> <cpp:value>asm volatile ("movq %%rbp, %0" : "=g" (ulp));</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_PTR_FROM_VALUE</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(value)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_FRAME_POINTER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>do { uint64 ulp; ASMFP; x = ulp; } while (0)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ASMFP</name></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_PTR_FROM_VALUE</name><parameter_list>(<parameter><type><name>value</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(value)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>GET_FRAME_POINTER</name><parameter_list>(<parameter><type><name>x</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>


<decl_stmt><decl><type><specifier>static</specifier> <name>ErrorData</name></type> <name><name>errordata</name><index>[<expr><name>ERRORDATA_STACK_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>errordata_stack_depth</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* index of topmost active frame */</comment>

<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>recursion_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* to detect actual recursion */</comment>

<comment type="block">/*
 * Saved timeval and buffers for formatted timestamps that might be used by
 * both log_line_prefix and csv logs.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name><name>struct</name> <name>timeval</name></name></type> <name>saved_timeval</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>saved_timeval_set</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FORMATTED_TS_LEN</name></cpp:macro> <cpp:value>128</cpp:value></cpp:define>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>formatted_start_time</name><index>[<expr><name>FORMATTED_TS_LEN</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>formatted_log_time</name><index>[<expr><name>FORMATTED_TS_LEN</name></expr>]</index></name></decl>;</decl_stmt>


<comment type="block">/* Macro for checking errordata_stack_depth is reasonable */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHECK_STACK_DEPTH</name><parameter_list>()</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (errordata_stack_depth &lt; 0) \
		{ \
			errordata_stack_depth = -1; \
			ereport(ERROR, (errmsg_internal("errstart was not called"))); \
		} \
	} while (0)</cpp:value></cpp:define>


<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>cdb_tidy_message</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>err_gettext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list> pg_attribute_format_arg<parameter_list>(</parameter_list>1</function_decl>)<empty_stmt>;</empty_stmt>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>set_errdata_field</name><parameter_list>(<parameter><decl><type><name>MemoryContextData</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_console</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_formatted_log_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_formatted_start_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>process_log_prefix_padding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>padding</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>log_line_prefix</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_csvlog</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>send_message_to_server_log</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_pipe_chunks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>send_message_to_frontend</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>error_severity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>append_with_tabs</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_log_level_output</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_min_level</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_pipe_chunks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>write_csvlog</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>elog_debug_linger</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* GPDB: wrapper function to silence unused result warning */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>ignore_returned_result</name><parameter_list>(<parameter><decl><type><name>long</name> <name>long</name> <name>int</name></type> <name>result</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>result</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_formatted_log_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>setup_formatted_start_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * in_error_recursion_trouble --- are we at risk of infinite error recursion?
 *
 * This function exists to provide common control of various fallback steps
 * that we take if we think we are facing infinite error recursion.  See the
 * callers for details.
 */</comment>
<function><type><name>bool</name></type>
<name>in_error_recursion_trouble</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Pull the plug if recurse more than once */</comment>
	<return>return <expr><operator>(</operator><name>recursion_depth</name> <operator>&gt;</operator> <literal type="number">2</literal><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * One of those fallback steps is to stop trying to localize the error
 * message, since there's a significant probability that that's exactly
 * what's causing the recursion.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>err_gettext</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ENABLE_NLS</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>in_error_recursion_trouble</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>str</name></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>gettext</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><name>str</name></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * errstart --- begin an error-reporting cycle
 *
 * Create and initialize error stack entry.  Subsequently, errmsg() and
 * perhaps other routines will be called to further populate the stack entry.
 * Finally, errfinish() will be called to actually process the error report.
 *
 * Returns true in normal case.  Returns false to short-circuit the error
 * report (if it's a warning or lower and not to be reported anywhere).
 */</comment>
<function><type><name>bool</name></type>
<name>errstart</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>output_to_server</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>output_to_client</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check some cases in which we want to promote an error into a more
	 * severe error.  None of this logic applies for non-error messages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If we are inside a critical section, all errors become PANIC
		 * errors.  See miscadmin.h.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>CritSectionCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>PANIC</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Check reasons for treating ERROR as FATAL:
		 *
		 * 1. we have no handler to pass the error to (implies we are in the
		 * postmaster or in backend startup).
		 *
		 * 2. ExitOnAnyError mode switch is set (initdb uses this).
		 *
		 * 3. the error occurred after proc_exit has begun to run.  (It's
		 * proc_exit's responsibility to see that this doesn't turn into
		 * infinite recursion!)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>ERROR</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>PG_exception_stack</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<name>ExitOnAnyError</name> <operator>||</operator>
				<name>proc_exit_inprogress</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>FATAL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If master process hits FATAL, post PREPARE but before COMMIT / ABORT on segment,
		 * just master process dies silently, leaves dangling prepared xact on segment.
		 * This also introduces inconsistency in the cluster, as xact is commited on master
		 * and some segments and still in-progress on few others.
		 * Hence converting FATAL to PANIC, here to reset master and perform full recovery
		 * instead, which would clean the dangling transaction update to COMMIT / ABORT.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>elevel</name> <operator>==</operator> <name>FATAL</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><call><name>getCurrentDtxState</name><argument_list>()</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>DTX_STATE_PREPARING</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_PREPARED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_INSERTING_COMMITTED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_INSERTED_COMMITTED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_NOTIFYING_COMMIT_PREPARED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_NOTIFYING_ABORT_SOME_PREPARED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_NOTIFYING_ABORT_PREPARED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_RETRY_COMMIT_PREPARED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_RETRY_ABORT_PREPARED</name></expr>:</case>
					<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name>PANIC</name></expr>;</expr_stmt>
					<break>break;</break>

				<case>case <expr><name>DTX_STATE_NONE</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_ACTIVE_DISTRIBUTED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_ONE_PHASE_COMMIT</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_NOTIFYING_ONE_PHASE_COMMIT</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_INSERTING_FORGET_COMMITTED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_INSERTED_FORGET_COMMITTED</name></expr>:</case>
				<case>case <expr><name>DTX_STATE_NOTIFYING_ABORT_NO_PREPARED</name></expr>:</case>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the error level is ERROR or more, errfinish is not going to
		 * return to caller; therefore, if there is any stacked error already
		 * in progress it will be lost.  This is more or less okay, except we
		 * do not want to have a FATAL or PANIC error downgraded because the
		 * reporting process was interrupted by a lower-grade error.  So check
		 * the stack and make sure we panic if panic is warranted.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>errordata_stack_depth</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name>elevel</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name><name>errordata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>elevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now decide whether we need to process this report at all; if it's
	 * warning or less and not enabled for logging, just return false without
	 * starting up any error logging machinery.
	 */</comment>

	<comment type="block">/* Determine whether message is enabled for server log output */</comment>
	<expr_stmt><expr><name>output_to_server</name> <operator>=</operator> <call><name>is_log_level_output</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>log_min_messages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Determine whether message is enabled for client output */</comment>
	<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name> <operator>&amp;&amp;</operator> <name>elevel</name> <operator>!=</operator> <name>LOG_SERVER_ONLY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * client_min_messages is honored only after we complete the
		 * authentication handshake.  This is required both for security
		 * reasons and because many clients can't handle NOTICE messages
		 * during authentication.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ClientAuthInProgress</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>output_to_client</name> <operator>=</operator> <operator>(</operator><name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>output_to_client</name> <operator>=</operator> <operator>(</operator><name>elevel</name> <operator>&gt;=</operator> <name>client_min_messages</name> <operator>||</operator>
								<name>elevel</name> <operator>==</operator> <name>INFO</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Skip processing effort if non-error message will not be output */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&lt;</operator> <name>ERROR</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>output_to_server</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>output_to_client</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We need to do some actual work.  Make sure that memory context
	 * initialization has finished, else we can't do anything useful.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ErrorContext</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Oops, hard crash time; very little we can do safely here */</comment>
		<expr_stmt><expr><call><name>write_stderr</name><argument_list>(<argument><expr><literal type="string">"error occurred before error message processing is available\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>exit</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Okay, crank up a stack entry to store the info in.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>recursion_depth</name><operator>++</operator> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Oops, error during error processing.  Clear ErrorContext as
		 * discussed at top of file.  We will not return to the original
		 * error's reporter or handler, so we don't need it.
		 */</comment>
		<expr_stmt><expr><call><name>MemoryContextReset</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Infinite error recursion might be due to something broken in a
		 * context traceback routine.  Abandon them too.  We also abandon
		 * attempting to print the error statement (which, if long, could
		 * itself be the source of the recursive failure).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>in_error_recursion_trouble</name><argument_list>()</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>debug_query_string</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

			<comment type="block">/*
			 * If we recurse too many times, this could mean that we have
			 * serious out of memory problems. We bail out immediately here.
			 * See MPP-2440.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>recursion_depth</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <name>ERRORDATA_STACK_SIZE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>false</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>++</operator><name>errordata_stack_depth</name> <operator>&gt;=</operator> <name>ERRORDATA_STACK_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Wups, stack not big enough.  We treat this as a PANIC condition
		 * because it suggests an infinite loop of errors during error
		 * recovery.
		 */</comment>
		<expr_stmt><expr><name>errordata_stack_depth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* make room on stack */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"ERRORDATA_STACK_SIZE exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Initialize data for this error frame */</comment>
	<expr_stmt><expr><name>edata</name> <operator>=</operator> <operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>elevel</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name> <operator>=</operator> <name>output_to_server</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_client</name></name> <operator>=</operator> <name>output_to_client</name></expr>;</expr_stmt>
	<comment type="block">/* the default text domain is the backend's */</comment>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name> <operator>=</operator> <ternary><condition><expr><name>domain</name></expr> ?</condition><then> <expr><name>domain</name></expr> </then><else>: <expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<comment type="block">/* initialize context_domain the same way (see set_errcontext_domain()) */</comment>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>context_domain</name></name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<comment type="block">/* Select default errcode based on elevel */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_INTERNAL_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>WARNING</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_WARNING</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_SUCCESSFUL_COMPLETION</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<comment type="block">/* errno is saved here so that error parameter eval can't change it */</comment>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name> <operator>=</operator> <name>errno</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BACKTRACE_SYMBOLS</name></cpp:ifdef>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>stacktracesize</name></name> <operator>=</operator> <call><name>backtrace</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stacktracearray</name></name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>stacktracesize</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Any allocations for this error state level should go into ErrorContext
	 */</comment>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name> <operator>=</operator> <name>ErrorContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * errfinish --- end an error-reporting cycle
 *
 * Produce the appropriate error report(s) and pop the error stack.
 *
 * If elevel, as passed to errstart(), is ERROR or worse, control does not
 * return to the caller.  See elog.h for the error level definitions.
 */</comment>
<function><type><name>void</name></type>
<name>errfinish</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>elevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>saved_errno</name></decl>;</decl_stmt>            <comment type="block">/*CDB*/</comment>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>saved_errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt>   <comment type="block">/*CDB*/</comment>

	<comment type="block">/* Save the last few bits of error state into the stack entry */</comment>
	<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash</name></decl>;</decl_stmt>

		<comment type="block">/* keep only base name, useful especially for vpath builds */</comment>
		<expr_stmt><expr><name>slash</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>slash</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>slash</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>elevel</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do processing in ErrorContext, which we hope has enough reserved space
	 * to report an error.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call any context callback functions.  Errors occurring in callback
	 * functions will be treated as recursive errors --- this ensures we will
	 * avoid infinite recursion (see errstart).
	 */</comment>
	<for>for <control>(<init><expr><name>econtext</name> <operator>=</operator> <name>error_context_stack</name></expr>;</init>
		 <condition><expr><name>econtext</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>econtext</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>previous</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>econtext</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * If ERROR (not more nor less) we pass it off to the current handler.
	 * Printing it and popping the stack is the responsibility of the handler.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>ERROR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We do some minimal cleanup before longjmp'ing so that handlers can
		 * execute in a reasonably sane state.
		 *
		 * Reset InterruptHoldoffCount in case we ereport'd from inside an
		 * interrupt holdoff section.  (We assume here that no handler will
		 * itself be inside a holdoff section.  If necessary, such a handler
		 * could save and restore InterruptHoldoffCount for itself, but this
		 * should make life easier for most.)
		 */</comment>
		<expr_stmt><expr><name>InterruptHoldoffCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>QueryCancelHoldoffCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>CritSectionCount</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>	<comment type="block">/* should be unnecessary, but... */</comment>

		<comment type="block">/*
		 * Note that we leave CurrentMemoryContext set to ErrorContext. The
		 * handler should reset it to something else soon.
		 */</comment>

		<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we are doing FATAL or PANIC, abort any old-style COPY OUT in
	 * progress, so that we can report the message before dying.  (Without
	 * this, pq_putmessage will refuse to send the message at all, which is
	 * what we want for NOTICE messages, but not for fatal exits.) This hack
	 * is necessary because of poor design of old-style copy protocol.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>FATAL</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_endcopyout</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* CDB: If fatal internal error, linger so user can attach a debugger. */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>FATAL</name> <operator>&amp;&amp;</operator>
		<name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>==</operator> <name>ERRCODE_INTERNAL_ERROR</name> <operator>&amp;&amp;</operator>
		<name>gp_debug_linger</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog_debug_linger</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>

	<comment type="block">/* Emit the message to the right places */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

    <comment type="block">/*
     * CDB: Let caller take care of terminating the process, if requested.
     * Used by CdbProgramErrorHandler() to re-raise a signal such as SIGSEGV
     * in order to produce a core file.  We don't want to get involved in
     * platform dependent signal handling here, so let caller do it.
     */</comment>
    <if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>FATAL</name> <operator>&amp;&amp;</operator>
        <name><name>edata</name><operator>-&gt;</operator><name>fatal_return</name></name></expr>)</condition>
    <block>{<block_content>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
        <expr_stmt><expr><name>errno</name> <operator>=</operator> <name>saved_errno</name></expr>;</expr_stmt>
        <return>return;</return>
    </block_content>}</block></if></if_stmt>

	<comment type="block">/* Now free up subsidiary data attached to stack entry, and release it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errordata_stack_depth</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* Exit error-handling context */</comment>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Perform error recovery action as specified by elevel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>FATAL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For a FATAL error, we let proc_exit clean up and exit.
		 *
		 * If we just reported a startup failure, the client will disconnect
		 * on receiving it, so don't send any more to the client.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>PG_exception_stack</name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>whereToSendOutput</name> <operator>=</operator> <name>DestNone</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * fflush here is just to improve the odds that we get to see the
		 * error message, in case things are so hosed that proc_exit crashes.
		 * Any other code you might be tempted to add here should probably be
		 * in an on_proc_exit or on_shmem_exit callback instead.
		 */</comment>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Do normal process-exit cleanup, then return exit code 1 to indicate
		 * FATAL termination.  The postmaster may or may not consider this
		 * worthy of panic, depending on which subprocess returns it.
		 */</comment>
		<expr_stmt><expr><call><name>proc_exit</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>PANIC</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Serious crash time. Postmaster will observe SIGABRT process exit
		 * status and kill the other backends too.
		 *
		 * XXX: what if we are *in* the postmaster?  abort() won't kill our
		 * children...
		 */</comment>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>abort</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check for cancel/die interrupt first --- this is so that the user can
	 * stop a query emitting tons of notice or warning messages, even if it's
	 * in a loop that otherwise fails to check for interrupts.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>saved_errno</name></expr>;</expr_stmt>                <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Finish constructing an error like errfinish(), but instead of throwing it,
 * return it to the caller as a palloc'd ErrorData object.
 */</comment>
<function><type><name>ErrorData</name> <modifier>*</modifier></type>
<name>errfinish_and_return</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata_copy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>saved_errno</name></decl>;</decl_stmt>            <comment type="block">/*CDB*/</comment>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>saved_errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt>   <comment type="block">/*CDB*/</comment>

	<comment type="block">/* Save the last few bits of error state into the stack entry */</comment>
	<if_stmt><if>if <condition>(<expr><name>filename</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>slash</name></decl>;</decl_stmt>

		<comment type="block">/* keep only base name, useful especially for vpath builds */</comment>
		<expr_stmt><expr><name>slash</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>filename</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>slash</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>filename</name> <operator>=</operator> <name>slash</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name> <operator>=</operator> <name>filename</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Do processing in ErrorContext, which we hope has enough reserved space
	 * to report an error.
	 */</comment>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call any context callback functions.  Errors occurring in callback
	 * functions will be treated as recursive errors --- this ensures we will
	 * avoid infinite recursion (see errstart).
	 */</comment>
	<for>for <control>(<init><expr><name>econtext</name> <operator>=</operator> <name>error_context_stack</name></expr>;</init>
		 <condition><expr><name>econtext</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>econtext</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>previous</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name><name>econtext</name><operator>-&gt;</operator><name>callback</name></name>) <argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edata_copy</name> <operator>=</operator> <call><name>CopyErrorData</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Now free up subsidiary data attached to stack entry, and release it */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errordata_stack_depth</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* Exit error-handling context */</comment>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name>saved_errno</name></expr>;</expr_stmt>                <comment type="block">/*CDB*/</comment>

	<return>return <expr><name>edata_copy</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * errcode --- add SQLSTATE error code to the current error
 *
 * The code is expected to be represented as per MAKE_SQLSTATE().
 */</comment>
<function><type><name>void</name></type>
<name>errcode</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sqlerrcode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>sqlerrcode</name></expr>;</expr_stmt>

	<comment type="block">/* Indicate that we want stack traces etc for internal errors */</comment>
	<if_stmt><if>if <condition>(<expr><name>sqlerrcode</name> <operator>==</operator> <name>ERRCODE_INTERNAL_ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * errcode_for_file_access --- add SQLSTATE error code to the current error
 *
 * The SQLSTATE code is chosen based on the saved errno value.  We assume
 * that the failing operation was some type of disk file access.
 *
 * NOTE: the primary error message string should generally include %m
 * when this is used.
 */</comment>
<function><type><name>void</name></type>
<name>errcode_for_file_access</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* Permission-denied failures */</comment>
		<case>case <expr><name>EPERM</name></expr>:</case>				<comment type="block">/* Not super-user */</comment>
		<case>case <expr><name>EACCES</name></expr>:</case>			<comment type="block">/* Permission denied */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>EROFS</name></cpp:ifdef>
		<case>case <expr><name>EROFS</name></expr>:</case>				<comment type="block">/* Read only file system */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_INSUFFICIENT_PRIVILEGE</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* File not found */</comment>
		<case>case <expr><name>ENOENT</name></expr>:</case>			<comment type="block">/* No such file or directory */</comment>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_UNDEFINED_FILE</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* Duplicate file */</comment>
		<case>case <expr><name>EEXIST</name></expr>:</case>			<comment type="block">/* File exists */</comment>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_DUPLICATE_FILE</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* Wrong object type or state */</comment>
		<case>case <expr><name>ENOTDIR</name></expr>:</case>			<comment type="block">/* Not a directory */</comment>
		<case>case <expr><name>EISDIR</name></expr>:</case>			<comment type="block">/* Is a directory */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>ENOTEMPTY</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><name>ENOTEMPTY</name> <operator>!=</operator> <name>EEXIST</name><operator>)</operator></expr></cpp:if> <comment type="block">/* same code on AIX */</comment>
		<case>case <expr><name>ENOTEMPTY</name></expr>:</case>			<comment type="block">/* Directory not empty */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_WRONG_OBJECT_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* Insufficient resources */</comment>
		<case>case <expr><name>ENOSPC</name></expr>:</case>			<comment type="block">/* No space left on device */</comment>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_DISK_FULL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>ENFILE</name></expr>:</case>			<comment type="block">/* File table overflow */</comment>
		<case>case <expr><name>EMFILE</name></expr>:</case>			<comment type="block">/* Too many open files */</comment>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* Hardware failure */</comment>
		<case>case <expr><name>EIO</name></expr>:</case>				<comment type="block">/* I/O error */</comment>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_IO_ERROR</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* All else is classified as internal errors */</comment>
		<default>default:</default>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_INTERNAL_ERROR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * errcode_for_socket_access --- add SQLSTATE error code to the current error
 *
 * The SQLSTATE code is chosen based on the saved errno value.  We assume
 * that the failing operation was some type of socket access.
 *
 * NOTE: the primary error message string should generally include %m
 * when this is used.
 */</comment>
<function><type><name>void</name></type>
<name>errcode_for_socket_access</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/* Loss of connection */</comment>
		<case>case <expr><name>EPIPE</name></expr>:</case>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>ECONNRESET</name></cpp:ifdef>
		<case>case <expr><name>ECONNRESET</name></expr>:</case>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_CONNECTION_FAILURE</name></expr>;</expr_stmt>
			<break>break;</break>

			<comment type="block">/* All else is classified as internal errors */</comment>
		<default>default:</default>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name>ERRCODE_INTERNAL_ERROR</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Convert compact error code (ERRCODE_xxx) to 5-char SQLSTATE string,
 * and put it into a 6-char buffer provided by caller.
 */</comment>
<function><type><name>void</name></type>
<name>errcode_to_sqlstate</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errcode</name></decl></parameter>, <parameter><decl><type><name>char</name></type> <name><name>outbuf</name><index>[<expr><literal type="number">6</literal></expr>]</index></name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>	<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>outbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PGUNSIXBIT</name><argument_list>(<argument><expr><name>errcode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>errcode</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>outbuf</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Convert SQLSTATE string to compact error code (ERRCODE_xxx).
 */</comment>
<function><type><name>int</name></type>
<name>sqlstate_to_errcode</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sqlstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>MAKE_SQLSTATE</name><argument_list>(<argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr></argument>,
						 <argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sqlstate</name><index>[<expr><literal type="number">4</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * This macro handles expansion of a format string and associated parameters;
 * it's common code for errmsg(), errdetail(), etc.  Must be called inside
 * a routine that is declared like "const char *fmt, ..." and has an edata
 * pointer set up.  The message is assigned to edata-&gt;targetfield, or
 * appended to it if appendval is true.  The message is subject to translation
 * if translateit is true.
 *
 * Note: we pstrdup the buffer rather than just transferring its storage
 * to the edata field because the buffer might be considerably larger than
 * really necessary.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVALUATE_MESSAGE</name><parameter_list>(<parameter><type><name>domain</name></type></parameter>, <parameter><type><name>targetfield</name></type></parameter>, <parameter><type><name>appendval</name></type></parameter>, <parameter><type><name>translateit</name></type></parameter>)</parameter_list></cpp:macro>	\
	<cpp:value>{ \
		StringInfoData	buf; \
		<comment type="block">/* Internationalize the error format string */</comment> \
		if ((translateit) &amp;&amp; !in_error_recursion_trouble()) \
			fmt = dgettext((domain), fmt);				  \
		initStringInfo(&amp;buf); \
		if ((appendval) &amp;&amp; edata-&gt;targetfield) { \
			appendStringInfoString(&amp;buf, edata-&gt;targetfield); \
			appendStringInfoChar(&amp;buf, '\n'); \
		} \
		<comment type="block">/* Generate actual output --- have to use appendStringInfoVA */</comment> \
		for (;;) \
		{ \
			va_list		args; \
			int			needed; \
			errno = edata-&gt;saved_errno; \
			va_start(args, fmt); \
			needed = appendStringInfoVA(&amp;buf, fmt, args); \
			va_end(args); \
			if (needed == 0) \
				break; \
			enlargeStringInfo(&amp;buf, needed); \
		} \
		<comment type="block">/* Save the completed message into the stack item */</comment> \
		if (edata-&gt;targetfield) \
			pfree(edata-&gt;targetfield); \
		edata-&gt;targetfield = pstrdup(buf.data); \
		pfree(buf.data); \
	}</cpp:value></cpp:define>

<comment type="block">/*
 * Same as above, except for pluralized error messages.  The calling routine
 * must be declared like "const char *fmt_singular, const char *fmt_plural,
 * unsigned long n, ...".  Translation is assumed always wanted.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>EVALUATE_MESSAGE_PLURAL</name><parameter_list>(<parameter><type><name>domain</name></type></parameter>, <parameter><type><name>targetfield</name></type></parameter>, <parameter><type><name>appendval</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>{ \
		const char	   *fmt; \
		StringInfoData	buf; \
		<comment type="block">/* Internationalize the error format string */</comment> \
		if (!in_error_recursion_trouble()) \
			fmt = dngettext((domain), fmt_singular, fmt_plural, n); \
		else \
			fmt = (n == 1 ? fmt_singular : fmt_plural); \
		initStringInfo(&amp;buf); \
		if ((appendval) &amp;&amp; edata-&gt;targetfield) { \
			appendStringInfoString(&amp;buf, edata-&gt;targetfield); \
			appendStringInfoChar(&amp;buf, '\n'); \
		} \
		<comment type="block">/* Generate actual output --- have to use appendStringInfoVA */</comment> \
		for (;;) \
		{ \
			va_list		args; \
			int			needed; \
			errno = edata-&gt;saved_errno; \
			va_start(args, n); \
			needed = appendStringInfoVA(&amp;buf, fmt, args); \
			va_end(args); \
			if (needed == 0) \
				break; \
			enlargeStringInfo(&amp;buf, needed); \
		} \
		<comment type="block">/* Save the completed message into the stack item */</comment> \
		if (edata-&gt;targetfield) \
			pfree(edata-&gt;targetfield); \
		edata-&gt;targetfield = pstrdup(buf.data); \
		pfree(buf.data); \
	}</cpp:value></cpp:define>


<comment type="block">/*
 * errmsg --- add a primary error message text to the current error
 *
 * In addition to the usual %-escapes recognized by printf, "%m" in
 * fmt is replaced by the error message for the caller's value of errno.
 *
 * Note: no newline is needed at the end of the fmt string, since
 * ereport will provide one for the output methods that need it.
 */</comment>
<function><type><name>void</name></type>
<name>errmsg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>message_id</name></name> <operator>=</operator> <name>fmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>

<comment type="block">/*
 * errmsg_internal --- add a primary error message text to the current error
 *
 * This is exactly like errmsg() except that strings passed to errmsg_internal
 * are not translated, and are customarily left out of the
 * internationalization message dictionary.  This should be used for "can't
 * happen" cases that are probably not worth spending translation effort on.
 * We also use this for certain cases where we *must* not try to translate
 * the message because the translation would fail and result in infinite
 * error recursion.
 */</comment>
<function><type><name>void</name></type>
<name>errmsg_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>message_id</name></name> <operator>=</operator> <name>fmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>


<comment type="block">/*
 * errmsg_plural --- add a primary error message text to the current error,
 * with support for pluralization of the message text
 */</comment>
<function><type><name>void</name></type>
<name>errmsg_plural</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt_singular</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt_plural</name></decl></parameter>,
			  <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>message_id</name></name> <operator>=</operator> <name>fmt_singular</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EVALUATE_MESSAGE_PLURAL</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>


<comment type="block">/*
 * errdetail --- add a detail error message text to the current error
 */</comment>
<function><type><name>void</name></type>
<name>errdetail</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>detail</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>


<comment type="block">/*
 * errdetail_internal --- add a detail error message text to the current error
 *
 * This is exactly like errdetail() except that strings passed to
 * errdetail_internal are not translated, and are customarily left out of the
 * internationalization message dictionary.  This should be used for detail
 * messages that seem not worth translating for one reason or another
 * (typically, that they don't seem to be useful to average users).
 */</comment>
<function><type><name>void</name></type>
<name>errdetail_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>detail</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * errdetail_log --- add a detail_log error message text to the current error
 */</comment>
<function><type><name>void</name></type>
<name>errdetail_log</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>detail_log</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>

<comment type="block">/*
 * errdetail_log_plural --- add a detail_log error message text to the current error
 * with support for pluralization of the message text
 */</comment>
<function><type><name>void</name></type>
<name>errdetail_log_plural</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt_singular</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt_plural</name></decl></parameter>,
					 <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EVALUATE_MESSAGE_PLURAL</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>detail_log</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * errdetail_plural --- add a detail error message text to the current error,
 * with support for pluralization of the message text
 */</comment>
<function><type><name>void</name></type>
<name>errdetail_plural</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt_singular</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt_plural</name></decl></parameter>,
				 <parameter><decl><type><name>unsigned</name> <name>long</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EVALUATE_MESSAGE_PLURAL</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>detail</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>


<comment type="block">/*
 * errhint --- add a hint error message text to the current error
 */</comment>
<function><type><name>void</name></type>
<name>errhint</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>hint</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>


<comment type="block">/*
 * errcontext_msg --- add a context error message text to the current error
 *
 * Unlike other cases, multiple calls are allowed to build up a stack of
 * context information.  We assume earlier calls represent more-closely-nested
 * states.
 */</comment>
<function><type><name>void</name></type>
<name>errcontext_msg</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context_domain</name></name></expr></argument>, <argument><expr><name>context</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>

<comment type="block">/*
 * set_errcontext_domain --- set message domain to be used by errcontext()
 *
 * errcontext_msg() can be called from a different module than the original
 * ereport(), so we cannot use the message domain passed in errstart() to
 * translate it.  Instead, each errcontext_msg() call should be preceded by
 * a set_errcontext_domain() call to specify the domain.  This is usually
 * done transparently by the errcontext() macro.
 */</comment>
<function><type><name>void</name></type>
<name>set_errcontext_domain</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* the default text domain is the backend's */</comment>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>context_domain</name></name> <operator>=</operator> <ternary><condition><expr><name>domain</name></expr> ?</condition><then> <expr><name>domain</name></expr> </then><else>: <expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * errhidestmt --- optionally suppress STATEMENT: field of log entry
 *
 * This should be called if the message text already includes the statement.
 */</comment>
<function><type><name>void</name></type>
<name>errhidestmt</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>hide_stmt</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>hide_stmt</name></name> <operator>=</operator> <name>hide_stmt</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * errhidecontext --- optionally suppress CONTEXT: field of log entry
 *
 * This should only be used for verbose debugging messages where the repeated
 * inclusion of context would bloat the log volume too much.
 */</comment>
<function><type><name>void</name></type>
<name>errhidecontext</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>hide_ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>hide_ctx</name></name> <operator>=</operator> <name>hide_ctx</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * errfunction --- add reporting function name to the current error
 *
 * This is used when backwards compatibility demands that the function
 * name appear in messages sent to old-protocol clients.  Note that the
 * passed string is expected to be a non-freeable constant string.
 */</comment>
<function><type><name>void</name></type>
<name>errfunction</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name> <operator>=</operator> <name>funcname</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>show_funcname</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * errposition --- add cursor position to the current error
 */</comment>
<function><type><name>void</name></type>
<name>errposition</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cursorpos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name> <operator>=</operator> <name>cursorpos</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * errprintstack -- force print out stack trace
 */</comment>
<function><type><name>int</name></type>
<name>errprintstack</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>printstack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>printstack</name></name> <operator>=</operator> <name>printstack</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * internalerrposition --- add internal cursor position to the current error
 */</comment>
<function><type><name>void</name></type>
<name>internalerrposition</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>cursorpos</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name> <operator>=</operator> <name>cursorpos</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * internalerrquery --- add internal query text to the current error
 *
 * Can also pass NULL to drop the internal query text entry.  This case
 * is intended for use in error callback subroutines that are editorializing
 * on the layout of the error report.
 */</comment>
<function><type><name>void</name></type>
<name>internalerrquery</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>query</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>, <argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>errno</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name></expr>;</expr_stmt> <comment type="block">/*CDB*/</comment>
</block_content>}</block></function>

<comment type="block">/*
 * err_generic_string -- used to set individual ErrorData string fields
 * identified by PG_DIAG_xxx codes.
 *
 * This intentionally only supports fields that don't use localized strings,
 * so that there are no translation considerations.
 *
 * Most potential callers should not use this directly, but instead prefer
 * higher-level abstractions, such as errtablecol() (see relcache.c).
 */</comment>
<function><type><name>void</name></type>
<name>err_generic_string</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>field</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>field</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>PG_DIAG_SCHEMA_NAME</name></expr>:</case>
			<expr_stmt><expr><call><name>set_errdata_field</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PG_DIAG_TABLE_NAME</name></expr>:</case>
			<expr_stmt><expr><call><name>set_errdata_field</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PG_DIAG_COLUMN_NAME</name></expr>:</case>
			<expr_stmt><expr><call><name>set_errdata_field</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PG_DIAG_DATATYPE_NAME</name></expr>:</case>
			<expr_stmt><expr><call><name>set_errdata_field</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PG_DIAG_CONSTRAINT_NAME</name></expr>:</case>
			<expr_stmt><expr><call><name>set_errdata_field</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported ErrorData field id: %d"</literal></expr></argument>, <argument><expr><name>field</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * set_errdata_field --- set an ErrorData string field
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>set_errdata_field</name><parameter_list>(<parameter><decl><type><name>MemoryContextData</name> <modifier>*</modifier></type><name>cxt</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>ptr</name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ptr</name> <operator>=</operator> <call><name>MemoryContextStrdup</name><argument_list>(<argument><expr><name>cxt</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * geterrcode --- return the currently set SQLSTATE error code
 *
 * This is only intended for use in error callback subroutines, since there
 * is no other place outside elog.c where the concept is meaningful.
 */</comment>
<function><type><name>int</name></type>
<name>geterrcode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * geterrposition --- return the currently set error position (0 if none)
 *
 * This is only intended for use in error callback subroutines, since there
 * is no other place outside elog.c where the concept is meaningful.
 */</comment>
<function><type><name>int</name></type>
<name>geterrposition</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * getinternalerrposition --- same for internal error position
 *
 * This is only intended for use in error callback subroutines, since there
 * is no other place outside elog.c where the concept is meaningful.
 */</comment>
<function><type><name>int</name></type>
<name>getinternalerrposition</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * CDB: errFatalReturn -- set flag indicating errfinish() should return
 * to the caller instead of calling proc_exit() after reporting a FATAL
 * error.  Allows termination by re-raising a signal in order to obtain
 * a core dump.
 */</comment>
<function><type><name>int</name></type>
<name>errFatalReturn</name><parameter_list>(<parameter><decl><type><name>bool</name></type> <name>fatalReturn</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* we don't bother incrementing recursion_depth */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>fatal_return</name></name> <operator>=</operator> <name>fatalReturn</name></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* return value does not matter */</comment>
</block_content>}</block></function>


<comment type="block">/*
 * Functions to allow construction of error message strings separately from
 * the ereport() call itself.
 *
 * The expected calling convention is
 *
 *	pre_format_elog_string(errno, domain), var = format_elog_string(format,...)
 *
 * which can be hidden behind a macro such as GUC_check_errdetail().  We
 * assume that any functions called in the arguments of format_elog_string()
 * cannot result in re-entrant use of these functions --- otherwise the wrong
 * text domain might be used, or the wrong errno substituted for %m.  This is
 * okay for the current usage with GUC check hooks, but might need further
 * effort someday.
 *
 * The result of format_elog_string() is stored in ErrorContext, and will
 * therefore survive until FlushErrorState() is called.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>save_format_errnumber</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>save_format_domain</name></decl>;</decl_stmt>

<function><type><name>void</name></type>
<name>pre_format_elog_string</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>errnumber</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>domain</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Save errno before evaluation of argument functions can change it */</comment>
	<expr_stmt><expr><name>save_format_errnumber</name> <operator>=</operator> <name>errnumber</name></expr>;</expr_stmt>
	<comment type="block">/* Save caller's text domain */</comment>
	<expr_stmt><expr><name>save_format_domain</name> <operator>=</operator> <name>domain</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>char</name> <modifier>*</modifier></type>
<name>format_elog_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name></type>	<name>errdata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<comment type="block">/* Initialize a mostly-dummy error frame */</comment>
	<expr_stmt><expr><name>edata</name> <operator>=</operator> <operator>&amp;</operator><name>errdata</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* the default text domain is the backend's */</comment>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name> <operator>=</operator> <ternary><condition><expr><name>save_format_domain</name></expr> ?</condition><then> <expr><name>save_format_domain</name></expr> </then><else>: <expr><call><name>PG_TEXTDOMAIN</name><argument_list>(<argument><expr><literal type="string">"postgres"</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<comment type="block">/* set the errno to be used to interpret %m */</comment>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>saved_errno</name></name> <operator>=</operator> <name>save_format_errnumber</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>message_id</name></name> <operator>=</operator> <name>fmt</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>EVALUATE_MESSAGE</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>, <argument><expr><name>message</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Actual output of the top-of-stack error message
 *
 * In the ereport(ERROR) case this is called from PostgresMain (or not at all,
 * if the error is caught by somebody).  For all other severity levels this
 * is called by errfinish.
 */</comment>
<function><type><name>void</name></type>
<name>EmitErrorReport</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 
	 * CDB: Tidy up the message sent to client
	 *
	 * Strip trailing whitespace.
	 * Append file name and line numebr.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_client</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>cdb_tidy_message</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Call hook before sending message to log.  The hook function is allowed
	 * to turn off edata-&gt;output_to_server, so we must recheck that afterward.
	 * Making any other change in the content of edata is not considered
	 * supported.
	 *
	 * Note: the reason why the hook can only turn off output_to_server, and
	 * not turn it on, is that it'd be unreliable: we will never get here at
	 * all if errstart() deems the message uninteresting.  A hook that could
	 * make decisions in that direction would have to hook into errstart(),
	 * where it would have much less information available.  emit_log_hook is
	 * intended for custom log filtering and custom log message transmission
	 * mechanisms.
	 *
	 * The log hook has access to both the translated and original English
	 * error message text, which is passed through to allow it to be used as a
	 * message identifier. Note that the original text is not available for
	 * detail, detail_log, hint and context text elements.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name> <operator>&amp;&amp;</operator> <name>emit_log_hook</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>emit_log_hook</name>) <argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Send to server log, if enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>send_message_to_server_log</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Send to client, if enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_client</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>send_message_to_frontend</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CopyErrorData --- obtain a copy of the topmost error stack entry
 *
 * This is only for use in error handler code.  The data is copied into the
 * current memory context, so callers should always switch away from
 * ErrorContext first; otherwise it will be lost when FlushErrorState is done.
 */</comment>
<function><type><name>ErrorData</name> <modifier>*</modifier></type>
<name>CopyErrorData</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>newedata</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * we don't increment recursion_depth because out-of-memory here does not
	 * indicate a problem within the error subsystem.
	 */</comment>
	<expr_stmt><expr><call><name>CHECK_STACK_DEPTH</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CurrentMemoryContext</name> <operator>!=</operator> <name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the struct itself */</comment>
	<expr_stmt><expr><name>newedata</name> <operator>=</operator> <operator>(</operator><name>ErrorData</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newedata</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make copies of separately-allocated fields */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail_log</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>hint</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>schema_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>schema_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>table_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>column_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>column_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>datatype_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>constraint_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>internalquery</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Use the calling context for string allocation */</comment>
	<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>assoc_context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<return>return <expr><name>newedata</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * FreeErrorData --- free the structure returned by CopyErrorData.
 *
 * Error handlers should use this in preference to assuming they know all
 * the separately-allocated fields.
 */</comment>
<function><type><name>void</name></type>
<name>FreeErrorData</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * FlushErrorState --- flush the error state after error recovery
 *
 * This should be called by an error handler after it's done processing
 * the error; or as soon as it's done CopyErrorData, if it intends to
 * do stuff that is likely to provoke another error.  You are not "out" of
 * the error subsystem until you have done this.
 */</comment>
<function><type><name>void</name></type>
<name>FlushErrorState</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Reset stack to empty.  The only case where it would be more than one
	 * deep is if we serviced an error that interrupted construction of
	 * another message.  We assume control escaped out of that message
	 * construction and won't ever go back.
	 */</comment>
	<expr_stmt><expr><name>errordata_stack_depth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Delete all data in ErrorContext */</comment>
	<expr_stmt><expr><call><name>MemoryContextResetAndDeleteChildren</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ThrowErrorData --- report an error described by an ErrorData structure
 *
 * This is somewhat like ReThrowError, but it allows elevels besides ERROR,
 * and the boolean flags such as output_to_server are computed via the
 * default rules rather than being copied from the given ErrorData.
 * This is primarily used to re-report errors originally reported by
 * background worker processes and then propagated (with or without
 * modification) to the backend responsible for them.
 */</comment>
<function><type><name>void</name></type>
<name>ThrowErrorData</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>newedata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>errstart</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>domain</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* error is not to be reported at all */</comment>

	<expr_stmt><expr><name>newedata</name> <operator>=</operator> <operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>assoc_context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Copy the supplied fields to the error stack entry. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail_log</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>hint</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<comment type="block">/* assume message_id is not available */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>schema_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>table_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>column_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>datatype_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>constraint_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>cursorpos</name></name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>internalpos</name></name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>internalquery</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/* Process the error. */</comment>
	<expr_stmt><expr><call><name>errfinish</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ReThrowError --- re-throw a previously copied error
 *
 * A handler can do CopyErrorData/FlushErrorState to get out of the error
 * subsystem, then do some processing, and finally ReThrowError to re-throw
 * the original error.  This is slower than just PG_RE_THROW() but should
 * be used if the "some processing" is likely to incur another error.
 */</comment>
<function><type><name>void</name></type>
<name>ReThrowError</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>newedata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&lt;=</operator> <name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* CDB: Ok to rethrow elog_demote'd error */</comment>

	<comment type="block">/* Push the data back into the error context */</comment>
	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>ErrorContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>++</operator><name>errordata_stack_depth</name> <operator>&gt;=</operator> <name>ERRORDATA_STACK_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Wups, stack not big enough.  We treat this as a PANIC condition
		 * because it suggests an infinite loop of errors during error
		 * recovery.  Note that the message is intentionally not localized,
		 * else failure to convert it to client encoding could cause further
		 * recursion.
		 */</comment>
		<expr_stmt><expr><name>errordata_stack_depth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* make room on stack */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"ERRORDATA_STACK_SIZE exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>newedata</name> <operator>=</operator> <operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>newedata</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Make copies of separately-allocated fields */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail_log</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>hint</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>context</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>schema_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>schema_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>table_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>column_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>column_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>datatype_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>constraint_name</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>newedata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>internalquery</name></name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>newedata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Reset the assoc_context to be ErrorContext */</comment>
	<expr_stmt><expr><name><name>newedata</name><operator>-&gt;</operator><name>assoc_context</name></name> <operator>=</operator> <name>ErrorContext</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RE_THROW</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * pg_re_throw --- out-of-line implementation of PG_RE_THROW() macro
 */</comment>
<function><type><name>void</name></type>
<name>pg_re_throw</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* If possible, throw the error to the next outer setjmp handler */</comment>
	<if_stmt><if>if <condition>(<expr><name>PG_exception_stack</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>siglongjmp</name><argument_list>(<argument><expr><operator>*</operator><name>PG_exception_stack</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we get here, elog(ERROR) was thrown inside a PG_TRY block, which
		 * we have now exited only to discover that there is no outer setjmp
		 * handler to pass the error to.  Had the error been thrown outside
		 * the block to begin with, we'd have promoted the error to FATAL, so
		 * the correct behavior is to make it FATAL now; that is, emit it and
		 * then call proc_exit.
		 */</comment>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>errordata_stack_depth</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>==</operator> <name>ERROR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>FATAL</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * At least in principle, the increase in severity could have changed
		 * where-to-output decisions, so recalculate.  This should stay in
		 * sync with errstart(), which see for comments.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>IsPostmasterEnvironment</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name> <operator>=</operator> <call><name>is_log_level_output</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
														  <argument><expr><name>log_min_messages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name> <operator>=</operator> <operator>(</operator><name>FATAL</name> <operator>&gt;=</operator> <name>log_min_messages</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>whereToSendOutput</name> <operator>==</operator> <name>DestRemote</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_client</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We can use errfinish() for the rest, but we don't want it to call
		 * any error context routines a second time.  Since we know we are
		 * about to exit, it should be OK to just clear the context stack.
		 */</comment>
		<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>errfinish</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Doesn't return ... */</comment>
	<expr_stmt><expr><call><name>ExceptionalCondition</name><argument_list>(<argument><expr><literal type="string">"pg_re_throw tried to return"</literal></expr></argument>, <argument><expr><literal type="string">"FailedAssertion"</literal></expr></argument>,
						 <argument><expr><name>__FILE__</name></expr></argument>, <argument><expr><name>__LINE__</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * GPDB: elog_exception_statement
 * Write statement in log file if an exception was encountered during
 * its execution.
 */</comment>
<function><type><name>void</name></type>
<name>elog_exception_statement</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>statement</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>errordata_stack_depth</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>statement</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>edata</name> <operator>=</operator> <operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr>;</expr_stmt>
	<comment type="block">/*
	 * We should also honour whether hide the statement and GUC
	 * log_min_error_statement to prevent print the statement
	 * when error happens.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>edata</name><operator>-&gt;</operator><name>hide_stmt</name></name> <operator>&amp;&amp;</operator>
		<call><name>is_log_level_output</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>, <argument><expr><name>log_min_error_statement</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"An exception was encountered during the execution of statement: %s"</literal></expr></argument>,
			 <argument><expr><name>statement</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * CDB: elog_demote
 *
 * A PG_CATCH() handler can call this to downgrade the error that it is
 * currently handling to a level lower than ERROR.  The caller should
 * then do PG_RE_THROW() to proceed to the next error handler.
 *
 * Clients using libpq cannot receive normal output together with an error.
 * The libpq frontend discards any results already buffered when a command
 * completes with an error notification of level ERROR or higher.
 *
 * elog_demote() can be used to reduce the error level reported to the client
 * so that libpq won't suppress normal output, while the backend still frees
 * resources, aborts the transaction, etc, as usual.
 *
 * Returns true if successful, false if the request is disallowed.
 */</comment>
<function><type><name>bool</name></type>
<name>elog_demote</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>downgrade_to_elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>errordata_stack_depth</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>errordata_stack_depth</name> <operator>&gt;=</operator> <name>ERRORDATA_STACK_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>edata</name> <operator>=</operator> <operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>downgrade_to_elevel</name> <operator>&gt;=</operator> <name>ERROR</name> <operator>||</operator>
		<name>recursion_depth</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&gt;</operator> <name>ERROR</name> <operator>||</operator>
		<name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&lt;</operator> <name>downgrade_to_elevel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>downgrade_to_elevel</name></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>							   <comment type="block">/* elog_demote */</comment>


<comment type="block">/*
 * CDB: elog_dismiss
 *
 * A PG_CATCH() handler can call this to downgrade the error that it is
 * currently handling to a level lower than ERROR, report it to the log
 * and/or client as appropriate, and purge it from the error system.
 *
 * This shouldn't be attempted unless the caller is certain that the
 * error does not need the services of upper level error handlers to
 * release resources, abort the transaction, etc.
 *
 * Returns true if successful, in which case the error has been expunged
 * and the caller should not do PG_RE_THROW(), but should instead fall or
 * jump out of the PG_CATCH() handler and resume normal execution.
 *
 * Returns false if unsuccessful; then the caller should carry on as
 * PG_CATCH() handlers ordinarily do, and exit via PG_RE_THROW().
 */</comment>
<function><type><name>bool</name></type>
<name>elog_dismiss</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>downgrade_to_elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorContextCallback</name>   <modifier>*</modifier></type><name>saveCallbackStack</name> <init>= <expr><name>error_context_stack</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorData</name>			   <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>					<name>shouldEmit</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>errordata_stack_depth</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>errordata_stack_depth</name> <operator>&gt;=</operator> <name>ERRORDATA_STACK_SIZE</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>edata</name> <operator>=</operator> <operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>downgrade_to_elevel</name> <operator>&gt;=</operator> <name>ERROR</name> <operator>||</operator>
		<name>recursion_depth</name> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&gt;</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Context callbacks, if any, were already invoked when this error
	 * first passed through errfinish.  Hide them so they won't be
	 * called redundantly.
	 */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<comment type="block">/* Use errstart to decide where to send the error report. */</comment>
	<expr_stmt><expr><name>shouldEmit</name> <operator>=</operator> <call><name>errstart</name><argument_list>(<argument><expr><name>downgrade_to_elevel</name></expr></argument>, <argument><expr><name>TEXTDOMAIN</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Send error report to log and/or client. */</comment>
	<if_stmt><if>if <condition>(<expr><name>shouldEmit</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>newedata</name> <init>= <expr><operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* errstart has stacked a new ErrorData entry. */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>newedata</name> <operator>==</operator> <name>edata</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* It tells us where to send the error report for the new elevel. */</comment>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name><name>newedata</name><operator>-&gt;</operator><name>elevel</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_client</name></name> <operator>=</operator> <name><name>newedata</name><operator>-&gt;</operator><name>output_to_client</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name> <operator>=</operator> <name><name>newedata</name><operator>-&gt;</operator><name>output_to_server</name></name></expr>;</expr_stmt>

		<comment type="block">/* Pop temp ErrorData entry. Nothing was palloc'ed; no need to pfree. */</comment>
		<expr_stmt><expr><name>errordata_stack_depth</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></if>

	<comment type="block">/* Nobody wants the error report. */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>=</operator> <name>downgrade_to_elevel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_client</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>output_to_server</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Sneak the caller's error through errfinish again (it has been through
	 * once already) to emit the error report (if requested) and clean up.
	 */</comment>
	<expr_stmt><expr><call><name>errfinish</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore the context callback stack. */</comment>
	<expr_stmt><expr><name>error_context_stack</name> <operator>=</operator> <name>saveCallbackStack</name></expr>;</expr_stmt>

	<comment type="block">/* Error not pending anymore, so caller should not do PG_RE_THROW(). */</comment>
	<return>return <expr><name>true</name></expr>;</return>				<comment type="block">/* success */</comment>
</block_content>}</block></function>							   <comment type="block">/* elog_dismiss */</comment>


<comment type="block">/*
 * CDB: elog_geterrcode
 * Return the SQLSTATE code for the error currently being handled, or 0.
 *
 * This is only intended for use in error handlers.
 */</comment>
<function><type><name>int</name></type>
<name>elog_geterrcode</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>errordata_stack_depth</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>
				?</condition><then> <expr><literal type="number">0</literal></expr>
				</then><else>: <expr><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name><operator>.</operator><name>sqlerrcode</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function> <comment type="block">/* elog_geterrcode */</comment>

<function><type><name>int</name></type>
<name>elog_getelevel</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>errordata_stack_depth</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>
				?</condition><then> <expr><name>NOTICE</name></expr>
				</then><else>: <expr><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name><operator>.</operator><name>elevel</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function> <comment type="block">/* elog_getelevel */</comment>

<comment type="block">/*
 * Note: A pointer is returned.  Make a copy of the message
 * before re-throwing or flushing the error state.
 */</comment>
<function><type><name>char</name><modifier>*</modifier></type>
<name>elog_message</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><ternary><condition><expr><operator>(</operator><name>errordata_stack_depth</name> <operator>&lt;</operator> <literal type="number">0</literal><operator>)</operator></expr>
				?</condition><then> <expr><name>NULL</name></expr>
				</then><else>: <expr><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name><operator>.</operator><name>message</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GetErrorContextStack - Return the context stack, for display/diags
 *
 * Returns a pstrdup'd string in the caller's context which includes the PG
 * error call stack.  It is the caller's responsibility to ensure this string
 * is pfree'd (or its context cleaned up) when done.
 *
 * This information is collected by traversing the error contexts and calling
 * each context's callback function, each of which is expected to call
 * errcontext() to return a string which can be presented to the user.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>GetErrorContextStack</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ErrorData</name>  <modifier>*</modifier></type><name>edata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ErrorContextCallback</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Okay, crank up a stack entry to store the info in.
	 */</comment>
	<expr_stmt><expr><name>recursion_depth</name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>++</operator><name>errordata_stack_depth</name> <operator>&gt;=</operator> <name>ERRORDATA_STACK_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Wups, stack not big enough.  We treat this as a PANIC condition
		 * because it suggests an infinite loop of errors during error
		 * recovery.
		 */</comment>
		<expr_stmt><expr><name>errordata_stack_depth</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt> <comment type="block">/* make room on stack */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"ERRORDATA_STACK_SIZE exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Things look good so far, so initialize our error frame
	 */</comment>
	<expr_stmt><expr><name>edata</name> <operator>=</operator> <operator>&amp;</operator><name><name>errordata</name><index>[<expr><name>errordata_stack_depth</name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Set up assoc_context to be the caller's context, so any allocations
	 * done (which will include edata-&gt;context) will use their context.
	 */</comment>
	<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>assoc_context</name></name> <operator>=</operator> <name>CurrentMemoryContext</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Call any context callback functions to collect the context information
	 * into edata-&gt;context.
	 *
	 * Errors occurring in callback functions should go through the regular
	 * error handling code which should handle any recursive errors, though we
	 * double-check above, just in case.
	 */</comment>
	<for>for <control>(<init><expr><name>econtext</name> <operator>=</operator> <name>error_context_stack</name></expr>;</init>
		 <condition><expr><name>econtext</name> <operator>!=</operator> <name>NULL</name></expr>;</condition>
		 <incr><expr><name>econtext</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>previous</name></name></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name><name>econtext</name><operator>-&gt;</operator><name>callback</name></name><argument_list>(<argument><expr><name><name>econtext</name><operator>-&gt;</operator><name>arg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Clean ourselves off the stack, any allocations done should have been
	 * using edata-&gt;assoc_context, which we set up earlier to be the caller's
	 * context, so we're free to just remove our entry off the stack and
	 * decrement recursion depth and exit.
	 */</comment>
	<expr_stmt><expr><name>errordata_stack_depth</name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>recursion_depth</name><operator>--</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return a pointer to the string the caller asked for, which should have
	 * been allocated in their context.
	 */</comment>
	<return>return <expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Initialization of error output file
 */</comment>
<function><type><name>void</name></type>
<name>DebugFileOpen</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name></decl>,
				<decl><type ref="prev"/><name>istty</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>OutputFileName</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A debug-output file name was given.
		 *
		 * Make sure we can write the file, and find out if it's a tty.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>fd</name> <operator>=</operator> <call><name>open</name><argument_list>(<argument><expr><name>OutputFileName</name></expr></argument>, <argument><expr><name>O_CREAT</name> <operator>|</operator> <name>O_APPEND</name> <operator>|</operator> <name>O_WRONLY</name></expr></argument>,
					   <argument><expr><literal type="number">0666</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not open file \"%s\": %m"</literal></expr></argument>, <argument><expr><name>OutputFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>istty</name> <operator>=</operator> <call><name>isatty</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>close</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Redirect our stderr to the debug output file.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>freopen</name><argument_list>(<argument><expr><name>OutputFileName</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not reopen file \"%s\" as stderr: %m"</literal></expr></argument>,
							<argument><expr><name>OutputFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If the file is a tty and we're running under the postmaster, try to
		 * send stdout there as well (if it isn't a tty then stderr will block
		 * out stdout, so we may as well let stdout go wherever it was going
		 * before).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>istty</name> <operator>&amp;&amp;</operator> <name>IsUnderPostmaster</name></expr>)</condition><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>freopen</name><argument_list>(<argument><expr><name>OutputFileName</name></expr></argument>, <argument><expr><literal type="string">"a"</literal></expr></argument>, <argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode_for_file_access</name><argument_list>()</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not reopen file \"%s\" as stdout: %m"</literal></expr></argument>,
								<argument><expr><name>OutputFileName</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>

<comment type="block">/*
 * Set or update the parameters for syslog logging
 */</comment>
<function><type><name>void</name></type>
<name>set_syslog_parameters</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>ident</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>facility</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * guc.c is likely to call us repeatedly with same parameters, so don't
	 * thrash the syslog connection unnecessarily.  Also, we do not re-open
	 * the connection until needed, since this routine will get called whether
	 * or not Log_destination actually mentions syslog.
	 *
	 * Note that we make our own copy of the ident string rather than relying
	 * on guc.c's.  This may be overly paranoid, but it ensures that we cannot
	 * accidentally free a string that syslog is still using.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>syslog_ident</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name>syslog_ident</name></expr></argument>, <argument><expr><name>ident</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal> <operator>||</operator>
		<name>syslog_facility</name> <operator>!=</operator> <name>facility</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>openlog_done</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>closelog</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>openlog_done</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>syslog_ident</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>syslog_ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>syslog_ident</name> <operator>=</operator> <call><name>strdup</name><argument_list>(<argument><expr><name>ident</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if the strdup fails, we will cope in write_syslog() */</comment>
		<expr_stmt><expr><name>syslog_facility</name> <operator>=</operator> <name>facility</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Write a message line to syslog
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_syslog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>unsigned</name> <name>long</name></type> <name>seq</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>nlpos</name></decl>;</decl_stmt>

	<comment type="block">/* Open syslog connection if not done yet */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>openlog_done</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>openlog</name><argument_list>(<argument><expr><ternary><condition><expr><name>syslog_ident</name></expr> ?</condition><then> <expr><name>syslog_ident</name></expr> </then><else>: <expr><literal type="string">"postgres"</literal></expr></else></ternary></expr></argument>,
				<argument><expr><name>LOG_PID</name> <operator>|</operator> <name>LOG_NDELAY</name> <operator>|</operator> <name>LOG_NOWAIT</name></expr></argument>,
				<argument><expr><name>syslog_facility</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>openlog_done</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We add a sequence number to each log message to suppress "same"
	 * messages.
	 */</comment>
	<expr_stmt><expr><name>seq</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Our problem here is that many syslog implementations don't handle long
	 * messages in an acceptable manner. While this function doesn't help that
	 * fact, it does work around by splitting up messages into smaller pieces.
	 *
	 * We divide into multiple syslog() calls if message is too long or if the
	 * message contains embedded newline(s).
	 */</comment>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nlpos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>syslog_split_messages</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>len</name> <operator>&gt;</operator> <name>PG_SYSLOG_LIMIT</name> <operator>||</operator> <name>nlpos</name> <operator>!=</operator> <name>NULL</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>chunk_nr</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>PG_SYSLOG_LIMIT</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<comment type="block">/* if we start at a newline, move ahead one char */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>line</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name><operator>--</operator></expr>;</expr_stmt>
				<comment type="block">/* we need to recompute the next newline's position, too */</comment>
				<expr_stmt><expr><name>nlpos</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* copy one line, or as much as will fit, to buf */</comment>
			<if_stmt><if>if <condition>(<expr><name>nlpos</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>nlpos</name> <operator>-</operator> <name>line</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>PG_SYSLOG_LIMIT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>buflen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<comment type="block">/* trim to multibyte letter boundary */</comment>
			<expr_stmt><expr><name>buflen</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>buflen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>buf</name><index>[<expr><name>buflen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

			<comment type="block">/* already word boundary? */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>line</name><index>[<expr><name>buflen</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
				<operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>line</name><index>[<expr><name>buflen</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* try to divide at word boundary */</comment>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <name>buflen</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<while>while <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>		<comment type="block">/* else couldn't divide word boundary */</comment>
				<block>{<block_content>
					<expr_stmt><expr><name>buflen</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>chunk_nr</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>syslog_sequence_numbers</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"[%lu-%d] %s"</literal></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><name>chunk_nr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"[%d] %s"</literal></expr></argument>, <argument><expr><name>chunk_nr</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name>line</name> <operator>+=</operator> <name>buflen</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>buflen</name></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* message short enough */</comment>
		<if_stmt><if>if <condition>(<expr><name>syslog_sequence_numbers</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"[%lu] %s"</literal></expr></argument>, <argument><expr><name>seq</name></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>syslog</name><argument_list>(<argument><expr><name>level</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>line</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_SYSLOG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
<comment type="block">/*
 * Get the PostgreSQL equivalent of the Windows ANSI code page.  "ANSI" system
 * interfaces (e.g. CreateFileA()) expect string arguments in this encoding.
 * Every process in a given system will find the same value at all times.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>GetACPEncoding</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>encoding</name> <init>= <expr><operator>-</operator><literal type="number">2</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>encoding</name> <operator>==</operator> <operator>-</operator><literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>encoding</name> <operator>=</operator> <call><name>pg_codepage_to_encoding</name><argument_list>(<argument><expr><call><name>GetACP</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>encoding</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Write a message line to the windows event log
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_eventlog</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>level</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WCHAR</name>	   <modifier>*</modifier></type><name>utf16</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>eventlevel</name> <init>= <expr><name>EVENTLOG_ERROR_TYPE</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>HANDLE</name></type> <name>evtHandle</name> <init>= <expr><name>INVALID_HANDLE_VALUE</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>evtHandle</name> <operator>==</operator> <name>INVALID_HANDLE_VALUE</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>evtHandle</name> <operator>=</operator> <call><name>RegisterEventSource</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><ternary><condition><expr><name>event_source</name></expr> ?</condition><then> <expr><name>event_source</name></expr> </then><else>: <expr><name>DEFAULT_EVENT_SOURCE</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>evtHandle</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>evtHandle</name> <operator>=</operator> <name>INVALID_HANDLE_VALUE</name></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<switch>switch <condition>(<expr><name>level</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DEBUG5</name></expr>:</case>
		<case>case <expr><name>DEBUG4</name></expr>:</case>
		<case>case <expr><name>DEBUG3</name></expr>:</case>
		<case>case <expr><name>DEBUG2</name></expr>:</case>
		<case>case <expr><name>DEBUG1</name></expr>:</case>
		<case>case <expr><name>LOG</name></expr>:</case>
		<case>case <expr><name>LOG_SERVER_ONLY</name></expr>:</case>
		<case>case <expr><name>INFO</name></expr>:</case>
		<case>case <expr><name>NOTICE</name></expr>:</case>
			<expr_stmt><expr><name>eventlevel</name> <operator>=</operator> <name>EVENTLOG_INFORMATION_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WARNING</name></expr>:</case>
			<expr_stmt><expr><name>eventlevel</name> <operator>=</operator> <name>EVENTLOG_WARNING_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ERROR</name></expr>:</case>
		<case>case <expr><name>FATAL</name></expr>:</case>
		<case>case <expr><name>PANIC</name></expr>:</case>
		<default>default:</default>
			<expr_stmt><expr><name>eventlevel</name> <operator>=</operator> <name>EVENTLOG_ERROR_TYPE</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * If message character encoding matches the encoding expected by
	 * ReportEventA(), call it to avoid the hazards of conversion.  Otherwise,
	 * try to convert the message to UTF16 and write it with ReportEventW().
	 * Fall back on ReportEventA() if conversion failed.
	 *
	 * Since we palloc the structure required for conversion, also fall
	 * through to writing unconverted if we have not yet set up
	 * CurrentMemoryContext.
	 *
	 * Also verify that we are not on our way into error recursion trouble due
	 * to error messages thrown deep inside pgwin32_message_to_UTF16().
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>in_error_recursion_trouble</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<name>CurrentMemoryContext</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<call><name>GetMessageEncoding</name><argument_list>()</argument_list></call> <operator>!=</operator> <call><name>GetACPEncoding</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>utf16</name> <operator>=</operator> <call><name>pgwin32_message_to_UTF16</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>utf16</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ReportEventW</name><argument_list>(<argument><expr><name>evtHandle</name></expr></argument>,
						 <argument><expr><name>eventlevel</name></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>,		<comment type="block">/* All events are Id 0 */</comment>
						 <argument><expr><name>NULL</name></expr></argument>,
						 <argument><expr><literal type="number">1</literal></expr></argument>,
						 <argument><expr><literal type="number">0</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>LPCWSTR</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>utf16</name></expr></argument>,
						 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* XXX Try ReportEventA() when ReportEventW() fails? */</comment>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>ReportEventA</name><argument_list>(<argument><expr><name>evtHandle</name></expr></argument>,
				 <argument><expr><name>eventlevel</name></expr></argument>,
				 <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><literal type="number">0</literal></expr></argument>,				<comment type="block">/* All events are Id 0 */</comment>
				 <argument><expr><name>NULL</name></expr></argument>,
				 <argument><expr><literal type="number">1</literal></expr></argument>,
				 <argument><expr><literal type="number">0</literal></expr></argument>,
				 <argument><expr><operator>&amp;</operator><name>line</name></expr></argument>,
				 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>


<comment type="block">/*
 * CDB: Tidy up the error message
 */</comment>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>cdb_strip_trailing_whitespace</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>buf</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>bp</name> <init>= <expr><operator>*</operator><name>buf</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>ep</name> <init>= <expr><name>bp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><name><name>bp</name> <argument_list type="generic">&lt; <argument><expr><name>ep</name> <operator>&amp;&amp;</operator>
			   <name><name>ep</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>&lt;=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator>
			   <name><name>ep</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name></expr></argument> &gt;</argument_list></name> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><operator>--</operator><name>ep</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></while>

		<if_stmt><if>if <condition>(<expr><name>bp</name> <operator>==</operator> <name>ep</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>*</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>buf</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>							   <comment type="block">/* cdb_strip_trailing_whitespace */</comment>

<comment type="block">/*
 * cdb_tidy_message is a gpdb specific error message postprocessing function.
 *
 * It supplies useful error information for debug which upstream is missing:
 * 1. append the filename and line number for internal error.
 * 2. truncate the trailing whitespace for edata
 */</comment>
<function><type><name>void</name></type>
<name>cdb_tidy_message</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>bp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>m</name></decl>, <decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>cdb_strip_trailing_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdb_strip_trailing_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdb_strip_trailing_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>cdb_strip_trailing_whitespace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look at main error message. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>bp</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>;</expr_stmt>
		<while>while <condition>(<expr><operator>*</operator><name>bp</name> <operator>&lt;=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>bp</name> <operator>&gt;</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><name>ep</name> <operator>=</operator> <name>bp</name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>bp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ep</name> <operator>=</operator> <name>bp</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If internal error, append the filename and line number.
	 * (Skip if error came from QE, because QE already added the info.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name> <operator>&amp;&amp;</operator>
		<name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name> <operator>==</operator> <name>ERRCODE_INTERNAL_ERROR</name> <operator>&amp;&amp;</operator>
		<name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">60</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>bfn</name></decl>;</decl_stmt>

		<comment type="block">/* With some compilers __FILE__ is absolute path.  Strip directory. */</comment>
		<expr_stmt><expr><name>bfn</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>filename</name></name> <operator>+</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<while>while <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name> <operator>&lt;</operator> <name>bfn</name> <operator>&amp;&amp;</operator>
			   <name><name>bfn</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'/'</literal> <operator>&amp;&amp;</operator>
			   <name><name>bfn</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>bfn</name><operator>--</operator></expr>;</expr_stmt></block_content></block></while>

		<comment type="block">/* Format the error location. */</comment>
		<expr_stmt><expr><name>n</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">" (%s:%d)"</literal></expr></argument>, <argument><expr><name>bfn</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Append to main error message. */</comment>
		<expr_stmt><expr><name>m</name> <operator>=</operator> <name>ep</name> <operator>-</operator> <name>bp</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>m</name> <operator>+</operator> <name>n</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tp</name></expr></argument>, <argument><expr><name>bp</name></expr></argument>, <argument><expr><name>m</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tp</name><operator>+</operator><name>m</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tp</name><index>[<expr><name>m</name><operator>+</operator><name>n</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name> <operator>=</operator> <name>tp</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>							   <comment type="block">/* cdb_tidy_message */</comment>


<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_console</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rc</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

	<comment type="block">/*
	 * Try to convert the message to UTF16 and write it with WriteConsoleW().
	 * Fall back on write() if anything fails.
	 *
	 * In contrast to write_eventlog(), don't skip straight to write() based
	 * on the applicable encodings.  Unlike WriteConsoleW(), write() depends
	 * on the suitability of the console output code page.  Since we put
	 * stderr into binary mode in SubPostmasterMain(), write() skips the
	 * necessary translation anyway.
	 *
	 * WriteConsoleW() will fail if stderr is redirected, so just fall through
	 * to writing unconverted to the logfile in this case.
	 *
	 * Since we palloc the structure required for conversion, also fall
	 * through to writing unconverted if we have not yet set up
	 * CurrentMemoryContext.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>in_error_recursion_trouble</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>redirection_done</name> <operator>&amp;&amp;</operator>
		<name>CurrentMemoryContext</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WCHAR</name>	   <modifier>*</modifier></type><name>utf16</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>utf16len</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>utf16</name> <operator>=</operator> <call><name>pgwin32_message_to_UTF16</name><argument_list>(<argument><expr><name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>utf16len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>utf16</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HANDLE</name></type>		<name>stdHandle</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>DWORD</name></type>		<name>written</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>stdHandle</name> <operator>=</operator> <call><name>GetStdHandle</name><argument_list>(<argument><expr><name>STD_ERROR_HANDLE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>WriteConsoleW</name><argument_list>(<argument><expr><name>stdHandle</name></expr></argument>, <argument><expr><name>utf16</name></expr></argument>, <argument><expr><name>utf16len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>written</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * In case WriteConsoleW() failed, fall back to writing the
			 * message unconverted.
			 */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>utf16</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>

	<comment type="block">/*
	 * Conversion on non-win32 platforms is not implemented yet. It requires
	 * non-throw version of pg_do_encoding_conversion(), that converts
	 * unconvertable characters to '?' without errors.
	 */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * We ignore any error from write() here.  We have no useful way to report
	 * it ... certainly whining on stderr isn't likely to be productive.
	 */</comment>
	<expr_stmt><expr><name>rc</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>line</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <name>rc</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setup formatted_log_time, for consistent times between CSV and regular logs
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_formatted_log_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>stamp_time</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>msbuf</name><index>[<expr><literal type="number">13</literal></expr>]</index></name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>saved_timeval_set</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>saved_timeval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>saved_timeval_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>stamp_time</name> <operator>=</operator> <operator>(</operator><name>pg_time_t</name><operator>)</operator> <name><name>saved_timeval</name><operator>.</operator><name>tv_sec</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Note: we expect that guc.c will ensure that log_timezone is set up (at
	 * least with a minimal GMT value) before Log_line_prefix can become
	 * nonempty or CSV mode can be selected.
	 */</comment>
	<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>formatted_log_time</name></expr></argument>, <argument><expr><name>FORMATTED_TS_LEN</name></expr></argument>,
	<comment type="block">/* leave room for microseconds... */</comment>
				<argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S        %Z"</literal></expr></argument>,
				<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* 'paste' microseconds into place... */</comment>
	<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>msbuf</name></expr></argument>, <argument><expr><literal type="string">".%06d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>saved_timeval</name><operator>.</operator><name>tv_usec</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>formatted_log_time</name> <operator>+</operator> <literal type="number">19</literal></expr></argument>, <argument><expr><name>msbuf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * setup formatted_start_time
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>setup_formatted_start_time</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>stamp_time</name> <init>= <expr><operator>(</operator><name>pg_time_t</name><operator>)</operator> <name>MyStartTime</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note: we expect that guc.c will ensure that log_timezone is set up (at
	 * least with a minimal GMT value) before Log_line_prefix can become
	 * nonempty or CSV mode can be selected.
	 */</comment>
	<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>formatted_start_time</name></expr></argument>, <argument><expr><name>FORMATTED_TS_LEN</name></expr></argument>,
				<argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S %Z"</literal></expr></argument>,
				<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * process_log_prefix_padding --- helper function for processing the format
 * string in log_line_prefix
 *
 * Note: This function returns NULL if it finds something which
 * it deems invalid in the format string.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>process_log_prefix_padding</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>ppadding</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>paddingsign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>padding</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>			<comment type="block">/* Did the buf end in %- ? */</comment>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>paddingsign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* generate an int version of the numerical string */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>p</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>padding</name> <operator>=</operator> <name>padding</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>++</operator> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/* format is invalid if it ends with the padding number */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>padding</name> <operator>*=</operator> <name>paddingsign</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>ppadding</name> <operator>=</operator> <name>padding</name></expr>;</expr_stmt>
	<return>return <expr><name>p</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Format tag info for log lines; append to the provided buffer.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>log_line_prefix</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* static counter for line numbers */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>log_line_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* has counter been reset in current process? */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>log_my_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>padding</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is one of the few places where we'd rather not inherit a static
	 * variable's value from the postmaster.  But since we will, reset it when
	 * MyProcPid changes. MyStartTime also changes when MyProcPid does, so
	 * reset the formatted start timestamp too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_my_pid</name> <operator>!=</operator> <name>MyProcPid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>log_line_number</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>log_my_pid</name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>formatted_start_time</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>log_line_number</name><operator>++</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Log_line_prefix</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* in case guc hasn't run yet */</comment>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>Log_line_prefix</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* literal char, just copy */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* must be a '%', so skip to the next char */</comment>
		<expr_stmt><expr><name>p</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>				<comment type="block">/* format error - ignore it */</comment>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* string contains %% */</comment>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'%'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>


		<comment type="block">/*
		 * Process any formatting which may exist after the '%'.  Note that
		 * process_log_prefix_padding moves p past the padding number if it
		 * exists.
		 *
		 * Note: Since only '-', '0' to '9' are valid formatting characters we
		 * can do a quick check here to pre-check for formatting. If the char
		 * is not formatting then we can skip a useless function call.
		 *
		 * Further note: At least on some platforms, passing %*s rather than
		 * %s to appendStringInfo() is substantially slower, so many of the
		 * cases below avoid doing that unless non-zero padding is in fact
		 * specified.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>&gt;</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>padding</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>process_log_prefix_padding</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>padding</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* process the option */</comment>
		<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'a'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>appname</name> <init>= <expr><name>application_name</name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>appname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>appname</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>appname</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"[unknown]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>appname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>appname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>padding</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>padding</name></expr> </then><else>: <expr><operator>-</operator><name>padding</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<break>break;</break>
			<case>case <expr><literal type="char">'u'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>username</name> <init>= <expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>user_name</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>username</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>username</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>username</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"[unknown]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>username</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>padding</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>padding</name></expr> </then><else>: <expr><operator>-</operator><name>padding</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'d'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dbname</name> <init>= <expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>database_name</name></name></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>dbname</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <operator>*</operator><name>dbname</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>dbname</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><literal type="string">"[unknown]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>dbname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>padding</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>padding</name></expr> </then><else>: <expr><operator>-</operator><name>padding</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'c'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>strfbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>strfbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strfbuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%lx.%x"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>MyStartTime</name><operator>)</operator></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>strfbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%lx.%x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <operator>(</operator><name>MyStartTime</name><operator>)</operator></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'p'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*d"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'l'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*ld"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>log_line_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name>log_line_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'m'</literal></expr>:</case>
				<expr_stmt><expr><call><name>setup_formatted_log_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>formatted_log_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>formatted_log_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'t'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>pg_time_t</name></type>	<name>stamp_time</name> <init>= <expr><operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>time</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>strfbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>pg_strftime</name><argument_list>(<argument><expr><name>strfbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strfbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>,
								<argument><expr><literal type="string">"%Y-%m-%d %H:%M:%S %Z"</literal></expr></argument>,
								<argument><expr><call><name>pg_localtime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>stamp_time</name></expr></argument>, <argument><expr><name>log_timezone</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>strfbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>strfbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="char">'n'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>strfbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>saved_timeval_set</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>gettimeofday</name><argument_list>(<argument><expr><operator>&amp;</operator><name>saved_timeval</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>saved_timeval_set</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>strfbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strfbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%ld.%03d"</literal></expr></argument>,
							 <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name><name>saved_timeval</name><operator>.</operator><name>tv_sec</name></name></expr></argument>,
							 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>saved_timeval</name><operator>.</operator><name>tv_usec</name></name> <operator>/</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>strfbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>strfbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><literal type="char">'s'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>formatted_start_time</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>setup_formatted_start_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>formatted_start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>formatted_start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'i'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>psdisp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>displen</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>psdisp</name> <operator>=</operator> <call><name>get_ps_display</name><argument_list>(<argument><expr><operator>&amp;</operator><name>displen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>psdisp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>psdisp</name></expr></argument>, <argument><expr><name>displen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>padding</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>padding</name></expr> </then><else>: <expr><operator>-</operator><name>padding</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'r'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * This option is slightly special as the port
							 * number may be appended onto the end. Here we
							 * need to build 1 string which contains the
							 * remote_host and optionally the remote_port (if
							 * set) so we can properly align the string.
							 */</comment>

							<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>hostport</name></decl>;</decl_stmt>

							<expr_stmt><expr><name>hostport</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%s(%s)"</literal></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>hostport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hostport</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* padding is 0, so we don't need a temp buffer */</comment>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name> <operator>&amp;&amp;</operator>
							<name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s)"</literal></expr></argument>,
											 <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>

				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>padding</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>padding</name></expr> </then><else>: <expr><operator>-</operator><name>padding</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'h'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>padding</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>padding</name></expr> </then><else>: <expr><operator>-</operator><name>padding</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'q'</literal></expr>:</case>
				<comment type="block">/* in postmaster and friends, stop if %q is seen */</comment>
				<comment type="block">/* in a backend, just ignore */</comment>
				<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return;</return></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'v'</literal></expr>:</case>
				<comment type="block">/* keep VXID format in sync with lockfuncs.c */</comment>
				<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<decl_stmt><decl><type><name>char</name></type>		<name><name>strfbuf</name><index>[<expr><literal type="number">128</literal></expr>]</index></name></decl>;</decl_stmt>

						<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>strfbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>strfbuf</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"%d/%u"</literal></expr></argument>,
								 <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><name>strfbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d/%u"</literal></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoSpaces</name><argument_list>(<argument><expr><name>buf</name></expr></argument>,
										   <argument><expr><ternary><condition><expr><name>padding</name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>padding</name></expr> </then><else>: <expr><operator>-</operator><name>padding</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'x'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*u"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>

			<comment type="block">/* MPP SPECIFIC OPTIONS. */</comment>
			<case>case <expr><literal type="char">'C'</literal></expr>:</case>
				<comment type="block">/* we use -2 to indicate that it hasn't been set yet.  we'll
				 * choose to not write anything for the very early log messages
				 * before GUC variables are set.
				 */</comment>
				<if_stmt><if>if<condition>( <expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name> <operator>!=</operator> <name>UNDEF_SEGMENT</name></expr> )</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'I'</literal></expr>:</case>
				<comment type="block">/* prints a succinct description of an MPP process. */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyProcPort</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sp</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uname</name> <init>= <expr><call><name>get_ps_display_username</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><name>uname</name> <operator>||</operator> <operator>!</operator><name><name>uname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"postmaster"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>(</operator><name>sp</name> <operator>=</operator> <call><name>strstr</name><argument_list>(<argument><expr><name>uname</name></expr></argument>, <argument><expr><literal type="string">" process"</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>uname</name></expr></argument>, <argument><expr><name>sp</name> <operator>-</operator> <name>uname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>uname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<decl_stmt><decl><type><name>int</name></type> <name>j</name> <init>= <expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>gp_session_id</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"con%d "</literal></expr></argument>, <argument><expr><name>gp_session_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>gp_command_count</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"cmd%d "</literal></expr></argument>, <argument><expr><name>gp_command_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"seg%d "</literal></expr></argument>, <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>currentSliceId</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"slice%d "</literal></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>j</name> <operator>&lt;</operator> <name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>&amp;&amp;</operator>
					<name><name>buf</name><operator>-&gt;</operator><name>data</name><index>[<expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'P'</literal></expr>:</case>
				<if_stmt><if>if<condition>( <expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr> )</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'P'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'R'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>MyProcPort</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>uname</name> <init>= <expr><call><name>get_ps_display_username</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><ternary><condition><expr><name>uname</name> <operator>&amp;&amp;</operator> <name><name>uname</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr> ?</condition><then> <expr><name>uname</name></expr> </then><else>: <expr><literal type="string">"postmaster"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>role_to_string</name><argument_list>(<argument><expr><name>Gp_role</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'S'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>currentSliceId</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument> )</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'T'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"qe"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"qd"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'X'</literal></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>distribXid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TransactionId</name></type> <name>localXid</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>TransactionId</name></type> <name>subXid</name></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>GetAllTransactionXids</name><argument_list>(
									<argument><expr><operator>&amp;</operator><name>distribXid</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>localXid</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>subXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<if_stmt><if>if <condition>(<expr><name>localXid</name> <operator>!=</operator> <name>InvalidTransactionId</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>distribXid</name> <operator>&gt;=</operator> <name>FirstDistributedTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"dx"</literal><name>UINT64_FORMAT</name><literal type="string">", "</literal></expr></argument>, <argument><expr><name>distribXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"x%u"</literal></expr></argument>, <argument><expr><name>localXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

						<if_stmt><if>if <condition>(<expr><name>subXid</name> <operator>&gt;=</operator> <name>FirstNormalTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">", sx%u, "</literal></expr></argument>, <argument><expr><name>subXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>

					<break>break;</break>
				</block_content>}</block>
			<case>case <expr><literal type="char">'e'</literal></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>padding</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><name>padding</name></expr></argument>, <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* format error - ignore it */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * append a CSV'd version of a string to a StringInfo
 * We use the PostgreSQL defaults for CSV, i.e. quote = escape = '"'
 * If it's NULL, append nothing.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>appendCSVLiteral</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name> <init>= <expr><name>data</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>

	<comment type="block">/* avoid confusing an empty string with NULL */</comment>
	<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>(</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>p</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>c</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Constructs the error message, depending on the Errordata it gets, in a CSV
 * format which is described in doc/src/sgml/config.sgml.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_csvlog</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>print_stmt</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* static counter for line numbers */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>long</name></type> <name>log_line_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* has counter been reset in current process? */</comment>
	<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>log_my_pid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * This is one of the few places where we'd rather not inherit a static
	 * variable's value from the postmaster.  But since we will, reset it when
	 * MyProcPid changes.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>log_my_pid</name> <operator>!=</operator> <name>MyProcPid</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>log_line_number</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>log_my_pid</name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>formatted_start_time</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>log_line_number</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * timestamp with milliseconds
	 *
	 * Check if the timestamp is already calculated for the syslog message,
	 * and use it if so.  Otherwise, get the current timestamp.  This is done
	 * to put same timestamp in both syslog and csvlog messages.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>formatted_log_time</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setup_formatted_log_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>formatted_log_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* username */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* database name */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Process id  */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remote host and port */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* session id */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%lx.%x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>long</name><operator>)</operator> <name>MyStartTime</name></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Line number */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%ld"</literal></expr></argument>, <argument><expr><name>log_line_number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* PS display */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>msgbuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>psdisp</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>displen</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>psdisp</name> <operator>=</operator> <call><name>get_ps_display</name><argument_list>(<argument><expr><operator>&amp;</operator><name>displen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>psdisp</name></expr></argument>, <argument><expr><name>displen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>msgbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>msgbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* session start timestamp */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>formatted_start_time</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>setup_formatted_start_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>formatted_start_time</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Virtual transaction id */</comment>
	<comment type="block">/* keep VXID format in sync with lockfuncs.c */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProc</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name> <operator>!=</operator> <name>InvalidBackendId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d/%u"</literal></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>backendId</name></name></expr></argument>, <argument><expr><name><name>MyProc</name><operator>-&gt;</operator><name>lxid</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Transaction id */</comment>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%u"</literal></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Error severity */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>error_severity</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* SQL state code */</comment>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* errmessage */</comment>
	<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* errdetail or errdetail_log */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* errhint */</comment>
	<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* internal query */</comment>
	<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* if printed internal query, print internal pos too */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* errcontext */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>edata</name><operator>-&gt;</operator><name>hide_ctx</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* user query --- only reported if not disabled by the caller */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_log_level_output</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>, <argument><expr><name>log_min_error_statement</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>debug_query_string</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>edata</name><operator>-&gt;</operator><name>hide_stmt</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>print_stmt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>print_stmt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>print_stmt</name> <operator>&amp;&amp;</operator> <name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* file error location */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_error_verbosity</name> <operator>&gt;=</operator> <name>PGERROR_VERBOSE</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>msgbuf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name> <operator>&amp;&amp;</operator> <name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><literal type="string">"%s, %s:%d"</literal></expr></argument>,
							 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
							 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><literal type="string">"%s:%d"</literal></expr></argument>,
							 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>msgbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>msgbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* application name */</comment>
	<if_stmt><if>if <condition>(<expr><name>application_name</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendCSVLiteral</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>application_name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* If in the syslogger process, try to write messages direct to file */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_syslogger</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>LOG_DESTINATION_CSVLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_pipe_chunks</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>LOG_DESTINATION_CSVLOG</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unpack MAKE_SQLSTATE code. Note that this returns a pointer to a
 * static buffer.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>unpack_sql_state</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>sql_state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name><name>buf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PGUNSIXBIT</name><argument_list>(<argument><expr><name>sql_state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sql_state</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>buf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>WRITE_PIPE_CHUNK_TIMEOUT</name></cpp:macro> <cpp:value>1000</cpp:value></cpp:define>

<comment type="block">/*
 * Send the data through the pipe.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>gp_write_pipe_chunk</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>retval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fd_set</name></type>		<name>wfds</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>timeval</name></name></type> <name>tv</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>retry_no</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Wait until stderr becomes available for write. If it doesn't become
	 * available for WRITE_PIPE_CHUNK_TIMEOUT seconds, give up and ignore the
	 * error message. This could happen e.g. when the logger process crashes.
	 *
	 * We perform the wait in one second intervals, so that interrupts don't
	 * reset the wait.
	 *
	 * XXX: We really should use non-blocking mode here. Currently, it's
	 * possible that the another process writes to the pipe just after we've
	 * determined that it's writeable, and by the time we call write(),
	 * the buffer might be full and we block.
	 */</comment>
	<for>for <control>(<init><expr><name>retry_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>retry_no</name> <operator>&lt;</operator> <name>WRITE_PIPE_CHUNK_TIMEOUT</name></expr>;</condition> <incr><expr><name>retry_no</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_sec</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tv</name><operator>.</operator><name>tv_usec</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>FD_ZERO</name><argument_list>(<argument><expr><operator>&amp;</operator><name>wfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>FD_SET</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>wfds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>retval</name> <operator>=</operator> <call><name>select</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>wfds</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>retval</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* select() timeout or interrupted. Retry */</comment>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * When the stderr is ready (retval == 1), or errors (other cases),
			 * break out the loop.
			 */</comment>
			<break>break;</break>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>retval</name> <operator>==</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>retval</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>!=</operator> <name>EINTR</name><operator>)</operator> <operator>||</operator> <operator>(</operator><name>retry_no</name> <operator>==</operator> <name>WRITE_PIPE_CHUNK_TIMEOUT</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>retval</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>bytes</name></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
			<block>{<block_content>
				<decl_stmt><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>chunk</name> <init>= <expr><operator>(</operator><name>PipeProtoChunk</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr></init></decl>;</decl_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>zero</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>chunk</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name>PIPE_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<expr_stmt><expr><name>bytes</name> <operator>=</operator> <call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		while <condition>(<expr><name>bytes</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>errno</name> <operator>==</operator> <name>EINTR</name></expr>)</condition>;</do>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append a string (terminated by '\0') to the GpPipeProtoChunk.
 *
 * If GpPipeProtoChunk does not have space for the given string,
 * this function appends enough data to fill the buffer, and
 * sends out the buffer. After that, the payload session of
 * GpPipeProtoChunk is reset and the rest of the given string
 * is appended. If the given string is pretty large, this function
 * may send out multiple chunks.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>append_string_to_pipe_chunk</name><parameter_list>(<parameter><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name><modifier>*</modifier></type> <name>input</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if<condition>(<expr><name>am_syslogger</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>int</name></type> <name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<if_stmt><if>if <condition>(<expr><name>input</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>input</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If this is a really long message, it does not really
	 * make lots of sense to print them all.  Truncate it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name>PIPE_MAX_PAYLOAD</name> <operator>*</operator> <literal type="number">20</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>input</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>PIPE_MAX_PAYLOAD</name> <operator>*</operator> <literal type="number">20</literal> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name> <operator>+</operator> <name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>offset</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>+</operator> <name>len</name> <operator>&gt;=</operator> <name>PIPE_MAX_PAYLOAD</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type> <name>bytes</name> <init>= <expr><name>PIPE_MAX_PAYLOAD</name> <operator>-</operator> <name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>bytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>bytes</name> <operator>+</operator> <name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>==</operator> <name>PIPE_MAX_PAYLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>PIPE_MAX_PAYLOAD</name></expr>;</expr_stmt>
		
		<expr_stmt><expr><call><name>gp_write_pipe_chunk</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <name>buffer</name></expr></argument>, <argument><expr><name>PIPE_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>chunk_no</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> <operator>=</operator> <name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>bytes</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>offset</name> <operator>+=</operator> <name>bytes</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Copy the remaining data, and add '\0' at the end */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><name>input</name> <operator>+</operator> <name>offset</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>data</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <name>len</name><operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>&lt;=</operator> <name>PIPE_MAX_PAYLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append the backtrace to the given PipeProtoChunk or the syslogger file or stderr.
 *
 * We can not use the default backtrace_symbols since it calls malloc, which
 * is not async-safe, to allocate space for symbols. Even though we don't
 * really support async-safe error logging yet, the malloc has caused several
 * deadlock issues in the past, we should avoid using them in our error handler.
 *
 * If buffer is NULL, the stack is written to the syslogger file if amsyslogger is true.
 * Otherwise, write to stderr.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_stacktrace</name><parameter_list>(<parameter><decl><type><name>PipeProtoChunk</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>append</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>stackarray</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>stacksize</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amsyslogger</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>WIN32</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>defined</name><argument_list>(<argument><expr><name>_AIX</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><name>int</name></type> <name>stack_no</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>symbol</name><index>[<expr><name>SYMBOL_SIZE</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* a reasonable size for a symbol */</comment>
	<decl_stmt><decl><type><name>Dl_info</name></type> <name>dli</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>symbol_len</name></decl>;</decl_stmt>


	<decl_stmt><decl><type><name>FILE</name> <modifier>*</modifier></type> <name>fd</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>fd_ok</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>cmd</name><index>[<expr><name>CMD_BUFFER_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>cmdresult</name><index>[<expr><name>STACK_DEPTH_MAX</name></expr>]</index><index>[<expr><name>SYMBOL_SIZE</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type> <name><name>addrtxt</name><index>[<expr><name>ADDRESS_SIZE</name></expr>]</index></name></decl>;</decl_stmt>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__darwin__</name></expr></argument>)</argument_list></call></expr></cpp:if>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>prog</name> <init>= <expr><literal type="string">"atos -o"</literal></expr></init></decl>;</decl_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type> <name>prog</name> <init>= <expr><literal type="string">"addr2line -s -e"</literal></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>in_translate_stacktrace</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type> <name>addr2line_ok</name> <init>= <expr><name>gp_log_stack_trace_lines</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>stacksize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>


	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>in_translate_stacktrace</name> <operator>&amp;&amp;</operator> <name>addr2line_ok</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Keep a record that we are doing this work, so if we crash during it, we don't
		 * try to do it again when we recurse back here,
		 */</comment>
		<expr_stmt><expr><name>in_translate_stacktrace</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%s %s "</literal></expr></argument>,<argument><expr><name>prog</name></expr></argument>,<argument><expr><name>my_exec_path</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>stack_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>stack_no</name> <operator>&lt;</operator> <name>stacksize</name> <operator>&amp;&amp;</operator> <name>stack_no</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>;</condition> <incr><expr><name>stack_no</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>   <comment type="block">/* clear this array for later */</comment>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>addrtxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>addrtxt</name></expr></argument>)</argument_list></sizeof></expr></argument>,<argument><expr><literal type="string">"%p "</literal></expr></argument>,<argument><expr><name><name>stackarray</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof> <operator>&gt;</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strncat</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>, <argument><expr><name>addrtxt</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></sizeof> <operator>-</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>cmdresult</name><index>[<expr><literal type="number">0</literal></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>fd</name> <operator>=</operator> <call><name>popen</name><argument_list>(<argument><expr><name>cmd</name></expr></argument>,<argument><expr><literal type="string">"r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>fd_ok</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd_ok</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>stack_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>stack_no</name> <operator>&lt;</operator> <name>stacksize</name> <operator>&amp;&amp;</operator> <name>stack_no</name> <operator>&lt;</operator> <name>STACK_DEPTH_MAX</name></expr>;</condition> <incr><expr><name>stack_no</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/* initialize the string */</comment>
				<expr_stmt><expr><name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<comment type="line">// Get one line of the result from addr2line (or atos)</comment>
				<if_stmt><if>if <condition>(<expr><call><name>fgets</name><argument_list>(<argument><expr><name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr></argument>,<argument><expr><name>SYMBOL_SIZE</name></expr></argument>,<argument><expr><name>fd</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<comment type="line">// Force it to be a valid string (in case it was too long)</comment>
				<expr_stmt><expr><name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index><index>[<expr><name>SYMBOL_SIZE</name><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<comment type="line">// Get rid of the newline at the end.</comment>
				<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
					<name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index><index>[<expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr></argument>)</argument_list></call><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fd_ok</name> <operator>||</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>cmdresult</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>addr2line_ok</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>fd</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pclose</name><argument_list>(<argument><expr><name>fd</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>in_translate_stacktrace</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>stack_no</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>stack_no</name> <operator>&lt;</operator> <name>stacksize</name></expr>;</condition> <incr><expr><name>stack_no</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* check if file/line info is available */</comment>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>lineInfo</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
		<if_stmt><if>if <condition>(<expr><name>addr2line_ok</name> <operator>&amp;&amp;</operator> <name>stack_no</name> <operator>&lt;</operator> <name>STACK_DEPTH_MAX</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>lineInfo</name> <operator>=</operator> <name><name>cmdresult</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>dladdr</name><argument_list>(<argument><expr><name><name>stackarray</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>dli</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>file</name> <init>= <expr><name><name>dli</name><operator>.</operator><name>dli_fname</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>file</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>	<name><name>file</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>dir_path</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="char">'/'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>file</name></expr></argument>, <argument><expr><literal type="string">"postgres:"</literal></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><literal type="string">"postgres:"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>file</name> <operator>=</operator> <literal type="string">"postgres"</literal></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>dir_path</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* don't print path to file */</comment>
					<expr_stmt><expr><name>file</name> <operator>=</operator> <name>dir_path</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>file</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>function</name> <init>= <expr><name><name>dli</name><operator>.</operator><name>dli_sname</name></name></expr></init></decl>;</decl_stmt>
			<if_stmt><if>if <condition>(<expr><name>function</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>function</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>function</name> <operator>=</operator> <literal type="string">"&lt;symbol not found&gt;"</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="line">// check if lineInfo was retrieved</comment>
			<comment type="line">// if lineinfo does not contain symbol ':' then the output of cmd contains the input address</comment>
			<comment type="line">// if lineinfo contains symbol '?' then the filename and line number cannot be determined (the output is ??:0)</comment>
			<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><name>lineInfo</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name> <operator>||</operator>
			    <call><name>strchr</name><argument_list>(<argument><expr><name>lineInfo</name></expr></argument>, <argument><expr><literal type="char">'?'</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* no line info, print offset in function */</comment>
				<expr_stmt><expr><name>symbol_len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>,
									  <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><literal type="string">"%-4d %p %s %s + 0x%x\n"</literal></expr></argument>,
									  <argument><expr><name>stack_no</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>stackarray</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name>file</name></expr></argument>,
									  <argument><expr><name>function</name></expr></argument>,
									  <argument><expr><operator>(</operator><name>int</name><operator>)</operator><operator>(</operator><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>stackarray</name><index>[<expr><name>stack_no</name></expr>]</index></name><operator>)</operator> <operator>-</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator><operator>(</operator><name><name>dli</name><operator>.</operator><name>dli_saddr</name></name><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* keep file:line info; required for atos */</comment>
				<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>parenth</name> <init>= <expr><call><name>strrchr</name><argument_list>(<argument><expr><name>lineInfo</name></expr></argument>, <argument><expr><literal type="char">'('</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name>parenth</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>lineInfo</name> <operator>=</operator> <name>parenth</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>parenth</name> <operator>=</operator> <call><name>strrchr</name><argument_list>(<argument><expr><name>lineInfo</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>parenth</name> <operator>!=</operator> <name>NULL</name></expr>)</condition> <block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>parenth</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/* line info added, print file and line info */</comment>
				<expr_stmt><expr><name>symbol_len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>,
									  <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr></argument>,
									  <argument><expr><literal type="string">"%-4d %p %s %s (%s)\n"</literal></expr></argument>,
									  <argument><expr><name>stack_no</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
									  <argument><expr><name><name>stackarray</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name>file</name></expr></argument>,
									  <argument><expr><name>function</name></expr></argument>,
									  <argument><expr><name>lineInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>


		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>lineInfo</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>lineInfo</name> <operator>=</operator> <literal type="string">"&lt;symbol not found&gt;"</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>symbol_len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>,
								  <argument><expr><call><name>ARRAY_SIZE</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr></argument>,
								  <argument><expr><literal type="string">"%-4d %p %s\n"</literal></expr></argument>,
								  <argument><expr><name>stack_no</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
								  <argument><expr><name><name>stackarray</name><index>[<expr><name>stack_no</name></expr>]</index></name></expr></argument>,
								  <argument><expr><name>lineInfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>buffer</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>stack_no</name> <operator>!=</operator> <name>stacksize</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Eliminate the last '\0' */</comment>
				<expr_stmt><expr><name><name>buffer</name><operator>-&gt;</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>--</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>

		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>append</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>append</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name>symbol</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name>symbol</name></expr></argument>, <argument><expr><name>symbol_len</name></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>symbol</name></expr></argument>, <argument><expr><name>symbol_len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>

<comment type="block">/*
 * Directly write a string to the syslogger file or stderr.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>write_syslogger_file_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amsyslogger</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>append_comma</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>str</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>str</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>syslogger_write_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>syslogger_write_str</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"\""</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>append_comma</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Directly write the message in CSV format to the syslogger file or stderr.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_syslogger_in_csv</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>amsyslogger</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* timestamp_with_millisecond */</comment>
	<expr_stmt><expr><call><name>syslogger_append_current_timestamp</name><argument_list>(<argument><expr><name>amsyslogger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* username */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>user_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* databasename */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>database_name</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Process id, thread id */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"p"</literal></expr></argument>, <argument><expr><name>MyProcPid</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"th"</literal></expr></argument>, <argument><expr><call><name>mythread</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Remote host, remote port */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* session start timestamp */</comment>
	<expr_stmt><expr><call><name>syslogger_append_timestamp</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>MyProcPort</name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then>
								<expr><operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>timestamptz_to_time_t</name><argument_list>(<argument><expr><name>MyStartTimestamp</name></expr></argument>)</argument_list></call></expr></then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr></argument>,
							   <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* transaction id */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* GPDB specific options */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"con"</literal></expr></argument>, <argument><expr><name>gp_session_id</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"cmd"</literal></expr></argument>, <argument><expr><name>gp_command_count</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="string">"seg"</literal></expr></argument>, <argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name>currentSliceId</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>dist_trans_id</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>local_trans_id</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TransactionId</name></type> <name>subtrans_id</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>GetAllTransactionXids</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dist_trans_id</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>local_trans_id</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>subtrans_id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"dx"</literal></expr></argument>, <argument><expr><name>dist_trans_id</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"x"</literal></expr></argument>, <argument><expr><name>local_trans_id</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">"sx"</literal></expr></argument>, <argument><expr><name>subtrans_id</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<comment type="block">/* error severity */</comment>
	<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><call><name>error_severity</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sql state code */</comment>
	<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* error message */</comment>
	<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* errdetail */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* errhint */</comment>
	<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* internal query */</comment>
	<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* internal query pos */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* error context */</comment>
	<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* user query */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>edata</name><operator>-&gt;</operator><name>hide_stmt</name></name> <operator>&amp;&amp;</operator>
		<call><name>is_log_level_output</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>, <argument><expr><name>log_min_error_statement</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name>debug_query_string</name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* cursor pos */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* func name */</comment>
	<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* file name */</comment>
	<expr_stmt><expr><call><name>write_syslogger_file_string</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* line number */</comment>
	<expr_stmt><expr><call><name>syslogger_write_int32</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="string">""</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* stack trace */</comment>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>edata</name><operator>-&gt;</operator><name>printstack</name></name> <operator>||</operator>
			<operator>(</operator><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&gt;=</operator> <name>ERROR</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>==</operator> <name>PANIC</name> <operator>||</operator> <operator>!</operator><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>edata</name><operator>-&gt;</operator><name>stacktracesize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>append_stacktrace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*PipeProtoChunk*/</comment>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/*StringInfo*/</comment>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stacktracearray</name></name></expr></argument>,
						  <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stacktracesize</name></name></expr></argument>, <argument><expr><name>amsyslogger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* EOL */</comment>
	<if_stmt><if>if <condition>(<expr><name>amsyslogger</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name>LOG_EOL</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>LOG_EOL</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>LOG_EOL</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>LOG_EOL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write error report to server's log.
 *
 * This is an equivalent function as send_message_to_server_log, but will write
 * the error report in the format of GpPipeProtoHeader, followed by a serialized
 * format of GpErrorData. The error report is sent over to the syslogger process
 * through the pipe.
 *
 * This function is thread-safe. Here, we assume that sprintf is thread-safe.
 */</comment>
<function><type><name>void</name></type>
<name>write_message_to_server_log</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>sqlerrcode</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>message</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>detail</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>hint</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>query_text</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>cursorpos</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>internalpos</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>internalquery</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>show_funcname</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>filename</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>lineno</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>stacktracesize</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>omit_location</name></decl></parameter>,
							<parameter><decl><type><name>void</name><modifier>*</modifier> <specifier>const</specifier> <modifier>*</modifier></type><name>stacktracearray</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>printstack</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PipeProtoChunk</name></type> <name>buffer</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpErrorDataFixFields</name></type> <name>fix_fields</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>static</specifier> <name>uint64</name></type> <name>log_line_number</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>am_syslogger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>zero</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>=</operator> <call><name>mythread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>main_thid</name></name> <operator>=</operator> <call><name>mainthread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>chunk_no</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>is_last</name></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>log_format</name></name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>log_line_number</name></name> <operator>=</operator> <name>log_line_number</name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>is_segv_msg</name></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>


    <comment type="block">/* Serialize edata in the order defined in GpErrorData. */</comment>

	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>session_start_time</name></name> <operator>=</operator>
		<ternary><condition><expr><operator>(</operator><name>MyProcPort</name> <operator>==</operator> <name>NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>(</operator><name>pg_time_t</name><operator>)</operator> <call><name>timestamptz_to_time_t</name><argument_list>(<argument><expr><name>MyStartTimestamp</name></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>omit_location</name></name> <operator>=</operator> <ternary><condition><expr><name>omit_location</name></expr> ?</condition><then> <expr><literal type="char">'t'</literal></expr> </then><else>: <expr><literal type="char">'f'</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>gp_is_primary</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>gp_session_id</name></name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>gp_command_count</name></name> <operator>=</operator> <name>gp_command_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>gp_segment_id</name></name> <operator>=</operator> <name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>slice_id</name></name> <operator>=</operator> <name>currentSliceId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>error_cursor_pos</name></name> <operator>=</operator> <name>cursorpos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>internal_query_pos</name></name> <operator>=</operator> <name>internalpos</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>error_fileline</name></name> <operator>=</operator> <name>lineno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fix_fields</name><operator>.</operator><name>top_trans_id</name></name> <operator>=</operator> <call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>GetAllTransactionXids</name><argument_list>(<argument><expr><operator>&amp;</operator><operator>(</operator><name><name>fix_fields</name><operator>.</operator><name>dist_trans_id</name></name><operator>)</operator></expr></argument>,
						  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>fix_fields</name><operator>.</operator><name>local_trans_id</name></name><operator>)</operator></expr></argument>,
						  <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>fix_fields</name><operator>.</operator><name>subtrans_id</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GpErrorDataFixFields</name></expr></argument>)</argument_list></sizeof> <operator>&lt;=</operator> <name>PIPE_MAX_PAYLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>data</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fix_fields</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpErrorDataFixFields</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GpErrorDataFixFields</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Variable-length fields */</comment>

	<comment type="block">/* username */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>user_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>user_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* databasename */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>database_name</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>database_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* remote_host */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_host</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* remote_port */</comment>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>MyProcPort</name><operator>-&gt;</operator><name>remote_port</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* error severity */</comment>
	<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><call><name>error_severity</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* sql state */</comment>
	<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><call><name>unpack_sql_state</name><argument_list>(<argument><expr><name>sqlerrcode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* error_message */</comment>
	<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>message</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* error_detail */</comment>
	<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>detail</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* error_hint */</comment>
	<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>hint</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* internal_query */</comment>
	<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>internalquery</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* error_context  */</comment>
	<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* debug_query_string */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_log_level_output</name><argument_list>(<argument><expr><name>elevel</name></expr></argument>, <argument><expr><name>log_min_error_statement</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>query_text</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* error_func_name */</comment>
	<if_stmt><if>if <condition>(<expr><name>show_funcname</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* error_filename */</comment>
	<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>filename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* stacktrace */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>printstack</name> <operator>||</operator>
		 <operator>(</operator><name>elevel</name> <operator>&gt;=</operator> <name>ERROR</name> <operator>&amp;&amp;</operator>
		  <operator>(</operator><name>elevel</name> <operator>==</operator> <name>PANIC</name> <operator>||</operator> <operator>!</operator><name>omit_location</name><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<name>stacktracesize</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name>stacktracearray</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="line">// move stack trace to new line</comment>
		<expr_stmt><expr><call><name>append_string_to_pipe_chunk</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><literal type="string">"Stack trace:\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>--</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>append_stacktrace</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/*StringInfo*/</comment>, <argument><expr><name>stacktracearray</name></expr></argument>, <argument><expr><name>stacktracesize</name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument> <comment type="block">/*amsyslogger*/</comment>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Send the last chunk */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>is_last</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gp_write_pipe_chunk</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>+</operator> <name>PIPE_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write error report to server's log
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>send_message_to_server_log</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>prefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nc</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><call><name>mainthread</name><argument_list>()</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><call><name>mythread</name><argument_list>()</argument_list></call> <operator>==</operator> <call><name>mainthread</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>Logging_collector</name> <operator>&amp;&amp;</operator> <name>gp_log_format</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>redirection_done</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_syslogger</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_message_to_server_log</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>,
												<argument><expr><ternary><condition><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name> <operator>!=</operator> <name>NULL</name></expr> ?</condition><then> <expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr> </then><else>: <expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></else></ternary></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>,
												<argument><expr><ternary><condition><expr><name><name>edata</name><operator>-&gt;</operator><name>hide_stmt</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name>debug_query_string</name></expr></else></ternary></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>,
												<argument><expr><ternary><condition><expr><name><name>edata</name><operator>-&gt;</operator><name>hide_ctx</name></name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></else></ternary></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>show_funcname</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stacktracesize</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stacktracearray</name></name></expr></argument>,
												<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>printstack</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>write_syslogger_in_csv</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>write_syslogger_in_csv</name><argument_list>(<argument><expr><name>edata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<return>return;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Format message prefix. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>saved_timeval_set</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>formatted_log_time</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nc</name> <operator>=</operator> <name><name>buf</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s:  "</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>error_severity</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save copy of prefix for subsequent lines of multi-line message. */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nc</name> <operator>=</operator> <literal type="number">2</literal> <operator>+</operator> <name><name>buf</name><operator>.</operator><name>len</name></name> <operator>-</operator> <name><name>prefix</name><operator>.</operator><name>len</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>enlargeStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>, <argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>prefix</name><operator>.</operator><name>data</name></name><operator>+</operator><name><name>prefix</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>nc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prefix</name><operator>.</operator><name>len</name></name> <operator>+=</operator> <name>nc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>prefix</name><operator>.</operator><name>data</name><index>[<expr><name><name>prefix</name><operator>.</operator><name>len</name></name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Log_error_verbosity</name> <operator>&gt;=</operator> <name>PGERROR_VERBOSE</name> <operator>&amp;&amp;</operator>
		<name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* unpack MAKE_SQLSTATE code */</comment>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>tbuf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ssval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>ssval</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PGUNSIXBIT</name><argument_list>(<argument><expr><name>ssval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ssval</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>tbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"(%s) "</literal></expr></argument>, <argument><expr><name>tbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>   <modifier>*</modifier></type><name>cp</name> <init>= <expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></init></decl>;</decl_stmt>

		<while>while <condition>(<expr><operator>*</operator><name>cp</name> <operator>&lt;=</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator>
			   <operator>*</operator><name>cp</name> <operator>&gt;</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cp</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
		<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>cp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"missing error text"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" at character %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" at character %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Log_error_verbosity</name> <operator>&gt;=</operator> <name>PGERROR_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"DETAIL:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail_log</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>prefix</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>prefix</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"DETAIL:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"HINT:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"QUERY:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>edata</name><operator>-&gt;</operator><name>hide_ctx</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"CONTEXT:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>Log_error_verbosity</name> <operator>&gt;=</operator> <name>PGERROR_VERBOSE</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>==</operator> <name>INFO</name> <operator>||</operator> <name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name></expr>)</condition>
			<block>{<block_content/>}</block></if>
			<comment type="block">/* assume no newlines in funcname or filename... */</comment>
			<if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name> <operator>&amp;&amp;</operator> <name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>prefix</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>prefix</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"LOCATION:  %s, %s:%d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>,
								 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"LOCATION:  %s:%d\n"</literal></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the user wants the query that generated this error logged, do it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>is_log_level_output</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>, <argument><expr><name>log_min_error_statement</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<name>debug_query_string</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name><name>edata</name><operator>-&gt;</operator><name>hide_stmt</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>log_line_prefix</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"STATEMENT:  "</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>append_with_tabs</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name>debug_query_string</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&gt;=</operator> <name>ERROR</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>==</operator> <name>PANIC</name> <operator>||</operator> <operator>!</operator><name><name>edata</name><operator>-&gt;</operator><name>omit_location</name></name><operator>)</operator> <operator>&amp;&amp;</operator>
		<name><name>edata</name><operator>-&gt;</operator><name>stacktracesize</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BACKTRACE_SYMBOLS</name></cpp:ifdef>
		<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>strings</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>strings</name> <operator>=</operator> <call><name>backtrace_symbols</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stacktracearray</name></name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>stacktracesize</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>strings</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>edata</name><operator>-&gt;</operator><name>stacktracesize</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>prefix</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>prefix</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"Traceback %d:  %.200s"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator><name>i</name></expr></argument>, <argument><expr><name><name>strings</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><call><name>free</name><argument_list>(<argument><expr><name>strings</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if></if_stmt>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_SYSLOG</name></cpp:ifdef>
	<comment type="block">/* Write to syslog, if enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_SYSLOG</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>syslog_level</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DEBUG5</name></expr>:</case>
			<case>case <expr><name>DEBUG4</name></expr>:</case>
			<case>case <expr><name>DEBUG3</name></expr>:</case>
			<case>case <expr><name>DEBUG2</name></expr>:</case>
			<case>case <expr><name>DEBUG1</name></expr>:</case>
				<expr_stmt><expr><name>syslog_level</name> <operator>=</operator> <name>LOG_DEBUG</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>LOG</name></expr>:</case>
			<case>case <expr><name>LOG_SERVER_ONLY</name></expr>:</case>
			<case>case <expr><name>INFO</name></expr>:</case>
				<expr_stmt><expr><name>syslog_level</name> <operator>=</operator> <name>LOG_INFO</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>NOTICE</name></expr>:</case>
			<case>case <expr><name>WARNING</name></expr>:</case>
				<expr_stmt><expr><name>syslog_level</name> <operator>=</operator> <name>LOG_NOTICE</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>ERROR</name></expr>:</case>
				<expr_stmt><expr><name>syslog_level</name> <operator>=</operator> <name>LOG_WARNING</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>FATAL</name></expr>:</case>
				<expr_stmt><expr><name>syslog_level</name> <operator>=</operator> <name>LOG_ERR</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>PANIC</name></expr>:</case>
			<default>default:</default>
				<expr_stmt><expr><name>syslog_level</name> <operator>=</operator> <name>LOG_CRIT</name></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<expr_stmt><expr><call><name>write_syslog</name><argument_list>(<argument><expr><name>syslog_level</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* HAVE_SYSLOG */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<comment type="block">/* Write to eventlog, if enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_EVENTLOG</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_eventlog</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* WIN32 */</comment>

	<comment type="block">/* Write to stderr, if enabled */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name><operator>)</operator> <operator>||</operator> <name>whereToSendOutput</name> <operator>==</operator> <name>DestDebug</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Use the chunking protocol if we know the syslogger should be
		 * catching stderr output, and we are not ourselves the syslogger.
		 * Otherwise, just do a vanilla write to stderr.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>redirection_done</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_syslogger</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_pipe_chunks</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

		<comment type="block">/*
		 * In a win32 service environment, there is no usable stderr. Capture
		 * anything going there and write it to the eventlog instead.
		 *
		 * If stderr redirection is active, it was OK to write to stderr above
		 * because that's really a pipe to the syslogger process.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>pgwin32_is_service</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><name>redirection_done</name> <operator>||</operator> <name>am_syslogger</name><operator>)</operator></expr> )</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>write_eventlog</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<comment type="block">/* only use the chunking protocol if we know the syslogger should
			 * be catching stderr output, and we are not ourselves the
			 * syslogger. Otherwise, go directly to stderr.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>redirection_done</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>am_syslogger</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_pipe_chunks</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_console</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If in the syslogger process, try to write messages direct to file */</comment>
	<if_stmt><if>if <condition>(<expr><name>am_syslogger</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>write_syslogger_file_binary</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>, <argument><expr><name>LOG_DESTINATION_STDERR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>prefix</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Write to CSV log if enabled */</comment>
	<if_stmt><if>if <condition>(<expr><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_CSVLOG</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>redirection_done</name> <operator>||</operator> <name>am_syslogger</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * send CSV data if it's safe to do so (syslogger doesn't need the
			 * pipe). First get back the space in the message buffer.
			 */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>write_csvlog</name><argument_list>(<argument><expr><name>edata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * syslogger not up (yet), so just dump the message to stderr,
			 * unless we already did so above.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>Log_destination</name> <operator>&amp;</operator> <name>LOG_DESTINATION_STDERR</name><operator>)</operator> <operator>&amp;&amp;</operator>
				<name>whereToSendOutput</name> <operator>!=</operator> <name>DestDebug</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_console</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Send data to the syslogger using the chunked protocol
 *
 * Note: when there are multiple backends writing into the syslogger pipe,
 * it's critical that each write go into the pipe indivisibly, and not
 * get interleaved with data from other processes.  Fortunately, the POSIX
 * spec requires that writes to pipes be atomic so long as they are not
 * more than PIPE_BUF bytes long.  So we divide long messages into chunks
 * that are no more than that length, and send one chunk per write() call.
 * The collector process knows how to reassemble the chunks.
 *
 * Because of the atomic write requirement, there are only two possible
 * results from write() here: -1 for failure, or the requested number of
 * bytes.  There is not really anything we can do about a failure; retry would
 * probably be an infinite loop, and we can't even report the error usefully.
 * (There is noplace else we could send it!)  So we might as well just ignore
 * the result from write().  However, on some platforms you get a compiler
 * warning from ignoring write()'s result, so do a little dance with casting
 * rc to void to shut up the compiler.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>write_pipe_chunks</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dest</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PipeProtoChunk</name></type> <name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fd</name> <init>= <expr><call><name>fileno</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>zero</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>=</operator> <call><name>mythread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>main_thid</name></name> <operator>=</operator> <call><name>mainthread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>chunk_no</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>log_format</name></name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>dest</name> <operator>==</operator> <name>LOG_DESTINATION_CSVLOG</name></expr> ?</condition><then> <expr><literal type="char">'c'</literal></expr> </then><else>: <expr><literal type="char">'t'</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>is_segv_msg</name></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* write all but the last chunk */</comment>
	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>PIPE_MAX_PAYLOAD</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>is_last</name></name> <operator>=</operator> <literal type="char">'f'</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>PIPE_MAX_PAYLOAD</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>PIPE_MAX_PAYLOAD</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>zero</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>PIPE_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>data</name> <operator>+=</operator> <name>PIPE_MAX_PAYLOAD</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>PIPE_MAX_PAYLOAD</name></expr>;</expr_stmt>

		<expr_stmt><expr><operator>++</operator><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>chunk_no</name></name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* write the last chunk */</comment>
	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>is_last</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ASSERT_CHECKING</name></cpp:ifdef>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>zero</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>PIPE_HEADER_SIZE</name> <operator>+</operator> <name>len</name> <operator>&lt;=</operator> <name>PIPE_CHUNK_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>p</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name>data</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ignore_returned_result</name><argument_list>(<argument><expr><call><name>write</name><argument_list>(<argument><expr><name>fd</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>PIPE_HEADER_SIZE</name> <operator>+</operator> <name>len</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Append a text string to the error report being built for the client.
 *
 * This is ordinarily identical to pq_sendstring(), but if we are in
 * error recursion trouble we skip encoding conversion, because of the
 * possibility that the problem is a failure in the encoding conversion
 * subsystem itself.  Code elsewhere should ensure that the passed-in
 * strings will be plain 7-bit ASCII, and thus not in need of conversion,
 * in such cases.  (In particular, we disable localization of error messages
 * to help ensure that's true.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>err_sendstring</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>in_error_recursion_trouble</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_send_ascii_string</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_sendstring</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Write error report to client
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>send_message_to_frontend</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>msgbuf</name></decl>;</decl_stmt>

	<comment type="block">/* 'N' (Notice) is for nonfatal conditions, 'E' is for errors */</comment>
	<expr_stmt><expr><call><name>pq_beginmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name> <operator>&lt;</operator> <name>ERROR</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'N'</literal></expr> </then><else>: <expr><literal type="char">'E'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_PROTOCOL_MAJOR</name><argument_list>(<argument><expr><name>FrontendProtocol</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">3</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* New style with separate fields */</comment>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sev</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>tbuf</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>ssval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sev</name> <operator>=</operator> <call><name>error_severity</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_SEVERITY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><name>sev</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_SEVERITY_NONLOCALIZED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>sev</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* unpack MAKE_SQLSTATE code */</comment>
		<expr_stmt><expr><name>ssval</name> <operator>=</operator> <name><name>edata</name><operator>-&gt;</operator><name>sqlerrcode</name></name></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">5</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>tbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>PGUNSIXBIT</name><argument_list>(<argument><expr><name>ssval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ssval</name> <operator>&gt;&gt;=</operator> <literal type="number">6</literal></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><name><name>tbuf</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_SQLSTATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>tbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* M field is required per protocol, so always send something */</comment>
		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_PRIMARY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"missing error text"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_DETAIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>detail</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* detail_log is intentionally not used here */</comment>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_MESSAGE_HINT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_SCHEMA_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>schema_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_TABLE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>table_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_COLUMN_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>column_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_DATATYPE_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>datatype_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_CONSTRAINT_NAME</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>constraint_name</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_STATEMENT_POSITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>tbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_INTERNAL_POSITION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>tbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_INTERNAL_QUERY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalquery</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_FILE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>filename</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>tbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>tbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>lineno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_LINE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>tbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name>PG_DIAG_SOURCE_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>pq_sendbyte</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><literal type="char">'\0'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* terminator */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Old style --- gin up a backwards-compatible message */</comment>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s:  "</literal></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><call><name>error_severity</name><argument_list>(<argument><expr><name><name>edata</name><operator>-&gt;</operator><name>elevel</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>show_funcname</name></name> <operator>&amp;&amp;</operator> <name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s: "</literal></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>funcname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>message</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">"missing error text"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" at character %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>cursorpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>_</name><argument_list>(<argument><expr><literal type="string">" at character %d"</literal></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><name><name>edata</name><operator>-&gt;</operator><name>internalpos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>err_sendstring</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pq_endmessage</name><argument_list>(<argument><expr><operator>&amp;</operator><name>msgbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This flush is normally not necessary, since postgres.c will flush out
	 * waiting data when control returns to the main loop. But it seems best
	 * to leave it here, so that the client has some clue what happened if the
	 * backend dies before getting back to the main loop ... error/notice
	 * messages should not be a performance-critical path anyway, so an extra
	 * flush won't hurt much ...
	 */</comment>
	<expr_stmt><expr><call><name>pq_flush</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Support routines for formatting error messages.
 */</comment>


<comment type="block">/*
 * error_severity --- get string representing elevel
 *
 * The string is not localized here, but we mark the strings for translation
 * so that callers can invoke _() on the result.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>error_severity</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>elevel</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DEBUG1</name></expr>:</case>
		<case>case <expr><name>DEBUG2</name></expr>:</case>
		<case>case <expr><name>DEBUG3</name></expr>:</case>
		<case>case <expr><name>DEBUG4</name></expr>:</case>
		<case>case <expr><name>DEBUG5</name></expr>:</case>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"DEBUG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>LOG</name></expr>:</case>
		<case>case <expr><name>LOG_SERVER_ONLY</name></expr>:</case>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"LOG"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>INFO</name></expr>:</case>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"INFO"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NOTICE</name></expr>:</case>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"NOTICE"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>WARNING</name></expr>:</case>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"WARNING"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>ERROR</name></expr>:</case>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"ERROR"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>FATAL</name></expr>:</case>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"FATAL"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>PANIC</name></expr>:</case>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>gettext_noop</name><argument_list>(<argument><expr><literal type="string">"PANIC"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>prefix</name> <operator>=</operator> <literal type="string">"???"</literal></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<return>return <expr><name>prefix</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 *	append_with_tabs
 *
 *	Append the string to the StringInfo buffer, inserting a tab after any
 *	newline.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>append_with_tabs</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name></type>		<name>ch</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>(</operator><name>ch</name> <operator>=</operator> <operator>*</operator><name>str</name><operator>++</operator><operator>)</operator> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>


<comment type="block">/*
 * Write errors to stderr (or by equal means when stderr is
 * not available). Used before ereport/elog can be used
 * safely (memory context, GUC load etc)
 */</comment>
<function><type><name>void</name></type>
<name>write_stderr</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,<parameter><decl><type><modifier>...</modifier></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>va_list</name></type>		<name>ap</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* Arbitrary size? */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>fmt</name> <operator>=</operator> <call><name>_</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>va_start</name><argument_list>(<argument><expr><name>ap</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>Logging_collector</name> <operator>&amp;&amp;</operator> <name>gp_log_format</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>errbuf</name><index>[<expr><literal type="number">2048</literal></expr>]</index></name></decl>;</decl_stmt>		<comment type="block">/* Arbitrary size? */</comment>

		<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>am_syslogger</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Write the message in the CSV format */</comment>
			<expr_stmt><expr><call><name>write_message_to_server_log</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>errbuf</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><literal type="number">0</literal></expr></argument>,
										<argument><expr><name>true</name></expr></argument>,
										<argument><expr><name>NULL</name></expr></argument>,
										<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>ErrorData</name></type> <name>edata</name></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>elevel</name></name> <operator>=</operator> <name>LOG</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>message</name></name> <operator>=</operator> <name>errbuf</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>edata</name><operator>.</operator><name>omit_location</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>redirection_done</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_syslogger_in_csv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>write_syslogger_in_csv</name><argument_list>(<argument><expr><operator>&amp;</operator><name>edata</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>WIN32</name></cpp:ifndef>
	<comment type="block">/* On Unix, we just fprintf to stderr */</comment>
	<expr_stmt><expr><call><name>vfprintf</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>vsnprintf</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * On Win32, we print to stderr if running on a console, or write to
	 * eventlog if running as a service
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>pgwin32_is_service</name><argument_list>()</argument_list></call></expr>)</condition>	<comment type="block">/* Running as a service */</comment>
	<block>{<block_content>
		<expr_stmt><expr><call><name>write_eventlog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><name>errbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Not running as service, write to stderr */</comment>
		<expr_stmt><expr><call><name>write_console</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>errbuf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><call><name>va_end</name><argument_list>(<argument><expr><name>ap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * is_log_level_output -- is elevel logically &gt;= log_min_level?
 *
 * We use this for tests that should consider LOG to sort out-of-order,
 * between ERROR and FATAL.  Generally this is the right thing for testing
 * whether a message should go to the postmaster log, whereas a simple &gt;=
 * test is correct for testing whether the message should go to the client.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_log_level_output</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>elevel</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>log_min_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>==</operator> <name>LOG</name> <operator>||</operator> <name>elevel</name> <operator>==</operator> <name>LOG_SERVER_ONLY</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>log_min_level</name> <operator>==</operator> <name>LOG</name> <operator>||</operator> <name>log_min_level</name> <operator>&lt;=</operator> <name>ERROR</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>log_min_level</name> <operator>==</operator> <name>LOG</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* elevel != LOG */</comment>
		<if_stmt><if>if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>FATAL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<comment type="block">/* Neither is LOG */</comment>
	<if type="elseif">else if <condition>(<expr><name>elevel</name> <operator>&gt;=</operator> <name>log_min_level</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Adjust the level of a recovery-related message per trace_recovery_messages.
 *
 * The argument is the default log level of the message, eg, DEBUG2.  (This
 * should only be applied to DEBUGn log messages, otherwise it's a no-op.)
 * If the level is &gt;= trace_recovery_messages, we return LOG, causing the
 * message to be logged unconditionally (for most settings of
 * log_min_messages).  Otherwise, we return the argument unchanged.
 * The message will then be shown based on the setting of log_min_messages.
 *
 * Intention is to keep this for at least the whole of the 9.0 production
 * release, so we can more easily diagnose production problems in the field.
 * It should go away eventually, though, because it's an ugly and
 * hard-to-explain kluge.
 */</comment>
<function><type><name>int</name></type>
<name>trace_recovery</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>trace_level</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>trace_level</name> <operator>&lt;</operator> <name>LOG</name> <operator>&amp;&amp;</operator>
		<name>trace_level</name> <operator>&gt;=</operator> <name>trace_recovery_messages</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>LOG</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>trace_level</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * elog_debug_linger
 */</comment>
<function><type><name>void</name></type>
<name>elog_debug_linger</name><parameter_list>(<parameter><decl><type><name>ErrorData</name> <modifier>*</modifier></type><name>edata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>seconds_to_linger</name> <init>= <expr><name>gp_debug_linger</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>seconds_lingered</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Don't linger again in the event of another error. */</comment>
	<expr_stmt><expr><name>gp_debug_linger</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/* A word of explanation to the user... */</comment>
	<expr_stmt><expr><call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"%s%sProcess %d will wait for gp_debug_linger=%d seconds before termination.\n"</literal>
			<literal type="string">"Note that its locks and other resources will not be released until then."</literal></expr></argument>,
			<argument><expr><ternary><condition><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr> ?</condition><then> <expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><ternary><condition><expr><name><name>edata</name><operator>-&gt;</operator><name>hint</name></name></expr> ?</condition><then> <expr><literal type="string">"\n"</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr></argument>,
			<argument><expr><name>MyProcPid</name></expr></argument>,
			<argument><expr><name>seconds_to_linger</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Log the error and notify the client. */</comment>
	<expr_stmt><expr><call><name>EmitErrorReport</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stdout</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fflush</name><argument_list>(<argument><expr><name>stderr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Terminate the client connection. */</comment>
	<expr_stmt><expr><call><name>pq_comm_close_fatal</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>seconds_lingered</name> <operator>&lt;</operator> <name>seconds_to_linger</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>seconds_left</name> <init>= <expr><name>seconds_to_linger</name> <operator>-</operator> <name>seconds_lingered</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>minutes_left</name> <init>= <expr><name>seconds_left</name> <operator>/</operator> <literal type="number">60</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>setproctitle_seconds</name> <init>= <expr><ternary><condition><expr><operator>(</operator><name>minutes_left</name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">5</literal></expr>
									 </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>minutes_left</name> <operator>&lt;=</operator> <literal type="number">5</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">30</literal></expr>
									 </then><else>: <expr><literal type="number">60</literal></expr></else></ternary></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>sleep_seconds</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><literal type="number">50</literal></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* Update 'ps' display. */</comment>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></sizeof><operator>-</operator><literal type="number">1</literal></expr></argument>,
				 <argument><expr><literal type="string">"error exit in %dm %ds"</literal></expr></argument>,
				 <argument><expr><name>minutes_left</name></expr></argument>,
				 <argument><expr><name>seconds_left</name> <operator>-</operator> <name>minutes_left</name> <operator>*</operator> <literal type="number">60</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>set_ps_display</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Sleep. */</comment>
		<expr_stmt><expr><name>sleep_seconds</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>seconds_left</name></expr></argument>, <argument><expr><name>setproctitle_seconds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><name>sleep_seconds</name> <operator>*</operator> <literal type="number">1000000L</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>seconds_lingered</name> <operator>+=</operator> <name>sleep_seconds</name></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>							   <comment type="block">/* elog_debug_linger */</comment>

<function><type><name>void</name></type>
<name>debug_backtrace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BACKTRACE_SYMBOLS</name></cpp:ifdef>
	<decl_stmt><decl><type><name>int</name></type> 		<name>stacktracesize</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name><name>stacktracearray</name><index>[<expr><literal type="number">30</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>stacktracesize</name> <operator>=</operator> <call><name>backtrace</name><argument_list>(<argument><expr><name>stacktracearray</name></expr></argument>, <argument><expr><literal type="number">30</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>append_stacktrace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*PipeProtoChunk*/</comment>, <argument><expr><name>NULL</name></expr></argument> <comment type="block">/*StringInfo*/</comment>, <argument><expr><name>stacktracearray</name></expr></argument>, <argument><expr><name>stacktracesize</name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument><comment type="block">/*amsyslogger*/</comment>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

</block_content>}</block></function>

<comment type="block">/*
 * Unwind stack up to a given depth and store frame addresses to passed array;
 * return stack depth;
 */</comment>
<function><type><name>uint32</name></type> <name>gp_backtrace</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>stackAddresses</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>maxStackDepth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
<cpp:ifndef>#<cpp:directive>ifndef</cpp:directive> <name>HAVE_BACKTRACE_SYMBOLS</name></cpp:ifndef>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:if>#<cpp:directive>if</cpp:directive> <expr><call><name>defined</name><argument_list>(<argument><expr><name>__i386</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>defined</name><argument_list>(<argument><expr><name>__x86_64__</name></expr></argument>)</argument_list></call></expr></cpp:if>

	<comment type="block">/*
	 * Stack base pointer has not been initialized by PostmasterMain,
	 * or PostgresMain/AuxiliaryProcessMain is called directly by main
	 * rather than forked by PostmasterMain (such as when initdb).
	 *
	 * In this case, just return depth as 0 to indicate that we have not
	 * stored any frame addresses.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stack_base_ptr</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* get base pointer of current frame */</comment>
	<decl_stmt><decl><type><name>uint64</name></type> <name>framePtrValue</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>GET_FRAME_POINTER</name><argument_list>(<argument><expr><name>framePtrValue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>uint32</name></type> <name>depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>pFramePtr</name> <init>= <expr><operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator> <call><name>GET_PTR_FROM_VALUE</name><argument_list>(<argument><expr><name>framePtrValue</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* check if the frame pointer is valid */</comment>
	<if_stmt><if>if <condition>(<expr><name>pFramePtr</name> <operator>!=</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>depth</name> <operator>&lt;</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pFramePtr</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* consider the first maxStackDepth frames only, below the stack base pointer */</comment>
		<for>for <control>(<init><expr><name>depth</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>depth</name> <operator>&lt;</operator> <name>maxStackDepth</name></expr>;</condition> <incr><expr><name>depth</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* check if next frame is within stack */</comment>
			<if_stmt><if>if <condition>(<expr><name>pFramePtr</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
				<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>pFramePtr</name> <operator>&gt;</operator> <operator>*</operator><name>pFramePtr</name> <operator>||</operator>
				<operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>stack_base_ptr</name> <operator>&lt;</operator> <operator>*</operator><name>pFramePtr</name></expr>)</condition>
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* get return address (one above the frame pointer) */</comment>
			<decl_stmt><decl><type><specifier>const</specifier> <name>uintptr_t</name> <modifier>*</modifier></type><name>returnAddr</name> <init>= <expr><operator>(</operator><name>uintptr_t</name> <operator>*</operator><operator>)</operator><operator>(</operator><name>pFramePtr</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

			<comment type="block">/* store return address */</comment>
			<expr_stmt><expr><name><name>stackAddresses</name><index>[<expr><name>depth</name></expr>]</index></name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>*</operator><name>returnAddr</name></expr>;</expr_stmt>

			<comment type="block">/* move to next frame */</comment>
			<expr_stmt><expr><name>pFramePtr</name> <operator>=</operator> <operator>(</operator><name>void</name><operator>*</operator><operator>*</operator><operator>)</operator><operator>*</operator><name>pFramePtr</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>depth</name>  <operator>=</operator> <call><name>backtrace</name><argument_list>(<argument><expr><name>stackAddresses</name></expr></argument>, <argument><expr><name>maxStackDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>depth</name></expr>;</return>

<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<return>return <expr><call><name>backtrace</name><argument_list>(<argument><expr><name>stackAddresses</name></expr></argument>, <argument><expr><name>maxStackDepth</name></expr></argument>)</argument_list></call></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
</block_content>}</block></function>


<comment type="block">/*
 * Build stack trace
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type><name>gp_stacktrace</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>stackAddresses</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>stackDepth</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>append</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>append</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BACKTRACE_SYMBOLS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>append_stacktrace</name><argument_list>(<argument><expr><name>NULL</name></expr></argument> <comment type="block">/*PipeProtoChunk*/</comment>, <argument><expr><operator>&amp;</operator><name>append</name></expr></argument>, <argument><expr><name>stackAddresses</name></expr></argument>, <argument><expr><name>stackDepth</name></expr></argument>,
					 <argument><expr><name>false</name></expr></argument><comment type="block">/*amsyslogger*/</comment>)</argument_list></call></expr>;</expr_stmt>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>append</name></expr></argument>, <argument><expr><literal type="string">"stack trace is not available for this platform"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/* we may fail to retrieve stack on opt build */</comment>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>append</name><operator>.</operator><name>len</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>append</name></expr></argument>, <argument><expr><literal type="string">"failed to retrieve stack"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name><name>append</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SignalName
 *   Convert a SEGV/BUS/ILL to name.
 */</comment>
<function><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>SegvBusIllName</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>signal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>signal</name> <operator>==</operator> <name>SIGILL</name> <operator>||</operator>
		   <name>signal</name> <operator>==</operator> <name>SIGSEGV</name> <operator>||</operator>
		   <name>signal</name> <operator>==</operator> <name>SIGBUS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<switch>switch <condition>(<expr><name>signal</name></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGILL</name></cpp:ifdef>
		<case>case <expr><name>SIGILL</name></expr>:</case>
			<return>return <expr><literal type="string">"SIGILL"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSEGV</name></cpp:ifdef>
		<case>case <expr><name>SIGSEGV</name></expr>:</case>
			<return>return <expr><literal type="string">"SIGSEGV"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBUS</name></cpp:ifdef>
		<case>case <expr><name>SIGBUS</name></expr>:</case>
			<return>return <expr><literal type="string">"SIGBUS"</literal></expr>;</return>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></switch>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * StandardHandlerForSigillSigsegvSigbus_OnMainThread
 *   Async-safe signal handler for SEGV/BUS/ILL.
 * This function simple collects the stack addresses and some process information
 * and write them to the pipe.
 */</comment>
<function><type><name>void</name></type>
<name>StandardHandlerForSigillSigsegvSigbus_OnMainThread</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>processName</name></decl></parameter>, <parameter><decl><type><name>SIGNAL_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_SETMASK</name><argument_list>(<argument><expr><operator>&amp;</operator><name>BlockSig</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Unblock SEGV/BUS/ILL signals, and set them to their default settings. */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGILL</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGILL</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGSEGV</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGSEGV</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>SIGBUS</name></cpp:ifdef>
	<expr_stmt><expr><call><name>pqsignal</name><argument_list>(<argument><expr><name>SIGBUS</name></expr></argument>, <argument><expr><name>SIG_DFL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<decl_stmt><decl><type><name>PipeProtoChunk</name></type> <name>buffer</name></decl>;</decl_stmt>
	
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>zero</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>pid</name></name> <operator>=</operator> <name>MyProcPid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * mythread() are not really async-safe, but syslogger requires this value
	 * to be set as part of an identifier of a chunk. We create a fake value here to
	 * satisfy the condition of a valid chunk. But in the syslogger, we reset its
	 * value to 0.
	 */</comment>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>thid</name></name> <operator>=</operator> <name>FIXED_THREAD_ID</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>main_thid</name></name> <operator>=</operator> <call><name>mainthread</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>chunk_no</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>is_last</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>log_format</name></name> <operator>=</operator> <literal type="char">'c'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>is_segv_msg</name></name> <operator>=</operator> <literal type="char">'t'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>log_line_number</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>next</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>data</name> <init>= <expr><name><name>buffer</name><operator>.</operator><name>data</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GpSegvErrorData</name> <modifier>*</modifier></type><name>errorData</name> <init>= <expr><operator>(</operator><name>GpSegvErrorData</name> <operator>*</operator><operator>)</operator><name>data</name></expr></init></decl>;</decl_stmt>
	
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>session_start_time</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>MyProcPort</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>session_start_time</name></name> <operator>=</operator>
			<operator>(</operator><name>pg_time_t</name><operator>)</operator><call><name>timestamptz_to_time_t</name><argument_list>(<argument><expr><name>MyStartTimestamp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>gp_session_id</name></name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>gp_command_count</name></name> <operator>=</operator> <name>gp_command_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>gp_segment_id</name></name> <operator>=</operator> <name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>slice_id</name></name> <operator>=</operator> <name>currentSliceId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>signal_num</name></name> <operator>=</operator> <operator>(</operator><name>int32</name><operator>)</operator><name>postgres_signal_arg</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>frame_depth</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute how many frame addresses we are able to send in a single chunk.
	 * The total space that is available for frame addresses is
	 * (PIPE_MAX_PAYLOAD - MAXALIGN(sizeof(GpSegvErrorData))).
	 */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>frameDepth</name> <init>= <expr><operator>(</operator><name>PIPE_MAX_PAYLOAD</name> <operator>-</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpSegvErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>frameDepth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier></type><name>stackAddressArray</name> <init>= <expr><name>data</name> <operator>+</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpSegvErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>stackAddresses</name> <init>= <expr><name>stackAddressArray</name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name><name>errorData</name><operator>-&gt;</operator><name>frame_depth</name></name> <operator>=</operator> <call><name>gp_backtrace</name><argument_list>(<argument><expr><name>stackAddresses</name></expr></argument>, <argument><expr><name>frameDepth</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>=</operator>
		<call><name>MAXALIGN</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GpSegvErrorData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call> <operator>+</operator>
		<name><name>errorData</name><operator>-&gt;</operator><name>frame_depth</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>void</name> <operator>*</operator></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gp_write_pipe_chunk</name><argument_list>(<argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>buffer</name></expr></argument>, <argument><expr><name><name>buffer</name><operator>.</operator><name>hdr</name><operator>.</operator><name>len</name></name> <operator>+</operator> <name>PIPE_HEADER_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* re-raise the signal to OS */</comment>
	<expr_stmt><expr><call><name>raise</name><argument_list>(<argument><expr><name>postgres_signal_arg</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
