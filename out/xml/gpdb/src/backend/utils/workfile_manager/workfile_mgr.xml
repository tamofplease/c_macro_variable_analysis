<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/workfile_manager/workfile_mgr.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * workfile_mgr.c
 *		Exposes information about BufFiles in shared memory
 *
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2014, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/workfile_manager/workfile_mgr.c
 *
 * NOTES:
 *
 * If a BufFile is created directly with BufFile* functions, it forms its
 * own workfile set.
 *
 *
 * There are three ways to use this:
 *
 * 1. Use the normal upstream BufFile functions, ignoring work files
 * altogether. A workfile set will be created for each BufFile automatically.
 * This ensures that files created by unmodified upstream code is tracked.
 *
 * 2. Use BufFile functions, and call XXX to add extra information to
 * the workfile set.
 *
 * 3. Use workfile_mgr_create_set() to create an explicit working set.
 *
 *
 * Workfile set is removed automatically when the last file associated with
 * it is closed excepted the pinned workfile_set, which should be removed by
 * workfile_mgr_close_set().
 *
 * Distinguish by the workfile_set life cycle, the workfile_set could be class
 * into several classes.
 * 1. workfile_set for a temporary workfile with interXact false(see buffile.c).
 * Once the file closed, the workfile_set will also get freed.
 * And if current transaction aborted, the workfile's resource owner is
 * responsible for closing it if the workfile is leaked, which also removes
 * the workfile_set.
 *
 * 2. workfile_set for a temporary workfile with interXact true(see buffile.c).
 * Once the file closed, the workfile_set will also get removed.
 * Since the workfile doesn't register to a resource owner, WorkFileLocalCtl
 * is responsible for removing its corresponding workfile_set in
 * AtProcExit_WorkFile(which gets called when process exit).
 *
 * 3. workfile_set is pinned and saved to prevent unexpected free operation.
 * When the workfile_set gets pinned, after all the file in the workfile_set
 * gets closed, we don't free the workfile_set, cause we may register new workfile
 * later. Call workfile_mgr_close_set to explicitly remove the workfile_set.
 * To deal with aborting, since the resource owner of the workfiles in the
 * workfile_set will close the workfiles, and this operation will not
 * remove workfile_set when no file exists in the workfile_set. We have to free
 * these kinds of workfile_sets when transaction ends in AtEOXact_WorkFile.
 * If the workfile_set contains interXact workfiles, we still rely on
 * WorkFileLocalCtl to remove workfile_sets in AtProcExit_WorkFile. But currently,
 * we don't have this kind of usage.
 *
 * NOTE: if a workfile_set gets created but no workfile register into it(in case of
 * error, RegisterFileWithSet not called), it will never have a chance to be removed
 * automatically through file close. Then we have to check and remove these
 * workfile_sets when the transaction end to prevent overflow in AtEOXact_WorkFile.
 *
 *
 * The purpose of this tracking is twofold:
 * 1. Provide the gp_toolkit views, so that you can view temporary file
 * usage from a different psql session.
 *
 * 2. Enforce gp_* limits.
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"common/hashfn.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/buffile.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/fd.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/ipc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/workfile_mgr.h"</cpp:file></cpp:include>

<comment type="block">/*
 * GUC: Number of unique workfile sets that can be open at any time. Each
 * workfile set can contain multiple files, however. A hashjoin for example
 * will create one file per batch, but they all belong to the same workfile
 * set.
 */</comment>
<decl_stmt><decl><type><name>int</name></type>			<name>gp_workfile_max_entries</name> <init>= <expr><literal type="number">8192</literal></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SizeOfWorkFileUsagePerQueryKey</name></cpp:macro> <cpp:value>(2 * sizeof(int32));</cpp:value></cpp:define>

<typedef>typedef <type><name><name>struct</name> <name>workfile_set</name></name></type> <name>WorkFileSetSharedEntry</name>;</typedef>

<comment type="block">/*
 * Protected by WorkFileManagerLock (except for sizes, which use atomics)
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>dlist_head</name></type>	<name>freeList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name></type>	<name>activeList</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_active</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint64</name></type>		<name>total_bytes</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>HTAB</name>	   <modifier>*</modifier></type><name>per_query_hash</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkFileSetSharedEntry</name></type> <name><name>entries</name><index>[]</index></name></decl>;</decl_stmt>

}</block></struct></type> <name>WorkFileShared</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>WorkFileShared</name> <modifier>*</modifier></type><name>workfile_shared</name></decl>;</decl_stmt>

<comment type="block">/*
 * WorkFileLocalEntry - track workfile_set for each workfile.
 *
 * work_set - the workfile_set in shared memory for a workfile.
 * size - the size of the workfile.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>WorkFileSetSharedEntry</name>	   <modifier>*</modifier></type><name>work_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>						<name>size</name></decl>;</decl_stmt>
}</block></struct></type> <name>WorkFileLocalEntry</name>;</typedef>

<comment type="block">/*
 * WorkFileLocalCtl, local control struct for workfiles
 *
 * entries - The workfile created in current process will be stored in the the entries
 * indexed by virtual File descriptor.
 * sizeLocalEntries - The total number of workfiles created.
 * localList - track the workfile_sets created in current process.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>WorkFileLocalEntry</name>	   <modifier>*</modifier></type><name>entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>						<name>sizeLocalEntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>					<name>initialized</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_head</name></type>				<name>localList</name></decl>;</decl_stmt>
}</block></struct></type> <name>WorkFileLocalCtl</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <name>WorkFileLocalCtl</name></type> <name>localCtl</name> <init>= <expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><name>false</name></expr>}</block></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>remove_workfile_set_if_possible</name><parameter_list>(<parameter><decl><type><name>workfile_set</name><modifier>*</modifier></type> <name>work_set</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>workfile_set</name> <modifier>*</modifier></type><name>workfile_mgr_create_set_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operator_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>pin_workset</name><parameter_list>(<parameter><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>unpin_workset</name><parameter_list>(<parameter><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl></parameter>)</parameter_list>;</function_decl>

<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>proc_exit_hook_registered</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<function_decl><type><name>Datum</name></type> <name>gp_workfile_mgr_cache_entries</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><name>Datum</name></type> <name>gp_workfile_mgr_used_diskspace</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Shared memory initialization
 */</comment>
<function><type><name>Size</name></type>
<name>WorkFileShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>WorkFileShared</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>gp_workfile_max_entries</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkFileSetSharedEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>hash_estimate_size</name><argument_list>(<argument><expr><name>gp_workfile_max_entries</name></expr></argument>,
											 <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkFileUsagePerQuery</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>WorkFileShmemInit</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>WorkFileShared</name></expr></argument>, <argument><expr><name>entries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>gp_workfile_max_entries</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkFileSetSharedEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>workfile_shared</name> <operator>=</operator> <operator>(</operator><name>WorkFileShared</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"WorkFile Data"</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type> <name>hctl</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>workfile_shared</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>freeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>activeList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workfile_shared</name><operator>-&gt;</operator><name>num_active</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>gp_workfile_max_entries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkFileSetSharedEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>freeList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Initialize per-query hashtable */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <name>SizeOfWorkFileUsagePerQueryKey</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkFileUsagePerQuery</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hctl</name><operator>.</operator><name>hash</name></name> <operator>=</operator> <name>tag_hash</name></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>workfile_shared</name><operator>-&gt;</operator><name>per_query_hash</name></name> <operator>=</operator>
			<call><name>ShmemInitHash</name><argument_list>(<argument><expr><literal type="string">"per-query workfile usage hash"</literal></expr></argument>,
						  <argument><expr><name>gp_workfile_max_entries</name></expr></argument>,
						  <argument><expr><name>gp_workfile_max_entries</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>hctl</name></expr></argument>,
						  <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_FUNCTION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Callback function, to delist all our temporary files from shared memory.
 *
 * We are about to exit, and the temporary files are about to deleted. We
 * have to delist them from shared memory before that, while we still
 * have access to shared memory. fd.c's on_proc_exit callback runs after
 * detaching from shared memory, which is too late.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>AtProcExit_WorkFile</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>code</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type>		<name>iter</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>localCtl</name><operator>.</operator><name>initialized</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;localCtl.localList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>workfile_set</name>	   <modifier>*</modifier></type><name>work_set</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>workfile_set</name></expr></argument>, <argument><expr><name>local_node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>workfile_mgr_close_set</name><argument_list>(<argument><expr><name>work_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Cleanup the workfile_sets at the end of transaction.
 * When transaction aborts, we should clean workfile_sets which
 * don't contain any workfiles.
 * Here we don't care about whether resource owner close workfiles first,
 * or we unpin the workset first. Under either order, the expected workfile_set
 * should be freed. Currently we put it after resource owner release logic.
*/</comment>
<function><type><name>void</name></type>
<name>AtEOXact_WorkFile</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type>		<name>iter</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>localCtl</name><operator>.</operator><name>initialized</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;localCtl.localList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>workfile_set</name>	   <modifier>*</modifier></type><name>work_set</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>workfile_set</name></expr></argument>, <argument><expr><name>local_node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>active</name></name> <operator>&amp;&amp;</operator> <name><name>work_set</name><operator>-&gt;</operator><name>perquery</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Currently, all pinned workfile_sets are calling workfile_mgr_close_set
		 * in transaction. So we should unpin it for aborting.
		 */</comment>
		<expr_stmt><expr><call><name>unpin_workset</name><argument_list>(<argument><expr><name>work_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*Remove the workfile_sets that don't contain any workfiles */</comment>
		<expr_stmt><expr><call><name>remove_workfile_set_if_possible</name><argument_list>(<argument><expr><name>work_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Enlarge the local array if necessary, so that it has space for 'file'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ensureLocalEntriesSize</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>oldsize</name> <init>= <expr><name><name>localCtl</name><operator>.</operator><name>sizeLocalEntries</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>newsize</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid virtual file descriptor: %d"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <name>oldsize</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>newsize</name> <operator>=</operator> <name>file</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">5</literal></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oldsize</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>localCtl</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <operator>(</operator><name>WorkFileLocalEntry</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>,
							   <argument><expr><name>newsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkFileLocalEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>localCtl</name><operator>.</operator><name>entries</name></name> <operator>=</operator> <operator>(</operator><name>WorkFileLocalEntry</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name><name>localCtl</name><operator>.</operator><name>entries</name></name></expr></argument>, <argument><expr><name>newsize</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkFileLocalEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>localCtl</name><operator>.</operator><name>sizeLocalEntries</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>

	<comment type="block">/* initialize the newly-allocated entries to all-zeros. */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>localCtl</name><operator>.</operator><name>entries</name><index>[<expr><name>oldsize</name></expr>]</index></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>,
		   <argument><expr><operator>(</operator><name>newsize</name> <operator>-</operator> <name>oldsize</name><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkFileLocalEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * fd.c / buffile.c call these
 */</comment>

<comment type="block">/*
 * Buffile.c calls this whenever a new BufFile is created, with a known
 * workfile set. Registers the file with the workfile set.
 */</comment>
<function><type><name>void</name></type>
<name>RegisterFileWithSet</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>ensureLocalEntriesSize</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>localCtl</name><operator>.</operator><name>entries</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>work_set</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"workfile is already registered with another workfile set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>work_set</name><operator>-&gt;</operator><name>active</name></name> <operator>||</operator> <operator>!</operator><name><name>work_set</name><operator>-&gt;</operator><name>perquery</name><operator>-&gt;</operator><name>active</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"Register file to a non-active workfile_set/per-query summary is illegal"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name><name>localCtl</name><operator>.</operator><name>entries</name><index>[<expr><name>file</name></expr>]</index></name><operator>.</operator><name>work_set</name> <operator>=</operator> <name>work_set</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>perquery</name><operator>-&gt;</operator><name>num_files</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* Enforce the limit on number of files */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_workfile_limit_files_per_query</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>work_set</name><operator>-&gt;</operator><name>perquery</name><operator>-&gt;</operator><name>num_files</name></name> <operator>&gt;</operator> <name>gp_workfile_limit_files_per_query</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"number of workfiles per query limit exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Update the totals of the workfile set for given file.
 *
 * If the given file is not associated with a workfile set yet,
 * a new workfile set is created.
 *
 * fd.c calls this whenever a (potentially) file is enlarged.
 */</comment>
<function><type><name>void</name></type>
<name>UpdateWorkFileSize</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>uint64</name></type> <name>newsize</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkFileLocalEntry</name> <modifier>*</modifier></type><name>localEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkFileSetSharedEntry</name> <modifier>*</modifier></type><name>work_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkFileUsagePerQuery</name> <modifier>*</modifier></type><name>perquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>diff</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>ensureLocalEntriesSize</name><argument_list>(<argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>localEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>localCtl</name><operator>.</operator><name>entries</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>work_set</name> <operator>=</operator> <name><name>localEntry</name><operator>-&gt;</operator><name>work_set</name></name></expr>;</expr_stmt>
	<comment type="block">/*
	 * We got here only when the file's fdstate is FD_WORKFILE, and that
	 * means the file is registered to a work set.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>work_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>perquery</name> <operator>=</operator> <name><name>work_set</name><operator>-&gt;</operator><name>perquery</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><name>diff</name> <operator>=</operator> <operator>(</operator><name>int64</name><operator>)</operator> <name>newsize</name> <operator>-</operator> <name><name>localEntry</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>work_set</name><operator>-&gt;</operator><name>active</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile_set %s for current file is freed which should not happen."</literal></expr></argument>, <argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errprintstack</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>perquery</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the file is being enlarged, enforce the limits.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>diff</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>gp_workfile_limit_per_query</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>perquery</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>+</operator> <name>diff</name> <operator>+</operator> <literal type="number">1023</literal><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal> <operator>&gt;</operator> <name>gp_workfile_limit_per_query</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile per query size limit exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>gp_workfile_limit_per_segment</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>+</operator> <name>diff</name><operator>)</operator> <operator>/</operator> <literal type="number">1024</literal> <operator>&gt;</operator> <name>gp_workfile_limit_per_segment</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile per segment size limit exceeded"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Update the summaries in shared memory.
	 */</comment>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workfile_shared</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>+=</operator> <name>diff</name></expr>;</expr_stmt>

	<comment type="block">/* also update the local entry */</comment>
	<expr_stmt><expr><name><name>localEntry</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * WorkFileDeleted - Delete the file from it's workfile_set, update
 * the stats for the workfile_set.
 *
 * If the file is the last one in the workfile_set, and it's workfile_set
 * is not pinned, free the workfile set.
 */</comment>
<function><type><name>void</name></type>
<name>WorkFileDeleted</name><parameter_list>(<parameter><decl><type><name>File</name></type> <name>file</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hold_lock</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkFileLocalEntry</name> <modifier>*</modifier></type><name>localEntry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkFileSetSharedEntry</name> <modifier>*</modifier></type><name>work_set</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkFileUsagePerQuery</name> <modifier>*</modifier></type><name>perquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int64</name></type>		<name>oldsize</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid virtual file descriptor: %d"</literal></expr></argument>, <argument><expr><name>file</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>file</name> <operator>&gt;=</operator> <name><name>localCtl</name><operator>.</operator><name>sizeLocalEntries</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>		<comment type="block">/* not a tracked work file */</comment>
	<expr_stmt><expr><name>localEntry</name> <operator>=</operator> <operator>&amp;</operator><name><name>localCtl</name><operator>.</operator><name>entries</name><index>[<expr><name>file</name></expr>]</index></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>localEntry</name><operator>-&gt;</operator><name>work_set</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>		<comment type="block">/* not a tracked work file */</comment>

	<if_stmt><if>if <condition>(<expr><name>hold_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>work_set</name> <operator>=</operator> <name><name>localEntry</name><operator>-&gt;</operator><name>work_set</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>perquery</name> <operator>=</operator> <name><name>work_set</name><operator>-&gt;</operator><name>perquery</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>work_set</name><operator>-&gt;</operator><name>active</name></name> <operator>||</operator> <operator>!</operator><name><name>work_set</name><operator>-&gt;</operator><name>perquery</name><operator>-&gt;</operator><name>active</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile_set/per-query summarry is not active"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Update the summaries in shared memory
	 */</comment>
	<expr_stmt><expr><name>oldsize</name> <operator>=</operator> <name><name>localEntry</name><operator>-&gt;</operator><name>size</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>-=</operator> <name>oldsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>perquery</name><operator>-&gt;</operator><name>num_files</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>num_files</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>-=</operator> <name>oldsize</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>workfile_shared</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>-=</operator> <name>oldsize</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Update the workfile_set. If this was the last file in this
	 * set, remove it.
	 */</comment>
	<expr_stmt><expr><call><name>remove_workfile_set_if_possible</name><argument_list>(<argument><expr><name>work_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>localEntry</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>localEntry</name><operator>-&gt;</operator><name>work_set</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hold_lock</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the workfile_set if possible. The workfile_set must be unpinned
 * and no workfile remains.
 * WorkFileManagerLock must be held.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>remove_workfile_set_if_possible</name><parameter_list>(<parameter><decl><type><name>workfile_set</name><modifier>*</modifier></type> <name>work_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkFileUsagePerQuery</name> <modifier>*</modifier></type><name>perquery</name> <init>= <expr><name><name>work_set</name><operator>-&gt;</operator><name>perquery</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Update the workfile_set. If there was no file exist in this
	 * set, remove it unless the set is pinned.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>work_set</name><operator>-&gt;</operator><name>pinned</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>refcount</name></name><operator>--</operator></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Unlink from the active list */</comment>
		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>work_set</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workfile_shared</name><operator>-&gt;</operator><name>num_active</name></name><operator>--</operator></expr>;</expr_stmt>

		<comment type="block">/* and add to the free list */</comment>
		<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>freeList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>work_set</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>work_set</name><operator>-&gt;</operator><name>local_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Similarly, update / remove the per-query entry.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>perquery</name><operator>-&gt;</operator><name>refcount</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>perquery</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>workfile_shared</name><operator>-&gt;</operator><name>per_query_hash</name></name></expr></argument>,
							   <argument><expr><name>perquery</name></expr></argument>,
							   <argument><expr><name>HASH_REMOVE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><literal type="string">"per-query hash table is corrupt"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Public API for creating a workfile set
 *
 * When hold_pin is set to true, the caller should use workfile_mgr_close_set
 * to remove the workfile_set.
 */</comment>
<function><type><name>workfile_set</name> <modifier>*</modifier></type>
<name>workfile_mgr_create_set</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operator_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>hold_pin</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>proc_exit_hook_registered</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * register proc-exit hook to ensure temp files are dropped at exit.
		 *
		 * The hook must run after before_shmem_exit(), because before_shmem_exit may do
		 * some cleanup in transaction level, but AtProcExit_WorkFile cleans up the session
		 * level objects which may be referenced by some short-life objects, e.g. executor nodes.
		 */</comment>
		<expr_stmt><expr><call><name>on_shmem_exit</name><argument_list>(<argument><expr><name>AtProcExit_WorkFile</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>proc_exit_hook_registered</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>work_set</name> <operator>=</operator> <call><name>workfile_mgr_create_set_internal</name><argument_list>(<argument><expr><name>operator_name</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hold_pin</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pin_workset</name><argument_list>(<argument><expr><name>work_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>work_set</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lock must be held
 */</comment>
<function><type><specifier>static</specifier> <name>workfile_set</name> <modifier>*</modifier></type>
<name>workfile_mgr_create_set_internal</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>operator_name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>WorkFileUsagePerQuery</name> <modifier>*</modifier></type><name>perquery</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>WorkFileUsagePerQuery</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>proc_exit_hook_registered</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>freeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Could not acquire another entry from the cache - we filled it up */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create workfile manager entry: exceeded number of concurrent spilling queries"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Find our per-query entry (or allocate, on first use)
	 */</comment>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>session_id</name></name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>command_count</name></name> <operator>=</operator> <name>gp_command_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>perquery</name> <operator>=</operator> <operator>(</operator><name>WorkFileUsagePerQuery</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name><name>workfile_shared</name><operator>-&gt;</operator><name>per_query_hash</name></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>key</name></expr></argument>,
													 <argument><expr><name>HASH_ENTER_NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>perquery</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The hash table was full. (The hash table is sized so that this
		 * should never happen.)
		 */</comment>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INSUFFICIENT_RESOURCES</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create workfile manager entry: per-query hash table is full"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>num_files</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>refcount</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>perquery</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate a workfile_set entry, and initialize it.
	 */</comment>
	<expr_stmt><expr><name>work_set</name> <operator>=</operator> <call><name>dlist_container</name><argument_list>(<argument><expr><name>WorkFileSetSharedEntry</name></expr></argument>, <argument><expr><name>node</name></expr></argument>,
							   <argument><expr><call><name>dlist_pop_head_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>freeList</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name><name>work_set</name><operator>-&gt;</operator><name>active</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>dlist_push_head</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>activeList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>work_set</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>workfile_shared</name><operator>-&gt;</operator><name>num_active</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>session_id</name></name> <operator>=</operator> <name>gp_session_id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>command_count</name></name> <operator>=</operator> <name>gp_command_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>slice_id</name></name> <operator>=</operator> <name>currentSliceId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>perquery</name></name> <operator>=</operator> <name>perquery</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>active</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>pinned</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/* Track all workfile_sets created in current process */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>localCtl</name><operator>.</operator><name>initialized</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>dlist_init</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>localCtl</name><operator>.</operator><name>localList</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>localCtl</name><operator>.</operator><name>initialized</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>localCtl</name><operator>.</operator><name>localList</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>work_set</name><operator>-&gt;</operator><name>local_node</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>operator_name</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>operator</name></name></expr></argument>, <argument><expr><name>operator_name</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>operator</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>operator</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>prefix</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>operator_name</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%s_%d"</literal></expr></argument>,
				 <argument><expr><name>operator_name</name></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>work_set</name> <operator>-</operator> <name><name>workfile_shared</name><operator>-&gt;</operator><name>entries</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"workfile_set_%d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name>work_set</name> <operator>-</operator> <name><name>workfile_shared</name><operator>-&gt;</operator><name>entries</name></name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>work_set</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Pin the workfile_set to prevent unexpected free operation.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>pin_workset</name><parameter_list>(<parameter><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>pinned</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unping the workfile_set.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>unpin_workset</name><parameter_list>(<parameter><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>pinned</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * workfile_mgr_close_set - force close and free the workfile_set.
 *
 * Normally, for unpinned workfile_set, it'll get freed until the last
 * file closed in it. workfile_mgr_close_set will force free the workfile_set
 * not matter it gets pinned or not.
 */</comment>
<function><type><name>void</name></type>
<name>workfile_mgr_close_set</name><parameter_list>(<parameter><decl><type><name>workfile_set</name> <modifier>*</modifier></type><name>work_set</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>work_set</name><operator>-&gt;</operator><name>active</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile_set is not active"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>unpin_workset</name><argument_list>(<argument><expr><name>work_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Delete files which in current workfile set */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>localCtl</name><operator>.</operator><name>sizeLocalEntries</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>localCtl</name><operator>.</operator><name>entries</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>work_set</name> <operator>==</operator> <name>work_set</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>WorkFileDeleted</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Since the workfile_mgr_close_set could be called at any moment to
	 * force close and free the workfile_set, so current workfile_set
	 * could have empty registered file yet.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>work_set</name><operator>-&gt;</operator><name>active</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>WorkFileUsagePerQuery</name> <modifier>*</modifier></type><name>perquery</name> <init>= <expr><name><name>work_set</name><operator>-&gt;</operator><name>perquery</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile_set %s still contains files for unknown reason."</literal></expr></argument>, <argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errprintstack</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>perquery</name><operator>-&gt;</operator><name>active</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"per-query summarry is not active"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>perquery</name><operator>-&gt;</operator><name>num_files</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>num_files</name></name> <operator>-=</operator> <name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>perquery</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>-=</operator> <name><name>work_set</name><operator>-&gt;</operator><name>total_bytes</name></name></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>work_set</name><operator>-&gt;</operator><name>total_bytes</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>remove_workfile_set_if_possible</name><argument_list>(<argument><expr><name>work_set</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>workfile_report_inconsistency</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_node</name> <modifier>*</modifier></type><name>node</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>		<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_freeList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_activeList</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;workfile_shared-&gt;freeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>num_freeList</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>iter</name><operator>.</operator><name>cur</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile freeList is corrupted: "</literal>
							<literal type="string">"node = %p, next = %p, next-&gt;prev = %p"</literal></expr></argument>,
							<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>freeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>freeList</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile freeList is corrupted: "</literal>
							<literal type="string">"node = %p, next = %p, next-&gt;prev = %p"</literal></expr></argument>,
							<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;workfile_shared-&gt;activeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<expr_stmt><expr><name>num_activeList</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <name><name>iter</name><operator>.</operator><name>cur</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile activeList is corrupted: "</literal>
							<literal type="string">"node = %p, next = %p, next-&gt;prev = %p"</literal></expr></argument>,
							<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	</block_content>}</block>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>dlist_is_empty</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>activeList</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>&amp;</operator><name><name>workfile_shared</name><operator>-&gt;</operator><name>activeList</name><operator>.</operator><name>head</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name> <operator>!=</operator> <name>node</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"workfile activeList is corrupted: "</literal>
							<literal type="string">"node = %p, next = %p, next-&gt;prev = %p"</literal></expr></argument>,
							<argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr></argument>, <argument><expr><ternary><condition><expr><name><name>node</name><operator>-&gt;</operator><name>next</name></name></expr> ?</condition><then> <expr><name><name>node</name><operator>-&gt;</operator><name>next</name><operator>-&gt;</operator><name>prev</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>PANIC</name></expr></argument>,
		<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"num_active = %d, the actual size = %d, total size = %d, free size = %d"</literal></expr></argument>,
		  <argument><expr><name><name>workfile_shared</name><operator>-&gt;</operator><name>num_active</name></name></expr></argument>, <argument><expr><name>num_activeList</name></expr></argument>,
		  <argument><expr><name>gp_workfile_max_entries</name></expr></argument>, <argument><expr><name>num_freeList</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Function copying all workfile cache entries for one segment
 */</comment>
<function><type><name>workfile_set</name> <modifier>*</modifier></type>
<name>workfile_mgr_cache_entries_get_copy</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>num_active</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>				<name>num_entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>workfile_set</name>	<modifier>*</modifier></type><name>copied_entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dlist_iter</name></type>		<name>iter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>				<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>num_entries</name> <operator>=</operator> <name><name>workfile_shared</name><operator>-&gt;</operator><name>num_active</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>copied_entries</name> <operator>=</operator> <operator>(</operator><name>WorkFileSetSharedEntry</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>num_entries</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>WorkFileSetSharedEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>dlist_foreach</name><argument_list>(<argument>iter</argument>, <argument>&amp;workfile_shared-&gt;activeList</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkFileSetSharedEntry</name> <modifier>*</modifier></type><name>e</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>WorkFileSetSharedEntry</name></expr></argument>, <argument><expr><name>node</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>copied_entries</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>e</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>WorkFileSetSharedEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block>
	<comment type="block">/* if i != num_entries, the shared memory for workfile is inconsistent. */</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>!=</operator> <name>num_entries</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>workfile_report_inconsistency</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>num_active</name> <operator>=</operator> <name>num_entries</name></expr>;</expr_stmt>
	<return>return <expr><name>copied_entries</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * User-visible function, for the view
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>num_entries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>WorkFileSetSharedEntry</name> <modifier>*</modifier></type><name>copied_entries</name></decl>;</decl_stmt>
}</block></struct></type> <name>get_entries_cxt</name>;</typedef>

<comment type="block">/*
 * Function returning all workfile cache entries for one segment
 */</comment>
<function><type><name>Datum</name></type>
<name>gp_workfile_mgr_cache_entries_internal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>funcctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>get_entries_cxt</name> <modifier>*</modifier></type><name>cxt</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>

		<comment type="block">/* create a function context for cross-call persistence */</comment>
		<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Switch to memory context appropriate for multiple function calls */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Build a tuple descriptor for our result type
		 * The number and type of attributes have to match the definition of the
		 * view gp_workfile_mgr_cache_entries
		 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CACHE_ENTRIES_ELEM</name></cpp:macro> <cpp:value>8</cpp:value></cpp:define>
		<decl_stmt><decl><type><name>TupleDesc</name></type> <name>tupdesc</name> <init>= <expr><call><name>CreateTemplateTupleDesc</name><argument_list>(<argument><expr><name>NUM_CACHE_ENTRIES_ELEM</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"segid"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><literal type="string">"prefix"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">3</literal></expr></argument>, <argument><expr><literal type="string">"size"</literal></expr></argument>, <argument><expr><name>INT8OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">4</literal></expr></argument>, <argument><expr><literal type="string">"operation"</literal></expr></argument>, <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">5</literal></expr></argument>, <argument><expr><literal type="string">"slice"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">6</literal></expr></argument>, <argument><expr><literal type="string">"sessionid"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">7</literal></expr></argument>, <argument><expr><literal type="string">"commandid"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>TupleDescInitEntry</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>(</operator><name>AttrNumber</name><operator>)</operator> <literal type="number">8</literal></expr></argument>, <argument><expr><literal type="string">"numfiles"</literal></expr></argument>, <argument><expr><name>INT4OID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name> <operator>=</operator> <call><name>BlessTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now copy all the active entries from shared memory.
		 */</comment>
		<expr_stmt><expr><name>cxt</name> <operator>=</operator> <operator>(</operator><name>get_entries_cxt</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>get_entries_cxt</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>copied_entries</name></name> <operator>=</operator> <call><name>workfile_mgr_cache_entries_get_copy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>cxt</name><operator>-&gt;</operator><name>num_entries</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>index</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>cxt</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>funcctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cxt</name> <operator>=</operator> <operator>(</operator><name>get_entries_cxt</name> <operator>*</operator><operator>)</operator> <name><name>funcctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>

	<while>while <condition>(<expr><name><name>cxt</name><operator>-&gt;</operator><name>index</name></name> <operator>&lt;</operator> <name><name>cxt</name><operator>-&gt;</operator><name>num_entries</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>WorkFileSetSharedEntry</name> <modifier>*</modifier></type><name>work_set</name> <init>= <expr><operator>&amp;</operator><name><name>cxt</name><operator>-&gt;</operator><name>copied_entries</name><index>[<expr><name><name>cxt</name><operator>-&gt;</operator><name>index</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>NUM_CACHE_ENTRIES_ELEM</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name><name>nulls</name><index>[<expr><name>NUM_CACHE_ENTRIES_ELEM</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>GpIdentity</name><operator>.</operator><name>segindex</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>prefix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">2</literal></expr>]</index></name> <operator>=</operator> <call><name>Int64GetDatum</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>total_bytes</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">3</literal></expr>]</index></name> <operator>=</operator> <call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>operator</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">4</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>slice_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">5</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>session_id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">6</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>command_count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>values</name><index>[<expr><literal type="number">7</literal></expr>]</index></name> <operator>=</operator> <call><name>UInt32GetDatum</name><argument_list>(<argument><expr><name><name>work_set</name><operator>-&gt;</operator><name>num_files</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>cxt</name><operator>-&gt;</operator><name>index</name></name><operator>++</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>tuple</name> <operator>=</operator> <call><name>heap_form_tuple</name><argument_list>(<argument><expr><name><name>funcctx</name><operator>-&gt;</operator><name>tuple_desc</name></name></expr></argument>, <argument><expr><name>values</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>HeapTupleGetDatum</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>, <argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>funcctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Get the total number of bytes used across all workfiles
 */</comment>
<function><type><name>uint64</name></type>
<name>WorkfileSegspace_GetSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name><name>workfile_shared</name><operator>-&gt;</operator><name>total_bytes</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>WorkFileManagerLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>
</unit>
