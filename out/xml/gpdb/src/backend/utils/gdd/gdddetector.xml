<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/gdd/gdddetector.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * gdddetector.c
 *	  Global DeadLock Detector - Detector Algorithm
 *
 *
 * Copyright (c) 2018-Present VMware, Inc. or its affiliates.
 *
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gdddetector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"gdddetectorpriv.h"</cpp:file></cpp:include>

<comment type="block" format="doxygen">/***************************************************************************/</comment>

<function_decl><type><specifier>static</specifier> <name>GddGraph</name> <modifier>*</modifier></type><name>gddCtxGetGraph</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GddStat</name> <modifier>*</modifier></type><name>gddCtxGetGlobalStat</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddCtxRemoveVid</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gddCtxGetMaxVid</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GddStat</name> <modifier>*</modifier></type><name>gddStatNew</name><parameter_list>(<parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddStatInit</name><parameter_list>(<parameter><decl><type><name>GddStat</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GddGraph</name> <modifier>*</modifier></type><name>gddGraphNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GddVert</name> <modifier>*</modifier></type><name>gddGraphGetVert</name><parameter_list>(<parameter><decl><type><name>GddGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GddEdge</name> <modifier>*</modifier></type><name>gddGraphMakeEdge</name><parameter_list>(<parameter><decl><type><name>GddGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>solid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddGraphRemoveVid</name><parameter_list>(<parameter><decl><type><name>GddGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GddVert</name> <modifier>*</modifier></type><name>gddVertNew</name><parameter_list>(<parameter><decl><type><name>DistributedTransactionId</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddVertBindStats</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>, <parameter><decl><type><name>GddStat</name> <modifier>*</modifier></type><name>global</name></decl></parameter>, <parameter><decl><type><name>GddStat</name> <modifier>*</modifier></type><name>topstat</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gddVertUnlinkAll</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>gddVertReduce</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gddVertGetInDegree</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type> <name>gddVertGetOutDegree</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>GddEdge</name> <modifier>*</modifier></type><name>gddEdgeNew</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>solid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddEdgeLink</name><parameter_list>(<parameter><decl><type><name>GddEdge</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddEdgeUnlink</name><parameter_list>(<parameter><decl><type><name>GddEdge</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>, <parameter><decl><type><name>GddListIter</name> <modifier>*</modifier></type><name>fromiter</name></decl></parameter>, <parameter><decl><type><name>GddListIter</name> <modifier>*</modifier></type><name>toiter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddEdgeUnlinkFrom</name><parameter_list>(<parameter><decl><type><name>GddEdge</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>, <parameter><decl><type><name>GddListIter</name> <modifier>*</modifier></type><name>fromiter</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddEdgeUnlinkTo</name><parameter_list>(<parameter><decl><type><name>GddEdge</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>, <parameter><decl><type><name>GddListIter</name> <modifier>*</modifier></type><name>toiter</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddMapInit</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddMapEnsureCapacity</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>capacity</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>GddPair</name> <modifier>*</modifier></type><name>gddMapGetPair</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type><name>gddMapGet</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>gddMapSetUnsafe</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/***************************************************************************/</comment>

<comment type="block">/*
 * Create a new Global DeadLock Detector context.
 */</comment>
<function><type><name>GddCtx</name> <modifier>*</modifier></type>
<name>GddCtxNew</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddCtx</name>		<modifier>*</modifier></type><name>ctx</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>ctx</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gddStatInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>topstat</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gddMapInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gddMapInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>graphs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>ctx</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Add an edge to one local graph.
 *
 * Return the edge.
 */</comment>
<function><type><name>GddEdge</name> <modifier>*</modifier></type>
<name>GddCtxAddEdge</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segid</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>solid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddEdge</name>		<modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GddGraph</name>	<modifier>*</modifier></type><name>graph</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GddStat</name>		<modifier>*</modifier></type><name>global</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>graph</name> <operator>=</operator> <call><name>gddCtxGetGraph</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>segid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>gddGraphMakeEdge</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>from</name></expr></argument>, <argument><expr><name>to</name></expr></argument>, <argument><expr><name>solid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>global</name> <operator>=</operator> <call><name>gddCtxGetGlobalStat</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gddVertBindStats</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name></name></expr></argument>, <argument><expr><name>global</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>topstat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>global</name> <operator>=</operator> <call><name>gddCtxGetGlobalStat</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gddVertBindStats</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name></name></expr></argument>, <argument><expr><name>global</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>topstat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Actually link the edge to its from/to verts,
	 * and update global in/out degrees.
	 */</comment>
	<expr_stmt><expr><call><name>gddEdgeLink</name><argument_list>(<argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>edge</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reduce verts and edges looply until nothing can be deleted.
 */</comment>
<function><type><name>void</name></type>
<name>GddCtxReduce</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddMapIter</name></type>	<name>graphiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GddMapIter</name></type>	<name>vertiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><name>dirty</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<macro><name>gdd_ctx_foreach_vert</name><argument_list>(<argument>graphiter</argument>, <argument>vertiter</argument>, <argument>ctx</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GddVert</name>		<modifier>*</modifier></type><name>vert</name> <init>= <expr><call><name>gdd_map_iter_get_ptr</name><argument_list>(<argument><expr><name>vertiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>gddVertReduce</name><argument_list>(<argument><expr><name>vert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Remove vert from the graph if no edges left.
			 *
			 * We want to do this even if gddVertReduce() returns false
			 * as vert1's last edge might be removed in vert2's reduce call.
			 * However depending on the order of vert1 and vert2, we can not
			 * promise all the empty verts are removed, so do not make the
			 * assumption on this.  See gddCtxGetMaxVid() for example.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>gddVertGetInDegree</name><argument_list>(<argument><expr><name>vert</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>gddVertGetOutDegree</name><argument_list>(<argument><expr><name>vert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>gdd_map_iter_delete</name><argument_list>(<argument><expr><name>vertiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></while>
</block_content>}</block></function>

<comment type="block">/*
 * Break deadlocks and return a list of vids to cancel.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>GddCtxBreakDeadLock</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>		<modifier>*</modifier></type><name>vids</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>!</operator><call><name>GddCtxEmpty</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The only policy supported for now is to cancel the youngest vert,
		 * who has the max vid.
		 */</comment>
		<decl_stmt><decl><type><name>DistributedTransactionId</name> <modifier>*</modifier></type><name>maxvid</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DistributedTransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<expr_stmt><expr><operator>*</operator><name>maxvid</name> <operator>=</operator> <call><name>gddCtxGetMaxVid</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>vids</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>vids</name></expr></argument>, <argument><expr><name>maxvid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Cancel this vert and reduce again to see if more deadlocks
		 * are detected.
		 */</comment>
		<expr_stmt><expr><call><name>gddCtxRemoveVid</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><operator>*</operator><name>maxvid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>GddCtxReduce</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>vids</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Return true if no edges left.
 */</comment>
<function><type><name>bool</name></type>
<name>GddCtxEmpty</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>ctx</name><operator>-&gt;</operator><name>topstat</name><operator>.</operator><name>indeg</name></name> <operator>==</operator> <name><name>ctx</name><operator>-&gt;</operator><name>topstat</name><operator>.</operator><name>outdeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name><name>ctx</name><operator>-&gt;</operator><name>topstat</name><operator>.</operator><name>indeg</name></name> <operator>==</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***************************************************************************/</comment>

<comment type="block">/*
 * Get the graph with segment id.
 *
 * A new one is created if it's first seen.
 */</comment>
<function><type><specifier>static</specifier> <name>GddGraph</name> <modifier>*</modifier></type>
<name>gddCtxGetGraph</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>segid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddGraph</name>	<modifier>*</modifier></type><name>graph</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>graph</name> <operator>=</operator> <call><name>gddMapGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>graphs</name></name></expr></argument>, <argument><expr><name>segid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>graph</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>graph</name> <operator>=</operator> <call><name>gddGraphNew</name><argument_list>(<argument><expr><name>segid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gddMapSetUnsafe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>graphs</name></name></expr></argument>, <argument><expr><name>segid</name></expr></argument>, <argument><expr><name>graph</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>graph</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the global with vert id.
 *
 * A new one is created if it's first seen.
 */</comment>
<function><type><specifier>static</specifier> <name>GddStat</name> <modifier>*</modifier></type>
<name>gddCtxGetGlobalStat</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddStat</name>		<modifier>*</modifier></type><name>global</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>global</name> <operator>=</operator> <call><name>gddMapGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>global</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>global</name> <operator>=</operator> <call><name>gddStatNew</name><argument_list>(<argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gddMapSetUnsafe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ctx</name><operator>-&gt;</operator><name>globals</name></name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>global</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>global</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove verts whose vert id equal to vid on all local graphs.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddCtxRemoveVid</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddMapIter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do not use gdd_ctx_foreach_vert() as break is used in the inner loop */</comment>
	<macro><name>gdd_ctx_foreach_graph</name><argument_list>(<argument>iter</argument>, <argument>ctx</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GddGraph</name>	<modifier>*</modifier></type><name>graph</name> <init>= <expr><call><name>gdd_map_iter_get_ptr</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gddGraphRemoveVid</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block">/*
 * Get the max vert id, return 0 if no vert left at all.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gddCtxGetMaxVid</name><parameter_list>(<parameter><decl><type><name>GddCtx</name> <modifier>*</modifier></type><name>ctx</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddMapIter</name></type>	<name>graphiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GddMapIter</name></type>	<name>vertiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DistributedTransactionId</name></type> <name>maxvid</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ctx</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>gdd_ctx_foreach_vert</name><argument_list>(<argument>graphiter</argument>, <argument>vertiter</argument>, <argument>ctx</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GddVert</name>		<modifier>*</modifier></type><name>vert</name> <init>= <expr><call><name>gdd_map_iter_get_ptr</name><argument_list>(<argument><expr><name>vertiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * It's possible for vert to have zero in/out edge,
		 * which means vert was already deleted in the
		 * algorithm conception so should be skipped.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>gddVertGetInDegree</name><argument_list>(<argument><expr><name>vert</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>gddVertGetOutDegree</name><argument_list>(<argument><expr><name>vert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>maxvid</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>maxvid</name></expr></argument>, <argument><expr><name><name>vert</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>maxvid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***************************************************************************/</comment>

<comment type="block">/*
 * Create a new global struct.
 */</comment>
<function><type><specifier>static</specifier> <name>GddStat</name> <modifier>*</modifier></type>
<name>gddStatNew</name><parameter_list>(<parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddStat</name>		<modifier>*</modifier></type><name>stat</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>stat</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gddStatInit</name><argument_list>(<argument><expr><name>stat</name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>stat</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize a global struct.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddStatInit</name><parameter_list>(<parameter><decl><type><name>GddStat</name> <modifier>*</modifier></type><name>stat</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>stat</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>vid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>indeg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>stat</name><operator>-&gt;</operator><name>outdeg</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***************************************************************************/</comment>

<comment type="block">/*
 * Create a new graph struct.
 */</comment>
<function><type><specifier>static</specifier> <name>GddGraph</name> <modifier>*</modifier></type>
<name>gddGraphNew</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddGraph</name> <modifier>*</modifier></type><name>graph</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>graph</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>graph</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gddMapInit</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>graph</name><operator>-&gt;</operator><name>verts</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>graph</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get the vert with vert id.
 *
 * A new one is created if it's first seen.
 */</comment>
<function><type><specifier>static</specifier> <name>GddVert</name> <modifier>*</modifier></type>
<name>gddGraphGetVert</name><parameter_list>(<parameter><decl><type><name>GddGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddVert</name>		<modifier>*</modifier></type><name>vert</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>graph</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vert</name> <operator>=</operator> <call><name>gddMapGet</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>graph</name><operator>-&gt;</operator><name>verts</name></name></expr></argument>, <argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>vert</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>vert</name> <operator>=</operator> <call><name>gddVertNew</name><argument_list>(<argument><expr><name>vid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>gddMapSetUnsafe</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>graph</name><operator>-&gt;</operator><name>verts</name></name></expr></argument>, <argument><expr><name>vid</name></expr></argument>, <argument><expr><name>vert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>vert</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Make an edge in graph.
 *
 * The edge is not linked yet.
 */</comment>
<function><type><specifier>static</specifier> <name>GddEdge</name> <modifier>*</modifier></type>
<name>gddGraphMakeEdge</name><parameter_list>(<parameter><decl><type><name>GddGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>from</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>to</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>solid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddEdge</name>		<modifier>*</modifier></type><name>edge</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GddVert</name>		<modifier>*</modifier></type><name>vfrom</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GddVert</name>		<modifier>*</modifier></type><name>vto</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>graph</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>vfrom</name> <operator>=</operator> <call><name>gddGraphGetVert</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>from</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>vto</name> <operator>=</operator> <call><name>gddGraphGetVert</name><argument_list>(<argument><expr><name>graph</name></expr></argument>, <argument><expr><name>to</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>edge</name> <operator>=</operator> <call><name>gddEdgeNew</name><argument_list>(<argument><expr><name>vfrom</name></expr></argument>, <argument><expr><name>vto</name></expr></argument>, <argument><expr><name>solid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>edge</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Remove the vert whose vert id is vid.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddGraphRemoveVid</name><parameter_list>(<parameter><decl><type><name>GddGraph</name> <modifier>*</modifier></type><name>graph</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>vid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddMapIter</name></type>	<name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>graph</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>gdd_graph_foreach_vert</name><argument_list>(<argument>iter</argument>, <argument>graph</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GddVert</name>		<modifier>*</modifier></type><name>vert</name> <init>= <expr><call><name>gdd_map_iter_get_ptr</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vert</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>vert</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>vid</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Remove all local in/out edges */</comment>
		<expr_stmt><expr><call><name>gddVertUnlinkAll</name><argument_list>(<argument><expr><name>vert</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Finally remove vert from graph */</comment>
		<expr_stmt><expr><call><name>gdd_map_iter_delete</name><argument_list>(<argument><expr><name>iter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Only one vert could have vert id equals to vid */</comment>
		<break>break;</break>
	</block_content>}</block>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***************************************************************************/</comment>

<comment type="block">/*
 * Create a new vert.
 */</comment>
<function><type><specifier>static</specifier> <name>GddVert</name> <modifier>*</modifier></type>
<name>gddVertNew</name><parameter_list>(<parameter><decl><type><name>DistributedTransactionId</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddVert</name>		<modifier>*</modifier></type><name>vert</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>vert</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>vert</name><operator>-&gt;</operator><name>id</name></name> <operator>=</operator> <name>id</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vert</name><operator>-&gt;</operator><name>edgesIn</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vert</name><operator>-&gt;</operator><name>edgesOut</name></name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vert</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<return>return <expr><name>vert</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Bind global and vert.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddVertBindStats</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>, <parameter><decl><type><name>GddStat</name> <modifier>*</modifier></type><name>global</name></decl></parameter>, <parameter><decl><type><name>GddStat</name> <modifier>*</modifier></type><name>topstat</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vert</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vert</name><operator>-&gt;</operator><name>global</name></name> <operator>=</operator> <name>global</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vert</name><operator>-&gt;</operator><name>topstat</name></name> <operator>=</operator> <name>topstat</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unlink vert's all edges.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gddVertUnlinkAll</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddListIter</name></type>	<name>edgeiter</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vert</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>gdd_vert_foreach_in_edge</name><argument_list>(<argument>edgeiter</argument>, <argument>vert</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GddEdge</name>		<modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>gdd_list_iter_get_ptr</name><argument_list>(<argument><expr><name>edgeiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gddEdgeUnlink</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edgeiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vert</name><operator>-&gt;</operator><name>edgesIn</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<macro><name>gdd_vert_foreach_out_edge</name><argument_list>(<argument>edgeiter</argument>, <argument>vert</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GddEdge</name>		<modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>gdd_list_iter_get_ptr</name><argument_list>(<argument><expr><name>edgeiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>gddEdgeUnlink</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edgeiter</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vert</name><operator>-&gt;</operator><name>edgesOut</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>dirty</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Reduce vert's edges.
 *
 * The algorithm is described at README.md.
 *
 * Return true if anything is deleted.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gddVertReduce</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddStat</name>		<modifier>*</modifier></type><name>global</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>dirty</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vert</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>vert</name><operator>-&gt;</operator><name>global</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>global</name> <operator>=</operator> <name><name>vert</name><operator>-&gt;</operator><name>global</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Remove global end verts (verts with global 0 in/out degrees)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>global</name><operator>-&gt;</operator><name>indeg</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>global</name><operator>-&gt;</operator><name>outdeg</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Remove all local in/out edges */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>gddVertUnlinkAll</name><argument_list>(<argument><expr><name>vert</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<return>return <expr><name>dirty</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Remove a vert's dotted in edges if vert's local out degree is 0.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>gddVertGetOutDegree</name><argument_list>(<argument><expr><name>vert</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GddListIter</name></type>	<name>edgeiter</name></decl>;</decl_stmt>

		<macro><name>gdd_vert_foreach_in_edge</name><argument_list>(<argument>edgeiter</argument>, <argument>vert</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GddEdge</name>		<modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>gdd_list_iter_get_ptr</name><argument_list>(<argument><expr><name>edgeiter</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/* Do not remove solid edges */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>edge</name><operator>-&gt;</operator><name>solid</name></name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>gddEdgeUnlink</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>edgeiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>dirty</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block>

		<expr_stmt><expr><call><name>AssertImply</name><argument_list>(<argument><expr><call><name>gdd_list_iter_get_list</name><argument_list>(<argument><expr><name>edgeiter</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NIL</name></expr></argument>,
					<argument><expr><name><name>vert</name><operator>-&gt;</operator><name>edgesIn</name></name> <operator>==</operator> <name>NIL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>dirty</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get vert's local in degree.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gddVertGetInDegree</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vert</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>vert</name><operator>-&gt;</operator><name>edgesIn</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get vert's local in degree.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>gddVertGetOutDegree</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>vert</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>vert</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>vert</name><operator>-&gt;</operator><name>edgesOut</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***************************************************************************/</comment>

<comment type="block">/*
 * Create a new edge.
 */</comment>
<function><type><specifier>static</specifier> <name>GddEdge</name> <modifier>*</modifier></type>
<name>gddEdgeNew</name><parameter_list>(<parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>from</name></decl></parameter>, <parameter><decl><type><name>GddVert</name> <modifier>*</modifier></type><name>to</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>solid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddEdge</name>		<modifier>*</modifier></type><name>edge</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><name>edge</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name></name> <operator>=</operator> <name>from</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name></name> <operator>=</operator> <name>to</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>solid</name></name> <operator>=</operator> <name>solid</name></expr>;</expr_stmt>

	<return>return <expr><name>edge</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Link edge to its from/to verts and update global in/out degrees.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddEdgeLink</name><parameter_list>(<parameter><decl><type><name>GddEdge</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>edge</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>global</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>global</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>topstat</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>topstat</name></name> <operator>==</operator> <name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>topstat</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>outdeg</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>indeg</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>outdeg</name></name> <operator>==</operator> <name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>indeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Update global in/out degrees */</comment>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>global</name><operator>-&gt;</operator><name>outdeg</name></name><operator>++</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>global</name><operator>-&gt;</operator><name>indeg</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>edgesOut</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>edgesOut</name></name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>edgesIn</name></name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>edgesIn</name></name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unlink edge from its from/to verts and update global in/out degrees.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddEdgeUnlink</name><parameter_list>(<parameter><decl><type><name>GddEdge</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>, <parameter><decl><type><name>GddListIter</name> <modifier>*</modifier></type><name>fromiter</name></decl></parameter>, <parameter><decl><type><name>GddListIter</name> <modifier>*</modifier></type><name>toiter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>edge</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>gddEdgeUnlinkFrom</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><name>fromiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>gddEdgeUnlinkTo</name><argument_list>(<argument><expr><name>edge</name></expr></argument>, <argument><expr><name>toiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>outdeg</name></name> <operator>==</operator> <name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>indeg</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unlink edge from its from vert and update global out degree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddEdgeUnlinkFrom</name><parameter_list>(<parameter><decl><type><name>GddEdge</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>, <parameter><decl><type><name>GddListIter</name> <modifier>*</modifier></type><name>fromiter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>edge</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>global</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>topstat</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>outdeg</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>outdeg</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>global</name><operator>-&gt;</operator><name>outdeg</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>global</name><operator>-&gt;</operator><name>outdeg</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the from vert's iter is provided then delete it in-place,
	 * otherwise delete it with a scan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>fromiter</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gdd_list_iter_delete</name><argument_list>(<argument><expr><operator>*</operator><name>fromiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>edgesOut</name></name> <operator>=</operator> <call><name>gdd_list_iter_get_list</name><argument_list>(<argument><expr><operator>*</operator><name>fromiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>edgesOut</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>from</name><operator>-&gt;</operator><name>edgesOut</name></name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Unlink edge from its to vert and update global in degree.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddEdgeUnlinkTo</name><parameter_list>(<parameter><decl><type><name>GddEdge</name> <modifier>*</modifier></type><name>edge</name></decl></parameter>, <parameter><decl><type><name>GddListIter</name> <modifier>*</modifier></type><name>toiter</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>edge</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>global</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>topstat</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>indeg</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>topstat</name><operator>-&gt;</operator><name>indeg</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>global</name><operator>-&gt;</operator><name>indeg</name></name><operator>--</operator></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>global</name><operator>-&gt;</operator><name>indeg</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the to vert's iter is provided then delete it in-place,
	 * otherwise delete it with a scan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>toiter</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>gdd_list_iter_delete</name><argument_list>(<argument><expr><operator>*</operator><name>toiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>edgesIn</name></name> <operator>=</operator> <call><name>gdd_list_iter_get_list</name><argument_list>(<argument><expr><operator>*</operator><name>toiter</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>edgesIn</name></name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name><name>edge</name><operator>-&gt;</operator><name>to</name><operator>-&gt;</operator><name>edgesIn</name></name></expr></argument>, <argument><expr><name>edge</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block" format="doxygen">/***************************************************************************/</comment>

<comment type="block">/*
 * Initialize a map.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddMapInit</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>length</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>pairs</name></name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>capacity</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GddPair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Ensure map has enough capacity.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddMapEnsureCapacity</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>capacity</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>capacity</name> <operator>&lt;=</operator> <name><name>map</name><operator>-&gt;</operator><name>capacity</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* To prevent frequently resizing we prepare double capacity as required */</comment>
	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>capacity</name></name> <operator>=</operator> <name>capacity</name> <operator>&lt;&lt;</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>map</name><operator>-&gt;</operator><name>pairs</name></name> <operator>=</operator> <call><name>repalloc</name><argument_list>(<argument><expr><name><name>map</name><operator>-&gt;</operator><name>pairs</name></name></expr></argument>,
						  <argument><expr><name><name>map</name><operator>-&gt;</operator><name>capacity</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>GddPair</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup the pair struct by key.
 *
 * Return NULL if key is not found.
 */</comment>
<function><type><specifier>static</specifier> <name>GddPair</name> <modifier>*</modifier></type>
<name>gddMapGetPair</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>map</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>map</name><operator>-&gt;</operator><name>length</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GddPair</name>		<modifier>*</modifier></type><name>pair</name> <init>= <expr><operator>&amp;</operator><name><name>map</name><operator>-&gt;</operator><name>pairs</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name> <operator>==</operator> <name>key</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>pair</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Lookup the pointer by key.
 *
 * Return NULL if key is not found.  If NULL is valid value for the pointer
 * then use gddMapGetPair() instead of this one.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <modifier>*</modifier></type>
<name>gddMapGet</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddPair</name>		<modifier>*</modifier></type><name>pair</name> <init>= <expr><call><name>gddMapGetPair</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name>key</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<return>return <expr><ternary><condition><expr><name>pair</name></expr> ?</condition><then> <expr><name><name>pair</name><operator>-&gt;</operator><name>ptr</name></name></expr> </then><else>: <expr><name>NULL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Append a new &lt;k,v&gt; pair without checking for existence.
 *
 * Only use this if you have already checked with the gddMapGet*() functions
 * that k does not exist.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>gddMapSetUnsafe</name><parameter_list>(<parameter><decl><type><name>GddMap</name> <modifier>*</modifier></type><name>map</name></decl></parameter>, <parameter><decl><type><name>DistributedTransactionId</name></type> <name>key</name></decl></parameter>, <parameter><decl><type><name>void</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GddPair</name>		<modifier>*</modifier></type><name>pair</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>gddMapEnsureCapacity</name><argument_list>(<argument><expr><name>map</name></expr></argument>, <argument><expr><name><name>map</name><operator>-&gt;</operator><name>length</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>pair</name> <operator>=</operator> <operator>&amp;</operator><name><name>map</name><operator>-&gt;</operator><name>pairs</name><index>[<expr><name><name>map</name><operator>-&gt;</operator><name>length</name></name><operator>++</operator></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>key</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pair</name><operator>-&gt;</operator><name>ptr</name></name> <operator>=</operator> <name>ptr</name></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
