<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/tsquery_rewrite.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * tsquery_rewrite.c
 *	  Utilities for reconstructing tsquery
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/tsquery_rewrite.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"tsearch/ts_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>


<comment type="block">/*
 * If "node" is equal to "ex", return a copy of "subs" instead.
 * If "ex" matches a subset of node's children, return a modified version
 * of "node" in which those children are replaced with a copy of "subs".
 * Otherwise return "node" unmodified.
 *
 * The QTN_NOCHANGE bit is set in successfully modified nodes, so that
 * we won't uselessly recurse into them.
 * Also, set *isfind true if we make a replacement.
 */</comment>
<function><type><specifier>static</specifier> <name>QTNode</name> <modifier>*</modifier></type>
<name>findeq</name><parameter_list>(<parameter><decl><type><name>QTNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>QTNode</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>, <parameter><decl><type><name>QTNode</name> <modifier>*</modifier></type><name>subs</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isfind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Can't match unless signature matches and node type matches. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name><name>node</name><operator>-&gt;</operator><name>sign</name></name> <operator>&amp;</operator> <name><name>ex</name><operator>-&gt;</operator><name>sign</name></name><operator>)</operator> <operator>!=</operator> <name><name>ex</name><operator>-&gt;</operator><name>sign</name></name> <operator>||</operator>
		<name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name><name>ex</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Ignore nodes marked NOCHANGE, too. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>QTN_NOCHANGE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_OPR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Must be same operator. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>!=</operator> <name><name>ex</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nchild</name></name> <operator>==</operator> <name><name>ex</name><operator>-&gt;</operator><name>nchild</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Simple case: when same number of children, match if equal.
			 * (This is reliable when the children were sorted earlier.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>QTNEq</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Match; delete node and return a copy of subs instead. */</comment>
				<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>subs</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>QTNCopy</name><argument_list>(<argument><expr><name>subs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>QTN_NOCHANGE</name></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><operator>*</operator><name>isfind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>nchild</name></name> <operator>&gt;</operator> <name><name>ex</name><operator>-&gt;</operator><name>nchild</name></name> <operator>&amp;&amp;</operator> <name><name>ex</name><operator>-&gt;</operator><name>nchild</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * AND and OR are commutative/associative, so we should check if a
			 * subset of the children match.  For example, if node is A|B|C,
			 * and ex is B|C, we have a match after we notionally convert node
			 * to A|(B|C).  This does not work for NOT or PHRASE nodes, but we
			 * can't get here for those node types because they have a fixed
			 * number of children.
			 *
			 * Because we expect that the children are sorted, it suffices to
			 * make one pass through the two lists to find the matches.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>matched</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>nmatched</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
						<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

			<comment type="block">/* Assert that the subset rule is OK */</comment>
			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_AND</name> <operator>||</operator>
				   <name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>==</operator> <name>OP_OR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* matched[] will record which children of node matched */</comment>
			<expr_stmt><expr><name>matched</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>nchild</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>nmatched</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nchild</name></name> <operator>&amp;&amp;</operator> <name>j</name> <operator>&lt;</operator> <name><name>ex</name><operator>-&gt;</operator><name>nchild</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>cmp</name> <init>= <expr><call><name>QTNodeCompare</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>child</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>ex</name><operator>-&gt;</operator><name>child</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* match! */</comment>
					<expr_stmt><expr><name><name>matched</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>nmatched</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<if type="elseif">else if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* node-&gt;child[i] has no match, ignore it */</comment>
					<expr_stmt><expr><name>i</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* ex-&gt;child[j] has no match; we can give up immediately */</comment>
					<break>break;</break>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>nmatched</name> <operator>==</operator> <name><name>ex</name><operator>-&gt;</operator><name>nchild</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* collapse out the matched children of node */</comment>
				<expr_stmt><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>node</name><operator>-&gt;</operator><name>nchild</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>matched</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>child</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>child</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>node</name><operator>-&gt;</operator><name>child</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/* and instead insert a copy of subs */</comment>
				<if_stmt><if>if <condition>(<expr><name>subs</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>subs</name> <operator>=</operator> <call><name>QTNCopy</name><argument_list>(<argument><expr><name>subs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>subs</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>QTN_NOCHANGE</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>child</name><index>[<expr><name>j</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name>subs</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>nchild</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

				<comment type="block">/*
				 * At this point we might have a node with zero or one child,
				 * which should be simplified.  But we leave it to our caller
				 * (dofindsubquery) to take care of that.
				 */</comment>

				<comment type="block">/*
				 * Re-sort the node to put new child in the right place.  This
				 * is a bit bogus, because it won't matter for findsubquery's
				 * remaining processing, and it's insufficient to prepare the
				 * tree for another search (we would need to re-flatten as
				 * well, and we don't want to do that because we'd lose the
				 * QTN_NOCHANGE marking on the new child).  But it's needed to
				 * keep the results the same as the regression tests expect.
				 */</comment>
				<expr_stmt><expr><call><name>QTNSort</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><operator>*</operator><name>isfind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_VAL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>node</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>valcrc</name></name> <operator>!=</operator> <name><name>ex</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperand</name><operator>.</operator><name>valcrc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>node</name></expr>;</return></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>QTNEq</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>subs</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <call><name>QTNCopy</name><argument_list>(<argument><expr><name>subs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>node</name><operator>-&gt;</operator><name>flags</name></name> <operator>|=</operator> <name>QTN_NOCHANGE</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<expr_stmt><expr><operator>*</operator><name>isfind</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Recursive guts of findsubquery(): attempt to replace "ex" with "subs"
 * at the root node, and if we failed to do so, recursively match against
 * child nodes.
 *
 * Delete any void subtrees resulting from the replacement.
 * In the following example '5' is replaced by empty operand:
 *
 *	  AND		-&gt;	  6
 *	 /	 \
 *	5	 OR
 *		/  \
 *	   6	5
 */</comment>
<function><type><specifier>static</specifier> <name>QTNode</name> <modifier>*</modifier></type>
<name>dofindsubquery</name><parameter_list>(<parameter><decl><type><name>QTNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>QTNode</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>, <parameter><decl><type><name>QTNode</name> <modifier>*</modifier></type><name>subs</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isfind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* since this function recurses, it could be driven to stack overflow. */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* also, since it's a bit expensive, let's check for query cancel. */</comment>
	<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* match at the node itself */</comment>
	<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>findeq</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>subs</name></expr></argument>, <argument><expr><name>isfind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* unless we matched here, consider matches at child nodes */</comment>
	<if_stmt><if>if <condition>(<expr><name>root</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>root</name><operator>-&gt;</operator><name>flags</name></name> <operator>&amp;</operator> <name>QTN_NOCHANGE</name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
		<name><name>root</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>QI_OPR</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>j</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Any subtrees that are replaced by NULL must be dropped from the
		 * tree.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>root</name><operator>-&gt;</operator><name>nchild</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>child</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <call><name>dofindsubquery</name><argument_list>(<argument><expr><name><name>root</name><operator>-&gt;</operator><name>child</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>subs</name></expr></argument>, <argument><expr><name>isfind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>child</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>j</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name><name>root</name><operator>-&gt;</operator><name>nchild</name></name> <operator>=</operator> <name>j</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we have just zero or one remaining child node, simplify out this
		 * operator node.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>nchild</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>root</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>root</name><operator>-&gt;</operator><name>nchild</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>root</name><operator>-&gt;</operator><name>valnode</name><operator>-&gt;</operator><name>qoperator</name><operator>.</operator><name>oper</name></name> <operator>!=</operator> <name>OP_NOT</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>QTNode</name>	   <modifier>*</modifier></type><name>nroot</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>child</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>root</name> <operator>=</operator> <name>nroot</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Substitute "subs" for "ex" throughout the QTNode tree at root.
 *
 * If isfind isn't NULL, set *isfind to show whether we made any substitution.
 *
 * Both "root" and "ex" must have been through QTNTernary and QTNSort
 * to ensure reliable matching.
 */</comment>
<function><type><name>QTNode</name> <modifier>*</modifier></type>
<name>findsubquery</name><parameter_list>(<parameter><decl><type><name>QTNode</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>QTNode</name> <modifier>*</modifier></type><name>ex</name></decl></parameter>, <parameter><decl><type><name>QTNode</name> <modifier>*</modifier></type><name>subs</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isfind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>DidFind</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>root</name> <operator>=</operator> <call><name>dofindsubquery</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ex</name></expr></argument>, <argument><expr><name>subs</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>DidFind</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>isfind</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>isfind</name> <operator>=</operator> <name>DidFind</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>root</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsquery_rewrite_query</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>query</name> <init>= <expr><call><name>PG_GETARG_TSQUERY_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>in</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>rewrited</name> <init>= <expr><name>query</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>outercontext</name> <init>= <expr><name>CurrentMemoryContext</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QTNode</name>	   <modifier>*</modifier></type><name>tree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Portal</name></type>		<name>portal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>rewrited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tree</name> <operator>=</operator> <call><name>QT2QTN</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GETOPERAND</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QTNTernary</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QTNSort</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SPI_connect</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>plan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare(\"%s\") failed"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>portal</name> <operator>=</operator> <call><name>SPI_cursor_open</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>plan</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_cursor_open(\"%s\") failed"</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>SPI_tuptable</name> <operator>==</operator> <name>NULL</name> <operator>||</operator>
		<name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name> <operator>!=</operator> <literal type="number">2</literal> <operator>||</operator>
		<call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TSQUERYOID</name> <operator>||</operator>
		<call><name>SPI_gettypeid</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call> <operator>!=</operator> <name>TSQUERYOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"ts_rewrite query must return two tsquery columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<while>while <condition>(<expr><name>SPI_processed</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>tree</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint64</name></type>		<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>SPI_processed</name> <operator>&amp;&amp;</operator> <name>tree</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>qdata</name> <init>= <expr><call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>sdata</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>sdata</name> <operator>=</operator> <call><name>SPI_getbinval</name><argument_list>(<argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TSQuery</name></type>		<name>qtex</name> <init>= <expr><call><name>DatumGetTSQuery</name><argument_list>(<argument><expr><name>qdata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>TSQuery</name></type>		<name>qtsubs</name> <init>= <expr><call><name>DatumGetTSQuery</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>QTNode</name>	   <modifier>*</modifier></type><name>qex</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>qsubs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>qtex</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>qtex</name> <operator>!=</operator> <operator>(</operator><name>TSQuery</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>qdata</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>qtex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><name>qtsubs</name> <operator>!=</operator> <operator>(</operator><name>TSQuery</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>qtsubs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<continue>continue;</continue>
				</block_content>}</block></if></if_stmt>

				<expr_stmt><expr><name>qex</name> <operator>=</operator> <call><name>QT2QTN</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>qtex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GETOPERAND</name><argument_list>(<argument><expr><name>qtex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>QTNTernary</name><argument_list>(<argument><expr><name>qex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>QTNSort</name><argument_list>(<argument><expr><name>qex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>qtsubs</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>qsubs</name> <operator>=</operator> <call><name>QT2QTN</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>qtsubs</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GETOPERAND</name><argument_list>(<argument><expr><name>qtsubs</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>outercontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>tree</name> <operator>=</operator> <call><name>findsubquery</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>qex</name></expr></argument>, <argument><expr><name>qsubs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name>qex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>qtex</name> <operator>!=</operator> <operator>(</operator><name>TSQuery</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>qdata</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>qtex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name>qsubs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>qtsubs</name> <operator>!=</operator> <operator>(</operator><name>TSQuery</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>sdata</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>qtsubs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>tree</name></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* ready the tree for another pass */</comment>
					<expr_stmt><expr><call><name>QTNClearFlags</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>QTN_NOCHANGE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>QTNTernary</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>QTNSort</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SPI_cursor_fetch</name><argument_list>(<argument><expr><name>portal</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><call><name>SPI_freetuptable</name><argument_list>(<argument><expr><name>SPI_tuptable</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_cursor_close</name><argument_list>(<argument><expr><name>portal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SPI_finish</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>tree</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>QTNBinary</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rewrited</name> <operator>=</operator> <call><name>QTN2QT</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>rewrited</name></expr></argument>, <argument><expr><name>HDRSIZETQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rewrited</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>in</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>rewrited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>tsquery_rewrite</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>query</name> <init>= <expr><call><name>PG_GETARG_TSQUERY_COPY</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>ex</name> <init>= <expr><call><name>PG_GETARG_TSQUERY</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>subst</name> <init>= <expr><call><name>PG_GETARG_TSQUERY</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TSQuery</name></type>		<name>rewrited</name> <init>= <expr><name>query</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>QTNode</name>	   <modifier>*</modifier></type><name>tree</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>qex</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>subs</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>query</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>ex</name><operator>-&gt;</operator><name>size</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>ex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>subst</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>rewrited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>tree</name> <operator>=</operator> <call><name>QT2QTN</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GETOPERAND</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QTNTernary</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QTNSort</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>qex</name> <operator>=</operator> <call><name>QT2QTN</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GETOPERAND</name><argument_list>(<argument><expr><name>ex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QTNTernary</name><argument_list>(<argument><expr><name>qex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QTNSort</name><argument_list>(<argument><expr><name>qex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>subst</name><operator>-&gt;</operator><name>size</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>subs</name> <operator>=</operator> <call><name>QT2QTN</name><argument_list>(<argument><expr><call><name>GETQUERY</name><argument_list>(<argument><expr><name>subst</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>GETOPERAND</name><argument_list>(<argument><expr><name>subst</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tree</name> <operator>=</operator> <call><name>findsubquery</name><argument_list>(<argument><expr><name>tree</name></expr></argument>, <argument><expr><name>qex</name></expr></argument>, <argument><expr><name>subs</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name>qex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name>subs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>tree</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>rewrited</name></expr></argument>, <argument><expr><name>HDRSIZETQ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>rewrited</name><operator>-&gt;</operator><name>size</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>ex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>subst</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>rewrited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>QTNBinary</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>rewrited</name> <operator>=</operator> <call><name>QTN2QT</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>QTNFree</name><argument_list>(<argument><expr><name>tree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>query</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>ex</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>subst</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>rewrited</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
