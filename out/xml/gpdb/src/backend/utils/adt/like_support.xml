<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/like_support.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * like_support.c
 *	  Planner support functions for LIKE, regex, and related operators.
 *
 * These routines handle special optimization of operators that can be
 * used with index scans even though they are not known to the executor's
 * indexscan machinery.  The key idea is that these operators allow us
 * to derive approximate indexscan qual clauses, such that any tuples
 * that pass the operator clause itself must also satisfy the simpler
 * indexscan condition(s).  Then we can use the indexscan machinery
 * to avoid scanning as much of the table as we'd otherwise have to,
 * while applying the original operator as a qpqual condition to ensure
 * we deliver only the tuples we want.  (In essence, we're using a regular
 * index as if it were a lossy index.)
 *
 * An example of what we're doing is
 *			textfield LIKE 'abc%def'
 * from which we can generate the indexscanable conditions
 *			textfield &gt;= 'abc' AND textfield &lt; 'abd'
 * which allow efficient scanning of an index on textfield.
 * (In reality, character set and collation issues make the transformation
 * from LIKE to indexscan limits rather harder than one might think ...
 * but that's the basic idea.)
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/like_support.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/stratnum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_opfamily.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/supportnodes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/varlena.h"</cpp:file></cpp:include>


<typedef>typedef <type><enum>enum
<block>{
	<decl><name>Pattern_Type_Like</name></decl>,
	<decl><name>Pattern_Type_Like_IC</name></decl>,
	<decl><name>Pattern_Type_Regex</name></decl>,
	<decl><name>Pattern_Type_Regex_IC</name></decl>,
	<decl><name>Pattern_Type_Prefix</name></decl>
}</block></enum></type> <name>Pattern_Type</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>Pattern_Prefix_None</name></decl>, <decl><name>Pattern_Prefix_Partial</name></decl>, <decl><name>Pattern_Prefix_Exact</name></decl>
}</block></enum></type> <name>Pattern_Prefix_Status</name>;</typedef>

<function_decl><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type><name>like_regex_support</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rawreq</name></decl></parameter>, <parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type><name>match_pattern_prefix</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>leftop</name></decl></parameter>,
								  <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightop</name></decl></parameter>,
								  <parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>expr_coll</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>indexcollation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>patternsel_common</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>oprid</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>opfuncid</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>,
								<parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
								<parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>,
								<parameter><decl><type><name>bool</name></type> <name>negate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Pattern_Prefix_Status</name></type> <name>pattern_fixed_prefix</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>patt</name></decl></parameter>,
												  <parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>,
												  <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
												  <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>prefix</name></decl></parameter>,
												  <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>rest_selec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>prefix_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									  <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name></type> <name>vartype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>prefixcon</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>like_selectivity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>patt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pattlen</name></decl></parameter>,
									<parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>regex_selectivity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>patt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pattlen</name></decl></parameter>,
									 <parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>fixed_prefix_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>pattern_char_isalpha</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_multibyte</name></decl></parameter>,
								 <parameter><decl><type><name>pg_locale_t</name></type> <name>locale</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>locale_is_c</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type><name>make_greater_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Const</name> <modifier>*</modifier></type><name>str_const</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>ltproc</name></decl></parameter>,
								  <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>string_to_datum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datatype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type><name>string_to_const</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datatype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type><name>string_to_bytea_const</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>str_len</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 * Planner support functions for LIKE, regex, and related operators
 */</comment>
<function><type><name>Datum</name></type>
<name>textlike_support</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rawreq</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>like_regex_support</name><argument_list>(<argument><expr><name>rawreq</name></expr></argument>, <argument><expr><name>Pattern_Type_Like</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>texticlike_support</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rawreq</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>like_regex_support</name><argument_list>(<argument><expr><name>rawreq</name></expr></argument>, <argument><expr><name>Pattern_Type_Like_IC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>textregexeq_support</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rawreq</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>like_regex_support</name><argument_list>(<argument><expr><name>rawreq</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>texticregexeq_support</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rawreq</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><call><name>like_regex_support</name><argument_list>(<argument><expr><name>rawreq</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex_IC</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* Common code for the above */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>like_regex_support</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rawreq</name></decl></parameter>, <parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>ret</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rawreq</name></expr></argument>, <argument><expr><name>SupportRequestSelectivity</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Make a selectivity estimate for a function call, just as we'd do if
		 * the call was via the corresponding operator.
		 */</comment>
		<decl_stmt><decl><type><name>SupportRequestSelectivity</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><operator>(</operator><name>SupportRequestSelectivity</name> <operator>*</operator><operator>)</operator> <name>rawreq</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>s1</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>is_join</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * For the moment we just punt.  If patternjoinsel is ever
			 * improved to do better, this should be made to call it.
			 */</comment>
			<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>DEFAULT_MATCH_SEL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Share code with operator restriction selectivity functions */</comment>
			<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>patternsel_common</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>root</name></name></expr></argument>,
								   <argument><expr><name>InvalidOid</name></expr></argument>,
								   <argument><expr><name><name>req</name><operator>-&gt;</operator><name>funcid</name></name></expr></argument>,
								   <argument><expr><name><name>req</name><operator>-&gt;</operator><name>args</name></name></expr></argument>,
								   <argument><expr><name><name>req</name><operator>-&gt;</operator><name>varRelid</name></name></expr></argument>,
								   <argument><expr><name><name>req</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
								   <argument><expr><name>ptype</name></expr></argument>,
								   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>req</name><operator>-&gt;</operator><name>selectivity</name></name> <operator>=</operator> <name>s1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>req</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rawreq</name></expr></argument>, <argument><expr><name>SupportRequestIndexCondition</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Try to convert operator/function call to index conditions */</comment>
		<decl_stmt><decl><type><name>SupportRequestIndexCondition</name> <modifier>*</modifier></type><name>req</name> <init>= <expr><operator>(</operator><name>SupportRequestIndexCondition</name> <operator>*</operator><operator>)</operator> <name>rawreq</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Currently we have no "reverse" match operators with the pattern on
		 * the left, so we only need consider cases with the indexkey on the
		 * left.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>req</name><operator>-&gt;</operator><name>indexarg</name></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>is_opclause</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name><name>req</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
				<call><name>match_pattern_prefix</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>ptype</name></expr></argument>,
									 <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
									 <argument><expr><name><name>req</name><operator>-&gt;</operator><name>opfamily</name></name></expr></argument>,
									 <argument><expr><name><name>req</name><operator>-&gt;</operator><name>indexcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>is_funcclause</name><argument_list>(<argument><expr><name><name>req</name><operator>-&gt;</operator><name>node</name></name></expr></argument>)</argument_list></call></expr>)</condition>	<comment type="block">/* be paranoid */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FuncExpr</name>   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>FuncExpr</name> <operator>*</operator><operator>)</operator> <name><name>req</name><operator>-&gt;</operator><name>node</name></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ret</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator>
				<call><name>match_pattern_prefix</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>ptype</name></expr></argument>,
									 <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
									 <argument><expr><name><name>req</name><operator>-&gt;</operator><name>opfamily</name></name></expr></argument>,
									 <argument><expr><name><name>req</name><operator>-&gt;</operator><name>indexcollation</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>ret</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * match_pattern_prefix
 *	  Try to generate an indexqual for a LIKE or regex operator.
 */</comment>
<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>match_pattern_prefix</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>leftop</name></decl></parameter>,
					 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>rightop</name></decl></parameter>,
					 <parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>expr_coll</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>indexcollation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>patt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pattern_Prefix_Status</name></type> <name>pstatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>ldatatype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rdatatype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>oproid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>expr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>ltproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>greaterstr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Can't do anything with a non-constant or NULL pattern argument.
	 *
	 * Note that since we restrict ourselves to cases with a hard constant on
	 * the RHS, it's a-fortiori a pseudoconstant, and we don't need to worry
	 * about verifying that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>patt</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Not supported if the expression collation is nondeterministic.  The
	 * optimized equality or prefix tests use bytewise comparisons, which is
	 * not consistent with nondeterministic collations.  The actual
	 * pattern-matching implementation functions will later error out that
	 * pattern-matching is not supported with nondeterministic collations. (We
	 * could also error out here, but by doing it later we get more precise
	 * error messages.)  (It should be possible to support at least
	 * Pattern_Prefix_Exact, but no point as along as the actual
	 * pattern-matching implementations don't support it.)
	 *
	 * expr_coll is not set for a non-collation-aware data type such as bytea.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>expr_coll</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_collation_isdeterministic</name><argument_list>(<argument><expr><name>expr_coll</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Try to extract a fixed prefix from the pattern.
	 */</comment>
	<expr_stmt><expr><name>pstatus</name> <operator>=</operator> <call><name>pattern_fixed_prefix</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>expr_coll</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fail if no fixed prefix */</comment>
	<if_stmt><if>if <condition>(<expr><name>pstatus</name> <operator>==</operator> <name>Pattern_Prefix_None</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Must also check that index's opfamily supports the operators we will
	 * want to apply.  (A hash index, for example, will not support "&gt;=".)
	 * Currently, only btree and spgist support the operators we need.
	 *
	 * Note: actually, in the Pattern_Prefix_Exact case, we only need "=" so a
	 * hash index would work.  Currently it doesn't seem worth checking for
	 * that, however.
	 *
	 * We insist on the opfamily being one of the specific ones we expect,
	 * else we'd do the wrong thing if someone were to make a reverse-sort
	 * opfamily with the same operators.
	 *
	 * The non-pattern opclasses will not sort the way we need in most non-C
	 * locales.  We can use such an index anyway for an exact match (simple
	 * equality), but not for prefix-match cases.  Note that here we are
	 * looking at the index's collation, not the expression's collation --
	 * this test is *not* dependent on the LIKE/regex operator's collation.
	 *
	 * While we're at it, identify the type the comparison constant(s) should
	 * have, based on the opfamily.
	 */</comment>
	<switch>switch <condition>(<expr><name>opfamily</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TEXT_BTREE_FAM_OID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>pstatus</name> <operator>==</operator> <name>Pattern_Prefix_Exact</name> <operator>||</operator>
				  <call><name>lc_collate_is_c</name><argument_list>(<argument><expr><name>indexcollation</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>rdatatype</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TEXT_PATTERN_BTREE_FAM_OID</name></expr>:</case>
		<case>case <expr><name>TEXT_SPGIST_FAM_OID</name></expr>:</case>
			<expr_stmt><expr><name>rdatatype</name> <operator>=</operator> <name>TEXTOID</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BPCHAR_BTREE_FAM_OID</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>pstatus</name> <operator>==</operator> <name>Pattern_Prefix_Exact</name> <operator>||</operator>
				  <call><name>lc_collate_is_c</name><argument_list>(<argument><expr><name>indexcollation</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NIL</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>rdatatype</name> <operator>=</operator> <name>BPCHAROID</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BPCHAR_PATTERN_BTREE_FAM_OID</name></expr>:</case>
			<expr_stmt><expr><name>rdatatype</name> <operator>=</operator> <name>BPCHAROID</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BYTEA_BTREE_FAM_OID</name></expr>:</case>
			<expr_stmt><expr><name>rdatatype</name> <operator>=</operator> <name>BYTEAOID</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<return>return <expr><name>NIL</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/* OK, prepare to create the indexqual(s) */</comment>
	<expr_stmt><expr><name>ldatatype</name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If necessary, coerce the prefix constant to the right type.  The given
	 * prefix constant is either text or bytea type, therefore the only case
	 * where we need to do anything is when converting text to bpchar.  Those
	 * two types are binary-compatible, so relabeling the Const node is
	 * sufficient.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>prefix</name><operator>-&gt;</operator><name>consttype</name></name> <operator>!=</operator> <name>rdatatype</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>consttype</name></name> <operator>==</operator> <name>TEXTOID</name> <operator>&amp;&amp;</operator>
			   <name>rdatatype</name> <operator>==</operator> <name>BPCHAROID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>prefix</name><operator>-&gt;</operator><name>consttype</name></name> <operator>=</operator> <name>rdatatype</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we found an exact-match pattern, generate an "=" indexqual.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>pstatus</name> <operator>==</operator> <name>Pattern_Prefix_Exact</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oproid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>ldatatype</name></expr></argument>, <argument><expr><name>rdatatype</name></expr></argument>,
									 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oproid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no = operator for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>oproid</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>leftop</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>prefix</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>indexcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, we have a nonempty required prefix of the values.
	 *
	 * We can always say "x &gt;= prefix".
	 */</comment>
	<expr_stmt><expr><name>oproid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>ldatatype</name></expr></argument>, <argument><expr><name>rdatatype</name></expr></argument>,
								 <argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oproid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no &gt;= operator for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>oproid</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
						 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>leftop</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>prefix</name></expr></argument>,
						 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>indexcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>list_make1</name><argument_list>(<argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*-------
	 * If we can create a string larger than the prefix, we can say
	 * "x &lt; greaterstr".  NB: we rely on make_greater_string() to generate
	 * a guaranteed-greater string, not just a probably-greater string.
	 * In general this is only guaranteed in C locale, so we'd better be
	 * using a C-locale index collation.
	 *-------
	 */</comment>
	<expr_stmt><expr><name>oproid</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>ldatatype</name></expr></argument>, <argument><expr><name>rdatatype</name></expr></argument>,
								 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>oproid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no &lt; operator for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>oproid</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>ltproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>greaterstr</name> <operator>=</operator> <call><name>make_greater_string</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ltproc</name></expr></argument>, <argument><expr><name>indexcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>greaterstr</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>expr</name> <operator>=</operator> <call><name>make_opclause</name><argument_list>(<argument><expr><name>oproid</name></expr></argument>, <argument><expr><name>BOOLOID</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							 <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>leftop</name></expr></argument>, <argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>greaterstr</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>indexcollation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>expr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * patternsel_common - generic code for pattern-match restriction selectivity.
 *
 * To support using this from either the operator or function paths, caller
 * may pass either operator OID or underlying function OID; we look up the
 * latter from the former if needed.  (We could just have patternsel() call
 * get_opcode(), but the work would be wasted if we don't have a need to
 * compare a fixed prefix to the pg_statistic data.)
 *
 * Note that oprid and/or opfuncid should be for the positive-match operator
 * even when negate is true.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>patternsel_common</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>oprid</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>opfuncid</name></decl></parameter>,
				  <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
				  <parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name></type> <name>negate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>varonleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>constval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>consttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>vartype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfamily</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pattern_Prefix_Status</name></type> <name>pstatus</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>patt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>prefix</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>rest_selec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Initialize result to the appropriate default estimate depending on
	 * whether it's a match or not-match operator.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>DEFAULT_MATCH_SEL</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DEFAULT_MATCH_SEL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If expression is not variable op constant, then punt and return the
	 * default estimate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_restriction_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>other</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varonleft</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>result</name></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>varonleft</name> <operator>||</operator> <operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the constant is NULL, assume operator is strict and return zero, ie,
	 * operator will never return TRUE.  (It's zero even for a negator op.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>constval</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>consttype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>consttype</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * The right-hand const is type text or bytea for all supported operators.
	 * We do not expect to see binary-compatible types here, since
	 * const-folding should have relabeled the const to exactly match the
	 * operator's declared type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>consttype</name> <operator>!=</operator> <name>TEXTOID</name> <operator>&amp;&amp;</operator> <name>consttype</name> <operator>!=</operator> <name>BYTEAOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Similarly, the exposed type of the left-hand side should be one of
	 * those we know.  (Do not look at vardata.atttype, which might be
	 * something binary-compatible but different.)	We can use it to choose
	 * the index opfamily from which we must draw the comparison operators.
	 *
	 * NOTE: It would be more correct to use the PATTERN opfamilies than the
	 * simple ones, but at the moment ANALYZE will not generate statistics for
	 * the PATTERN operators.  But our results are so approximate anyway that
	 * it probably hardly matters.
	 */</comment>
	<expr_stmt><expr><name>vartype</name> <operator>=</operator> <name><name>vardata</name><operator>.</operator><name>vartype</name></name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name>vartype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TEXTOID</name></expr>:</case>
		<case>case <expr><name>NAMEOID</name></expr>:</case>
			<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name>TEXT_BTREE_FAM_OID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BPCHAROID</name></expr>:</case>
			<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name>BPCHAR_BTREE_FAM_OID</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BYTEAOID</name></expr>:</case>
			<expr_stmt><expr><name>opfamily</name> <operator>=</operator> <name>BYTEA_BTREE_FAM_OID</name></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></switch>

	<comment type="block">/*
	 * Grab the nullfrac for use below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullfrac</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Pull out any fixed prefix implied by the pattern, and estimate the
	 * fractional selectivity of the remainder of the pattern.  Unlike many
	 * other selectivity estimators, we use the pattern operator's actual
	 * collation for this step.  This is not because we expect the collation
	 * to make a big difference in the selectivity estimate (it seldom would),
	 * but because we want to be sure we cache compiled regexps under the
	 * right cache key, so that they can be re-used at runtime.
	 */</comment>
	<expr_stmt><expr><name>patt</name> <operator>=</operator> <operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pstatus</name> <operator>=</operator> <call><name>pattern_fixed_prefix</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><name>ptype</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>prefix</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rest_selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If necessary, coerce the prefix constant to the right type.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>&amp;&amp;</operator> <name><name>prefix</name><operator>-&gt;</operator><name>consttype</name></name> <operator>!=</operator> <name>vartype</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prefixstr</name></decl>;</decl_stmt>

		<switch>switch <condition>(<expr><name><name>prefix</name><operator>-&gt;</operator><name>consttype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>TEXTOID</name></expr>:</case>
				<expr_stmt><expr><name>prefixstr</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>BYTEAOID</name></expr>:</case>
				<expr_stmt><expr><name>prefixstr</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>byteaout</name></expr></argument>,
																<argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized consttype: %u"</literal></expr></argument>,
					 <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>result</name></expr>;</return>
		</block_content>}</block></switch>
		<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>string_to_const</name><argument_list>(<argument><expr><name>prefixstr</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prefixstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>pstatus</name> <operator>==</operator> <name>Pattern_Prefix_Exact</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Pattern specifies an exact match, so pretend operator is '='
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eqopr</name> <init>= <expr><call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>,
												<argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>eqopr</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no = operator for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>var_eq_const</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><name>eqopr</name></expr></argument>, <argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
							  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Not exact-match pattern.  If we have a sufficiently large
		 * histogram, estimate selectivity for the histogram part of the
		 * population by counting matches in the histogram.  If not, estimate
		 * selectivity of the fixed prefix and remainder of pattern
		 * separately, then combine the two to get an estimate of the
		 * selectivity for the part of the column population represented by
		 * the histogram.  (For small histograms, we combine these
		 * approaches.)
		 *
		 * We then add up data for any most-common-values values; these are
		 * not in the histogram population, and we can get exact answers for
		 * them by applying the pattern operator, so there's no reason to
		 * approximate.  (If the MCVs cover a significant part of the total
		 * population, this gives us a big leg up in accuracy.)
		 */</comment>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>hist_size</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>opproc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>mcv_selec</name></decl>,
					<decl><type ref="prev"/><name>sumcommon</name></decl>;</decl_stmt>

		<comment type="block">/* Try to use the histogram entries to get selectivity */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>opfuncid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>oprid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>opfuncid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>histogram_selectivity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>, <argument><expr><name>constval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									  <argument><expr><literal type="number">10</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>hist_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If not at least 100 entries, use the heuristic method */</comment>
		<if_stmt><if>if <condition>(<expr><name>hist_size</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Selectivity</name></type> <name>heursel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Selectivity</name></type> <name>prefixsel</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>pstatus</name> <operator>==</operator> <name>Pattern_Prefix_Partial</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>prefixsel</name> <operator>=</operator> <call><name>prefix_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>,
											   <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>prefixsel</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>heursel</name> <operator>=</operator> <name>prefixsel</name> <operator>*</operator> <name>rest_selec</name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* fewer than 10 histogram entries? */</comment>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>heursel</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * For histogram sizes from 10 to 100, we combine the
				 * histogram and heuristic selectivities, putting increasingly
				 * more trust in the histogram for larger sizes.
				 */</comment>
				<decl_stmt><decl><type><name>double</name></type>		<name>hist_weight</name> <init>= <expr><name>hist_size</name> <operator>/</operator> <literal type="number">100.0</literal></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>selec</name> <operator>*</operator> <name>hist_weight</name> <operator>+</operator> <name>heursel</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>hist_weight</name><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* In any case, don't believe extremely small or large estimates. */</comment>
		<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>&lt;</operator> <literal type="number">0.0001</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0001</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>selec</name> <operator>&gt;</operator> <literal type="number">0.9999</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.9999</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * If we have most-common-values info, add up the fractions of the MCV
		 * entries that satisfy MCV OP PATTERN.  These fractions contribute
		 * directly to the result selectivity.  Also add up the total fraction
		 * represented by MCV entries.
		 */</comment>
		<expr_stmt><expr><name>mcv_selec</name> <operator>=</operator> <call><name>mcv_selectivity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>, <argument><expr><name>constval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
									<argument><expr><operator>&amp;</operator><name>sumcommon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now merge the results from the MCV and histogram calculations,
		 * realizing that the histogram covers only the non-null values that
		 * are not listed in MCV.
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>*=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac</name> <operator>-</operator> <name>sumcommon</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>selec</name> <operator>+=</operator> <name>mcv_selec</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <name>selec</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* now adjust if we wanted not-match rather than match */</comment>
	<if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>result</name> <operator>-</operator> <name>nullfrac</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* result should be in range, but make sure... */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prefix</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>prefix</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fix impedance mismatch between SQL-callable functions and patternsel_common
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>patternsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>negate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varRelid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name> <init>= <expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If this is for a NOT LIKE or similar operator, get the corresponding
	 * positive-match operator and work with that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>operator</name> <operator>=</operator> <call><name>get_negator</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"patternsel called for operator without a negator"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>patternsel_common</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
							 <argument><expr><name>operator</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>args</name></expr></argument>,
							 <argument><expr><name>varRelid</name></expr></argument>,
							 <argument><expr><name>collation</name></expr></argument>,
							 <argument><expr><name>ptype</name></expr></argument>,
							 <argument><expr><name>negate</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regexeqsel		- Selectivity of regular-expression pattern match.
 */</comment>
<function><type><name>Datum</name></type>
<name>regexeqsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		icregexeqsel	- Selectivity of case-insensitive regex match.
 */</comment>
<function><type><name>Datum</name></type>
<name>icregexeqsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex_IC</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		likesel			- Selectivity of LIKE pattern match.
 */</comment>
<function><type><name>Datum</name></type>
<name>likesel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Like</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		prefixsel			- selectivity of prefix operator
 */</comment>
<function><type><name>Datum</name></type>
<name>prefixsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Prefix</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *
 *		iclikesel			- Selectivity of ILIKE pattern match.
 */</comment>
<function><type><name>Datum</name></type>
<name>iclikesel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Like_IC</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regexnesel		- Selectivity of regular-expression pattern non-match.
 */</comment>
<function><type><name>Datum</name></type>
<name>regexnesel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		icregexnesel	- Selectivity of case-insensitive regex non-match.
 */</comment>
<function><type><name>Datum</name></type>
<name>icregexnesel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex_IC</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		nlikesel		- Selectivity of LIKE pattern non-match.
 */</comment>
<function><type><name>Datum</name></type>
<name>nlikesel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Like</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		icnlikesel		- Selectivity of ILIKE pattern non-match.
 */</comment>
<function><type><name>Datum</name></type>
<name>icnlikesel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Like_IC</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * patternjoinsel		- Generic code for pattern-match join selectivity.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>patternjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>negate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* For the moment we just punt. */</comment>
	<return>return <expr><ternary><condition><expr><name>negate</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>DEFAULT_MATCH_SEL</name><operator>)</operator></expr> </then><else>: <expr><name>DEFAULT_MATCH_SEL</name></expr></else></ternary></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		regexeqjoinsel	- Join selectivity of regular-expression pattern match.
 */</comment>
<function><type><name>Datum</name></type>
<name>regexeqjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternjoinsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		icregexeqjoinsel	- Join selectivity of case-insensitive regex match.
 */</comment>
<function><type><name>Datum</name></type>
<name>icregexeqjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternjoinsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex_IC</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		likejoinsel			- Join selectivity of LIKE pattern match.
 */</comment>
<function><type><name>Datum</name></type>
<name>likejoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternjoinsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Like</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		prefixjoinsel			- Join selectivity of prefix operator
 */</comment>
<function><type><name>Datum</name></type>
<name>prefixjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternjoinsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Prefix</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		iclikejoinsel			- Join selectivity of ILIKE pattern match.
 */</comment>
<function><type><name>Datum</name></type>
<name>iclikejoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternjoinsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Like_IC</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		regexnejoinsel	- Join selectivity of regex non-match.
 */</comment>
<function><type><name>Datum</name></type>
<name>regexnejoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternjoinsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		icregexnejoinsel	- Join selectivity of case-insensitive regex non-match.
 */</comment>
<function><type><name>Datum</name></type>
<name>icregexnejoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternjoinsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Regex_IC</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		nlikejoinsel		- Join selectivity of LIKE pattern non-match.
 */</comment>
<function><type><name>Datum</name></type>
<name>nlikejoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternjoinsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Like</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		icnlikejoinsel		- Join selectivity of ILIKE pattern non-match.
 */</comment>
<function><type><name>Datum</name></type>
<name>icnlikejoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>patternjoinsel</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>Pattern_Type_Like_IC</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *
 * Pattern analysis functions
 *
 * These routines support analysis of LIKE and regular-expression patterns
 * by the planner/optimizer.  It's important that they agree with the
 * regular-expression code in backend/regex/ and the LIKE code in
 * backend/utils/adt/like.c.  Also, the computation of the fixed prefix
 * must be conservative: if we report a string longer than the true fixed
 * prefix, the query may produce actually wrong answers, rather than just
 * getting a bad selectivity estimate!
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Extract the fixed prefix, if any, for a pattern.
 *
 * *prefix is set to a palloc'd prefix string (in the form of a Const node),
 *	or to NULL if no fixed prefix exists for the pattern.
 * If rest_selec is not NULL, *rest_selec is set to an estimate of the
 *	selectivity of the remainder of the pattern (without any fixed prefix).
 * The prefix Const has the same type (TEXT or BYTEA) as the input pattern.
 *
 * The return value distinguishes no fixed prefix, a partial prefix,
 * or an exact-match-only pattern.
 */</comment>

<function><type><specifier>static</specifier> <name>Pattern_Prefix_Status</name></type>
<name>like_fixed_prefix</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>patt_const</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
				  <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>prefix_const</name></decl></parameter>, <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>rest_selec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>match</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>patt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pattlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name> <init>= <expr><name><name>patt_const</name><operator>-&gt;</operator><name>consttype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>,
				<decl><type ref="prev"/><name>match_pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_multibyte</name> <init>= <expr><operator>(</operator><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>locale</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>locale_is_c</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* the right-hand const is type text or bytea */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>typeid</name> <operator>==</operator> <name>BYTEAOID</name> <operator>||</operator> <name>typeid</name> <operator>==</operator> <name>TEXTOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>case_insensitive</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"case insensitive matching not supported on type bytea"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* If case-insensitive, we need locale info */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>lc_ctype_is_c</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>locale_is_c</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>collation</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This typically means that the parser could not resolve a
				 * conflict of implicit collations, so report it that way.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for ILIKE"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>locale</name> <operator>=</operator> <call><name>pg_newlocale_from_collation</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>!=</operator> <name>BYTEAOID</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>patt</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>patt_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pattlen</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>patt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>bstr</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name><name>patt_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>pattlen</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>patt</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>pattlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>pattlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>bstr</name> <operator>==</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>patt_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>pattlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>match_pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>pattlen</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* % and _ are wildcard characters in LIKE */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal> <operator>||</operator>
			<name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* Backslash escapes the next character */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>pattlen</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Stop if case-varying character (it's sort of a wildcard) */</comment>
		<if_stmt><if>if <condition>(<expr><name>case_insensitive</name> <operator>&amp;&amp;</operator>
			<call><name>pattern_char_isalpha</name><argument_list>(<argument><expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>is_multibyte</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>, <argument><expr><name>locale_is_c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>match</name><index>[<expr><name>match_pos</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>match</name><index>[<expr><name>match_pos</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>!=</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>prefix_const</name> <operator>=</operator> <call><name>string_to_const</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>prefix_const</name> <operator>=</operator> <call><name>string_to_bytea_const</name><argument_list>(<argument><expr><name>match</name></expr></argument>, <argument><expr><name>match_pos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>rest_selec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>rest_selec</name> <operator>=</operator> <call><name>like_selectivity</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name></expr></argument>, <argument><expr><name>pattlen</name> <operator>-</operator> <name>pos</name></expr></argument>,
									   <argument><expr><name>case_insensitive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>patt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>match</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* in LIKE, an empty pattern is an exact match! */</comment>
	<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>==</operator> <name>pattlen</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>Pattern_Prefix_Exact</name></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* reached end of pattern, so exact */</comment>

	<if_stmt><if>if <condition>(<expr><name>match_pos</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>Pattern_Prefix_Partial</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>Pattern_Prefix_None</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Pattern_Prefix_Status</name></type>
<name>regex_fixed_prefix</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>patt_const</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
				   <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>prefix_const</name></decl></parameter>, <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>rest_selec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name> <init>= <expr><name><name>patt_const</name><operator>-&gt;</operator><name>consttype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>exact</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Should be unnecessary, there are no bytea regex operators defined. As
	 * such, it should be noted that the rest of this function has *not* been
	 * made safe for binary (possibly NULL containing) strings.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"regular-expression matching not supported on type bytea"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Use the regexp machinery to extract the prefix, if any */</comment>
	<expr_stmt><expr><name>prefix</name> <operator>=</operator> <call><name>regexp_fixed_prefix</name><argument_list>(<argument><expr><call><name>DatumGetTextPP</name><argument_list>(<argument><expr><name><name>patt_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><name>case_insensitive</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>exact</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prefix</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>prefix_const</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>rest_selec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>patt</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>patt_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>rest_selec</name> <operator>=</operator> <call><name>regex_selectivity</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>patt</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>case_insensitive</name></expr></argument>,
											<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>patt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<return>return <expr><name>Pattern_Prefix_None</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>prefix_const</name> <operator>=</operator> <call><name>string_to_const</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>rest_selec</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>exact</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Exact match, so there's no additional selectivity */</comment>
			<expr_stmt><expr><operator>*</operator><name>rest_selec</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>patt</name> <init>= <expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>patt_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><operator>*</operator><name>rest_selec</name> <operator>=</operator> <call><name>regex_selectivity</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>patt</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><name>case_insensitive</name></expr></argument>,
											<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>patt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>prefix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>exact</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>Pattern_Prefix_Exact</name></expr>;</return></block_content></block></if>	<comment type="block">/* pattern specifies exact match */</comment>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>Pattern_Prefix_Partial</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Pattern_Prefix_Status</name></type>
<name>pattern_fixed_prefix</name><parameter_list>(<parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>patt</name></decl></parameter>, <parameter><decl><type><name>Pattern_Type</name></type> <name>ptype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>,
					 <parameter><decl><type><name>Const</name> <modifier>*</modifier><modifier>*</modifier></type><name>prefix</name></decl></parameter>, <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>rest_selec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Pattern_Prefix_Status</name></type> <name>result</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>ptype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>Pattern_Type_Like</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>like_fixed_prefix</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>,
									   <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>rest_selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>Pattern_Type_Like_IC</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>like_fixed_prefix</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>,
									   <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>rest_selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>Pattern_Type_Regex</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>regex_fixed_prefix</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>,
										<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>rest_selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>Pattern_Type_Regex_IC</name></expr>:</case>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>regex_fixed_prefix</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>collation</name></expr></argument>,
										<argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>rest_selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>Pattern_Type_Prefix</name></expr>:</case>
			<comment type="block">/* Prefix type work is trivial.  */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>Pattern_Prefix_Partial</name></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rest_selec</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>	<comment type="block">/* all */</comment>
			<expr_stmt><expr><operator>*</operator><name>prefix</name> <operator>=</operator> <call><name>makeConst</name><argument_list>(<argument><expr><name><name>patt</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>,
								<argument><expr><name><name>patt</name><operator>-&gt;</operator><name>consttypmod</name></name></expr></argument>,
								<argument><expr><name><name>patt</name><operator>-&gt;</operator><name>constcollid</name></name></expr></argument>,
								<argument><expr><name><name>patt</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>,
								<argument><expr><call><name>datumCopy</name><argument_list>(<argument><expr><name><name>patt</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
										  <argument><expr><name><name>patt</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>,
										  <argument><expr><name><name>patt</name><operator>-&gt;</operator><name>constlen</name></name></expr></argument>)</argument_list></call></expr></argument>,
								<argument><expr><name><name>patt</name><operator>-&gt;</operator><name>constisnull</name></name></expr></argument>,
								<argument><expr><name><name>patt</name><operator>-&gt;</operator><name>constbyval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized ptype: %d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>ptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>Pattern_Prefix_None</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the selectivity of a fixed prefix for a pattern match.
 *
 * A fixed prefix "foo" is estimated as the selectivity of the expression
 * "variable &gt;= 'foo' AND variable &lt; 'fop'" (see also indxpath.c).
 *
 * The selectivity estimate is with respect to the portion of the column
 * population represented by the histogram --- the caller must fold this
 * together with info about MCVs and NULLs.
 *
 * We use the &gt;= and &lt; operators from the specified btree opfamily to do the
 * estimation.  The given variable and Const must be of the associated
 * datatype.
 *
 * XXX Note: we make use of the upper bound to estimate operator selectivity
 * even if the locale is such that we cannot rely on the upper-bound string.
 * The selectivity only needs to be approximately right anyway, so it seems
 * more useful to use the upper-bound code than not.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>prefix_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>,
				   <parameter><decl><type><name>Oid</name></type> <name>vartype</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>, <parameter><decl><type><name>Const</name> <modifier>*</modifier></type><name>prefixcon</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>prefixsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>cmpopr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>opproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>greaterstrcon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>eq_sel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cmpopr</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>,
								 <argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmpopr</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no &gt;= operator for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>cmpopr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prefixsel</name> <operator>=</operator> <call><name>ineq_histogram_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>,
										   <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
										   <argument><expr><name><name>prefixcon</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
										   <argument><expr><name><name>prefixcon</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>prefixsel</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No histogram is present ... return a suitable default estimate */</comment>
		<return>return <expr><name>DEFAULT_MATCH_SEL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*-------
	 * If we can create a string larger than the prefix, say
	 * "x &lt; greaterstr".  We try to generate the string referencing the
	 * collation of the var's statistics, but if that's not available,
	 * use DEFAULT_COLLATION_OID.
	 *-------
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
						 <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		 <comment type="block">/* sslot.stacoll is set up */</comment> <empty_stmt>;</empty_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name>cmpopr</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>,
								 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmpopr</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no &lt; operator for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>cmpopr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>greaterstrcon</name> <operator>=</operator> <call><name>make_greater_string</name><argument_list>(<argument><expr><name>prefixcon</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>, <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>greaterstrcon</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>topsel</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>topsel</name> <operator>=</operator> <call><name>ineq_histogram_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
											<argument><expr><name><name>greaterstrcon</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
											<argument><expr><name><name>greaterstrcon</name><operator>-&gt;</operator><name>consttype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* ineq_histogram_selectivity worked before, it shouldn't fail now */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>topsel</name> <operator>&gt;=</operator> <literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Merge the two selectivities in the same way as for a range query
		 * (see clauselist_selectivity()).  Note that we don't need to worry
		 * about double-exclusion of nulls, since ineq_histogram_selectivity
		 * doesn't count those anyway.
		 */</comment>
		<expr_stmt><expr><name>prefixsel</name> <operator>=</operator> <name>topsel</name> <operator>+</operator> <name>prefixsel</name> <operator>-</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the prefix is long then the two bounding values might be too close
	 * together for the histogram to distinguish them usefully, resulting in a
	 * zero estimate (plus or minus roundoff error). To avoid returning a
	 * ridiculously small estimate, compute the estimated selectivity for
	 * "variable = 'foo'", and clamp to that. (Obviously, the resultant
	 * estimate should be at least that.)
	 *
	 * We apply this even if we couldn't make a greater string.  That case
	 * suggests that the prefix is near the maximum possible, and thus
	 * probably off the end of the histogram, and thus we probably got a very
	 * small estimate from the &gt;= condition; so we still need to clamp.
	 */</comment>
	<expr_stmt><expr><name>cmpopr</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>, <argument><expr><name>vartype</name></expr></argument>,
								 <argument><expr><name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cmpopr</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no = operator for opfamily %u"</literal></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>eq_sel</name> <operator>=</operator> <call><name>var_eq_const</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><name>cmpopr</name></expr></argument>, <argument><expr><name><name>prefixcon</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>,
						  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>prefixsel</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>prefixsel</name></expr></argument>, <argument><expr><name>eq_sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>prefixsel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Estimate the selectivity of a pattern of the specified type.
 * Note that any fixed prefix of the pattern will have been removed already,
 * so actually we may be looking at just a fragment of the pattern.
 *
 * For now, we use a very simplistic approach: fixed characters reduce the
 * selectivity a good deal, character ranges reduce it a little,
 * wildcards (such as % for LIKE or .* for regex) increase it.
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FIXED_CHAR_SEL</name></cpp:macro>	<cpp:value>0.20</cpp:value></cpp:define>	<comment type="block">/* about 1/5 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CHAR_RANGE_SEL</name></cpp:macro>	<cpp:value>0.25</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ANY_CHAR_SEL</name></cpp:macro>	<cpp:value>0.9</cpp:value></cpp:define>		<comment type="block">/* not 1, since it won't match end-of-string */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FULL_WILDCARD_SEL</name></cpp:macro> <cpp:value>5.0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PARTIAL_WILDCARD_SEL</name></cpp:macro> <cpp:value>2.0</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>like_selectivity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>patt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pattlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>sel</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>

	<comment type="block">/* Skip any leading wildcard; it's already factored into initial sel */</comment>
	<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>pattlen</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'%'</literal> <operator>&amp;&amp;</operator> <name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<for>for <control>(<init>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>pattlen</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* % and _ are wildcard characters in LIKE */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'%'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>FULL_WILDCARD_SEL</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'_'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>ANY_CHAR_SEL</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Backslash quotes the next character */</comment>
			<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>pattlen</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>FIXED_CHAR_SEL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>FIXED_CHAR_SEL</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Could get sel &gt; 1 if multiple wildcards */</comment>
	<if_stmt><if>if <condition>(<expr><name>sel</name> <operator>&gt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sel</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>sel</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>regex_selectivity_sub</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>patt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pattlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>sel</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>paren_depth</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>paren_pos</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* dummy init to keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name>pattlen</name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'('</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>paren_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>paren_pos</name> <operator>=</operator> <name>pos</name></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* remember start of parenthesized item */</comment>
			<expr_stmt><expr><name>paren_depth</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">')'</literal> <operator>&amp;&amp;</operator> <name>paren_depth</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>paren_depth</name><operator>--</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>paren_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sel</name> <operator>*=</operator> <call><name>regex_selectivity_sub</name><argument_list>(<argument><expr><name>patt</name> <operator>+</operator> <operator>(</operator><name>paren_pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
											 <argument><expr><name>pos</name> <operator>-</operator> <operator>(</operator><name>paren_pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
											 <argument><expr><name>case_insensitive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'|'</literal> <operator>&amp;&amp;</operator> <name>paren_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If unquoted | is present at paren level 0 in pattern, we have
			 * multiple alternatives; sum their probabilities.
			 */</comment>
			<expr_stmt><expr><name>sel</name> <operator>+=</operator> <call><name>regex_selectivity_sub</name><argument_list>(<argument><expr><name>patt</name> <operator>+</operator> <operator>(</operator><name>pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
										 <argument><expr><name>pattlen</name> <operator>-</operator> <operator>(</operator><name>pos</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>,
										 <argument><expr><name>case_insensitive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>				<comment type="block">/* rest of pattern is now processed */</comment>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'['</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>bool</name></type>		<name>negclass</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>patt</name><index>[<expr><operator>++</operator><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'^'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>negclass</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* ']' at start of class is not special */</comment>
				<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>pattlen</name> <operator>&amp;&amp;</operator> <name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>!=</operator> <literal type="char">']'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<if_stmt><if>if <condition>(<expr><name>paren_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sel</name> <operator>*=</operator> <operator>(</operator><ternary><condition><expr><name>negclass</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>CHAR_RANGE_SEL</name><operator>)</operator></expr> </then><else>: <expr><name>CHAR_RANGE_SEL</name></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>paren_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>ANY_CHAR_SEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'*'</literal> <operator>||</operator>
				 <name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'?'</literal> <operator>||</operator>
				 <name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Ought to be smarter about quantifiers... */</comment>
			<if_stmt><if>if <condition>(<expr><name>paren_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>PARTIAL_WILDCARD_SEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'{'</literal></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><name>pos</name> <operator>&lt;</operator> <name>pattlen</name> <operator>&amp;&amp;</operator> <name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>!=</operator> <literal type="char">'}'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>
			<if_stmt><if>if <condition>(<expr><name>paren_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>PARTIAL_WILDCARD_SEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>patt</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* backslash quotes the next character */</comment>
			<expr_stmt><expr><name>pos</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pos</name> <operator>&gt;=</operator> <name>pattlen</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>paren_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>FIXED_CHAR_SEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>paren_depth</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>FIXED_CHAR_SEL</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* Could get sel &gt; 1 if multiple wildcards */</comment>
	<if_stmt><if>if <condition>(<expr><name>sel</name> <operator>&gt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sel</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>sel</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>regex_selectivity</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>patt</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>pattlen</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>case_insensitive</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>fixed_prefix_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>sel</name></decl>;</decl_stmt>

	<comment type="block">/* If patt doesn't end with $, consider it to have a trailing wildcard */</comment>
	<if_stmt><if>if <condition>(<expr><name>pattlen</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>patt</name><index>[<expr><name>pattlen</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'$'</literal> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>pattlen</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>patt</name><index>[<expr><name>pattlen</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\\'</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* has trailing $ */</comment>
		<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>regex_selectivity_sub</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><name>pattlen</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>case_insensitive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* no trailing $ */</comment>
		<expr_stmt><expr><name>sel</name> <operator>=</operator> <call><name>regex_selectivity_sub</name><argument_list>(<argument><expr><name>patt</name></expr></argument>, <argument><expr><name>pattlen</name></expr></argument>, <argument><expr><name>case_insensitive</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sel</name> <operator>*=</operator> <name>FULL_WILDCARD_SEL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* If there's a fixed prefix, discount its selectivity */</comment>
	<if_stmt><if>if <condition>(<expr><name>fixed_prefix_len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>sel</name> <operator>/=</operator> <call><name>pow</name><argument_list>(<argument><expr><name>FIXED_CHAR_SEL</name></expr></argument>, <argument><expr><name>fixed_prefix_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Make sure result stays in range */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>sel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>sel</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether char is a letter (and, hence, subject to case-folding)
 *
 * In multibyte character sets or with ICU, we can't use isalpha, and it does
 * not seem worth trying to convert to wchar_t to use iswalpha.  Instead, just
 * assume any multibyte char is potentially case-varying.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>pattern_char_isalpha</name><parameter_list>(<parameter><decl><type><name>char</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_multibyte</name></decl></parameter>,
					 <parameter><decl><type><name>pg_locale_t</name></type> <name>locale</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>locale_is_c</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>locale_is_c</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator> <operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>is_multibyte</name> <operator>&amp;&amp;</operator> <call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>locale</name> <operator>&amp;&amp;</operator> <name><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr>;</return></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
	<if type="elseif">else if <condition>(<expr><name>locale</name> <operator>&amp;&amp;</operator> <name><name>locale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_LIBC</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>isalpha_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>, <argument><expr><name><name>locale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>isalpha</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>c</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * For bytea, the increment function need only increment the current byte
 * (there are no multibyte characters to worry about).
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>byte_increment</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>ptr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>ptr</name> <operator>&gt;=</operator> <literal type="number">255</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>(</operator><operator>*</operator><name>ptr</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Try to generate a string greater than the given string or any
 * string it is a prefix of.  If successful, return a palloc'd string
 * in the form of a Const node; else return NULL.
 *
 * The caller must provide the appropriate "less than" comparison function
 * for testing the strings, along with the collation to use.
 *
 * The key requirement here is that given a prefix string, say "foo",
 * we must be able to generate another string "fop" that is greater than
 * all strings "foobar" starting with "foo".  We can test that we have
 * generated a string greater than the prefix string, but in non-C collations
 * that is not a bulletproof guarantee that an extension of the string might
 * not sort after it; an example is that "foo " is less than "foo!", but it
 * is not clear that a "dictionary" sort ordering will consider "foo!" less
 * than "foo bar".  CAUTION: Therefore, this function should be used only for
 * estimation purposes when working in a non-C collation.
 *
 * To try to catch most cases where an extended string might otherwise sort
 * before the result value, we determine which of the strings "Z", "z", "y",
 * and "9" is seen as largest by the collation, and append that to the given
 * prefix before trying to find a string that compares as larger.
 *
 * To search for a greater string, we repeatedly "increment" the rightmost
 * character, using an encoding-specific character incrementer function.
 * When it's no longer possible to increment the last character, we truncate
 * off that character and start incrementing the next-to-rightmost.
 * For example, if "z" were the last character in the sort order, then we
 * could produce "foo" as a string greater than "fonz".
 *
 * This could be rather slow in the worst case, but in most cases we
 * won't have to try more than one or two strings before succeeding.
 *
 * Note that it's important for the character incrementer not to be too anal
 * about producing every possible character code, since in some cases the only
 * way to get a larger string is to increment a previous character position.
 * So we don't want to spend too much time trying every possible character
 * code at the last position.  A good rule of thumb is to be sure that we
 * don't try more than 256*K values for a K-byte character (and definitely
 * not 256^K, which is what an exhaustive search would approach).
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>make_greater_string</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>Const</name> <modifier>*</modifier></type><name>str_const</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>ltproc</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>datatype</name> <init>= <expr><name><name>str_const</name><operator>-&gt;</operator><name>consttype</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>workstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>cmpstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>cmptxt</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>mbcharacter_incrementer</name></type> <name>charinc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Get a modifiable copy of the prefix string in C-string format, and set
	 * up the string we will compare to as a Datum.  In C locale this can just
	 * be the given prefix string, otherwise we need to add a suffix.  Type
	 * BYTEA sorts bytewise so it never needs a suffix either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>datatype</name> <operator>==</operator> <name>BYTEAOID</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>bstr</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name><name>str_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>workstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>workstr</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>(</operator><name>Pointer</name><operator>)</operator> <name>bstr</name> <operator>==</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>str_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmpstr</name> <operator>=</operator> <name><name>str_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>datatype</name> <operator>==</operator> <name>NAMEOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>workstr</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>nameout</name></expr></argument>,
														  <argument><expr><name><name>str_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>workstr</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>str_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>workstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>lc_collate_is_c</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call> <operator>||</operator> <name>len</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>cmpstr</name> <operator>=</operator> <name><name>str_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* If first time through, determine the suffix to use */</comment>
			<decl_stmt><decl><type><specifier>static</specifier> <name>char</name></type> <name>suffixchar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>static</specifier> <name>Oid</name></type>	<name>suffixcollation</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>suffixchar</name> <operator>||</operator> <name>suffixcollation</name> <operator>!=</operator> <name>collation</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>best</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>best</name> <operator>=</operator> <literal type="string">"Z"</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>varstr_cmp</name><argument_list>(<argument><expr><name>best</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"z"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>best</name> <operator>=</operator> <literal type="string">"z"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>varstr_cmp</name><argument_list>(<argument><expr><name>best</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"y"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>best</name> <operator>=</operator> <literal type="string">"y"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>varstr_cmp</name><argument_list>(<argument><expr><name>best</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="string">"9"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>best</name> <operator>=</operator> <literal type="string">"9"</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>suffixchar</name> <operator>=</operator> <operator>*</operator><name>best</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>suffixcollation</name> <operator>=</operator> <name>collation</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* And build the string to compare to */</comment>
			<if_stmt><if>if <condition>(<expr><name>datatype</name> <operator>==</operator> <name>NAMEOID</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>cmptxt</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>cmptxt</name></expr></argument>, <argument><expr><name>workstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cmptxt</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <name>suffixchar</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>cmptxt</name><index>[<expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>cmpstr</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>cmptxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>cmptxt</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>cmptxt</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>cmptxt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>workstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><operator>(</operator><call><name>VARDATA</name><argument_list>(<argument><expr><name>cmptxt</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>len</name><operator>)</operator> <operator>=</operator> <name>suffixchar</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>cmpstr</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>cmptxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Select appropriate character-incrementer function */</comment>
	<if_stmt><if>if <condition>(<expr><name>datatype</name> <operator>==</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>charinc</name> <operator>=</operator> <name>byte_increment</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>charinc</name> <operator>=</operator> <call><name>pg_database_encoding_character_incrementer</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* And search ... */</comment>
	<while>while <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>charlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lastchar</name></decl>;</decl_stmt>

		<comment type="block">/* Identify the last character --- for bytea, just the last byte */</comment>
		<if_stmt><if>if <condition>(<expr><name>datatype</name> <operator>==</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>charlen</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>charlen</name> <operator>=</operator> <name>len</name> <operator>-</operator> <call><name>pg_mbcliplen</name><argument_list>(<argument><expr><name>workstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>len</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>lastchar</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>workstr</name> <operator>+</operator> <name>len</name> <operator>-</operator> <name>charlen</name><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Try to generate a larger string by incrementing the last character
		 * (for BYTEA, we treat each byte as a character).
		 *
		 * Note: the incrementer function is expected to return true if it's
		 * generated a valid-per-the-encoding new character, otherwise false.
		 * The contents of the character on false return are unspecified.
		 */</comment>
		<while>while <condition>(<expr><call><name>charinc</name><argument_list>(<argument><expr><name>lastchar</name></expr></argument>, <argument><expr><name>charlen</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Const</name>	   <modifier>*</modifier></type><name>workstr_const</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>datatype</name> <operator>==</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>workstr_const</name> <operator>=</operator> <call><name>string_to_bytea_const</name><argument_list>(<argument><expr><name>workstr</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>workstr_const</name> <operator>=</operator> <call><name>string_to_const</name><argument_list>(<argument><expr><name>workstr</name></expr></argument>, <argument><expr><name>datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>ltproc</name></expr></argument>,
											   <argument><expr><name>collation</name></expr></argument>,
											   <argument><expr><name>cmpstr</name></expr></argument>,
											   <argument><expr><name><name>workstr_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Successfully made a string larger than cmpstr */</comment>
				<if_stmt><if>if <condition>(<expr><name>cmptxt</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cmptxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>workstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>workstr_const</name></expr>;</return>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* No good, release unusable value and try again */</comment>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><call><name>DatumGetPointer</name><argument_list>(<argument><expr><name><name>workstr_const</name><operator>-&gt;</operator><name>constvalue</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>workstr_const</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * No luck here, so truncate off the last character and try to
		 * increment the next one.
		 */</comment>
		<expr_stmt><expr><name>len</name> <operator>-=</operator> <name>charlen</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>workstr</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/* Failed... */</comment>
	<if_stmt><if>if <condition>(<expr><name>cmptxt</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>cmptxt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>workstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Datum of the appropriate type from a C string.
 * Note that all of the supported types are pass-by-ref, so the
 * returned value should be pfree'd if no longer needed.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>string_to_datum</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datatype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>str</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We cheat a little by assuming that CStringGetTextDatum() will do for
	 * bpchar and varchar constants too...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>datatype</name> <operator>==</operator> <name>NAMEOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>namein</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>datatype</name> <operator>==</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>byteain</name></expr></argument>, <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Const node of the appropriate type from a C string.
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>string_to_const</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>datatype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>conval</name> <init>= <expr><call><name>string_to_datum</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>datatype</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>constlen</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We only need to support a few datatypes here, so hard-wire properties
	 * instead of incurring the expense of catalog lookups.
	 */</comment>
	<switch>switch <condition>(<expr><name>datatype</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TEXTOID</name></expr>:</case>
		<case>case <expr><name>VARCHAROID</name></expr>:</case>
		<case>case <expr><name>BPCHAROID</name></expr>:</case>
			<expr_stmt><expr><name>collation</name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>constlen</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NAMEOID</name></expr>:</case>
			<expr_stmt><expr><name>collation</name> <operator>=</operator> <name>C_COLLATION_OID</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>constlen</name> <operator>=</operator> <name>NAMEDATALEN</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>BYTEAOID</name></expr>:</case>
			<expr_stmt><expr><name>collation</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>constlen</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected datatype in string_to_const: %u"</literal></expr></argument>,
				 <argument><expr><name>datatype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>

	<return>return <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>datatype</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>, <argument><expr><name>constlen</name></expr></argument>,
					 <argument><expr><name>conval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Generate a Const node of bytea type from a binary C string and a length.
 */</comment>
<function><type><specifier>static</specifier> <name>Const</name> <modifier>*</modifier></type>
<name>string_to_bytea_const</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>str_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>bstr</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>str_len</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>conval</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>str_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>, <argument><expr><name>VARHDRSZ</name> <operator>+</operator> <name>str_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>conval</name> <operator>=</operator> <call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>bstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>makeConst</name><argument_list>(<argument><expr><name>BYTEAOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>conval</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>
</unit>
