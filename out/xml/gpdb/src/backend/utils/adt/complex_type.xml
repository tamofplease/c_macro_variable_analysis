<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/complex_type.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * complex_type.c
 *	  Core I/O functions for the built-in complex type.
 *
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 * Portions Copyright (c) 2016-Present VMware, Inc. or its affiliates.
 *
 *
 * IDENTIFICATION
 *	src/backend/utils/adt/complex_type.c
 *
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/hash.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"fmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/complex_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/float.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/float_utils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/geo_decls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/numeric.h"</cpp:file></cpp:include>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_pl</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall2(float8pl, Float8GetDatum((a)), Float8GetDatum((b))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_mi</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall2(float8mi, Float8GetDatum((a)), Float8GetDatum((b))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_mul</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall2(float8mul, Float8GetDatum((a)), Float8GetDatum((b))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_div</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall2(float8div, Float8GetDatum((a)), Float8GetDatum((b))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_pow</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall2(dpow, Float8GetDatum((a)), Float8GetDatum((b))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_atan2</name><parameter_list>(<parameter><type><name>a</name></type></parameter>, <parameter><type><name>b</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall2(datan2, Float8GetDatum((a)), Float8GetDatum((b))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_exp</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall1(dexp, Float8GetDatum((a))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_log1</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall1(dlog1, Float8GetDatum((a))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_sin</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall1(dsin, Float8GetDatum((a))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_cos</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall1(dcos, Float8GetDatum((a))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_sinh</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall1(dsinh, Float8GetDatum((a))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_cosh</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall1(dcosh, Float8GetDatum((a))))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>dp_asin</name><parameter_list>(<parameter><type><name>a</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>DatumGetFloat8(DirectFunctionCall1(dasin, Float8GetDatum((a))))</cpp:value></cpp:define>

<comment type="block">/*
 * decode a double precision from a cstring
 *
 * This is copy-pasted from float8in. The difference is that this returns a pointer
 * to the end of valid float, so that the caller can continue processing.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>complex_decode_double</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>num_p</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>num</name> <init>= <expr><operator>*</operator><name>num_p</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>orig_num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * endptr points to the first character _after_ the sequence we recognized
	 * as a valid floating point number. orig_num points to the original input
	 * string.
	 */</comment>
	<expr_stmt><expr><name>orig_num</name> <operator>=</operator> <name>num</name></expr>;</expr_stmt>

	<comment type="block">/* skip leading whitespace */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>num</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/*
	 * Check for an empty-string input to begin with, to avoid the vagaries of
	 * strtod() on different platforms.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>num</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type complex: \"%s\""</literal></expr></argument>,
					<argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>strtod</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* did we not see anything that looks like a double? */</comment>
	<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>==</operator> <name>num</name> <operator>||</operator> <name>errno</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>save_errno</name> <init>= <expr><name>errno</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * C99 requires that strtod() accept NaN, [+-]Infinity, and [+-]Inf,
		 * but not all platforms support all of these (and some accept them
		 * but set ERANGE anyway...)  Therefore, we check for these inputs
		 * ourselves if strtod() fails.
		 *
		 * Note: C99 also requires hexadecimal input as well as some extended
		 * forms of NaN, but we consider these forms unportable and don't try
		 * to support them.  You can use 'em if your strtod() takes 'em.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"Infinity"</literal></expr></argument>, <argument><expr><literal type="number">8</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">8</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"+Infinity"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"-Infinity"</literal></expr></argument>, <argument><expr><literal type="number">9</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">9</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"inf"</literal></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">3</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"+inf"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>pg_strncasecmp</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="string">"-inf"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>-</operator><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>num</name> <operator>+</operator> <literal type="number">4</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>save_errno</name> <operator>==</operator> <name>ERANGE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Some platforms return ERANGE for denormalized numbers (those
			 * that are not zero, but are too close to zero to have full
			 * precision).  We'd prefer not to throw error for that, so try to
			 * detect whether it's a "real" out-of-range condition by checking
			 * to see if the result is zero or huge.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>val</name> <operator>==</operator> <literal type="number">0.0</literal> <operator>||</operator> <name>val</name> <operator>&gt;=</operator> <name>HUGE_VAL</name> <operator>||</operator> <name>val</name> <operator>&lt;=</operator> <operator>-</operator><name>HUGE_VAL</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NUMERIC_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				   <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is out of range for type double precision"</literal></expr></argument>,
						  <argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type complex: \"%s\""</literal></expr></argument>,
					<argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_BUGGY_SOLARIS_STRTOD</name></cpp:ifdef>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Many versions of Solaris have a bug wherein strtod sets endptr to
		 * point one byte beyond the end of the string when given "inf" or
		 * "infinity".
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>endptr</name> <operator>!=</operator> <name>num</name> <operator>&amp;&amp;</operator> <name><name>endptr</name><index>[<expr><operator>-</operator><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>endptr</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>   <comment type="block">/* HAVE_BUGGY_SOLARIS_STRTOD */</comment>

	<comment type="block" format="doxygen">/*** end of float8in ***/</comment>

	<comment type="block">/*
	 * Instead of checking for garbage at end of the string, return pointer
	 * to where we stopped.
	 */</comment>

	<expr_stmt><expr><operator>*</operator><name>num_p</name> <operator>=</operator> <name>endptr</name></expr>;</expr_stmt>
	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	complex_in	- converts "num" to complex
 *				  restricted syntax are:
 *				  {&lt;sp&gt;} [+|-] {digit} [.{digit}] [&lt;exp&gt;] {&lt;sp&gt;} [+|-] {&lt;sp&gt;} {digit} [.{digit}] [&lt;exp&gt;]i
 *				  or
 *				  {&lt;sp&gt;} [+|-] {digit} [.{digit}] [&lt;exp&gt;]
 *				  or
 *				  {&lt;sp&gt;} [+|-] {digit} [.{digit}] [&lt;exp&gt;]i
 *				  where &lt;sp&gt; is a space, digit is 0-9,
 *				  &lt;exp&gt; is "e" or "E" followed by an integer.
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>num</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>re</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>im</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>im_sign</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>orig_num</name> <init>= <expr><name>num</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>comp</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>==</operator> <operator>*</operator><name>num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type complex: \"%s\""</literal></expr></argument>, <argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>complex_decode_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* first part is the imaginary part, so there is only imaginary */</comment>
	<if_stmt><if>if <condition>(<expr><literal type="char">'i'</literal> <operator>==</operator> <operator>*</operator><name>num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>im</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<comment type="block">/* first part is the real part */</comment>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>re</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>
		<comment type="block">/* skip spaces after the real part */</comment>
		<while>while <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <operator>*</operator><name>num</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
		<comment type="block">/* there is the imaginary part */</comment>
		<if_stmt><if>if <condition>(<expr><literal type="char">'-'</literal> <operator>==</operator> <operator>*</operator><name>num</name> <operator>||</operator> <literal type="char">'+'</literal> <operator>==</operator> <operator>*</operator><name>num</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><literal type="char">'-'</literal> <operator>==</operator> <operator>*</operator><name>num</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>im_sign</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * skip whitespaces after the plus/minus operator between the real part
			 * and the imaginary part
			 */</comment>
			<while>while <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <operator>*</operator><name>num</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
			<comment type="block">/* get the imaginary part */</comment>
			<expr_stmt><expr><name>im</name> <operator>=</operator> <call><name>complex_decode_double</name><argument_list>(<argument><expr><operator>&amp;</operator><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><literal type="char">'i'</literal> <operator>==</operator> <operator>*</operator><name>num</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* store the sign of the imaginary with the imaginary part */</comment>
				<expr_stmt><expr><name>im</name> <operator>=</operator> <name>im</name> <operator>*</operator> <name>im_sign</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type complex: \"%s\""</literal></expr></argument>, <argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* skip trailing whitespaces */</comment>
	<while>while <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <operator>*</operator><name>num</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>*</operator><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>num</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<if_stmt><if>if <condition>(<expr><literal type="char">'\0'</literal> <operator>!=</operator> <operator>*</operator><name>num</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						<call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type complex: \"%s\""</literal></expr></argument>, <argument><expr><name>orig_num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>comp</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* max size of the representation of a complex number */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAXCOMPLEXWIDTH</name></cpp:macro> <cpp:value>320</cpp:value></cpp:define>
<comment type="block">/*
 * outputs the real/imag part of a complex number
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>complex_part_out</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>p</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>limit</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>part</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><call><name>is_infinite</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>limit</name> <operator>-</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"Infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><operator>-</operator><literal type="number">1</literal></expr>:</case>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>limit</name> <operator>-</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"-Infinity"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>limit</name> <operator>-</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>	<name>ndig</name> <init>= <expr><name>DBL_DIG</name> <operator>+</operator> <name>extra_float_digits</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>ndig</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>ndig</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<expr_stmt><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><name>limit</name> <operator>-</operator> <operator>(</operator><operator>*</operator><name>p</name><operator>)</operator></expr></argument>, <argument><expr><literal type="string">"%.*g"</literal></expr></argument>, <argument><expr><name>ndig</name></expr></argument>, <argument><expr><name>part</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * complex_out		- converts complex number to a string
 *					  with format x +/- yi
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>num</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ascii</name> <init>= <expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXCOMPLEXWIDTH</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>limit</name> <init>= <expr><name>ascii</name> <operator>+</operator> <name>MAXCOMPLEXWIDTH</name> <operator>+</operator> <literal type="number">1</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name>ascii</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>complex_part_out</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><call><name>re</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>p</name> <operator>+=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>limit</name> <operator>-</operator> <name>p</name></expr></argument>, <argument><expr><literal type="string">" %c "</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><call><name>im</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>isnan</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	
	<comment type="block">/*
	 * Complex numbers with 0 imaginary part have different meaning whether the imaginary part
	 * is -0 or 0. E.x. sqrt(-1 + 0i) = 0 + 1i V.S. sqrt(-1 - 0i) = 0 - 1i. So we must output
	 * the sign of the imaginary part if it equals 0.
	 */</comment>
	<expr_stmt><expr><call><name>complex_part_out</name><argument_list>(<argument><expr><operator>&amp;</operator><name>p</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><call><name>im</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><call><name>fabs</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>: <expr><call><name>im</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>p</name></expr></argument>, <argument><expr><name>limit</name> <operator>-</operator> <name>p</name></expr></argument>, <argument><expr><literal type="string">"%c"</literal></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name>ascii</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_recv			- converts external binary format to complex
 *
 *		We represent a complex number by two double numbers
 *		(one for the real part, the other one for the imaginary part).
 *		This rule is not perfect but it gives us portability across
 *		most IEEE-float-using architectures.
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>num</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>real</name> <init>= <expr><call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>imag</name> <init>= <expr><call><name>pq_getmsgfloat8</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>real</name></expr></argument>, <argument><expr><name>imag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_send			- converts complex to binary format
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>num</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>re</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendfloat8</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>im</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>Complex</name> <modifier>*</modifier></type>
<name>construct_complex_in</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>re</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>im</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>num</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>re</name></expr></argument>, <argument><expr><name>im</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		construct_complex		- construct a complex number with two double,
 *								  returns arg1 + arg2i
 */</comment>
<function><type><name>Datum</name></type>
<name>construct_complex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>re</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>im</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><call><name>construct_complex_in</name><argument_list>(<argument><expr><name>re</name></expr></argument>, <argument><expr><name>im</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		construct_complex_trig	- returns arg1*cos(arg2) + arg1*sin(arg2)i
 */</comment>
<function><type><specifier>extern</specifier> <name>Datum</name></type>
<name>construct_complex_trig</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>mag</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>arg</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>construct_complex_in</name><argument_list>(<argument><expr><name>mag</name> <operator>*</operator> <call><name>dp_cos</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>mag</name> <operator>*</operator> <call><name>dp_sin</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>mag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>mag</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_re				- get the real part of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_re</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>num</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_im				- get the imaginary part of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_im</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>num</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_arg				- returns the phase of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_arg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>comp</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt><empty_stmt>;</empty_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>dp_atan2</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>re</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_mag				- returns magnitude of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_mag</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>comp</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>hypot</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>im</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><literal type="number">0</literal> <operator>==</operator> <call><name>re</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>im</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_conj			- return conjunction of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_conj</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>comp</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>re</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><name>comp</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_hash			- return hash value of arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_hash</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>

	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>num</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<struct>struct
	<block>{
		<decl_stmt><decl><type><name>double</name></type>		<name>x</name></decl>,
					<decl><type ref="prev"/><name>y</name></decl>;</decl_stmt>
	}</block>			<decl><name>key</name></decl>;</struct>

	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>x</name></name> <operator>=</operator> <call><name>re</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>y</name></name> <operator>=</operator> <call><name>im</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * On IEEE-float machines, minus zero and zero have different bit patterns
	 * but should compare as equal.  We must ensure that they have the same
	 * hash value, which is most easily done this way:
	 */</comment>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>key</name><operator>.</operator><name>x</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <name><name>key</name><operator>.</operator><name>y</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>key</name><operator>.</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><name>float8</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>hash_any</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>key</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int</name></type>
<name>complex_abs_cmp_internal</name><parameter_list>(<parameter><decl><type><name>Complex</name> <modifier>*</modifier></type><name>a</name></decl></parameter>, <parameter><decl><type><name>Complex</name> <modifier>*</modifier></type><name>b</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type> <name>a_x</name> <init>= <expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>a_y</name> <init>= <expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>b_x</name> <init>= <expr><call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type> <name>b_y</name> <init>= <expr><call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	
	
	<comment type="block">/* We can only define a partial order when comparing complex numbers so
	 * we compare real parts first and if they are equal, we compare imaginary
	 * parts
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>a_x</name> <operator>&gt;</operator> <name>b_x</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>a_x</name> <operator>==</operator> <name>b_x</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>a_y</name> <operator>&gt;</operator> <name>b_y</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>a_y</name> <operator>&lt;</operator> <name>b_y</name></expr>)</condition>
		<block>{<block_content>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>a_x</name> <operator>&lt;</operator> <name>b_x</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
	</block_content>}</block></if></if_stmt>
	
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>
	
<comment type="block">/*
 *		complex_lt				- checks whether arg1 is less than arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_lt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>complex_abs_cmp_internal</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_gt				- checks whether arg1 is greater than arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_gt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>complex_abs_cmp_internal</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_lte				- checks whether arg1 is less than or equal to arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_lte</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>complex_abs_cmp_internal</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_gte				- checks whether arg1 is greater than or equal to arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_gte</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>complex_abs_cmp_internal</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_eq				- checks whether arg1 equals arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_eq</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>complex_abs_cmp_internal</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_ne				- checks whether arg1 not equals arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_ne</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>complex_abs_cmp_internal</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>complex_cmp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>	<modifier>*</modifier></type><name>num1</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>	<modifier>*</modifier></type><name>num2</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>complex_abs_cmp_internal</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><name>num2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_FREE_IF_COPY</name><argument_list>(<argument><expr><name>num2</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT32</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_pl				- returns arg1 + arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_pl</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_mi				- returns arg1 - arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_mi</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_mul				- returns arg1 * arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_mul</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,
				<argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_div				- returns arg1/arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_div</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>div</name> <init>= <expr><call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>x</name></name> <operator>=</operator> <operator>(</operator><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name>div</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>c</name><operator>-&gt;</operator><name>y</name></name> <operator>=</operator> <operator>(</operator><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <name>div</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
				  <operator>||</operator> <operator>(</operator><literal type="number">0</literal> <operator>==</operator> <call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr></argument>,
				  <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
				  <operator>||</operator> <operator>(</operator><literal type="number">0</literal> <operator>==</operator> <call><name>re</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>im</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>,
				  <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_up				- returns +arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_up</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <operator>*</operator><name>a</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_um				- returns -arg1
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_um</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><operator>-</operator><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>-</operator><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* return x^k */</comment>
<function><type><specifier>static</specifier> <name>Complex</name></type>
<name>pg_cpow_n</name><parameter_list>(<parameter><decl><type><name>Complex</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>k</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name></type>		<name>res</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><operator>&amp;</operator><name>res</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>res</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>x</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>k</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Complex</name></type>		<name>one</name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Complex</name></type>		<name>pow_mi_n</name> <init>= <expr><call><name>pg_cpow_n</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><operator>-</operator><name>k</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<return>return <expr><operator>*</operator><call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>complex_div</name></expr></argument>,
					   <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>one</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>pow_mi_n</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>							<comment type="block">/* k &gt; 0 */</comment>
		<decl_stmt><decl><type><name>Complex</name></type>		<name>z</name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>re_x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>re_z</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 *	Euclidean method to calculate power.
		 *	Target: calculating r = a^c, where c is an integer.
		 *	
		 *	Initial: z = 1, x = a, k = c, r = z*x^k
		 *	Loop invariant: r = z*x^k
		 *			 x is the base
		 *			 k is the power
		 *			 z is the remaining which makes the loop invariant valid
		 *	End condition: k == 0, r = z*x^0, so r = z
		 *
		 *	while k &gt; 1:
		 *		if k is odd:
					/// z*x^k = (z*x)*x^(k-1), the following two steps keep loop invariant
		 *			k = k - 1		/// make the power k even, then r = z*x*x^k
		 *			z = z * x		/// to keep loop invariant, combining z and x
		 *		if k == 0:			/// this step don't make any changing, so the loop invariant was kept
		 *			break
		 *		/// now k is even and bigger than 0, so x^k = (x*x)^(k/2),
		 *		/// the following two steps keep loop invariant
		 *		k = k/2
		 *		x = x*x
		 *	endwhile
		 *	r = z
		 */</comment>	
		<while>while <condition>(<expr><name>k</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>re_x</name> <operator>=</operator> <call><name>re</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>re_z</name> <operator>=</operator> <call><name>re</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>k</name> <operator>&amp;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Let z = z*x; */</comment>
				<block>{<block_content>
					<expr_stmt><expr><name><name>z</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>re_z</name> <operator>*</operator> <name>re_x</name> <operator>-</operator> <call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>z</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>re_z</name> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>re_x</name></expr>;</expr_stmt>
				</block_content>}</block>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>k</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>k</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>			<comment type="block">/* efficient division by 2; now have k &gt;= 1 */</comment>

			<comment type="block">/* Let x = x*x; */</comment>
			<block>{<block_content>
				<expr_stmt><expr><name><name>x</name><operator>.</operator><name>x</name></name> <operator>=</operator> <name>re_x</name> <operator>*</operator> <name>re_x</name> <operator>-</operator> <call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>x</name><operator>.</operator><name>y</name></name> <operator>=</operator> <name>re_x</name> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call> <operator>*</operator> <name>re_x</name></expr>;</expr_stmt>
			</block_content>}</block>
		</block_content>}</block></while>

		<comment type="block">/*
		 * According to pg_cpow, x should not be zero, but the result can be
		 * zero. Let x = r(cos(a) + sin(a)*i) where a is the phase of x, then
		 * x^k equals (r^k)(cos(k*a) + sin(k*a)*i). If k*a = 2*m*pi + pi,
		 * or k*a = 2*m*pi + pi, or k*a = 2*m*pi + pi/2, or k*a = 2*m*pi + 3*pi/2,
		 * we will get a result with 0 real part or with 0 imaginary part.
		 */</comment>
		<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>z</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* reason for this:
 * 1) x^n  (e.g. for n = +/- 2, 3) is unnecessarily inaccurate in glibc;
 *	  cut-off 65536 : guided from empirical speed measurements
 *
 * 2) On Mingw (but not Mingw-w64) the system cpow is explicitly linked
 *	  against the (slow) MSVCRT pow, and gets (0+0i)^y as 0+0i for all y.
 *
 * 3) PPC Mac OS x crashes on powers of 0+0i (at least under Rosetta).
 *	  Really 0i^-1 should by Inf+NaNi, but getting that portably seems too hard.
 *	  (C1x's CMPLX will eventually be possible.)
 */</comment>

<function><type><specifier>static</specifier> <name>Complex</name></type>
<name>pg_cpow</name><parameter_list>(<parameter><decl><type><name>Complex</name></type> <name>x</name></decl></parameter>, <parameter><decl><type><name>Complex</name></type> <name>y</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name></type>		<name>z</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>yr</name> <init>= <expr><call><name>re</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>yi</name> <init>= <expr><call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>y</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>re</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <call><name>im</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>yi</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><call><name>dp_pow</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>, <argument><expr><name>yr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><name>yi</name> <operator>==</operator> <literal type="number">0.0</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>yr</name> <operator>==</operator> <operator>(</operator><name>k</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <name>yr</name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><call><name>abs</name><argument_list>(<argument><expr><name>k</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">65536</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>z</name> <operator>=</operator> <call><name>pg_cpow_n</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>k</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* We must check overflow each step, so we can't use cpow directly */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>rho</name></decl>,
					<decl><type ref="prev"/><name>r</name></decl>,
					<decl><type ref="prev"/><name>i</name></decl>,
					<decl><type ref="prev"/><name>theta</name></decl>,
					<decl><type ref="prev"/><name>a</name></decl>,
					<decl><type ref="prev"/><name>b</name></decl>;</decl_stmt>

		<comment type="block">/* Let r = hypot(re(&amp;x), im(&amp;x)); */</comment>
		<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_mag</name></expr></argument>, <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Let i = atan2(im(&amp;x), re(&amp;x)); */</comment>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_arg</name></expr></argument>, <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Let theta = i * yr; */</comment>
		<expr_stmt><expr><name>theta</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>yr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>yi</name> <operator>==</operator> <literal type="number">0.0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Let rho = pow(r, yr); */</comment>
			<expr_stmt><expr><name>rho</name> <operator>=</operator> <call><name>dp_pow</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>yr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* rearrangement of cexp(x * clog(y)) */</comment>
			<comment type="block">/* Let r = log(r); */</comment>
			<expr_stmt><expr><name>r</name> <operator>=</operator> <call><name>dp_log1</name><argument_list>(<argument><expr><name>r</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Let a = r * yi; */</comment>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>yi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Let theta += a; */</comment>
			<expr_stmt><expr><name>theta</name> <operator>=</operator> <call><name>dp_pl</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* Let a = r * yr; */</comment>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>r</name></expr></argument>, <argument><expr><name>yr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Let b = i * yi; */</comment>
			<expr_stmt><expr><name>b</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>i</name></expr></argument>, <argument><expr><name>yi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Let a = a - b; */</comment>
			<expr_stmt><expr><name>a</name> <operator>=</operator> <call><name>dp_mi</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Let rho = exp(a); i.e. exp(r*yr - i*yi) */</comment>
			<expr_stmt><expr><name>rho</name> <operator>=</operator> <call><name>dp_exp</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><operator>&amp;</operator><name>z</name></expr></argument>, <argument><expr><call><name>dp_mul</name><argument_list>(<argument><expr><name>rho</name></expr></argument>, <argument><expr><call><name>dp_cos</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dp_mul</name><argument_list>(<argument><expr><name>rho</name></expr></argument>, <argument><expr><call><name>dp_sin</name><argument_list>(<argument><expr><name>theta</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<return>return <expr><name>z</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_pow				- return arg1^arg2
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_pow</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>b</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* We must check overflow each step, so we can't use cpow directly */</comment>
	<expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <call><name>pg_cpow</name><argument_list>(<argument><expr><operator>*</operator><name>a</name></expr></argument>, <argument><expr><operator>*</operator><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_sqrt			- returns sqrt(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_sqrt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name></type>		<name>b</name> <init>= <expr><block>{<expr><literal type="number">0.5</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <call><name>pg_cpow</name><argument_list>(<argument><expr><operator>*</operator><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_cbrt			- returns cbrt(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_cbrt</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name></type>		<name>b</name> <init>= <expr><block>{<expr><literal type="number">1.0</literal> <operator>/</operator> <literal type="number">3</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>c</name> <operator>=</operator> <call><name>pg_cpow</name><argument_list>(<argument><expr><operator>*</operator><name>a</name></expr></argument>, <argument><expr><name>b</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_degrees			- returns degrees(arg(arg1))
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_degrees</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>arg_a</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>arg_a</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_arg</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>arg_a</name> <operator>*</operator> <operator>(</operator><literal type="number">180.0</literal> <operator>/</operator> <name>M_PI</name><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>arg_a</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>arg_a</name> <operator>==</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_exp				- returns exp(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_exp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>exp_ar</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ai</name> <init>= <expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>cr</name></decl>,
				<decl><type ref="prev"/><name>ci</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>exp_ar</name> <operator>=</operator> <call><name>dp_exp</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>exp_ar</name></expr></argument>, <argument><expr><call><name>dp_cos</name><argument_list>(<argument><expr><name>ai</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>exp_ar</name></expr></argument>, <argument><expr><call><name>dp_sin</name><argument_list>(<argument><expr><name>ai</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_ln				- returns ln(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_ln</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>mag</name></decl>,
				<decl><type ref="prev"/><name>ci</name></decl>,
				<decl><type ref="prev"/><name>cr</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">0</literal> <operator>==</operator> <call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>cr</name> <operator>=</operator> <operator>-</operator><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ci</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>mag</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_mag</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_arg</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>dp_log1</name><argument_list>(<argument><expr><name>mag</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_log10			- returns log10(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_log10</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>ln_a</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name></type>		<name>ln_10</name> <init>= <expr><block>{<expr><call><name>log</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>ln_a</name> <operator>=</operator> <call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_ln</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>complex_div</name></expr></argument>, <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><name>ln_a</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ln_10</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_log				- returns log(arg1, arg2), where arg1 is the base
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_log</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ln_a</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>ln_b</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ln_a</name> <operator>=</operator> <call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_ln</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ln_b</name> <operator>=</operator> <call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_ln</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>complex_div</name></expr></argument>, <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><name>ln_b</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><name>ln_a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_acos			- returns acos(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_acos</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>asin_a</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name></type>		<name>C_M_PI_2</name> <init>= <expr><block>{<expr><name>M_PI_2</name></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>asin_a</name> <operator>=</operator> <call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_asin</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>complex_mi</name></expr></argument>, <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>C_M_PI_2</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><name>asin_a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_asin			- returns asin(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_asin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ar</name> <init>= <expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ai</name> <init>= <expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>cr</name></decl>,
				<decl><type ref="prev"/><name>ci</name></decl>,
				<decl><type ref="prev"/><name>alpha</name></decl>,
				<decl><type ref="prev"/><name>t1</name></decl>,
				<decl><type ref="prev"/><name>t2</name></decl>,
				<decl><type ref="prev"/><name>tmp</name></decl>;</decl_stmt>

	<comment type="block">/* Let t1 = 0.5*hypot(ar+1, ai); */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dp_pl</name><argument_list>(<argument><expr><name>ar</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>hypot</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>ai</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>ai</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>==</operator> <name>tmp</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <name>ai</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let t2 = 0.5*hypot(ar-1, ai) */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dp_mi</name><argument_list>(<argument><expr><name>ar</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>hypot</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>ai</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><call><name>isinf</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>ai</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal> <operator>==</operator> <name>tmp</name> <operator>&amp;&amp;</operator> <literal type="number">0</literal> <operator>==</operator> <name>ai</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>t2</name></expr></argument>, <argument><expr><literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let alpha = t1 + t2; */</comment>
	<expr_stmt><expr><name>alpha</name> <operator>=</operator> <call><name>dp_pl</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let tmp = alpha + sqrt(alpha*alpha -1); */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>alpha</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dp_mi</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dp_pow</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dp_pl</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>, <argument><expr><name>alpha</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let ci = log(tmp); */</comment>
	<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>dp_log1</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * This comes from 'z_asin() is continuous from below if x &gt;= 1 and
	 * continuous from above if x &lt;= -1.'
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ai</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>ai</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>ar</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ci</name> <operator>*=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Let cr = asin(t1 - t2); */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dp_mi</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>dp_asin</name><argument_list>(<argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_atan			- returns atan(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_atan</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ar</name></decl>,
				<decl><type ref="prev"/><name>square_ar</name></decl>,
				<decl><type ref="prev"/><name>ai</name></decl>,
				<decl><type ref="prev"/><name>square_ai</name></decl>,
				<decl><type ref="prev"/><name>cr</name></decl>,
				<decl><type ref="prev"/><name>ci</name></decl>,
				<decl><type ref="prev"/><name>tmp</name></decl>,
				<decl><type ref="prev"/><name>t1</name></decl>,
				<decl><type ref="prev"/><name>t2</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ar</name> <operator>=</operator> <call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ai</name> <operator>=</operator> <call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>square_ar</name> <operator>=</operator> <call><name>dp_pow</name><argument_list>(<argument><expr><name>ar</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>square_ai</name> <operator>=</operator> <call><name>dp_pow</name><argument_list>(<argument><expr><name>ai</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let cr = 0.5*atan2(2*ar, (1 - ar*ar - ai*ai)); */</comment>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>dp_pl</name><argument_list>(<argument><expr><name>square_ai</name></expr></argument>, <argument><expr><name>square_ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dp_mi</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>t1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>ar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>dp_atan2</name><argument_list>(<argument><expr><name>cr</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>cr</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>cr</name></expr></argument>, <argument><expr><literal type="number">0.5</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Let ci = 0.25*log((ar*ar + ai*ai + 2*ai + 1)/(ar*ar + ai*ai - 2*ai + 1)); */</comment>
	<comment type="block">/* Let t1 = ar*ar + ai*ai + 1; */</comment>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>dp_pl</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Let tmp = 2*ai; */</comment>
	<expr_stmt><expr><name>tmp</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>ai</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Let t2 =  (ar*ar + ai*ai - 2*ai + 1); */</comment>
	<expr_stmt><expr><name>t2</name> <operator>=</operator> <call><name>dp_mi</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Let t1 =  (ar*ar + ai*ai + 2*ai + 1); */</comment>
	<expr_stmt><expr><name>t1</name> <operator>=</operator> <call><name>dp_pl</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>tmp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* Let t2 = t1/t2; */</comment>
	<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>dp_div</name><argument_list>(<argument><expr><name>t1</name></expr></argument>, <argument><expr><name>t2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>dp_log1</name><argument_list>(<argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><name>ci</name></expr></argument>, <argument><expr><literal type="number">0.25</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><name>cr</name></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_cos				- returns cos(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_cos</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>dp_mul</name><argument_list>(<argument><expr><call><name>dp_cos</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dp_cosh</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><operator>-</operator><call><name>dp_mul</name><argument_list>(<argument><expr><call><name>dp_sin</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dp_sinh</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_cot				- returns cot(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_cot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name></type>		<name>one</name> <init>= <expr><block>{<expr><literal type="number">1</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>tan_a</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>tan_a</name> <operator>=</operator> <call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>complex_tan</name></expr></argument>, <argument><expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>c</name> <operator>=</operator> <call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>complex_div</name></expr></argument>, <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>one</name></expr></argument>)</argument_list></call></expr></argument>,
											 <argument><expr><call><name>ComplexPGetDatum</name><argument_list>(<argument><expr><name>tan_a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_sin				- returns sin(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_sin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>dp_mul</name><argument_list>(<argument><expr><call><name>dp_sin</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dp_cosh</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>,
				 <argument><expr><call><name>dp_mul</name><argument_list>(<argument><expr><call><name>dp_cos</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dp_sinh</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_tan				- returns tan(arg1)
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_tan</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>a</name> <init>= <expr><call><name>PG_GETARG_COMPLEX_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>c</name> <init>= <expr><operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>double</name></type>		<name>x2</name></decl>,
				<decl><type ref="prev"/><name>y2</name></decl>,
				<decl><type ref="prev"/><name>den</name></decl>,
				<decl><type ref="prev"/><name>ci</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>x2</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><literal type="number">2.0</literal></expr></argument>, <argument><expr><call><name>re</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>y2</name> <operator>=</operator> <call><name>dp_mul</name><argument_list>(<argument><expr><literal type="number">2.0</literal></expr></argument>, <argument><expr><call><name>im</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>den</name> <operator>=</operator> <call><name>dp_pl</name><argument_list>(<argument><expr><call><name>dp_cos</name><argument_list>(<argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>dp_cosh</name><argument_list>(<argument><expr><name>y2</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<comment type="block">/* any threshold between -log(DBL_EPSILON) and log(DBL_XMAX) will do */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>y2</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>fabs</name><argument_list>(<argument><expr><name>y2</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">50.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>ci</name> <operator>=</operator> <call><name>dp_div</name><argument_list>(<argument><expr><call><name>dp_sinh</name><argument_list>(<argument><expr><name>y2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>den</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>ci</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>y2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1.0</literal></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>c</name></expr></argument>, <argument><expr><call><name>dp_div</name><argument_list>(<argument><expr><call><name>dp_sin</name><argument_list>(<argument><expr><name>x2</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>den</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>ci</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>c</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float2complex			- returns complex(arg1, 0)
 *
 *		Note: expression -4::COMPLEX will get -4 - 0i, not -4 + 0i,
 *		because operator :: has higher precedence than unary minus.
 *		So sqrt(-4::complex) will get 0 - 2i, and sqrt(complex(-4,0))
 *		will get 0 + 2i.
 */</comment>
<function><type><name>Datum</name></type>
<name>float82complex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>a</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><call><name>construct_complex_in</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>float42complex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>a</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><call><name>construct_complex_in</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		float2complex			- returns complex(arg1, 0)
 */</comment>
<function><type><name>Datum</name></type>
<name>int82complex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int8</name></type>		<name>a</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><call><name>construct_complex_in</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int42complex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>a</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><call><name>construct_complex_in</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>int22complex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>a</name> <init>= <expr><call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><call><name>construct_complex_in</name><argument_list>(<argument><expr><name>a</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>numeric2complex</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>num</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>float_num</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>numeric_is_nan</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>float_num</name> <operator>=</operator> <call><name>get_float8_nan</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>float_num</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8</name></expr></argument>, <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><call><name>construct_complex_in</name><argument_list>(<argument><expr><name>float_num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		complex_dot_product		- returns dot product of two 1-dim array with the same size
 */</comment>
<function><type><name>Datum</name></type>
<name>complex_dot_product</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>la</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>lnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>ra</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>rnull</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>num</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>inf_valid</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>(</operator><name>Complex</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>la</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ra</name> <operator>=</operator> <call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><literal type="number">1</literal> <operator>!=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call> <operator>||</operator> <literal type="number">1</literal> <operator>!=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot dot product two multi-dimentsion arrays"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The dimension of the left argument is %d, the dimension of the right argument is %d."</literal></expr></argument>,
						   <argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index> <operator>!=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATATYPE_MISMATCH</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot dot product two 1-dim arrays with different number of elements"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			  <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The number of elements of the left argument is %d, "</literal>
						<literal type="string">"the number of elements of the right argument is %d."</literal></expr></argument>,
						<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>,
						<argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>ra</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>


	<expr_stmt><expr><call><name>INIT_COMPLEX</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>la</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>indx</name> <init>= <expr><name>i</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>lc</name> <init>= <expr><call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>array_ref</name><argument_list>(<argument><expr><name>la</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>lnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Complex</name>    <modifier>*</modifier></type><name>rc</name> <init>= <expr><call><name>DatumGetComplexP</name><argument_list>(<argument><expr><call><name>array_ref</name><argument_list>(<argument><expr><name>ra</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>indx</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
									   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>Complex</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'d'</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rnull</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>lnull</name> <operator>||</operator> <name>rnull</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>mul_re</name> <init>= <expr><call><name>re</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>re</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>im</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>mul_im</name> <init>= <expr><call><name>re</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>im</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>im</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call> <operator>*</operator> <call><name>re</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>inf_valid</name> <operator>=</operator> <operator>(</operator><name>inf_valid</name>
						 <operator>||</operator> <operator>(</operator><call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>rc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>x</name></name> <operator>+=</operator> <name>mul_re</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>y</name></name> <operator>+=</operator> <name>mul_im</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>lnull</name> <operator>||</operator> <name>rnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>re</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inf_valid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CHECKFLOATVAL</name><argument_list>(<argument><expr><call><name>im</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>inf_valid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_COMPLEX_P</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>
</unit>
