<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/json.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * json.c
 *		JSON data type support.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/json.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/array.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/json.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/jsonapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>

<comment type="block">/*
 * The context of the parser is maintained by the recursive descent
 * mechanism, but is passed explicitly to the error reporting routine
 * for better diagnostics.
 */</comment>
<typedef>typedef <type><enum>enum					<comment type="block">/* contexts of JSON parser */</comment>
<block>{
	<decl><name>JSON_PARSE_VALUE</name></decl>,			<comment type="block">/* expecting a value */</comment>
	<decl><name>JSON_PARSE_STRING</name></decl>,			<comment type="block">/* expecting a string (for a field name) */</comment>
	<decl><name>JSON_PARSE_ARRAY_START</name></decl>,		<comment type="block">/* saw '[', expecting value or ']' */</comment>
	<decl><name>JSON_PARSE_ARRAY_NEXT</name></decl>,		<comment type="block">/* saw array element, expecting ',' or ']' */</comment>
	<decl><name>JSON_PARSE_OBJECT_START</name></decl>,	<comment type="block">/* saw '{', expecting label or '}' */</comment>
	<decl><name>JSON_PARSE_OBJECT_LABEL</name></decl>,	<comment type="block">/* saw object label, expecting ':' */</comment>
	<decl><name>JSON_PARSE_OBJECT_NEXT</name></decl>,		<comment type="block">/* saw object value, expecting ',' or '}' */</comment>
	<decl><name>JSON_PARSE_OBJECT_COMMA</name></decl>,	<comment type="block">/* saw object ',', expecting next label */</comment>
	<decl><name>JSON_PARSE_END</name></decl>				<comment type="block">/* saw the end of a document, expect nothing */</comment>
}</block></enum></type> <name>JsonParseContext</name>;</typedef>

<typedef>typedef <type><enum>enum					<comment type="block">/* type categories for datum_to_json */</comment>
<block>{
	<decl><name>JSONTYPE_NULL</name></decl>,				<comment type="block">/* null, so we didn't bother to identify */</comment>
	<decl><name>JSONTYPE_BOOL</name></decl>,				<comment type="block">/* boolean (built-in types only) */</comment>
	<decl><name>JSONTYPE_NUMERIC</name></decl>,			<comment type="block">/* numeric (ditto) */</comment>
	<decl><name>JSONTYPE_DATE</name></decl>,				<comment type="block">/* we use special formatting for datetimes */</comment>
	<decl><name>JSONTYPE_TIMESTAMP</name></decl>,
	<decl><name>JSONTYPE_TIMESTAMPTZ</name></decl>,
	<decl><name>JSONTYPE_JSON</name></decl>,				<comment type="block">/* JSON itself (and JSONB) */</comment>
	<decl><name>JSONTYPE_ARRAY</name></decl>,				<comment type="block">/* array */</comment>
	<decl><name>JSONTYPE_COMPOSITE</name></decl>,			<comment type="block">/* composite */</comment>
	<decl><name>JSONTYPE_CAST</name></decl>,				<comment type="block">/* something with an explicit cast to JSON */</comment>
	<decl><name>JSONTYPE_OTHER</name></decl>				<comment type="block">/* all else */</comment>
}</block></enum></type> <name>JsonTypeCategory</name>;</typedef>

<typedef>typedef <type><struct>struct <name>JsonAggState</name>
<block>{
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTypeCategory</name></type> <name>key_category</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>key_output_func</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTypeCategory</name></type> <name>val_category</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>val_output_func</name></decl>;</decl_stmt>
}</block></struct></type> <name>JsonAggState</name>;</typedef>

<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>json_lex</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>json_lex_string</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>json_lex_number</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>num_err</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>total_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type> <name>parse_scalar</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_object_field</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_object</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_array_element</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_array</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_parse_error</name><parameter_list>(<parameter><decl><type><name>JsonParseContext</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>report_invalid_token</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>report_json_context</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>extract_mb_char</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>composite_to_json</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>composite</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>use_line_feeds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>array_dim_to_json</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dim</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>,
							  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valcount</name></decl></parameter>,
							  <parameter><decl><type><name>JsonTypeCategory</name></type> <name>tcategory</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>use_line_feeds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>array_to_json_internal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>,
								   <parameter><decl><type><name>bool</name></type> <name>use_line_feeds</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>json_categorize_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>,
								 <parameter><decl><type><name>JsonTypeCategory</name> <modifier>*</modifier></type><name>tcategory</name></decl></parameter>,
								 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>outfuncoid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>datum_to_json</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>,
						  <parameter><decl><type><name>JsonTypeCategory</name></type> <name>tcategory</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name></type> <name>key_scalar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>add_json</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name></type> <name>val_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>key_scalar</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type><name>catenate_stringinfo_string</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>addon</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/* the null action object used for pure validation */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>JsonSemAction</name></type> <name>nullSemAction</name> <init>=
<expr><block>{
	<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>,
	<expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* Recursive Descent parser support routines */</comment>

<comment type="block">/*
 * lex_peek
 *
 * what is the current look_ahead token?
*/</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>JsonTokenType</name></type>
<name>lex_peek</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lex_accept
 *
 * accept the look_ahead token and move the lexer to the next token if the
 * look_ahead token matches the token parameter. In that case, and if required,
 * also hand back the de-escaped lexeme.
 *
 * returns true if the token matched, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>bool</name></type>
<name>lex_accept</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>token</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>lexeme</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>token</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>lexeme</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_STRING</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>lexeme</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name><operator>-&gt;</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><operator>(</operator><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tokstr</name> <init>= <expr><call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>tokstr</name></expr></argument>, <argument><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tokstr</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name>lexeme</name> <operator>=</operator> <name>tokstr</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>json_lex</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * lex_accept
 *
 * move the lexer to the next token if the current look_ahead token matches
 * the parameter token. Otherwise, report an error.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>lex_expect</name><parameter_list>(<parameter><decl><type><name>JsonParseContext</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonTokenType</name></type> <name>token</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>token</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_parse_error</name><argument_list>(<argument><expr><name>ctx</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* chars to consider as part of an alphanumeric token */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>JSON_ALPHANUMERIC_CHAR</name><parameter_list>(<parameter><type><name>c</name></type></parameter>)</parameter_list></cpp:macro>  \
	<cpp:value>(((c) &gt;= 'a' &amp;&amp; (c) &lt;= 'z') || \
	 ((c) &gt;= 'A' &amp;&amp; (c) &lt;= 'Z') || \
	 ((c) &gt;= '0' &amp;&amp; (c) &lt;= '9') || \
	 (c) == '_' || \
	 IS_HIGHBIT_SET(c))</cpp:value></cpp:define>

<comment type="block">/*
 * Utility function to check if a string is a valid JSON number.
 *
 * str is of length len, and need not be null-terminated.
 */</comment>
<function><type><name>bool</name></type>
<name>IsValidJsonNumber</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>numeric_error</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>total_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonLexContext</name></type> <name>dummy_lex</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * json_lex_number expects a leading  '-' to have been eaten already.
	 *
	 * having to cast away the constness of str is ugly, but there's not much
	 * easy alternative.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>dummy_lex</name><operator>.</operator><name>input</name></name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummy_lex</name><operator>.</operator><name>input_length</name></name> <operator>=</operator> <name>len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>dummy_lex</name><operator>.</operator><name>input</name></name> <operator>=</operator> <call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummy_lex</name><operator>.</operator><name>input_length</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>json_lex_number</name><argument_list>(<argument><expr><operator>&amp;</operator><name>dummy_lex</name></expr></argument>, <argument><expr><name><name>dummy_lex</name><operator>.</operator><name>input</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numeric_error</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>total_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><operator>!</operator><name>numeric_error</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><name>total_len</name> <operator>==</operator> <name><name>dummy_lex</name><operator>.</operator><name>input_length</name></name><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Input.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>json</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>

	<comment type="block">/* validate it */</comment>
	<expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nullSemAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Internal representation is the same as text, for now */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Output.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* we needn't detoast because text_to_cstring will handle that */</comment>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>txt</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>txt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Binary send.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>t</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendtext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>t</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Binary receive.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nbytes</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>pq_getmsgtext</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name> <operator>-</operator> <name><name>buf</name><operator>-&gt;</operator><name>cursor</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Validate it. */</comment>
	<expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>makeJsonLexContextCstringLen</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pg_parse_json</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nullSemAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * makeJsonLexContext
 *
 * lex constructor, with or without StringInfo object
 * for de-escaped lexemes.
 *
 * Without is better as it makes the processing faster, so only make one
 * if really required.
 *
 * If you already have the json as a text* value, use the first of these
 * functions, otherwise use  makeJsonLexContextCstringLen().
 */</comment>
<function><type><name>JsonLexContext</name> <modifier>*</modifier></type>
<name>makeJsonLexContext</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_escapes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>makeJsonLexContextCstringLen</name><argument_list>(<argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>json</name></expr></argument>)</argument_list></call></expr></argument>,
										<argument><expr><name>need_escapes</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><name>JsonLexContext</name> <modifier>*</modifier></type>
<name>makeJsonLexContextCstringLen</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>json</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>need_escapes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name> <init>= <expr><call><name>palloc0</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonLexContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>input</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>line_start</name></name> <operator>=</operator> <name>json</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>line_number</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>=</operator> <name>len</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>need_escapes</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>lex</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * pg_parse_json
 *
 * Publicly visible entry point for the JSON parser.
 *
 * lex is a lexing context, set up for the json to be processed by calling
 * makeJsonLexContext(). sem is a structure of function pointers to semantic
 * action routines to be called at appropriate spots during parsing, and a
 * pointer to a state object to be passed to those routines.
 */</comment>
<function><type><name>void</name></type>
<name>pg_parse_json</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>tok</name></decl>;</decl_stmt>

	<comment type="block">/* get the initial token */</comment>
	<expr_stmt><expr><call><name>json_lex</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* parse by recursive descent */</comment>
	<switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JSON_TOKEN_OBJECT_START</name></expr>:</case>
			<expr_stmt><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_ARRAY_START</name></expr>:</case>
			<expr_stmt><expr><call><name>parse_array</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>parse_scalar</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* json can be a bare scalar */</comment>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>JSON_PARSE_END</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * json_count_array_elements
 *
 * Returns number of array elements in lex context at start of array token
 * until end of array token at same nesting level.
 *
 * Designed to be called from array_start routines.
 */</comment>
<function><type><name>int</name></type>
<name>json_count_array_elements</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonLexContext</name></type> <name>copylex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * It's safe to do this with a shallow copy because the lexical routines
	 * don't scribble on the input. They do scribble on the other pointers
	 * etc, so doing this with a copy makes that safe.
	 */</comment>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copylex</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonLexContext</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>copylex</name><operator>.</operator><name>strval</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>		<comment type="block">/* not interested in values here */</comment>
	<expr_stmt><expr><name><name>copylex</name><operator>.</operator><name>lex_level</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>count</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>JSON_PARSE_ARRAY_START</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copylex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_ARRAY_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lex_peek</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copylex</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>JSON_TOKEN_ARRAY_END</name></expr>)</condition>
	<block>{<block_content>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>parse_array_element</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copylex</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nullSemAction</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
		while <condition>(<expr><call><name>lex_accept</name><argument_list>(<argument><expr><operator>&amp;</operator><name>copylex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_COMMA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition>;</do>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>JSON_PARSE_ARRAY_NEXT</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>copylex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_ARRAY_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>count</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	Recursive Descent parse routines. There is one for each structural
 *	element in a json document:
 *	  - scalar (string, number, true, false, null)
 *	  - array  ( [ ] )
 *	  - array element
 *	  - object ( { } )
 *	  - object field
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>parse_scalar</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>json_scalar_action</name></type> <name>sfunc</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>scalar</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>valaddr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>tok</name> <init>= <expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name>valaddr</name> <operator>=</operator> <ternary><condition><expr><name>sfunc</name> <operator>==</operator> <name>NULL</name></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>&amp;</operator><name>val</name></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* a scalar must be a string, a number, true, false, or null */</comment>
	<switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JSON_TOKEN_TRUE</name></expr>:</case>
			<expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_TRUE</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_FALSE</name></expr>:</case>
			<expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_FALSE</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_NULL</name></expr>:</case>
			<expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_NULL</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_NUMBER</name></expr>:</case>
			<expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_NUMBER</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_STRING</name></expr>:</case>
			<expr_stmt><expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_STRING</name></expr></argument>, <argument><expr><name>valaddr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>report_parse_error</name><argument_list>(<argument><expr><name>JSON_PARSE_VALUE</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>sfunc</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>sfunc</name>) <argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_object_field</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * An object field is "fieldname" : value where value can be a scalar,
	 * object or array.  Note: in user-facing docs and error messages, we
	 * generally call a field name a "key".
	 */</comment>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fname</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* keep compiler quiet */</comment>
	<decl_stmt><decl><type><name>json_ofield_action</name></type> <name>ostart</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_start</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>json_ofield_action</name></type> <name>oend</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>object_field_end</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	  <modifier>*</modifier><modifier>*</modifier></type><name>fnameaddr</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>tok</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>ostart</name> <operator>!=</operator> <name>NULL</name> <operator>||</operator> <name>oend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>fnameaddr</name> <operator>=</operator> <operator>&amp;</operator><name>fname</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_STRING</name></expr></argument>, <argument><expr><name>fnameaddr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>report_parse_error</name><argument_list>(<argument><expr><name>JSON_PARSE_STRING</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>JSON_PARSE_OBJECT_LABEL</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_COLON</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>tok</name> <operator>==</operator> <name>JSON_TOKEN_NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ostart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ostart</name>) <argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JSON_TOKEN_OBJECT_START</name></expr>:</case>
			<expr_stmt><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_ARRAY_START</name></expr>:</case>
			<expr_stmt><expr><call><name>parse_array</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>parse_scalar</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>oend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>oend</name>) <argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>fname</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_object</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * an object is a possibly empty sequence of object fields, separated by
	 * commas and surrounded by curly braces.
	 */</comment>
	<decl_stmt><decl><type><name>json_struct_action</name></type> <name>ostart</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>object_start</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>json_struct_action</name></type> <name>oend</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>object_end</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>tok</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>ostart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>ostart</name>) <argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Data inside an object is at a higher nesting level than the object
	 * itself. Note that we increment this after we call the semantic routine
	 * for the object start and restore it before we call the routine for the
	 * object end.
	 */</comment>
	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* we know this will succeed, just clearing the token */</comment>
	<expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>JSON_PARSE_OBJECT_START</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_OBJECT_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JSON_TOKEN_STRING</name></expr>:</case>
			<expr_stmt><expr><call><name>parse_object_field</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<while>while <condition>(<expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_COMMA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>parse_object_field</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_OBJECT_END</name></expr>:</case>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* case of an invalid initial token inside the object */</comment>
			<expr_stmt><expr><call><name>report_parse_error</name><argument_list>(<argument><expr><name>JSON_PARSE_OBJECT_START</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>JSON_PARSE_OBJECT_NEXT</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_OBJECT_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name><operator>--</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>oend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>oend</name>) <argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_array_element</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>json_aelem_action</name></type> <name>astart</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_start</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>json_aelem_action</name></type> <name>aend</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>array_element_end</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>tok</name> <init>= <expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>isnull</name> <operator>=</operator> <name>tok</name> <operator>==</operator> <name>JSON_TOKEN_NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>astart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>astart</name>) <argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* an array element is any object, array or scalar */</comment>
	<switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JSON_TOKEN_OBJECT_START</name></expr>:</case>
			<expr_stmt><expr><call><name>parse_object</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_ARRAY_START</name></expr>:</case>
			<expr_stmt><expr><call><name>parse_array</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>parse_scalar</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>aend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>aend</name>) <argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_array</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>JsonSemAction</name> <modifier>*</modifier></type><name>sem</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * an array is a possibly empty sequence of array elements, separated by
	 * commas and surrounded by square brackets.
	 */</comment>
	<decl_stmt><decl><type><name>json_struct_action</name></type> <name>astart</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>array_start</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>json_struct_action</name></type> <name>aend</name> <init>= <expr><name><name>sem</name><operator>-&gt;</operator><name>array_end</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>astart</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>astart</name>) <argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Data inside an array is at a higher nesting level than the array
	 * itself. Note that we increment this after we call the semantic routine
	 * for the array start and restore it before we call the routine for the
	 * array end.
	 */</comment>
	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>JSON_PARSE_ARRAY_START</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_ARRAY_START</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>JSON_TOKEN_ARRAY_END</name></expr>)</condition>
	<block>{<block_content>

		<expr_stmt><expr><call><name>parse_array_element</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<while>while <condition>(<expr><call><name>lex_accept</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_COMMA</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>parse_array_element</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>sem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>lex_expect</name><argument_list>(<argument><expr><name>JSON_PARSE_ARRAY_NEXT</name></expr></argument>, <argument><expr><name>lex</name></expr></argument>, <argument><expr><name>JSON_TOKEN_ARRAY_END</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>lex_level</name></name><operator>--</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>aend</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call>(<modifier>*</modifier><name>aend</name>) <argument_list>(<argument><expr><name><name>sem</name><operator>-&gt;</operator><name>semstate</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Lex one token from the input stream.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>json_lex</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<comment type="block">/* Skip leading whitespace. */</comment>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name>s</name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator>
		   <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">' '</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\t'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\r'</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name><name>lex</name><operator>-&gt;</operator><name>line_number</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>++</operator><name>s</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>++</operator><name>len</name></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>

	<comment type="block">/* Determine token type. */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_END</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/* Single-character token, some kind of punctuation mark. */</comment>
			<case>case <expr><literal type="char">'{'</literal></expr>:</case>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_OBJECT_START</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'}'</literal></expr>:</case>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_OBJECT_END</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'['</literal></expr>:</case>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_ARRAY_START</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">']'</literal></expr>:</case>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_ARRAY_END</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">','</literal></expr>:</case>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_COMMA</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">':'</literal></expr>:</case>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_COLON</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'"'</literal></expr>:</case>
				<comment type="block">/* string */</comment>
				<expr_stmt><expr><call><name>json_lex_string</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_STRING</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'-'</literal></expr>:</case>
				<comment type="block">/* Negative number. */</comment>
				<expr_stmt><expr><call><name>json_lex_number</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>s</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_NUMBER</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'0'</literal></expr>:</case>
			<case>case <expr><literal type="char">'1'</literal></expr>:</case>
			<case>case <expr><literal type="char">'2'</literal></expr>:</case>
			<case>case <expr><literal type="char">'3'</literal></expr>:</case>
			<case>case <expr><literal type="char">'4'</literal></expr>:</case>
			<case>case <expr><literal type="char">'5'</literal></expr>:</case>
			<case>case <expr><literal type="char">'6'</literal></expr>:</case>
			<case>case <expr><literal type="char">'7'</literal></expr>:</case>
			<case>case <expr><literal type="char">'8'</literal></expr>:</case>
			<case>case <expr><literal type="char">'9'</literal></expr>:</case>
				<comment type="block">/* Positive number. */</comment>
				<expr_stmt><expr><call><name>json_lex_number</name><argument_list>(<argument><expr><name>lex</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_NUMBER</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

					<comment type="block">/*
					 * We're not dealing with a string, number, legal
					 * punctuation mark, or end of string.  The only legal
					 * tokens we might find here are true, false, and null,
					 * but for error reporting purposes we scan until we see a
					 * non-alphanumeric character.  That way, we can report
					 * the whole word as an unexpected token, rather than just
					 * some unintuitive prefix thereof.
					 */</comment>
					<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>s</name></expr>;</init> <condition><expr><name>p</name> <operator>-</operator> <name>s</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>-</operator> <name>len</name> <operator>&amp;&amp;</operator> <call><name>JSON_ALPHANUMERIC_CHAR</name><argument_list>(<argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
						 <comment type="block">/* skip */</comment> <empty_stmt>;</empty_stmt></block_content></block></for>

					<comment type="block">/*
					 * We got some sort of unexpected punctuation or an
					 * otherwise unexpected character, so just complain about
					 * that one character.
					 */</comment>
					<if_stmt><if>if <condition>(<expr><name>p</name> <operator>==</operator> <name>s</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/*
					 * We've got a real alphanumeric token here.  If it
					 * happens to be true, false, or null, all is well.  If
					 * not, error out.
					 */</comment>
					<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>p</name> <operator>-</operator> <name>s</name> <operator>==</operator> <literal type="number">4</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"true"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_TRUE</name></expr>;</expr_stmt></block_content></block></if>
						<if type="elseif">else if <condition>(<expr><call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_NULL</name></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>p</name> <operator>-</operator> <name>s</name> <operator>==</operator> <literal type="number">5</literal> <operator>&amp;&amp;</operator> <call><name>memcmp</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"false"</literal></expr></argument>, <argument><expr><literal type="number">5</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>=</operator> <name>JSON_TOKEN_FALSE</name></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

				</block_content>}</block>
		</block_content>}</block></switch></block_content></block></else></if_stmt>						<comment type="block">/* end of switch */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * The next token in the input stream is known to be a string; lex it.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>json_lex_string</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hi_surrogate</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>resetStringInfo</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>s</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
		<comment type="block">/* Premature end of the string. */</comment>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name> <operator>&lt;</operator> <literal type="number">32</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Per RFC4627, these characters MUST be escaped. */</comment>
			<comment type="block">/* Since *s isn't printable, exclude it from the context string */</comment>
			<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Character with value 0x%02x must be escaped."</literal></expr></argument>,
							   <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'\\'</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* OK, we have an escape character. */</comment>
			<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'u'</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>ch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

				<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <literal type="number">4</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
					<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>ch</name> <operator>*</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'f'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>ch</name> <operator>*</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'a'</literal><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'F'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>ch</name> <operator>=</operator> <operator>(</operator><name>ch</name> <operator>*</operator> <literal type="number">16</literal><operator>)</operator> <operator>+</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'A'</literal><operator>)</operator> <operator>+</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>,
										<argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"\\u\" must be followed by four hexadecimal digits."</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>
				<if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name></type>		<name><name>utf8str</name><index>[<expr><literal type="number">5</literal></expr>]</index></name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>int</name></type>			<name>utf8len</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&gt;=</operator> <literal type="number">0xd800</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="number">0xdbff</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>,
											<argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unicode high surrogate must not follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>hi_surrogate</name> <operator>=</operator> <operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator> <operator>&lt;&lt;</operator> <literal type="number">10</literal></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&gt;=</operator> <literal type="number">0xdc00</literal> <operator>&amp;&amp;</operator> <name>ch</name> <operator>&lt;=</operator> <literal type="number">0xdfff</literal></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
									<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
									 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						<expr_stmt><expr><name>ch</name> <operator>=</operator> <literal type="number">0x10000</literal> <operator>+</operator> <name>hi_surrogate</name> <operator>+</operator> <operator>(</operator><name>ch</name> <operator>&amp;</operator> <literal type="number">0x3ff</literal><operator>)</operator></expr>;</expr_stmt>
						<expr_stmt><expr><name>hi_surrogate</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/*
					 * For UTF8, replace the escape sequence by the actual
					 * utf8 character in lex-&gt;strval. Do this also for other
					 * encodings if the escape designates an ASCII character,
					 * otherwise raise an error.
					 */</comment>

					<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* We can't allow this, since our TEXT type doesn't */</comment>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNTRANSLATABLE_CHARACTER</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported Unicode escape sequence"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\\u0000 cannot be converted to text."</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><call><name>GetDatabaseEncoding</name><argument_list>()</argument_list></call> <operator>==</operator> <name>PG_UTF8</name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>unicode_to_utf8</name><argument_list>(<argument><expr><name>ch</name></expr></argument>, <argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>utf8str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name>utf8len</name> <operator>=</operator> <call><name>pg_utf_mblen</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <name>utf8str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><name>utf8str</name></expr></argument>, <argument><expr><name>utf8len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&lt;=</operator> <literal type="number">0x007f</literal></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * This is the only way to designate things like a
						 * form feed character in JSON, so it's useful in all
						 * encodings.
						 */</comment>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><operator>(</operator><name>char</name><operator>)</operator> <name>ch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_UNTRANSLATABLE_CHARACTER</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"unsupported Unicode escape sequence"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unicode escape values cannot be used for code point values above 007F when the server encoding is not UTF8."</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>

				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>,
									<argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<switch>switch <condition>(<expr><operator>*</operator><name>s</name></expr>)</condition>
				<block>{<block_content>
					<case>case <expr><literal type="char">'"'</literal></expr>:</case>
					<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
					<case>case <expr><literal type="char">'/'</literal></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'b'</literal></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\b'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'f'</literal></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\f'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'n'</literal></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\n'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'r'</literal></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\r'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<case>case <expr><literal type="char">'t'</literal></expr>:</case>
						<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><literal type="char">'\t'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>
					<default>default:</default>
						<comment type="block">/* Not a valid string escape, so error out. */</comment>
						<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>,
										<argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Escape sequence \"\\%s\" is invalid."</literal></expr></argument>,
										   <argument><expr><call><name>extract_mb_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></switch>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"\"\\/bfnrt"</literal></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Simpler processing if we're not bothered about de-escaping
				 *
				 * It's very tempting to remove the strchr() call here and
				 * replace it with a switch statement, but testing so far has
				 * shown it's not a performance win.
				 */</comment>
				<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Escape sequence \"\\%s\" is invalid."</literal></expr></argument>,
								   <argument><expr><call><name>extract_mb_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>lex</name><operator>-&gt;</operator><name>strval</name></name></expr></argument>, <argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>hi_surrogate</name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Unicode low surrogate must follow a high surrogate."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Hooray, we found the end of the string! */</comment>
	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * The next token in the input stream is known to be a number; lex it.
 *
 * In JSON, a number consists of four parts:
 *
 * (1) An optional minus sign ('-').
 *
 * (2) Either a single '0', or a string of one or more digits that does not
 *	   begin with a '0'.
 *
 * (3) An optional decimal part, consisting of a period ('.') followed by
 *	   one or more digits.  (Note: While this part can be omitted
 *	   completely, it's not OK to have only the decimal point without
 *	   any digits afterwards.)
 *
 * (4) An optional exponent part, consisting of 'e' or 'E', optionally
 *	   followed by '+' or '-', followed by one or more digits.  (Note:
 *	   As with the decimal part, if 'e' or 'E' is present, it must be
 *	   followed by at least one digit.)
 *
 * The 's' argument to this function points to the ostensible beginning
 * of part 2 - i.e. the character after any optional minus sign, or the
 * first character of the string if there is none.
 *
 * If num_err is not NULL, we return an error flag to *num_err rather than
 * raising an error for a badly-formed number.  Also, if total_len is not NULL
 * the distance from lex-&gt;input to the token end+1 is returned to *total_len.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>json_lex_number</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>,
				<parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>num_err</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>total_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>error</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><name>s</name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Part (1): leading sign indicator. */</comment>
	<comment type="block">/* Caller already did this for us; so do nothing. */</comment>

	<comment type="block">/* Part (2): parse main digit string. */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'0'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'1'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>
	<block>{<block_content>
		<do>do
		<block>{<block_content>
			<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block> while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>;</do>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Part (3): parse optional decimal portion. */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>||</operator> <operator>*</operator><name><name>s</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <operator>*</operator><name>s</name></expr></argument> &gt;</argument_list></name> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>;</do>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Part (4): parse optional exponent. */</comment>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'e'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'E'</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>||</operator> <operator>*</operator><name><name>s</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <operator>*</operator><name>s</name></expr></argument> &gt;</argument_list></name> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<do>do
			<block>{<block_content>
				<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block> while <condition>(<expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>&lt;=</operator> <literal type="char">'9'</literal></expr>)</condition>;</do>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Check for trailing garbage.  As in json_lex(), any alphanumeric stuff
	 * here should be considered part of the token for error-reporting
	 * purposes.
	 */</comment>
	<for>for <control>(<init>;</init> <condition><expr><name>len</name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <call><name>JSON_ALPHANUMERIC_CHAR</name><argument_list>(<argument><expr><operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr><operator>,</operator> <expr><name>len</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name>error</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></for>

	<if_stmt><if>if <condition>(<expr><name>total_len</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>total_len</name> <operator>=</operator> <name>len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_err</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* let the caller handle any error */</comment>
		<expr_stmt><expr><operator>*</operator><name>num_err</name> <operator>=</operator> <name>error</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* return token endpoint */</comment>
		<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>prev_token_terminator</name></name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>=</operator> <name>s</name></expr>;</expr_stmt>
		<comment type="block">/* handle error if any */</comment>
		<if_stmt><if>if <condition>(<expr><name>error</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>report_invalid_token</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report a parse error.
 *
 * lex-&gt;token_start and lex-&gt;token_terminator must identify the current token.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_parse_error</name><parameter_list>(<parameter><decl><type><name>JsonParseContext</name></type> <name>ctx</name></decl></parameter>, <parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>toklen</name></decl>;</decl_stmt>

	<comment type="block">/* Handle case where the input ended prematurely. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>==</operator> <name>JSON_TOKEN_END</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The input string ended unexpectedly."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Separate out the current token. */</comment>
	<expr_stmt><expr><name>toklen</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>toklen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr></argument>, <argument><expr><name>toklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>token</name><index>[<expr><name>toklen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/* Complain, with the appropriate detail message. */</comment>
	<if_stmt><if>if <condition>(<expr><name>ctx</name> <operator>==</operator> <name>JSON_PARSE_END</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected end of input, but found \"%s\"."</literal></expr></argument>,
						   <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<switch>switch <condition>(<expr><name>ctx</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>JSON_PARSE_VALUE</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected JSON value, but found \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JSON_PARSE_STRING</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected string, but found \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JSON_PARSE_ARRAY_START</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected array element or \"]\", but found \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JSON_PARSE_ARRAY_NEXT</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected \",\" or \"]\", but found \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JSON_PARSE_OBJECT_START</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected string or \"}\", but found \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JSON_PARSE_OBJECT_LABEL</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected \":\", but found \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JSON_PARSE_OBJECT_NEXT</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected \",\" or \"}\", but found \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>JSON_PARSE_OBJECT_COMMA</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Expected string, but found \"%s\"."</literal></expr></argument>,
								   <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected json parse state: %d"</literal></expr></argument>, <argument><expr><name>ctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report an invalid input token.
 *
 * lex-&gt;token_start and lex-&gt;token_terminator must identify the token.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>report_invalid_token</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>token</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>toklen</name></decl>;</decl_stmt>

	<comment type="block">/* Separate out the offending token. */</comment>
	<expr_stmt><expr><name>toklen</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>token</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>toklen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>token</name></expr></argument>, <argument><expr><name><name>lex</name><operator>-&gt;</operator><name>token_start</name></name></expr></argument>, <argument><expr><name>toklen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>token</name><index>[<expr><name>toklen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s"</literal></expr></argument>, <argument><expr><literal type="string">"json"</literal></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Token \"%s\" is invalid."</literal></expr></argument>, <argument><expr><name>token</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>report_json_context</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report a CONTEXT line for bogus JSON input.
 *
 * lex-&gt;token_terminator must be set to identify the spot where we detected
 * the error.  Note that lex-&gt;token_start might be NULL, in case we recognized
 * error at EOF.
 *
 * The return value isn't meaningful, but we make it non-void so that this
 * can be invoked inside ereport().
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>report_json_context</name><parameter_list>(<parameter><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>context_end</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>line_start</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>line_number</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>ctxt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ctxtlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>suffix</name></decl>;</decl_stmt>

	<comment type="block">/* Choose boundaries for the part of the input we will display */</comment>
	<expr_stmt><expr><name>context_start</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>context_end</name> <operator>=</operator> <name><name>lex</name><operator>-&gt;</operator><name>token_terminator</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>line_start</name> <operator>=</operator> <name>context_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>line_number</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<comment type="block">/* Always advance over newlines */</comment>
		<if_stmt><if>if <condition>(<expr><name>context_start</name> <operator>&lt;</operator> <name>context_end</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>context_start</name> <operator>==</operator> <literal type="char">'\n'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>context_start</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>line_start</name> <operator>=</operator> <name>context_start</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>line_number</name><operator>++</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<comment type="block">/* Otherwise, done as soon as we are close enough to context_end */</comment>
		<if_stmt><if>if <condition>(<expr><name>context_end</name> <operator>-</operator> <name>context_start</name> <operator>&lt;</operator> <literal type="number">50</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<comment type="block">/* Advance to next multibyte character */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_HIGHBIT_SET</name><argument_list>(<argument><expr><operator>*</operator><name>context_start</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>context_start</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>context_start</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>context_start</name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * We add "..." to indicate that the excerpt doesn't start at the
	 * beginning of the line ... but if we're within 3 characters of the
	 * beginning of the line, we might as well just show the whole line.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>context_start</name> <operator>-</operator> <name>line_start</name> <operator>&lt;=</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>context_start</name> <operator>=</operator> <name>line_start</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Get a null-terminated copy of the data to present */</comment>
	<expr_stmt><expr><name>ctxtlen</name> <operator>=</operator> <name>context_end</name> <operator>-</operator> <name>context_start</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>ctxt</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>ctxtlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>context_start</name></expr></argument>, <argument><expr><name>ctxtlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctxt</name><index>[<expr><name>ctxtlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Show the context, prefixing "..." if not starting at start of line, and
	 * suffixing "..." if not ending at end of line.
	 */</comment>
	<expr_stmt><expr><name>prefix</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>context_start</name> <operator>&gt;</operator> <name>line_start</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"..."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>suffix</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name><name>lex</name><operator>-&gt;</operator><name>token_type</name></name> <operator>!=</operator> <name>JSON_TOKEN_END</name> <operator>&amp;&amp;</operator> <name>context_end</name> <operator>-</operator> <name><name>lex</name><operator>-&gt;</operator><name>input</name></name> <operator>&lt;</operator> <name><name>lex</name><operator>-&gt;</operator><name>input_length</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name>context_end</name> <operator>!=</operator> <literal type="char">'\n'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>context_end</name> <operator>!=</operator> <literal type="char">'\r'</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"..."</literal></expr> </then><else>: <expr><literal type="string">""</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>errcontext</name><argument_list>(<argument><expr><literal type="string">"JSON data, line %d: %s%s%s"</literal></expr></argument>,
			   <argument><expr><name>line_number</name></expr></argument>, <argument><expr><name>prefix</name></expr></argument>, <argument><expr><name>ctxt</name></expr></argument>, <argument><expr><name>suffix</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract a single, possibly multi-byte char from the input string.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>extract_mb_char</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>res</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>res</name><index>[<expr><name>len</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Determine how we want to print values of a given type in datum_to_json.
 *
 * Given the datatype OID, return its JsonTypeCategory, as well as the type's
 * output function OID.  If the returned category is JSONTYPE_CAST, we
 * return the OID of the type-&gt;JSON cast function instead.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>json_categorize_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>typoid</name></decl></parameter>,
					 <parameter><decl><type><name>JsonTypeCategory</name> <modifier>*</modifier></type><name>tcategory</name></decl></parameter>,
					 <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>outfuncoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

	<comment type="block">/* Look through any domain */</comment>
	<expr_stmt><expr><name>typoid</name> <operator>=</operator> <call><name>getBaseType</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>outfuncoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * We need to get the output function for everything except date and
	 * timestamp types, array and composite types, booleans, and non-builtin
	 * types where there's a cast to json.
	 */</comment>

	<switch>switch <condition>(<expr><name>typoid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_BOOL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_NUMERIC</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>DATEOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_DATE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_TIMESTAMP</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_TIMESTAMPTZ</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>JSONOID</name></expr>:</case>
		<case>case <expr><name>JSONBOID</name></expr>:</case>
			<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_JSON</name></expr>;</expr_stmt>
			<break>break;</break>

		<default>default:</default>
			<comment type="block">/* Check for arrays and composites */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><call><name>get_element_type</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <name>typoid</name> <operator>==</operator> <name>ANYARRAYOID</name>
				<operator>||</operator> <name>typoid</name> <operator>==</operator> <name>RECORDARRAYOID</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_ARRAY</name></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><call><name>type_is_rowtype</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* includes RECORDOID */</comment>
				<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_COMPOSITE</name></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* It's probably the general case ... */</comment>
				<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_OTHER</name></expr>;</expr_stmt>
				<comment type="block">/* but let's look for a cast to json, if it's not built-in */</comment>
				<if_stmt><if>if <condition>(<expr><name>typoid</name> <operator>&gt;=</operator> <name>FirstNormalObjectId</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Oid</name></type>			<name>castfunc</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>ctype</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>ctype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>JSONOID</name></expr></argument>, <argument><expr><name>typoid</name></expr></argument>,
												  <argument><expr><name>COERCION_EXPLICIT</name></expr></argument>,
												  <argument><expr><operator>&amp;</operator><name>castfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>ctype</name> <operator>==</operator> <name>COERCION_PATH_FUNC</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>castfunc</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_CAST</name></expr>;</expr_stmt>
						<expr_stmt><expr><operator>*</operator><name>outfuncoid</name> <operator>=</operator> <name>castfunc</name></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* non builtin type with no cast */</comment>
						<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/* any other builtin type */</comment>
					<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name>typoid</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Turn a Datum into JSON text, appending the string to "result".
 *
 * tcategory and outfuncoid are from a previous call to json_categorize_type,
 * except that if is_null is true then they can be invalid.
 *
 * If key_scalar is true, the value is being printed as a key, so insist
 * it's of an acceptable type, and force it to be quoted.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>datum_to_json</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>,
			  <parameter><decl><type><name>JsonTypeCategory</name></type> <name>tcategory</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl></parameter>,
			  <parameter><decl><type><name>bool</name></type> <name>key_scalar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>outputstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>jsontext</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* callers are expected to ensure that null keys are not passed in */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name>key_scalar</name> <operator>&amp;&amp;</operator> <name>is_null</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>key_scalar</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>tcategory</name> <operator>==</operator> <name>JSONTYPE_ARRAY</name> <operator>||</operator>
		 <name>tcategory</name> <operator>==</operator> <name>JSONTYPE_COMPOSITE</name> <operator>||</operator>
		 <name>tcategory</name> <operator>==</operator> <name>JSONTYPE_JSON</name> <operator>||</operator>
		 <name>tcategory</name> <operator>==</operator> <name>JSONTYPE_CAST</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"key value must be scalar, not array, composite, or json"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>tcategory</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JSONTYPE_ARRAY</name></expr>:</case>
			<expr_stmt><expr><call><name>array_to_json_internal</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSONTYPE_COMPOSITE</name></expr>:</case>
			<expr_stmt><expr><call><name>composite_to_json</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSONTYPE_BOOL</name></expr>:</case>
			<expr_stmt><expr><name>outputstr</name> <operator>=</operator> <ternary><condition><expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"true"</literal></expr> </then><else>: <expr><literal type="string">"false"</literal></expr></else></ternary></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>key_scalar</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>JSONTYPE_NUMERIC</name></expr>:</case>
			<expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Don't call escape_json for a non-key if it's a valid JSON
			 * number.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>key_scalar</name> <operator>&amp;&amp;</operator> <call><name>IsValidJsonNumber</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSONTYPE_DATE</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JsonEncodeDateTime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>DATEOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>JSONTYPE_TIMESTAMP</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JsonEncodeDateTime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>TIMESTAMPOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>JSONTYPE_TIMESTAMPTZ</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name></type>		<name><name>buf</name><index>[<expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>JsonEncodeDateTime</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>TIMESTAMPTZOID</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"\"%s\""</literal></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>JSONTYPE_JSON</name></expr>:</case>
			<comment type="block">/* JSON and JSONB output will already be escaped */</comment>
			<expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSONTYPE_CAST</name></expr>:</case>
			<comment type="block">/* outfuncoid refers to a cast function, not an output function */</comment>
			<expr_stmt><expr><name>jsontext</name> <operator>=</operator> <call><name>DatumGetTextPP</name><argument_list>(<argument><expr><call><name>OidFunctionCall1</name><argument_list>(<argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>jsontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>jsontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><name>outputstr</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>outputstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * Encode 'value' of datetime type 'typid' into JSON string in ISO format using
 * optionally preallocated buffer 'buf'.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>JsonEncodeDateTime</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buf</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buf</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>MAXDATELEN</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>DateADT</name></type>		<name>date</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>date</name> <operator>=</operator> <call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Same as date_out(), but forcing DateStyle */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>DATE_NOT_FINITE</name><argument_list>(<argument><expr><name>date</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>EncodeSpecialDate</name><argument_list>(<argument><expr><name>date</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>date</name> <operator>+</operator> <name>POSTGRES_EPOCH_JDATE</name></expr></argument>,
						   <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>.</operator><name>tm_year</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>.</operator><name>tm_mon</name></name><operator>)</operator></expr></argument>, <argument><expr><operator>&amp;</operator><operator>(</operator><name><name>tm</name><operator>.</operator><name>tm_mday</name></name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>EncodeDateOnly</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>TIMEOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TimeADT</name></type>		<name>time</name> <init>= <expr><call><name>DatumGetTimeADT</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

				<comment type="block">/* Same as time_out(), but forcing DateStyle */</comment>
				<expr_stmt><expr><call><name>time2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EncodeTimeOnly</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>TIMETZOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>time</name> <init>= <expr><call><name>DatumGetTimeTzADTP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tt</name></decl>,
						   <decl><type ref="prev"><modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name>tt</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>

				<comment type="block">/* Same as timetz_out(), but forcing DateStyle */</comment>
				<expr_stmt><expr><call><name>timetz2tm</name><argument_list>(<argument><expr><name>time</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>EncodeTimeOnly</name><argument_list>(<argument><expr><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Timestamp</name></type>	<name>timestamp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Same as timestamp_out(), but forcing DateStyle */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>EncodeSpecialTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TimestampTz</name></type> <name>timestamp</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>timestamp</name> <operator>=</operator> <call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Same as timestamptz_out(), but forcing DateStyle */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>EncodeSpecialTimestamp</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>timestamp</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tzn</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>EncodeDateTime</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>tz</name></expr></argument>, <argument><expr><name>tzn</name></expr></argument>, <argument><expr><name>USE_XSD_DATES</name></expr></argument>, <argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown jsonb value datetime type oid %d"</literal></expr></argument>, <argument><expr><name>typid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>

	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Process a single dimension of an array.
 * If it's the innermost dimension, output the values, otherwise call
 * ourselves recursively to process the next dimension.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>array_dim_to_json</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>dim</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ndims</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dims</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>,
				  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>valcount</name></decl></parameter>, <parameter><decl><type><name>JsonTypeCategory</name></type> <name>tcategory</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>outfuncoid</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_line_feeds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>dim</name> <operator>&lt;</operator> <name>ndims</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <ternary><condition><expr><name>use_line_feeds</name></expr> ?</condition><then> <expr><literal type="string">",\n "</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name><name>dims</name><index>[<expr><name>dim</name></expr>]</index></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>dim</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>ndims</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>datum_to_json</name><argument_list>(<argument><expr><name><name>vals</name><index>[<expr><operator>*</operator><name>valcount</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>nulls</name><index>[<expr><operator>*</operator><name>valcount</name></expr>]</index></name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>,
						  <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>(</operator><operator>*</operator><name>valcount</name><operator>)</operator><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Do we want line feeds on inner dimensions of arrays? For now
			 * we'll say no.
			 */</comment>
			<expr_stmt><expr><call><name>array_dim_to_json</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>dim</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>ndims</name></expr></argument>, <argument><expr><name>dims</name></expr></argument>, <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
							  <argument><expr><name>valcount</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Turn an array into JSON.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>array_to_json_internal</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>array</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_line_feeds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>v</name> <init>= <expr><call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>element_type</name> <init>= <expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>dim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndim</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nitems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>typalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTypeCategory</name></type> <name>tcategory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outfuncoid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ndim</name> <operator>=</operator> <call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>dim</name> <operator>=</operator> <call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nitems</name> <operator>=</operator> <call><name>ArrayGetNItems</name><argument_list>(<argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nitems</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"[]"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>typlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>json_categorize_type</name><argument_list>(<argument><expr><name>element_type</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>tcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>v</name></expr></argument>, <argument><expr><name>element_type</name></expr></argument>, <argument><expr><name>typlen</name></expr></argument>, <argument><expr><name>typbyval</name></expr></argument>,
					  <argument><expr><name>typalign</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elements</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>nitems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>array_dim_to_json</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>ndim</name></expr></argument>, <argument><expr><name>dim</name></expr></argument>, <argument><expr><name>elements</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>count</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>,
					  <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>use_line_feeds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>elements</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Turn a composite / record into JSON.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>composite_to_json</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>composite</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>use_line_feeds</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTupleHeader</name></type> <name>td</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>tupType</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>tupTypmod</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTupleData</name></type> <name>tmptup</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>tuple</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>needsep</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <ternary><condition><expr><name>use_line_feeds</name></expr> ?</condition><then> <expr><literal type="string">",\n "</literal></expr> </then><else>: <expr><literal type="string">","</literal></expr></else></ternary></expr>;</expr_stmt>

	<expr_stmt><expr><name>td</name> <operator>=</operator> <call><name>DatumGetHeapTupleHeader</name><argument_list>(<argument><expr><name>composite</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract rowtype info and find a tupdesc */</comment>
	<expr_stmt><expr><name>tupType</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypeId</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupTypmod</name> <operator>=</operator> <call><name>HeapTupleHeaderGetTypMod</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <call><name>lookup_rowtype_tupdesc</name><argument_list>(<argument><expr><name>tupType</name></expr></argument>, <argument><expr><name>tupTypmod</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Build a temporary HeapTuple control structure */</comment>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_len</name></name> <operator>=</operator> <call><name>HeapTupleHeaderGetDatumLength</name><argument_list>(<argument><expr><name>td</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tmptup</name><operator>.</operator><name>t_data</name></name> <operator>=</operator> <name>td</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>tuple</name> <operator>=</operator> <operator>&amp;</operator><name>tmptup</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>tupdesc</name><operator>-&gt;</operator><name>natts</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>attname</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>JsonTypeCategory</name></type> <name>tcategory</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>outfuncoid</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>att</name><operator>-&gt;</operator><name>attisdropped</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>needsep</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>needsep</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>attname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">':'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>heap_getattr</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_NULL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>outfuncoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>json_categorize_type</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><call><name>datum_to_json</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseTupleDesc</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Append JSON text for "val" to "result".
 *
 * This is just a thin wrapper around datum_to_json.  If the same type will be
 * printed many times, avoid using this; better to do the json_categorize_type
 * lookups only once.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>add_json</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>val</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_null</name></decl></parameter>, <parameter><decl><type><name>StringInfo</name></type> <name>result</name></decl></parameter>,
		 <parameter><decl><type><name>Oid</name></type> <name>val_type</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>key_scalar</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonTypeCategory</name></type> <name>tcategory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outfuncoid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>val_type</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine input data type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_null</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>tcategory</name> <operator>=</operator> <name>JSONTYPE_NULL</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>outfuncoid</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>json_categorize_type</name><argument_list>(<argument><expr><name>val_type</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>tcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>datum_to_json</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>is_null</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>key_scalar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function array_to_json(row)
 */</comment>
<function><type><name>Datum</name></type>
<name>array_to_json</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>array</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>array_to_json_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function array_to_json(row, prettybool)
 */</comment>
<function><type><name>Datum</name></type>
<name>array_to_json_pretty</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>array</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_line_feeds</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>array_to_json_internal</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>use_line_feeds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function row_to_json(row)
 */</comment>
<function><type><name>Datum</name></type>
<name>row_to_json</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>array</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>composite_to_json</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function row_to_json(row, prettybool)
 */</comment>
<function><type><name>Datum</name></type>
<name>row_to_json_pretty</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>array</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>use_line_feeds</name> <init>= <expr><call><name>PG_GETARG_BOOL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>composite_to_json</name><argument_list>(<argument><expr><name>array</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>use_line_feeds</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function to_json(anyvalue)
 */</comment>
<function><type><name>Datum</name></type>
<name>to_json</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name> <init>= <expr><call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>val_type</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTypeCategory</name></type> <name>tcategory</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>outfuncoid</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>val_type</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine input data type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>json_categorize_type</name><argument_list>(<argument><expr><name>val_type</name></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>tcategory</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>outfuncoid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>datum_to_json</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>tcategory</name></expr></argument>, <argument><expr><name>outfuncoid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * json_agg transition function
 *
 * aggregate input column as a json array value.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_agg_transfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>aggcontext</name></decl>,
				<decl><type ref="prev"/><name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>val</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggcontext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cannot be called directly because of internal-type argument */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"json_agg_transfn called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>arg_type</name> <init>= <expr><call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>arg_type</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine input data type"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Make this state object in a context where it will persist for the
		 * duration of the aggregate call.  MemoryContextSwitchTo is only
		 * needed the first time, as the StringInfo routines make sure they
		 * use the right context to enlarge the object if necessary.
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>aggcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>JsonAggState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonAggState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>json_categorize_type</name><argument_list>(<argument><expr><name>arg_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>val_category</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>val_output_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>JsonAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* fast path for NULLs */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>datum_to_json</name><argument_list>(<argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>JSONTYPE_NULL</name></expr></argument>,
					  <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* add some whitespace if structured type and not first item */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>state</name><operator>-&gt;</operator><name>val_category</name></name> <operator>==</operator> <name>JSONTYPE_ARRAY</name> <operator>||</operator>
		 <name><name>state</name><operator>-&gt;</operator><name>val_category</name></name> <operator>==</operator> <name>JSONTYPE_COMPOSITE</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"\n "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>datum_to_json</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>val_category</name></name></expr></argument>,
				  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>val_output_func</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * The transition type for json_agg() is declared to be "internal", which
	 * is a pass-by-value type the same size as a pointer.  So we can safely
	 * pass the JsonAggState pointer through nodeAgg.c's machinations.
	 */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * json_agg final function
 */</comment>
<function><type><name>Datum</name></type>
<name>json_agg_finalfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<comment type="block">/* cannot be called directly because of internal-type argument */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then>
		<expr><name>NULL</name></expr> </then><else>:
		<expr><operator>(</operator><name>JsonAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* NULL result for no rows in, as is standard with aggregates */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Else return state with appropriate array terminator added */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>catenate_stringinfo_string</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"]"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * json_object_agg transition function.
 *
 * aggregate two input columns as a single json object value.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_object_agg_transfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>MemoryContext</name></type> <name>aggcontext</name></decl>,
				<decl><type ref="prev"/><name>oldcontext</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>arg</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>aggcontext</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* cannot be called directly because of internal-type argument */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"json_object_agg_transfn called in non-aggregate context"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>arg_type</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Make the StringInfo in a context where it will persist for the
		 * duration of the aggregate call. Switching context is only needed
		 * for this initial step, as the StringInfo routines make sure they
		 * use the right context to enlarge the object if necessary.
		 */</comment>
		<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>aggcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>JsonAggState</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>JsonAggState</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>arg_type</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>arg_type</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine data type for argument %d"</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>json_categorize_type</name><argument_list>(<argument><expr><name>arg_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>key_category</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>key_output_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>arg_type</name> <operator>=</operator> <call><name>get_fn_expr_argtype</name><argument_list>(<argument><expr><name><name>fcinfo</name><operator>-&gt;</operator><name>flinfo</name></name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>arg_type</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine data type for argument %d"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>json_categorize_type</name><argument_list>(<argument><expr><name>arg_type</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>val_category</name></name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name><name>state</name><operator>-&gt;</operator><name>val_output_func</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">"{ "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>state</name> <operator>=</operator> <operator>(</operator><name>JsonAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Note: since json_object_agg() is declared as taking type "any", the
	 * parser will not do any type conversion on unknown-type literals (that
	 * is, undecorated strings or NULLs).  Such values will arrive here as
	 * type UNKNOWN, which fortunately does not matter to us, since
	 * unknownout() works fine.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"field name must not be null"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>datum_to_json</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>key_category</name></name></expr></argument>,
				  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>key_output_func</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" : "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>arg</name> <operator>=</operator> <call><name>PG_GETARG_DATUM</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>datum_to_json</name><argument_list>(<argument><expr><name>arg</name></expr></argument>, <argument><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>val_category</name></name></expr></argument>,
				  <argument><expr><name><name>state</name><operator>-&gt;</operator><name>val_output_func</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * json_object_agg final function.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_object_agg_finalfn</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>JsonAggState</name> <modifier>*</modifier></type><name>state</name></decl>;</decl_stmt>

	<comment type="block">/* cannot be called directly because of internal-type argument */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>AggCheckCallContext</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>state</name> <operator>=</operator> <ternary><condition><expr><call><name>PG_ARGISNULL</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><name>NULL</name></expr> </then><else>: <expr><operator>(</operator><name>JsonAggState</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* NULL result for no rows in, as is standard with aggregates */</comment>
	<if_stmt><if>if <condition>(<expr><name>state</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Else return state with appropriate object terminator added */</comment>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>catenate_stringinfo_string</name><argument_list>(<argument><expr><name><name>state</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><literal type="string">" }"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper function for aggregates: return given StringInfo's contents plus
 * specified trailing string, as a text datum.  We need this because aggregate
 * final functions are not allowed to modify the aggregate state.
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>catenate_stringinfo_string</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>addon</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* custom version of cstring_to_text_with_len */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>buflen</name> <init>= <expr><name><name>buffer</name><operator>-&gt;</operator><name>len</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>addlen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>addon</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><operator>(</operator><name>text</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>buflen</name> <operator>+</operator> <name>addlen</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>buflen</name> <operator>+</operator> <name>addlen</name> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>buffer</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name>buflen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><call><name>VARDATA</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call> <operator>+</operator> <name>buflen</name></expr></argument>, <argument><expr><name>addon</name></expr></argument>, <argument><expr><name>addlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function json_build_object(variadic "any")
 */</comment>
<function><type><name>Datum</name></type>
<name>json_build_object</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name> <init>= <expr><call><name>PG_NARGS</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>

	<comment type="block">/* fetch argument values to build the object */</comment>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>%</operator> <literal type="number">2</literal> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument list must have even number of elements"</literal></expr></argument>)</argument_list></call><operator>,</operator>
		<comment type="block">/* translator: %s is a SQL function name */</comment>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"The arguments of %s must consist of alternating keys and values."</literal></expr></argument>,
						 <argument><expr><literal type="string">"json_build_object()"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <literal type="number">2</literal></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>

		<comment type="block">/* process key */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"argument %d cannot be null"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Object keys should be text."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><call><name>add_json</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">" : "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* process value */</comment>
		<expr_stmt><expr><call><name>add_json</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>nulls</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * degenerate case of json_build_object where it gets 0 arguments.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_build_object_noargs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><literal type="string">"{}"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function json_build_array(variadic "any")
 */</comment>
<function><type><name>Datum</name></type>
<name>json_build_array</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>nargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name> <init>= <expr><literal type="string">""</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name>		   <modifier>*</modifier></type><name>types</name></decl>;</decl_stmt>

	<comment type="block">/* fetch argument values to build the array */</comment>
	<expr_stmt><expr><name>nargs</name> <operator>=</operator> <call><name>extract_variadic_args</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>args</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>types</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nargs</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'['</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nargs</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>add_json</name><argument_list>(<argument><expr><name><name>args</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>types</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">']'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>result</name><operator>-&gt;</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * degenerate case of json_build_array where it gets 0 arguments.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_build_array_noargs</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><literal type="string">"[]"</literal></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function json_object(text[])
 *
 * take a one or two dimensional array of text as key/value pairs
 * for a json object.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_object</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>in_array</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ndims</name> <init>= <expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>in_array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>in_datums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>in_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>in_count</name></decl>,
				<decl><type ref="prev"/><name>count</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>rval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>ndims</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="number">0</literal></expr>:</case>
			<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"{}"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><literal type="number">1</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>in_array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">0</literal></expr>]</index><operator>)</operator> <operator>%</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array must have even number of elements"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><literal type="number">2</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>in_array</name></expr></argument>)</argument_list></call><index>[<expr><literal type="number">1</literal></expr>]</index><operator>)</operator> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"array must have two columns"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>in_array</name></expr></argument>,
					  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>in_datums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>in_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>in_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>count</name> <operator>=</operator> <name>in_count</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>in_nulls</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null value not allowed for object key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>in_datums</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">" : "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>in_nulls</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>in_datums</name><index>[<expr><name>i</name> <operator>*</operator> <literal type="number">2</literal> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>in_datums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>in_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * SQL function json_object(text[], text[])
 *
 * take separate key and value arrays of text to construct a json object
 * pairwise.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_object_two_arg</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>key_array</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>val_array</name> <init>= <expr><call><name>PG_GETARG_ARRAYTYPE_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkdims</name> <init>= <expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>key_array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nvdims</name> <init>= <expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>val_array</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>key_datums</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>val_datums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>key_nulls</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>val_nulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>key_count</name></decl>,
				<decl><type ref="prev"/><name>val_count</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>rval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>v</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>nkdims</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name>nkdims</name> <operator>!=</operator> <name>nvdims</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"wrong number of array subscripts"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nkdims</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_DATUM</name><argument_list>(<argument><expr><call><name>CStringGetTextDatum</name><argument_list>(<argument><expr><literal type="string">"{}"</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>key_array</name></expr></argument>,
					  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>key_datums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>key_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>val_array</name></expr></argument>,
					  <argument><expr><name>TEXTOID</name></expr></argument>, <argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="char">'i'</literal></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>val_datums</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>val_count</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>key_count</name> <operator>!=</operator> <name>val_count</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_ARRAY_SUBSCRIPT_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"mismatched array dimensions"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="char">'{'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>key_count</name></expr>;</condition> <incr><expr><operator>++</operator><name>i</name></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>key_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_NULL_VALUE_NOT_ALLOWED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"null value not allowed for object key"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>key_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">" : "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>val_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="string">"null"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>v</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name><name>val_datums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>escape_json</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>v</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><literal type="char">'}'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>key_datums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>key_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val_datums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val_nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>rval</name> <operator>=</operator> <call><name>cstring_to_text_with_len</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>result</name><operator>.</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>result</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>rval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Produce a JSON string literal, properly escaping characters in the text.
 */</comment>
<function><type><name>void</name></type>
<name>escape_json</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>str</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<switch>switch <condition>(<expr><operator>*</operator><name>p</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><literal type="char">'\b'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\b"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'\f'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\f"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'\n'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\n"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'\r'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\r"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'\t'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\t"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'"'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\\""</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><literal type="char">'\\'</literal></expr>:</case>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\\\"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name> <operator>&lt;</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">"\\u%04x"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoCharMacro</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="char">'"'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * SQL function json_typeof(json) -&gt; text
 *
 * Returns the type of the outermost JSON value as TEXT.  Possible types are
 * "object", "array", "string", "number", "boolean", and "null".
 *
 * Performs a single call to json_lex() to get the first token of the supplied
 * value.  This initial token uniquely determines the value's type.  As our
 * input must already have been validated by json_in() or json_recv(), the
 * initial token should never be JSON_TOKEN_OBJECT_END, JSON_TOKEN_ARRAY_END,
 * JSON_TOKEN_COLON, JSON_TOKEN_COMMA, or JSON_TOKEN_END.
 */</comment>
<function><type><name>Datum</name></type>
<name>json_typeof</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>json</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>JsonLexContext</name> <modifier>*</modifier></type><name>lex</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JsonTokenType</name></type> <name>tok</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>type</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>json</name> <operator>=</operator> <call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>lex</name> <operator>=</operator> <call><name>makeJsonLexContext</name><argument_list>(<argument><expr><name>json</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Lex exactly one token from the input and check its type. */</comment>
	<expr_stmt><expr><call><name>json_lex</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tok</name> <operator>=</operator> <call><name>lex_peek</name><argument_list>(<argument><expr><name>lex</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<switch>switch <condition>(<expr><name>tok</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JSON_TOKEN_OBJECT_START</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"object"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_ARRAY_START</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"array"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_STRING</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"string"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_NUMBER</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"number"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_TRUE</name></expr>:</case>
		<case>case <expr><name>JSON_TOKEN_FALSE</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"boolean"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JSON_TOKEN_NULL</name></expr>:</case>
			<expr_stmt><expr><name>type</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected json token: %d"</literal></expr></argument>, <argument><expr><name>tok</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
