<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/rangetypes_selfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * rangetypes_selfuncs.c
 *	  Functions for selectivity estimation of range operators
 *
 * Estimates are based on histograms of lower and upper bounds, and the
 * fraction of empty ranges.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/rangetypes_selfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/float.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgrprotos.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rangetypes.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>calc_rangesel</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>,
							<parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>default_range_selectivity</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>calc_hist_selectivity</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
									<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>,
									<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>calc_hist_selectivity_scalar</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
										   <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>constbound</name></decl></parameter>,
										   <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>,
										   <parameter><decl><type><name>bool</name></type> <name>equal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>rbound_bsearch</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						   <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>get_position</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						   <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist1</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>get_len_position</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>hist1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>hist2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>float8</name></type> <name>get_distance</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>bound1</name></decl></parameter>,
						   <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>bound2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>length_hist_bsearch</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>length_hist_values</name></decl></parameter>,
								<parameter><decl><type><name>int</name></type> <name>length_hist_nvalues</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>calc_length_hist_frac</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>length_hist_values</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>length_hist_nvalues</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>length1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>length2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equal</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>calc_hist_selectivity_contained</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
											  <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>lower</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>upper</name></decl></parameter>,
											  <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist_lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>,
											  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>length_hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length_hist_nvalues</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>calc_hist_selectivity_contains</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
											 <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>lower</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>upper</name></decl></parameter>,
											 <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist_lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>,
											 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>length_hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length_hist_nvalues</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Returns a default selectivity estimate for given operator, when we don't
 * have statistics or cannot use them for some reason.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>default_range_selectivity</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>operator</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OID_RANGE_OVERLAP_OP</name></expr>:</case>
			<return>return <expr><literal type="number">0.01</literal></expr>;</return>

		<case>case <expr><name>OID_RANGE_CONTAINS_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_CONTAINED_OP</name></expr>:</case>
			<return>return <expr><literal type="number">0.005</literal></expr>;</return>

		<case>case <expr><name>OID_RANGE_CONTAINS_ELEM_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_ELEM_CONTAINED_OP</name></expr>:</case>

			<comment type="block">/*
			 * "range @&gt; elem" is more or less identical to a scalar
			 * inequality "A &gt;= b AND A &lt;= c".
			 */</comment>
			<return>return <expr><name>DEFAULT_RANGE_INEQ_SEL</name></expr>;</return>

		<case>case <expr><name>OID_RANGE_LESS_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_LESS_EQUAL_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_GREATER_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_GREATER_EQUAL_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_LEFT_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_RIGHT_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_OVERLAPS_LEFT_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_OVERLAPS_RIGHT_OP</name></expr>:</case>
			<comment type="block">/* these are similar to regular scalar inequalities */</comment>
			<return>return <expr><name>DEFAULT_INEQ_SEL</name></expr>;</return>

		<default>default:</default>
			<comment type="block">/* all range operators should be handled above, but just in case */</comment>
			<return>return <expr><literal type="number">0.01</literal></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/*
 * rangesel -- restriction selectivity for range operators
 */</comment>
<function><type><name>Datum</name></type>
<name>rangesel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varRelid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>varonleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeType</name>  <modifier>*</modifier></type><name>constrange</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * If expression is not (variable op something) or (something op
	 * variable), then punt and return a default estimate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_restriction_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>other</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varonleft</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>default_range_selectivity</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't do anything useful if the something is not a constant, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>default_range_selectivity</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * All the range operators are strict, so we can cope with a NULL constant
	 * right away.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If var is on the right, commute the operator, so that we can assume the
	 * var is on the left in what follows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>varonleft</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we have other Op var, commute to make var Op other */</comment>
		<expr_stmt><expr><name>operator</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>operator</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use default selectivity (should we raise an error instead?) */</comment>
			<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>default_range_selectivity</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * OK, there's a Var and a Const we're dealing with here.  We need the
	 * Const to be of same range type as the column, else we can't do anything
	 * useful. (Such cases will likely fail at runtime, but here we'd rather
	 * just return a default estimate.)
	 *
	 * If the operator is "range @&gt; element", the constant should be of the
	 * element type of the range column. Convert it to a range that includes
	 * only that single point, so that we don't need special handling for that
	 * in what follows.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_RANGE_CONTAINS_ELEM_OP</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>.</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>consttype</name> <operator>==</operator> <name><name>typcache</name><operator>-&gt;</operator><name>rngelemtype</name><operator>-&gt;</operator><name>type_id</name></name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RangeBound</name></type>	<name>lower</name></decl>,
						<decl><type ref="prev"/><name>upper</name></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>lower</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>inclusive</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>val</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>infinite</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>upper</name><operator>.</operator><name>lower</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>constrange</name> <operator>=</operator> <call><name>range_serialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>upper</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_RANGE_ELEM_CONTAINED_OP</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Here, the Var is the elem, not the range.  For now we just punt and
		 * return the default estimate.  In future we could disassemble the
		 * range constant and apply scalarineqsel ...
		 */</comment>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>consttype</name> <operator>==</operator> <name><name>vardata</name><operator>.</operator><name>vartype</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Both sides are the same range type */</comment>
		<expr_stmt><expr><name>typcache</name> <operator>=</operator> <call><name>range_get_typcache</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>.</operator><name>vartype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>constrange</name> <operator>=</operator> <call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we got a valid constant on one side of the operator, proceed to
	 * estimate using statistics. Otherwise punt and return a default constant
	 * estimate.  Note that calc_rangesel need not handle
	 * OID_RANGE_ELEM_CONTAINED_OP.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>constrange</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>calc_rangesel</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><name>constrange</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>default_range_selectivity</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>calc_rangesel</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>,
			  <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>hist_selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float4</name></type>		<name>empty_frac</name></decl>,
				<decl><type ref="prev"/><name>null_frac</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * First look up the fraction of NULLs and empty ranges from pg_statistic.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>null_frac</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>

		<comment type="block">/* Try to get fraction of empty ranges */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
							 <argument><expr><name>STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM</name></expr></argument>,
							 <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>!=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid empty fraction statistic"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>	<comment type="block">/* shouldn't happen */</comment>
			<expr_stmt><expr><name>empty_frac</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* No empty fraction statistic. Assume no empty ranges. */</comment>
			<expr_stmt><expr><name>empty_frac</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * No stats are available. Follow through the calculations below
		 * anyway, assuming no NULLs and no empty ranges. This still allows us
		 * to give a better-than-nothing estimate based on whether the
		 * constant is an empty range or not.
		 */</comment>
		<expr_stmt><expr><name>null_frac</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>empty_frac</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>RangeIsEmpty</name><argument_list>(<argument><expr><name>constval</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * An empty range matches all ranges, all empty ranges, or nothing,
		 * depending on the operator
		 */</comment>
		<switch>switch <condition>(<expr><name>operator</name></expr>)</condition>
		<block>{<block_content>
				<comment type="block">/* these return false if either argument is empty */</comment>
			<case>case <expr><name>OID_RANGE_OVERLAP_OP</name></expr>:</case>
			<case>case <expr><name>OID_RANGE_OVERLAPS_LEFT_OP</name></expr>:</case>
			<case>case <expr><name>OID_RANGE_OVERLAPS_RIGHT_OP</name></expr>:</case>
			<case>case <expr><name>OID_RANGE_LEFT_OP</name></expr>:</case>
			<case>case <expr><name>OID_RANGE_RIGHT_OP</name></expr>:</case>
				<comment type="block">/* nothing is less than an empty range */</comment>
			<case>case <expr><name>OID_RANGE_LESS_OP</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* only empty ranges can be contained by an empty range */</comment>
			<case>case <expr><name>OID_RANGE_CONTAINED_OP</name></expr>:</case>
				<comment type="block">/* only empty ranges are &lt;= an empty range */</comment>
			<case>case <expr><name>OID_RANGE_LESS_EQUAL_OP</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>empty_frac</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* everything contains an empty range */</comment>
			<case>case <expr><name>OID_RANGE_CONTAINS_OP</name></expr>:</case>
				<comment type="block">/* everything is &gt;= an empty range */</comment>
			<case>case <expr><name>OID_RANGE_GREATER_EQUAL_OP</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* all non-empty ranges are &gt; an empty range */</comment>
			<case>case <expr><name>OID_RANGE_GREATER_OP</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>empty_frac</name></expr>;</expr_stmt>
				<break>break;</break>

				<comment type="block">/* an element cannot be empty */</comment>
			<case>case <expr><name>OID_RANGE_CONTAINS_ELEM_OP</name></expr>:</case>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected operator %u"</literal></expr></argument>, <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Calculate selectivity using bound histograms. If that fails for
		 * some reason, e.g no histogram in pg_statistic, use the default
		 * constant estimate for the fraction of non-empty values. This is
		 * still somewhat better than just returning the default estimate,
		 * because this still takes into account the fraction of empty and
		 * NULL tuples, if we had statistics for them.
		 */</comment>
		<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <call><name>calc_hist_selectivity</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>, <argument><expr><name>constval</name></expr></argument>,
										   <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>hist_selec</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <call><name>default_range_selectivity</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Now merge the results for the empty ranges and histogram
		 * calculations, realizing that the histogram covers only the
		 * non-null, non-empty values.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_RANGE_CONTAINED_OP</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* empty is contained by anything non-empty */</comment>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>empty_frac</name><operator>)</operator> <operator>*</operator> <name>hist_selec</name> <operator>+</operator> <name>empty_frac</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* with any other operator, empty Op non-empty matches nothing */</comment>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>empty_frac</name><operator>)</operator> <operator>*</operator> <name>hist_selec</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* all range operators are strict */</comment>
	<expr_stmt><expr><name>selec</name> <operator>*=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>null_frac</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* result should be in range, but make sure... */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate range operator selectivity using histograms of range bounds.
 *
 * This estimate is for the portion of values that are not empty and not
 * NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>calc_hist_selectivity</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>,
					  <parameter><decl><type><name>RangeType</name> <modifier>*</modifier></type><name>constval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>hslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>lslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nhist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist_lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist_upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>const_lower</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeBound</name></type>	<name>const_upper</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>empty</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>hist_selec</name></decl>;</decl_stmt>

	<comment type="block">/* Can't use the histogram with insecure range support functions */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>,
									   <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_cmp_proc_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>!</operator><call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>,
									   <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Try to get histogram of ranges */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		  <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
						   <argument><expr><name>STATISTIC_KIND_BOUNDS_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						   <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Convert histogram of ranges into histograms of its lower and upper
	 * bounds.
	 */</comment>
	<expr_stmt><expr><name>nhist</name> <operator>=</operator> <name><name>hslot</name><operator>.</operator><name>nvalues</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>hist_lower</name> <operator>=</operator> <operator>(</operator><name>RangeBound</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeBound</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nhist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>hist_upper</name> <operator>=</operator> <operator>(</operator><name>RangeBound</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RangeBound</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>nhist</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nhist</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><call><name>DatumGetRangeTypeP</name><argument_list>(<argument><expr><name><name>hslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hist_upper</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* The histogram should not contain any empty ranges */</comment>
		<if_stmt><if>if <condition>(<expr><name>empty</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"bounds histogram contains an empty range"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* @&gt; and @&lt; also need a histogram of range lengths */</comment>
	<if_stmt><if>if <condition>(<expr><name>operator</name> <operator>==</operator> <name>OID_RANGE_CONTAINS_OP</name> <operator>||</operator>
		<name>operator</name> <operator>==</operator> <name>OID_RANGE_CONTAINED_OP</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			  <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
							   <argument><expr><name>STATISTIC_KIND_RANGE_LENGTH_HISTOGRAM</name></expr></argument>,
							   <argument><expr><name>InvalidOid</name></expr></argument>,
							   <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1.0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* check that it's a histogram, not just a dummy entry */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lslot</name><operator>.</operator><name>nvalues</name></name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>-</operator><literal type="number">1.0</literal></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lslot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>lslot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Extract the bounds of the constant value. */</comment>
	<expr_stmt><expr><call><name>range_deserialize</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>constval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_upper</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>empty</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate selectivity comparing the lower or upper bound of the
	 * constant with the histogram of lower or upper bounds.
	 */</comment>
	<switch>switch <condition>(<expr><name>operator</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OID_RANGE_LESS_OP</name></expr>:</case>

			<comment type="block">/*
			 * The regular b-tree comparison operators (&lt;, &lt;=, &gt;, &gt;=) compare
			 * the lower bounds first, and the upper bounds for values with
			 * equal lower bounds. Estimate that by comparing the lower bounds
			 * only. This gives a fairly accurate estimate assuming there
			 * aren't many rows with a lower bound equal to the constant's
			 * lower bound.
			 */</comment>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>,
											 <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_LESS_EQUAL_OP</name></expr>:</case>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>,
											 <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_GREATER_OP</name></expr>:</case>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<literal type="number">1</literal> <operator>-</operator> <call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>,
												 <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_GREATER_EQUAL_OP</name></expr>:</case>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<literal type="number">1</literal> <operator>-</operator> <call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>,
												 <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_LEFT_OP</name></expr>:</case>
			<comment type="block">/* var &lt;&lt; const when upper(var) &lt; lower(const) */</comment>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>,
											 <argument><expr><name>hist_upper</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_RIGHT_OP</name></expr>:</case>
			<comment type="block">/* var &gt;&gt; const when lower(var) &gt; upper(const) */</comment>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<literal type="number">1</literal> <operator>-</operator> <call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_upper</name></expr></argument>,
												 <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_OVERLAPS_RIGHT_OP</name></expr>:</case>
			<comment type="block">/* compare lower bounds */</comment>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<literal type="number">1</literal> <operator>-</operator> <call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>,
												 <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_OVERLAPS_LEFT_OP</name></expr>:</case>
			<comment type="block">/* compare upper bounds */</comment>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_upper</name></expr></argument>,
											 <argument><expr><name>hist_upper</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_OVERLAP_OP</name></expr>:</case>
		<case>case <expr><name>OID_RANGE_CONTAINS_ELEM_OP</name></expr>:</case>

			<comment type="block">/*
			 * A &amp;&amp; B &lt;=&gt; NOT (A &lt;&lt; B OR A &gt;&gt; B).
			 *
			 * Since A &lt;&lt; B and A &gt;&gt; B are mutually exclusive events we can
			 * sum their probabilities to find probability of (A &lt;&lt; B OR A &gt;&gt;
			 * B).
			 *
			 * "range @&gt; elem" is equivalent to "range &amp;&amp; [elem,elem]". The
			 * caller already constructed the singular range from the element
			 * constant, so just treat it the same as &amp;&amp;.
			 */</comment>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>, <argument><expr><name>hist_upper</name></expr></argument>,
											 <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hist_selec</name> <operator>+=</operator>
				<operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_upper</name></expr></argument>, <argument><expr><name>hist_lower</name></expr></argument>,
													<argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>hist_selec</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_CONTAINS_OP</name></expr>:</case>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
				<call><name>calc_hist_selectivity_contains</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>const_upper</name></expr></argument>, <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>,
											   <argument><expr><name><name>lslot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>lslot</name><operator>.</operator><name>nvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>OID_RANGE_CONTAINED_OP</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>const_lower</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Lower bound no longer matters. Just estimate the fraction
				 * with an upper bound &lt;= const upper bound
				 */</comment>
				<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
					<call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_upper</name></expr></argument>,
												 <argument><expr><name>hist_upper</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>const_upper</name><operator>.</operator><name>infinite</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
					<literal type="number">1.0</literal> <operator>-</operator> <call><name>calc_hist_selectivity_scalar</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>,
													   <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>hist_selec</name> <operator>=</operator>
					<call><name>calc_hist_selectivity_contained</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>const_lower</name></expr></argument>,
													<argument><expr><operator>&amp;</operator><name>const_upper</name></expr></argument>, <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>nhist</name></expr></argument>,
													<argument><expr><name><name>lslot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>lslot</name><operator>.</operator><name>nvalues</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>

		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unknown range operator %u"</literal></expr></argument>, <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>lslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>hist_selec</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Look up the fraction of values less than (or equal, if 'equal' argument
 * is true) a given const in a histogram of range bounds.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>calc_hist_selectivity_scalar</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>constbound</name></decl></parameter>,
							 <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Find the histogram bin the given constant falls into. Estimate
	 * selectivity as the number of preceding whole bins.
	 */</comment>
	<expr_stmt><expr><name>index</name> <operator>=</operator> <call><name>rbound_bsearch</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>constbound</name></expr></argument>, <argument><expr><name>hist</name></expr></argument>, <argument><expr><name>hist_nvalues</name></expr></argument>, <argument><expr><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><name>Selectivity</name><operator>)</operator> <operator>(</operator><call><name>Max</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call><operator>)</operator> <operator>/</operator> <operator>(</operator><name>Selectivity</name><operator>)</operator> <operator>(</operator><name>hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Adjust using linear interpolation within the bin */</comment>
	<if_stmt><if>if <condition>(<expr><name>index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>index</name> <operator>&lt;</operator> <name>hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>+=</operator> <call><name>get_position</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>constbound</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hist</name><index>[<expr><name>index</name></expr>]</index></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name><name>hist</name><index>[<expr><name>index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call> <operator>/</operator> <operator>(</operator><name>Selectivity</name><operator>)</operator> <operator>(</operator><name>hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Binary search on an array of range bounds. Returns greatest index of range
 * bound in array which is less(less or equal) than given range bound. If all
 * range bounds in array are greater or equal(greater) than given range bound,
 * return -1. When "equal" flag is set conditions in brackets are used.
 *
 * This function is used in scalar operator selectivity estimation. Another
 * goal of this function is to find a histogram bin where to stop
 * interpolation of portion of bounds which are less or equal to given bound.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>rbound_bsearch</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>hist_length</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lower</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>upper</name> <init>= <expr><name>hist_length</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>cmp</name></decl>,
				<decl><type ref="prev"/><name>middle</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>lower</name> <operator>&lt;</operator> <name>upper</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>middle</name> <operator>=</operator> <operator>(</operator><name>lower</name> <operator>+</operator> <name>upper</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>cmp</name> <operator>=</operator> <call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hist</name><index>[<expr><name>middle</name></expr>]</index></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>cmp</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <operator>(</operator><name>equal</name> <operator>&amp;&amp;</operator> <name>cmp</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lower</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>upper</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>lower</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Binary search on length histogram. Returns greatest index of range length in
 * histogram which is less than (less than or equal) the given length value. If
 * all lengths in the histogram are greater than (greater than or equal) the
 * given length, returns -1.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>length_hist_bsearch</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>length_hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length_hist_nvalues</name></decl></parameter>,
					<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>lower</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>upper</name> <init>= <expr><name>length_hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>middle</name></decl>;</decl_stmt>

	<while>while <condition>(<expr><name>lower</name> <operator>&lt;</operator> <name>upper</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>middleval</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>middle</name> <operator>=</operator> <operator>(</operator><name>lower</name> <operator>+</operator> <name>upper</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>middleval</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>length_hist_values</name><index>[<expr><name>middle</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>middleval</name> <operator>&lt;</operator> <name>value</name> <operator>||</operator> <operator>(</operator><name>equal</name> <operator>&amp;&amp;</operator> <name>middleval</name> <operator>&lt;=</operator> <name>value</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>lower</name> <operator>=</operator> <name>middle</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>upper</name> <operator>=</operator> <name>middle</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>lower</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Get relative position of value in histogram bin in [0,1] range.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>get_position</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist1</name></decl></parameter>,
			 <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_subdiff</name> <init>= <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>position</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>hist1</name><operator>-&gt;</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>hist2</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>float8</name></type>		<name>bin_width</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Both bounds are finite. Assuming the subtype's comparison function
		 * works sanely, the value must be finite, too, because it lies
		 * somewhere between the bounds. If it doesn't, just return something.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>value</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0.5</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Can't interpolate without subdiff function */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>has_subdiff</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0.5</literal></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Calculate relative position using subdiff function. */</comment>
		<expr_stmt><expr><name>bin_width</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(
													 <argument><expr><operator>&amp;</operator><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name></name></expr></argument>,
													 <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
													 <argument><expr><name><name>hist2</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
													 <argument><expr><name><name>hist1</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>bin_width</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0.5</literal></expr>;</return></block_content></block></if></if_stmt>			<comment type="block">/* zero width bin */</comment>

		<expr_stmt><expr><name>position</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(
													<argument><expr><operator>&amp;</operator><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name></name></expr></argument>,
													<argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
													<argument><expr><name><name>value</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
													<argument><expr><name><name>hist1</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call>
			<operator>/</operator> <name>bin_width</name></expr>;</expr_stmt>

		<comment type="block">/* Relative position must be in [0,1] range */</comment>
		<expr_stmt><expr><name>position</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>position</name></expr></argument>, <argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>position</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>position</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>position</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>hist1</name><operator>-&gt;</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>hist2</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Lower bin boundary is -infinite, upper is finite. If the value is
		 * -infinite, return 0.0 to indicate it's equal to the lower bound.
		 * Otherwise return 1.0 to indicate it's infinitely far from the lower
		 * bound.
		 */</comment>
		<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>value</name><operator>-&gt;</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>value</name><operator>-&gt;</operator><name>lower</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0.0</literal></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>hist1</name><operator>-&gt;</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>hist2</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* same as above, but in reverse */</comment>
		<return>return <expr><operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>value</name><operator>-&gt;</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>value</name><operator>-&gt;</operator><name>lower</name></name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1.0</literal></expr> </then><else>: <expr><literal type="number">0.0</literal></expr></else></ternary><operator>)</operator></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If both bin boundaries are infinite, they should be equal to each
		 * other, and the value should also be infinite and equal to both
		 * bounds. (But don't Assert that, to avoid crashing if a user creates
		 * a datatype with a broken comparison function).
		 *
		 * Assume the value to lie in the middle of the infinite bounds.
		 */</comment>
		<return>return <expr><literal type="number">0.5</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Get relative position of value in a length histogram bin in [0,1] range.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>get_len_position</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>hist1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>hist2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isinf</name><argument_list>(<argument><expr><name>hist1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isinf</name><argument_list>(<argument><expr><name>hist2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Both bounds are finite. The value should be finite too, because it
		 * lies somewhere between the bounds. If it doesn't, just return
		 * something.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0.5</literal></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><literal type="number">1.0</literal> <operator>-</operator> <operator>(</operator><name>hist2</name> <operator>-</operator> <name>value</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>hist2</name> <operator>-</operator> <name>hist1</name><operator>)</operator></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>hist1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>isinf</name><argument_list>(<argument><expr><name>hist2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Lower bin boundary is -infinite, upper is finite. Return 1.0 to
		 * indicate the value is infinitely far from the lower bound.
		 */</comment>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>hist1</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>hist2</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* same as above, but in reverse */</comment>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If both bin boundaries are infinite, they should be equal to each
		 * other, and the value should also be infinite and equal to both
		 * bounds. (But don't Assert that, to avoid crashing unnecessarily if
		 * the caller messes up)
		 *
		 * Assume the value to lie in the middle of the infinite bounds.
		 */</comment>
		<return>return <expr><literal type="number">0.5</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Measure distance between two range bounds.
 */</comment>
<function><type><specifier>static</specifier> <name>float8</name></type>
<name>get_distance</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>bound1</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>bound2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_subdiff</name> <init>= <expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>bound1</name><operator>-&gt;</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>bound2</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No bounds are infinite, use subdiff function or return default
		 * value of 1.0 if no subdiff is available.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>has_subdiff</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return
				<expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>typcache</name><operator>-&gt;</operator><name>rng_subdiff_finfo</name></name></expr></argument>,
												 <argument><expr><name><name>typcache</name><operator>-&gt;</operator><name>rng_collation</name></name></expr></argument>,
												 <argument><expr><name><name>bound2</name><operator>-&gt;</operator><name>val</name></name></expr></argument>,
												 <argument><expr><name><name>bound1</name><operator>-&gt;</operator><name>val</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>bound1</name><operator>-&gt;</operator><name>infinite</name></name> <operator>&amp;&amp;</operator> <name><name>bound2</name><operator>-&gt;</operator><name>infinite</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Both bounds are infinite */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>bound1</name><operator>-&gt;</operator><name>lower</name></name> <operator>==</operator> <name><name>bound2</name><operator>-&gt;</operator><name>lower</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* One bound is infinite, another is not */</comment>
		<return>return <expr><call><name>get_float8_infinity</name><argument_list>()</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate the average of function P(x), in the interval [length1, length2],
 * where P(x) is the fraction of tuples with length &lt; x (or length &lt;= x if
 * 'equal' is true).
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>calc_length_hist_frac</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>length_hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length_hist_nvalues</name></decl></parameter>,
					  <parameter><decl><type><name>double</name></type> <name>length1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>length2</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>equal</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>frac</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>A</name></decl>,
				<decl><type ref="prev"/><name>B</name></decl>,
				<decl><type ref="prev"/><name>PA</name></decl>,
				<decl><type ref="prev"/><name>PB</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>pos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>area</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>length2</name> <operator>&gt;=</operator> <name>length1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>length2</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* shouldn't happen, but doesn't hurt to check */</comment>

	<comment type="block">/* All lengths in the table are &lt;= infinite. */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>length2</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>equal</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*----------
	 * The average of a function between A and B can be calculated by the
	 * formula:
	 *
	 *			B
	 *	  1		/
	 * -------	| P(x)dx
	 *	B - A	/
	 *			A
	 *
	 * The geometrical interpretation of the integral is the area under the
	 * graph of P(x). P(x) is defined by the length histogram. We calculate
	 * the area in a piecewise fashion, iterating through the length histogram
	 * bins. Each bin is a trapezoid:
	 *
	 *		 P(x2)
	 *		  /|
	 *		 / |
	 * P(x1)/  |
	 *	   |   |
	 *	   |   |
	 *	---+---+--
	 *	   x1  x2
	 *
	 * where x1 and x2 are the boundaries of the current histogram, and P(x1)
	 * and P(x1) are the cumulative fraction of tuples at the boundaries.
	 *
	 * The area of each trapezoid is 1/2 * (P(x2) + P(x1)) * (x2 - x1)
	 *
	 * The first bin contains the lower bound passed by the caller, so we
	 * use linear interpolation between the previous and next histogram bin
	 * boundary to calculate P(x1). Likewise for the last bin: we use linear
	 * interpolation to calculate P(x2). For the bins in between, x1 and x2
	 * lie on histogram bin boundaries, so P(x1) and P(x2) are simply:
	 * P(x1) =	  (bin index) / (number of bins)
	 * P(x2) = (bin index + 1 / (number of bins)
	 */</comment>

	<comment type="block">/* First bin, the one that contains lower bound */</comment>
	<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>length_hist_bsearch</name><argument_list>(<argument><expr><name>length_hist_values</name></expr></argument>, <argument><expr><name>length_hist_nvalues</name></expr></argument>, <argument><expr><name>length1</name></expr></argument>, <argument><expr><name>equal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>length_hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* interpolate length1's position in the bin */</comment>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>get_len_position</name><argument_list>(<argument><expr><name>length1</name></expr></argument>,
							   <argument><expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>length_hist_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
							   <argument><expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>length_hist_values</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>PB</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>i</name><operator>)</operator> <operator>+</operator> <name>pos</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>length_hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><name>B</name> <operator>=</operator> <name>length1</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * In the degenerate case that length1 == length2, simply return
	 * P(length1). This is not merely an optimization: if length1 == length2,
	 * we'd divide by zero later on.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>length2</name> <operator>==</operator> <name>length1</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>PB</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Loop through all the bins, until we hit the last bin, the one that
	 * contains the upper bound. (if lower and upper bounds are in the same
	 * bin, this falls out immediately)
	 */</comment>
	<expr_stmt><expr><name>area</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<for>for <control>(<init>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>length_hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>bin_upper</name> <init>= <expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>length_hist_values</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* check if we've reached the last bin */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>bin_upper</name> <operator>&lt;</operator> <name>length2</name> <operator>||</operator> <operator>(</operator><name>equal</name> <operator>&amp;&amp;</operator> <name>bin_upper</name> <operator>&lt;=</operator> <name>length2</name><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<comment type="block">/* the upper bound of previous bin is the lower bound of this bin */</comment>
		<expr_stmt><expr><name>A</name> <operator>=</operator> <name>B</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PA</name> <operator>=</operator> <name>PB</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>B</name> <operator>=</operator> <name>bin_upper</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>PB</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>i</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>length_hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add the area of this trapezoid to the total. The point of the
		 * if-check is to avoid NaN, in the corner case that PA == PB == 0,
		 * and B - A == Inf. The area of a zero-height trapezoid (PA == PB ==
		 * 0) is zero, regardless of the width (B - A).
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>PA</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>PB</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>area</name> <operator>+=</operator> <literal type="number">0.5</literal> <operator>*</operator> <operator>(</operator><name>PB</name> <operator>+</operator> <name>PA</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>B</name> <operator>-</operator> <name>A</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/* Last bin */</comment>
	<expr_stmt><expr><name>A</name> <operator>=</operator> <name>B</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>PA</name> <operator>=</operator> <name>PB</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>B</name> <operator>=</operator> <name>length2</name></expr>;</expr_stmt>				<comment type="block">/* last bin ends at the query upper bound */</comment>
	<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;=</operator> <name>length_hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>length_hist_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>length_hist_values</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>pos</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>pos</name> <operator>=</operator> <call><name>get_len_position</name><argument_list>(<argument><expr><name>length2</name></expr></argument>, <argument><expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>length_hist_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name><name>length_hist_values</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><name>PB</name> <operator>=</operator> <operator>(</operator><operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>i</name><operator>)</operator> <operator>+</operator> <name>pos</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>length_hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>PA</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator> <name>PB</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>area</name> <operator>+=</operator> <literal type="number">0.5</literal> <operator>*</operator> <operator>(</operator><name>PB</name> <operator>+</operator> <name>PA</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>B</name> <operator>-</operator> <name>A</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Ok, we have calculated the area, ie. the integral. Divide by width to
	 * get the requested average.
	 *
	 * Avoid NaN arising from infinite / infinite. This happens at least if
	 * length2 is infinite. It's not clear what the correct value would be in
	 * that case, so 0.5 seems as good as any value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isinf</name><argument_list>(<argument><expr><name>area</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>length2</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>frac</name> <operator>=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>frac</name> <operator>=</operator> <name>area</name> <operator>/</operator> <operator>(</operator><name>length2</name> <operator>-</operator> <name>length1</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<return>return <expr><name>frac</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate selectivity of "var &lt;@ const" operator, ie. estimate the fraction
 * of ranges that fall within the constant lower and upper bounds. This uses
 * the histograms of range lower bounds and range lengths, on the assumption
 * that the range lengths are independent of the lower bounds.
 *
 * The caller has already checked that constant lower and upper bounds are
 * finite.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>calc_hist_selectivity_contained</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
								<parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>lower</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>upper</name></decl></parameter>,
								<parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist_lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>,
								<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>length_hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length_hist_nvalues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>upper_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>prev_dist</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>bin_width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>upper_bin_width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>sum_frac</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Begin by finding the bin containing the upper bound, in the lower bound
	 * histogram. Any range with a lower bound &gt; constant upper bound can't
	 * match, ie. there are no matches in bins greater than upper_index.
	 */</comment>
	<expr_stmt><expr><name><name>upper</name><operator>-&gt;</operator><name>inclusive</name></name> <operator>=</operator> <operator>!</operator><name><name>upper</name><operator>-&gt;</operator><name>inclusive</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>upper</name><operator>-&gt;</operator><name>lower</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>upper_index</name> <operator>=</operator> <call><name>rbound_bsearch</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>, <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>hist_nvalues</name></expr></argument>,
								 <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate upper_bin_width, ie. the fraction of the (upper_index,
	 * upper_index + 1) bin which is greater than upper bound of query range
	 * using linear interpolation of subdiff function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>upper_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>upper_index</name> <operator>&lt;</operator> <name>hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>upper_bin_width</name> <operator>=</operator> <call><name>get_position</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>upper_index</name></expr>]</index></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>upper_index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>upper_bin_width</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * In the loop, dist and prev_dist are the distance of the "current" bin's
	 * lower and upper bounds from the constant upper bound.
	 *
	 * bin_width represents the width of the current bin. Normally it is 1.0,
	 * meaning a full width bin, but can be less in the corner cases: start
	 * and end of the loop. We start with bin_width = upper_bin_width, because
	 * we begin at the bin containing the upper bound.
	 */</comment>
	<expr_stmt><expr><name>prev_dist</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>bin_width</name> <operator>=</operator> <name>upper_bin_width</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>sum_frac</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>upper_index</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>dist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>length_hist_frac</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>final_bin</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * dist -- distance from upper bound of query range to lower bound of
		 * the current bin in the lower bound histogram. Or to the lower bound
		 * of the constant range, if this is the final bin, containing the
		 * constant lower bound.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>range_cmp_bounds</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>lower</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>get_distance</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Subtract from bin_width the portion of this bin that we want to
			 * ignore.
			 */</comment>
			<expr_stmt><expr><name>bin_width</name> <operator>-=</operator> <call><name>get_position</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>bin_width</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>bin_width</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>final_bin</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>get_distance</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Estimate the fraction of tuples in this bin that are narrow enough
		 * to not exceed the distance to the upper bound of the query range.
		 */</comment>
		<expr_stmt><expr><name>length_hist_frac</name> <operator>=</operator> <call><name>calc_length_hist_frac</name><argument_list>(<argument><expr><name>length_hist_values</name></expr></argument>,
												 <argument><expr><name>length_hist_nvalues</name></expr></argument>,
												 <argument><expr><name>prev_dist</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Add the fraction of tuples in this bin, with a suitable length, to
		 * the total.
		 */</comment>
		<expr_stmt><expr><name>sum_frac</name> <operator>+=</operator> <name>length_hist_frac</name> <operator>*</operator> <name>bin_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>final_bin</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>bin_width</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_dist</name> <operator>=</operator> <name>dist</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>sum_frac</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Calculate selectivity of "var @&gt; const" operator, ie. estimate the fraction
 * of ranges that contain the constant lower and upper bounds. This uses
 * the histograms of range lower bounds and range lengths, on the assumption
 * that the range lengths are independent of the lower bounds.
 *
 * Note, this is "var @&gt; const", ie. estimate the fraction of ranges that
 * contain the constant lower and upper bounds.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>calc_hist_selectivity_contains</name><parameter_list>(<parameter><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typcache</name></decl></parameter>,
							   <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>lower</name></decl></parameter>, <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>upper</name></decl></parameter>,
							   <parameter><decl><type><name>RangeBound</name> <modifier>*</modifier></type><name>hist_lower</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>,
							   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>length_hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>length_hist_nvalues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>lower_index</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>bin_width</name></decl>,
				<decl><type ref="prev"/><name>lower_bin_width</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>sum_frac</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>prev_dist</name></decl>;</decl_stmt>

	<comment type="block">/* Find the bin containing the lower bound of query range. */</comment>
	<expr_stmt><expr><name>lower_index</name> <operator>=</operator> <call><name>rbound_bsearch</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>, <argument><expr><name>hist_lower</name></expr></argument>, <argument><expr><name>hist_nvalues</name></expr></argument>,
								 <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate lower_bin_width, ie. the fraction of the of (lower_index,
	 * lower_index + 1) bin which is greater than lower bound of query range
	 * using linear interpolation of subdiff function.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>lower_index</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>lower_index</name> <operator>&lt;</operator> <name>hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>lower_bin_width</name> <operator>=</operator> <call><name>get_position</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>lower_index</name></expr>]</index></name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>lower_index</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>lower_bin_width</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Loop through all the lower bound bins, smaller than the query lower
	 * bound. In the loop, dist and prev_dist are the distance of the
	 * "current" bin's lower and upper bounds from the constant upper bound.
	 * We begin from query lower bound, and walk backwards, so the first bin's
	 * upper bound is the query lower bound, and its distance to the query
	 * upper bound is the length of the query range.
	 *
	 * bin_width represents the width of the current bin. Normally it is 1.0,
	 * meaning a full width bin, except for the first bin, which is only
	 * counted up to the constant lower bound.
	 */</comment>
	<expr_stmt><expr><name>prev_dist</name> <operator>=</operator> <call><name>get_distance</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><name>lower</name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sum_frac</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>bin_width</name> <operator>=</operator> <name>lower_bin_width</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>lower_index</name></expr>;</init> <condition><expr><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>i</name><operator>--</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>float8</name></type>		<name>dist</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>length_hist_frac</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * dist -- distance from upper bound of query range to current value
		 * of lower bound histogram or lower bound of query range (if we've
		 * reach it).
		 */</comment>
		<expr_stmt><expr><name>dist</name> <operator>=</operator> <call><name>get_distance</name><argument_list>(<argument><expr><name>typcache</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>hist_lower</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>upper</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Get average fraction of length histogram which covers intervals
		 * longer than (or equal to) distance to upper bound of query range.
		 */</comment>
		<expr_stmt><expr><name>length_hist_frac</name> <operator>=</operator>
			<literal type="number">1.0</literal> <operator>-</operator> <call><name>calc_length_hist_frac</name><argument_list>(<argument><expr><name>length_hist_values</name></expr></argument>,
										<argument><expr><name>length_hist_nvalues</name></expr></argument>,
										<argument><expr><name>prev_dist</name></expr></argument>, <argument><expr><name>dist</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>sum_frac</name> <operator>+=</operator> <name>length_hist_frac</name> <operator>*</operator> <name>bin_width</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>hist_nvalues</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

		<expr_stmt><expr><name>bin_width</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>prev_dist</name> <operator>=</operator> <name>dist</name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>sum_frac</name></expr>;</return>
</block_content>}</block></function>
</unit>
