<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/selfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * selfuncs.c
 *	  Selectivity functions and index cost estimation functions for
 *	  standard operators and index access methods.
 *
 *	  Selectivity routines are registered in the pg_operator catalog
 *	  in the "oprrest" and "oprjoin" attributes.
 *
 *	  Index cost functions are located via the index AM's API struct,
 *	  which is obtained from the handler function registered in pg_am.
 *
 * Portions Copyright (c) 2006-2009, Greenplum inc
 * Portions Copyright (c) 2012-Present VMware, Inc. or its affiliates.
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/selfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*----------
 * Operator selectivity estimation functions are called to estimate the
 * selectivity of WHERE clauses whose top-level operator is their operator.
 * We divide the problem into two cases:
 *		Restriction clause estimation: the clause involves vars of just
 *			one relation.
 *		Join clause estimation: the clause involves vars of multiple rels.
 * Join selectivity estimation is far more difficult and usually less accurate
 * than restriction estimation.
 *
 * When dealing with the inner scan of a nestloop join, we consider the
 * join's joinclauses as restriction clauses for the inner relation, and
 * treat vars of the outer relation as parameters (a/k/a constants of unknown
 * values).  So, restriction estimators need to be able to accept an argument
 * telling which relation is to be treated as the variable.
 *
 * The call convention for a restriction estimator (oprrest function) is
 *
 *		Selectivity oprrest (PlannerInfo *root,
 *							 Oid operator,
 *							 List *args,
 *							 int varRelid);
 *
 * root: general information about the query (rtable and RelOptInfo lists
 * are particularly important for the estimator).
 * operator: OID of the specific operator in question.
 * args: argument list from the operator clause.
 * varRelid: if not zero, the relid (rtable index) of the relation to
 * be treated as the variable relation.  May be zero if the args list
 * is known to contain vars of only one relation.
 *
 * This is represented at the SQL level (in pg_proc) as
 *
 *		float8 oprrest (internal, oid, internal, int4);
 *
 * The result is a selectivity, that is, a fraction (0 to 1) of the rows
 * of the relation that are expected to produce a TRUE result for the
 * given operator.
 *
 * The call convention for a join estimator (oprjoin function) is similar
 * except that varRelid is not needed, and instead join information is
 * supplied:
 *
 *		Selectivity oprjoin (PlannerInfo *root,
 *							 Oid operator,
 *							 List *args,
 *							 JoinType jointype,
 *							 SpecialJoinInfo *sjinfo);
 *
 *		float8 oprjoin (internal, oid, internal, int2, internal);
 *
 * (Before Postgres 8.4, join estimators had only the first four of these
 * parameters.  That signature is still allowed, but deprecated.)  The
 * relationship between jointype and sjinfo is explained in the comments for
 * clause_selectivity() --- the short version is that jointype is usually
 * best ignored in favor of examining sjinfo.
 *
 * Join selectivity for regular inner and outer joins is defined as the
 * fraction (0 to 1) of the cross product of the relations that is expected
 * to produce a TRUE result for the given operator.  For both semi and anti
 * joins, however, the selectivity is defined as the fraction of the left-hand
 * side relation's rows that are expected to have a match (ie, at least one
 * row with a TRUE result) in the right-hand side.
 *
 * For both oprrest and oprjoin functions, the operator's input collation OID
 * (if any) is passed using the standard fmgr mechanism, so that the estimator
 * function can fetch it with PG_GET_COLLATION().  Note, however, that all
 * statistics in pg_statistic are currently built using the relevant column's
 * collation.  Thus, in most cases where we are looking at statistics, we
 * should ignore the operator collation and use the stats entry's collation.
 * We expect that the error induced by doing this is usually not large enough
 * to justify complicating matters.  In any case, doing otherwise would yield
 * entirely garbage results for ordered stats data such as histograms.
 *----------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/brin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/gin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/index.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_am.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic_ext.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/nodeAgg.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/makefuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"nodes/nodeFuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/clauses.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/cost.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/optimizer.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/pathnode.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/paths.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/plancat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_clause.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parsetree.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"statistics/statistics.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/index_selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/spccache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/timestamp.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/typcache.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbgroup.h"</cpp:file></cpp:include> <comment type="block">/* cdbpathlocus_collocates_expressions */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbutil.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"optimizer/restrictinfo.h"</cpp:file></cpp:include>

<comment type="block">/* Hooks for plugins to get control when we ask for stats */</comment>
<decl_stmt><decl><type><name>get_relation_stats_hook_type</name></type> <name>get_relation_stats_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><name>get_index_stats_hook_type</name></type> <name>get_index_stats_hook</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>eqsel_internal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>negate</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>eqjoinsel_inner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfuncoid</name></decl></parameter>,
							  <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata1</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata2</name></decl></parameter>,
							  <parameter><decl><type><name>double</name></type> <name>nd1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>nd2</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>isdefault1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdefault2</name></decl></parameter>,
							  <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot1</name></decl></parameter>, <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot2</name></decl></parameter>,
							  <parameter><decl><type><name>Form_pg_statistic</name></type> <name>stats1</name></decl></parameter>, <parameter><decl><type><name>Form_pg_statistic</name></type> <name>stats2</name></decl></parameter>,
							  <parameter><decl><type><name>bool</name></type> <name>have_mcvs1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>have_mcvs2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>eqjoinsel_semi</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfuncoid</name></decl></parameter>,
							 <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata1</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata2</name></decl></parameter>,
							 <parameter><decl><type><name>double</name></type> <name>nd1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>nd2</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>isdefault1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdefault2</name></decl></parameter>,
							 <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot1</name></decl></parameter>, <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot2</name></decl></parameter>,
							 <parameter><decl><type><name>Form_pg_statistic</name></type> <name>stats1</name></decl></parameter>, <parameter><decl><type><name>Form_pg_statistic</name></type> <name>stats2</name></decl></parameter>,
							 <parameter><decl><type><name>bool</name></type> <name>have_mcvs1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>have_mcvs2</name></decl></parameter>,
							 <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>estimate_multivariate_ndistinct</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
											<parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>varinfos</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>ndistinct</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>convert_to_scalar</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valuetypid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledvalue</name></decl></parameter>,
							  <parameter><decl><type><name>Datum</name></type> <name>lobound</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>hibound</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>boundstypid</name></decl></parameter>,
							  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledlobound</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledhibound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>convert_numeric_to_scalar</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>failure</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convert_string_to_scalar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
									 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledvalue</name></decl></parameter>,
									 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lobound</name></decl></parameter>,
									 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledlobound</name></decl></parameter>,
									 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hibound</name></decl></parameter>,
									 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledhibound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>convert_bytea_to_scalar</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
									<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledvalue</name></decl></parameter>,
									<parameter><decl><type><name>Datum</name></type> <name>lobound</name></decl></parameter>,
									<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledlobound</name></decl></parameter>,
									<parameter><decl><type><name>Datum</name></type> <name>hibound</name></decl></parameter>,
									<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledhibound</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>convert_one_string_to_scalar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
										   <parameter><decl><type><name>int</name></type> <name>rangelo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangehi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>double</name></type> <name>convert_one_bytea_to_scalar</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>valuelen</name></decl></parameter>,
										  <parameter><decl><type><name>int</name></type> <name>rangelo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangehi</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>convert_string_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>,
								  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>failure</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>examine_simple_variable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
									<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>get_variable_range</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>,
							   <parameter><decl><type><name>Oid</name></type> <name>sortop</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>get_actual_variable_range</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
									  <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>,
									  <parameter><decl><type><name>Oid</name></type> <name>sortop</name></decl></parameter>,
									  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type><name>find_join_input_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>try_fetch_rel_stats</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>,
								<parameter><decl><type><name>VariableStatData</name><modifier>*</modifier></type> <name>vardata</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>try_fetch_largest_child_stats</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>parent_rti</name></decl></parameter>,
										  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name><modifier>*</modifier></type> <name>vardata</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/*
 *		eqsel			- Selectivity of "=" for any data types.
 *
 * Note: this routine is also used to estimate selectivity for some
 * operators that are not "=" but have comparable selectivity behavior,
 * such as "~=" (geometric approximate-match).  Even for "=", we must
 * keep in mind that the left and right datatypes may differ.
 */</comment>
<function><type><name>Datum</name></type>
<name>eqsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <call><name>eqsel_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Common code for eqsel() and neqsel()
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>eqsel_internal</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>negate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varRelid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>varonleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * When asked about &lt;&gt;, we do the estimation using the corresponding =
	 * operator, then convert to &lt;&gt; via "1.0 - eq_selectivity - nullfrac".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>operator</name> <operator>=</operator> <call><name>get_negator</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use default selectivity (should we raise an error instead?) */</comment>
			<return>return <expr><literal type="number">1.0</literal> <operator>-</operator> <name>DEFAULT_EQ_SEL</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If expression is not variable = something or something = variable, then
	 * punt and return a default estimate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_restriction_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>other</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varonleft</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><ternary><condition><expr><name>negate</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>DEFAULT_EQ_SEL</name><operator>)</operator></expr> </then><else>: <expr><name>DEFAULT_EQ_SEL</name></expr></else></ternary></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We can do a lot better if the something is a constant.  (Note: the
	 * Const might result from estimation rather than being a simple constant
	 * in the query.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>var_eq_const</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>,
							 <argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>,
							 <argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr></argument>,
							 <argument><expr><name>varonleft</name></expr></argument>, <argument><expr><name>negate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>var_eq_non_const</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>, <argument><expr><name>other</name></expr></argument>,
								 <argument><expr><name>varonleft</name></expr></argument>, <argument><expr><name>negate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * var_eq_const --- eqsel for var = const case
 *
 * This is exported so that some other estimation functions can use it.
 */</comment>
<function><type><name>double</name></type>
<name>var_eq_const</name><parameter_list>(<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>,
			 <parameter><decl><type><name>Datum</name></type> <name>constval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>constisnull</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>varonleft</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>negate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfuncoid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the constant is NULL, assume operator is strict and return zero, ie,
	 * operator will never return TRUE.  (It's zero even for a negator op.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Grab the nullfrac for use below.  Note we allow use of nullfrac
	 * regardless of security check.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullfrac</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we matched the var to a unique index or DISTINCT clause, assume
	 * there is exactly one match regardless of anything else.  (This is
	 * slightly bogus, since the index or clause's equality operator might be
	 * different from ours, but it's much more likely to be right than
	 * ignoring the information.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>isunique</name></name> <operator>&amp;&amp;</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>,
										   <argument><expr><operator>(</operator><name>opfuncoid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>match</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Is the constant "=" to any of the column's most common values?
		 * (Although the given operator may not really be "=", we will assume
		 * that seeing whether it returns TRUE is an appropriate test.  If you
		 * don't like this, maybe you shouldn't be using eqsel for your
		 * operator...)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
							 <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>eqproc</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>opfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<comment type="block">/* be careful to apply operator right way 'round */</comment>
				<if_stmt><if>if <condition>(<expr><name>varonleft</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eqproc</name></expr></argument>,
														   <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
														   <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
														   <argument><expr><name>constval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>match</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eqproc</name></expr></argument>,
														   <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
														   <argument><expr><name>constval</name></expr></argument>,
														   <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* no most-common-value info available */</comment>
			<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>				<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>match</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Constant is "=" to this common value.  We know selectivity
			 * exactly (or as exactly as ANALYZE could calculate it, anyway).
			 */</comment>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Comparison is against a constant that is neither NULL nor any
			 * of the common values.  Its selectivity cannot be more than
			 * this:
			 */</comment>
			<decl_stmt><decl><type><name>double</name></type>		<name>sumcommon</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>otherdistinct</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot</name><operator>.</operator><name>nnumbers</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
				<expr_stmt><expr><name>sumcommon</name> <operator>+=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>sumcommon</name> <operator>-</operator> <name>nullfrac</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * and in fact it's probably a good deal less. We approximate that
			 * all the not-common values share this remaining fraction
			 * equally, so we divide by the number of other distinct values.
			 */</comment>
			<expr_stmt><expr><name>otherdistinct</name> <operator>=</operator> <call><name>get_variable_numdistinct</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdefault</name></expr></argument>)</argument_list></call> <operator>-</operator>
				<name><name>sslot</name><operator>.</operator><name>nnumbers</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>otherdistinct</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>/=</operator> <name>otherdistinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Another cross-check: selectivity shouldn't be estimated as more
			 * than the least common "most common value".
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>selec</name> <operator>&gt;</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * No ANALYZE stats available, so make a guess using estimated number
		 * of distinct values and assuming they are equally common. (The guess
		 * is unlikely to be very good, but we do know a few special cases.)
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <call><name>get_variable_numdistinct</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* now adjust if we wanted &lt;&gt; rather than = */</comment>
	<if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>selec</name> <operator>-</operator> <name>nullfrac</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* result should be in range, but make sure... */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * var_eq_non_const --- eqsel for var = something-other-than-const case
 *
 * This is exported so that some other estimation functions can use it.
 */</comment>
<function><type><name>double</name></type>
<name>var_eq_non_const</name><parameter_list>(<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>,
				 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>other</name></decl></parameter>,
				 <parameter><decl><type><name>bool</name></type> <name>varonleft</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>negate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isdefault</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Grab the nullfrac for use below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullfrac</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we matched the var to a unique index or DISTINCT clause, assume
	 * there is exactly one match regardless of anything else.  (This is
	 * slightly bogus, since the index or clause's equality operator might be
	 * different from ours, but it's much more likely to be right than
	 * ignoring the information.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>isunique</name></name> <operator>&amp;&amp;</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>ndistinct</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Search is for a value that we do not know a priori, but we will
		 * assume it is not NULL.  Estimate the selectivity as non-null
		 * fraction divided by number of distinct values, so that we get a
		 * result averaged over all possible values whether common or
		 * uncommon.  (Essentially, we are assuming that the not-yet-known
		 * comparison value is equally likely to be any of the possible
		 * values, regardless of their frequency in the table.  Is that a good
		 * idea?)
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <call><name>get_variable_numdistinct</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ndistinct</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>/=</operator> <name>ndistinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Cross-check: selectivity should never be estimated as more than the
		 * most common value's.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
							 <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>selec</name> <operator>&gt;</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * No ANALYZE stats available, so make a guess using estimated number
		 * of distinct values and assuming they are equally common. (The guess
		 * is unlikely to be very good, but we do know a few special cases.)
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <call><name>get_variable_numdistinct</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* now adjust if we wanted &lt;&gt; rather than = */</comment>
	<if_stmt><if>if <condition>(<expr><name>negate</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>selec</name> <operator>-</operator> <name>nullfrac</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* result should be in range, but make sure... */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		neqsel			- Selectivity of "!=" for any data types.
 *
 * This routine is also used for some operators that are not "!="
 * but have comparable selectivity behavior.  See above comments
 * for eqsel().
 */</comment>
<function><type><name>Datum</name></type>
<name>neqsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <call><name>eqsel_internal</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *	scalarineqsel		- Selectivity of "&lt;", "&lt;=", "&gt;", "&gt;=" for scalars.
 *
 * This is the guts of scalarltsel/scalarlesel/scalargtsel/scalargesel.
 * The isgt and iseq flags distinguish which of the four cases apply.
 *
 * The caller has commuted the clause, if necessary, so that we can treat
 * the variable as being on the left.  The caller must also make sure that
 * the other side of the clause is a non-null Const, and dissect that into
 * a value and datatype.  (This definition simplifies some callers that
 * want to estimate against a computed value instead of a Const node.)
 *
 * This routine works for any datatype (or pair of datatypes) known to
 * convert_to_scalar().  If it is applied to some other datatype,
 * it will return an approximate estimate based on assuming that the constant
 * value falls in the middle of the bin identified by binary search.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>scalarineqsel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isgt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iseq</name></decl></parameter>,
			  <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>constval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>consttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>opproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>mcv_selec</name></decl>,
				<decl><type ref="prev"/><name>hist_selec</name></decl>,
				<decl><type ref="prev"/><name>sumcommon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * No stats are available.  Typically this means we have to fall back
		 * on the default estimate; but if the variable is CTID then we can
		 * make an estimate based on comparing the constant to the table size.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>var</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>vardata</name><operator>-&gt;</operator><name>var</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>==</operator> <name>SelfItemPointerAttributeNumber</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ItemPointer</name></type> <name>itemptr</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>block</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>density</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the relation's empty, we're going to include all of it.
			 * (This is mostly to avoid divide-by-zero below.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>itemptr</name> <operator>=</operator> <operator>(</operator><name>ItemPointer</name><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>constval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>block</name> <operator>=</operator> <call><name>ItemPointerGetBlockNumberNoCheck</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Determine the average number of tuples per page (density).
			 *
			 * Since the last page will, on average, be only half full, we can
			 * estimate it to have half as many tuples as earlier pages.  So
			 * give it half the weight of a regular page.
			 */</comment>
			<expr_stmt><expr><name>density</name> <operator>=</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <operator>(</operator><name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>-</operator> <literal type="number">0.5</literal><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/* If target is the last page, use half the density. */</comment>
			<if_stmt><if>if <condition>(<expr><name>block</name> <operator>&gt;=</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>-</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>density</name> <operator>*=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Using the average tuples per page, calculate how far into the
			 * page the itemptr is likely to be and adjust block accordingly,
			 * by adding that fraction of a whole block (but never more than a
			 * whole block, no matter how high the itemptr's offset is).  Here
			 * we are ignoring the possibility of dead-tuple line pointers,
			 * which is fairly bogus, but we lack the info to do better.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>density</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OffsetNumber</name></type> <name>offset</name> <init>= <expr><call><name>ItemPointerGetOffsetNumberNoCheck</name><argument_list>(<argument><expr><name>itemptr</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>block</name> <operator>+=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>offset</name> <operator>/</operator> <name>density</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/*
			 * Convert relative block number to selectivity.  Again, the last
			 * page has only half weight.
			 */</comment>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>block</name> <operator>/</operator> <operator>(</operator><name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>pages</name></name> <operator>-</operator> <literal type="number">0.5</literal><operator>)</operator></expr>;</expr_stmt>

			<comment type="block">/*
			 * The calculation so far gave us a selectivity for the "&lt;=" case.
			 * We'll have one less tuple for "&lt;" and one additional tuple for
			 * "&gt;=", the latter of which we'll reverse the selectivity for
			 * below, so we can simply subtract one tuple for both cases.  The
			 * cases that need this adjustment can be identified by iseq being
			 * equal to isgt.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>iseq</name> <operator>==</operator> <name>isgt</name> <operator>&amp;&amp;</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>-=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>/</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/* Finally, reverse the selectivity for the "&gt;", "&gt;=" cases. */</comment>
			<if_stmt><if>if <condition>(<expr><name>isgt</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>selec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><name>selec</name></expr>;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* no stats available, so default result */</comment>
		<return>return <expr><name>DEFAULT_INEQ_SEL</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have most-common-values info, add up the fractions of the MCV
	 * entries that satisfy MCV OP CONST.  These fractions contribute directly
	 * to the result selectivity.  Also add up the total fraction represented
	 * by MCV entries.
	 */</comment>
	<expr_stmt><expr><name>mcv_selec</name> <operator>=</operator> <call><name>mcv_selectivity</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>, <argument><expr><name>constval</name></expr></argument>, <argument><expr><name>true</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>sumcommon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a histogram, determine which bin the constant falls in, and
	 * compute the resulting contribution to selectivity.
	 */</comment>
	<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <call><name>ineq_histogram_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>, <argument><expr><name>isgt</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>,
											<argument><expr><name>constval</name></expr></argument>, <argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now merge the results from the MCV and histogram calculations,
	 * realizing that the histogram covers only the non-null values that are
	 * not listed in MCV.
	 */</comment>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name> <operator>-</operator> <name>sumcommon</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>hist_selec</name> <operator>&gt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>*=</operator> <name>hist_selec</name></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If no histogram but there are values not accounted for by MCV,
		 * arbitrarily assume half of them will match.
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>*=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>selec</name> <operator>+=</operator> <name>mcv_selec</name></expr>;</expr_stmt>

	<comment type="block">/* result should be in range, but make sure... */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	mcv_selectivity			- Examine the MCV list for selectivity estimates
 *
 * Determine the fraction of the variable's MCV population that satisfies
 * the predicate (VAR OP CONST), or (CONST OP VAR) if !varonleft.  Also
 * compute the fraction of the total column population represented by the MCV
 * list.  This code will work for any boolean-returning predicate operator.
 *
 * The function result is the MCV selectivity, and the fraction of the
 * total population is returned into *sumcommonp.  Zeroes are returned
 * if there is no MCV list.
 */</comment>
<function><type><name>double</name></type>
<name>mcv_selectivity</name><parameter_list>(<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>opproc</name></decl></parameter>,
				<parameter><decl><type><name>Datum</name></type> <name>constval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>varonleft</name></decl></parameter>,
				<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>sumcommonp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>mcv_selec</name></decl>,
				<decl><type ref="prev"/><name>sumcommon</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>mcv_selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sumcommon</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><name><name>opproc</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
						 <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>varonleft</name></expr> ?</condition><then>
				<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>opproc</name></expr></argument>,
											   <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
											   <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
											   <argument><expr><name>constval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
				<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>opproc</name></expr></argument>,
											   <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
											   <argument><expr><name>constval</name></expr></argument>,
											   <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>mcv_selec</name> <operator>+=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>sumcommon</name> <operator>+=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>sumcommonp</name> <operator>=</operator> <name>sumcommon</name></expr>;</expr_stmt>
	<return>return <expr><name>mcv_selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	histogram_selectivity	- Examine the histogram for selectivity estimates
 *
 * Determine the fraction of the variable's histogram entries that satisfy
 * the predicate (VAR OP CONST), or (CONST OP VAR) if !varonleft.
 *
 * This code will work for any boolean-returning predicate operator, whether
 * or not it has anything to do with the histogram sort operator.  We are
 * essentially using the histogram just as a representative sample.  However,
 * small histograms are unlikely to be all that representative, so the caller
 * should be prepared to fall back on some other estimation approach when the
 * histogram is missing or very small.  It may also be prudent to combine this
 * approach with another one when the histogram is small.
 *
 * If the actual histogram size is not at least min_hist_size, we won't bother
 * to do the calculation at all.  Also, if the n_skip parameter is &gt; 0, we
 * ignore the first and last n_skip histogram elements, on the grounds that
 * they are outliers and hence not very representative.  Typical values for
 * these parameters are 10 and 1.
 *
 * The function result is the selectivity, or -1 if there is no histogram
 * or it's smaller than min_hist_size.
 *
 * The output parameter *hist_size receives the actual histogram size,
 * or zero if no histogram.  Callers may use this number to decide how
 * much faith to put in the function result.
 *
 * Note that the result disregards both the most-common-values (if any) and
 * null entries.  The caller is expected to combine this result with
 * statistics for those portions of the column population.  It may also be
 * prudent to clamp the result range, ie, disbelieve exact 0 or 1 outputs.
 */</comment>
<function><type><name>double</name></type>
<name>histogram_selectivity</name><parameter_list>(<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>opproc</name></decl></parameter>,
					  <parameter><decl><type><name>Datum</name></type> <name>constval</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>varonleft</name></decl></parameter>,
					  <parameter><decl><type><name>int</name></type> <name>min_hist_size</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n_skip</name></decl></parameter>,
					  <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>hist_size</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>

	<comment type="block">/* check sanity of parameters */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>n_skip</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>min_hist_size</name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>*</operator> <name>n_skip</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><name><name>opproc</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
						 <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>hist_size</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>&gt;=</operator> <name>min_hist_size</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>nmatch</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>n_skip</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <name>n_skip</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><ternary><condition><expr><name>varonleft</name></expr> ?</condition><then>
					<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>opproc</name></expr></argument>,
												   <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
												   <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												   <argument><expr><name>constval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
					<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>opproc</name></expr></argument>,
												   <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
												   <argument><expr><name>constval</name></expr></argument>,
												   <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>nmatch</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <name>nmatch</name><operator>)</operator> <operator>/</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <literal type="number">2</literal> <operator>*</operator> <name>n_skip</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>hist_size</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *	ineq_histogram_selectivity	- Examine the histogram for scalarineqsel
 *
 * Determine the fraction of the variable's histogram population that
 * satisfies the inequality condition, ie, VAR &lt; (or &lt;=, &gt;, &gt;=) CONST.
 * The isgt and iseq flags distinguish which of the four cases apply.
 *
 * Returns -1 if there is no histogram (valid results will always be &gt;= 0).
 *
 * Note that the result disregards both the most-common-values (if any) and
 * null entries.  The caller is expected to combine this result with
 * statistics for those portions of the column population.
 *
 * This is exported so that some other estimation functions can use it.
 */</comment>
<function><type><name>double</name></type>
<name>ineq_histogram_selectivity</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						   <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>,
						   <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>opproc</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isgt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iseq</name></decl></parameter>,
						   <parameter><decl><type><name>Datum</name></type> <name>constval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>consttype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>hist_selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Someday, ANALYZE might store more than one histogram per rel/att,
	 * corresponding to more than one possible sort ordering defined for the
	 * column type.  However, to make that work we will need to figure out
	 * which staop to search for --- it's not necessarily the one we have at
	 * hand!  (For example, we might have a '&lt;=' operator rather than the '&lt;'
	 * operator that will appear in staop.)  For now, assume that whatever
	 * appears in pg_statistic is sorted the same way our operator sorts, or
	 * the reverse way if isgt is true.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><name><name>opproc</name><operator>-&gt;</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
						 <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Use binary search to find the desired location, namely the
			 * right end of the histogram bin containing the comparison value,
			 * which is the leftmost entry for which the comparison operator
			 * succeeds (if isgt) or fails (if !isgt).  (If the given operator
			 * isn't actually sort-compatible with the histogram, you'll get
			 * garbage results ... but probably not any more garbage-y than
			 * you would have from the old linear search.)
			 *
			 * In this loop, we pay no attention to whether the operator iseq
			 * or not; that detail will be mopped up below.  (We cannot tell,
			 * anyway, whether the operator thinks the values are equal.)
			 *
			 * If the binary search accesses the first or last histogram
			 * entry, we try to replace that endpoint with the true column min
			 * or max as found by get_actual_variable_range().  This
			 * ameliorates misestimates when the min or max is moving as a
			 * result of changes since the last ANALYZE.  Note that this could
			 * result in effectively including MCVs into the histogram that
			 * weren't there before, but we don't try to correct for that.
			 */</comment>
			<decl_stmt><decl><type><name>double</name></type>		<name>histfrac</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>lobound</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* first possible slot to search */</comment>
			<decl_stmt><decl><type><name>int</name></type>			<name>hibound</name> <init>= <expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr></init></decl>;</decl_stmt>	<comment type="block">/* last+1 slot to search */</comment>
			<decl_stmt><decl><type><name>bool</name></type>		<name>have_end</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If there are only two histogram entries, we'll want up-to-date
			 * values for both.  (If there are more than two, we need at most
			 * one of them to be updated, so we deal with that within the
			 * loop.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>have_end</name> <operator>=</operator> <call><name>get_actual_variable_range</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
													 <argument><expr><name>vardata</name></expr></argument>,
													 <argument><expr><name><name>sslot</name><operator>.</operator><name>staop</name></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<while>while <condition>(<expr><name>lobound</name> <operator>&lt;</operator> <name>hibound</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>int</name></type>			<name>probe</name> <init>= <expr><operator>(</operator><name>lobound</name> <operator>+</operator> <name>hibound</name><operator>)</operator> <operator>/</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>ltcmp</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * If we find ourselves about to compare to the first or last
				 * histogram entry, first try to replace it with the actual
				 * current min or max (unless we already did so above).
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>probe</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>have_end</name> <operator>=</operator> <call><name>get_actual_variable_range</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name>vardata</name></expr></argument>,
														 <argument><expr><name><name>sslot</name><operator>.</operator><name>staop</name></name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>probe</name> <operator>==</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>&gt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>have_end</name> <operator>=</operator> <call><name>get_actual_variable_range</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														 <argument><expr><name>vardata</name></expr></argument>,
														 <argument><expr><name><name>sslot</name><operator>.</operator><name>staop</name></name></expr></argument>,
														 <argument><expr><name>NULL</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>probe</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><name>ltcmp</name> <operator>=</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><name>opproc</name></expr></argument>,
													   <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
													   <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>probe</name></expr>]</index></name></expr></argument>,
													   <argument><expr><name>constval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isgt</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>ltcmp</name> <operator>=</operator> <operator>!</operator><name>ltcmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>ltcmp</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>lobound</name> <operator>=</operator> <name>probe</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>hibound</name> <operator>=</operator> <name>probe</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></while>

			<if_stmt><if>if <condition>(<expr><name>lobound</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Constant is below lower histogram boundary.  More
				 * precisely, we have found that no entry in the histogram
				 * satisfies the inequality clause (if !isgt) or they all do
				 * (if isgt).  We estimate that that's true of the entire
				 * table, so set histfrac to 0.0 (which we'll flip to 1.0
				 * below, if isgt).
				 */</comment>
				<expr_stmt><expr><name>histfrac</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name>lobound</name> <operator>&gt;=</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Inverse case: constant is above upper histogram boundary.
				 */</comment>
				<expr_stmt><expr><name>histfrac</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* We have values[i-1] &lt;= constant &lt;= values[i]. */</comment>
				<decl_stmt><decl><type><name>int</name></type>			<name>i</name> <init>= <expr><name>lobound</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>eq_selec</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>val</name></decl>,
							<decl><type ref="prev"/><name>high</name></decl>,
							<decl><type ref="prev"/><name>low</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>double</name></type>		<name>binfrac</name></decl>;</decl_stmt>

				<comment type="block">/*
				 * In the cases where we'll need it below, obtain an estimate
				 * of the selectivity of "x = constval".  We use a calculation
				 * similar to what var_eq_const() does for a non-MCV constant,
				 * ie, estimate that all distinct non-MCV values occur equally
				 * often.  But multiplication by "1.0 - sumcommon - nullfrac"
				 * will be done by our caller, so we shouldn't do that here.
				 * Therefore we can't try to clamp the estimate by reference
				 * to the least common MCV; the result would be too small.
				 *
				 * Note: since this is effectively assuming that constval
				 * isn't an MCV, it's logically dubious if constval in fact is
				 * one.  But we have to apply *some* correction for equality,
				 * and anyway we cannot tell if constval is an MCV, since we
				 * don't have a suitable equality operator at hand.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal> <operator>||</operator> <name>isgt</name> <operator>==</operator> <name>iseq</name></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>double</name></type>		<name>otherdistinct</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>bool</name></type>		<name>isdefault</name></decl>;</decl_stmt>
					<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>mcvslot</name></decl>;</decl_stmt>

					<comment type="block">/* Get estimated number of distinct values */</comment>
					<expr_stmt><expr><name>otherdistinct</name> <operator>=</operator> <call><name>get_variable_numdistinct</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>,
															 <argument><expr><operator>&amp;</operator><name>isdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Subtract off the number of known MCVs */</comment>
					<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcvslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
										 <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										 <argument><expr><name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>otherdistinct</name> <operator>-=</operator> <name><name>mcvslot</name><operator>.</operator><name>nnumbers</name></name></expr>;</expr_stmt>
						<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcvslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>

					<comment type="block">/* If result doesn't seem sane, leave eq_selec at 0 */</comment>
					<if_stmt><if>if <condition>(<expr><name>otherdistinct</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>eq_selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>otherdistinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>

				<comment type="block">/*
				 * Convert the constant and the two nearest bin boundary
				 * values to a uniform comparison scale, and do a linear
				 * interpolation within this bin.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>convert_to_scalar</name><argument_list>(<argument><expr><name>constval</name></expr></argument>, <argument><expr><name>consttype</name></expr></argument>, <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>val</name></expr></argument>,
									  <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
									  <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>vartype</name></name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>low</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>high</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>high</name> <operator>&lt;=</operator> <name>low</name></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/* cope if bin boundaries appear identical */</comment>
						<expr_stmt><expr><name>binfrac</name> <operator>=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<if type="elseif">else if <condition>(<expr><name>val</name> <operator>&lt;=</operator> <name>low</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>binfrac</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
					<if type="elseif">else if <condition>(<expr><name>val</name> <operator>&gt;=</operator> <name>high</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>binfrac</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><name>binfrac</name> <operator>=</operator> <operator>(</operator><name>val</name> <operator>-</operator> <name>low</name><operator>)</operator> <operator>/</operator> <operator>(</operator><name>high</name> <operator>-</operator> <name>low</name><operator>)</operator></expr>;</expr_stmt>

						<comment type="block">/*
						 * Watch out for the possibility that we got a NaN or
						 * Infinity from the division.  This can happen
						 * despite the previous checks, if for example "low"
						 * is -Infinity.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>binfrac</name></expr></argument>)</argument_list></call> <operator>||</operator>
							<name><name>binfrac</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0.0</literal> <operator>||</operator> <name>binfrac</name></expr></argument> &gt;</argument_list></name> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name>binfrac</name> <operator>=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<comment type="block">/*
					 * Ideally we'd produce an error here, on the grounds that
					 * the given operator shouldn't have scalarXXsel
					 * registered as its selectivity func unless we can deal
					 * with its operand types.  But currently, all manner of
					 * stuff is invoking scalarXXsel, so give a default
					 * estimate until that can be fixed.
					 */</comment>
					<expr_stmt><expr><name>binfrac</name> <operator>=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>

				<comment type="block">/*
				 * Now, compute the overall selectivity across the values
				 * represented by the histogram.  We have i-1 full bins and
				 * binfrac partial bin below the constant.
				 */</comment>
				<expr_stmt><expr><name>histfrac</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>i</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>+</operator> <name>binfrac</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>histfrac</name> <operator>/=</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>

				<comment type="block">/*
				 * At this point, histfrac is an estimate of the fraction of
				 * the population represented by the histogram that satisfies
				 * "x &lt;= constval".  Somewhat remarkably, this statement is
				 * true regardless of which operator we were doing the probes
				 * with, so long as convert_to_scalar() delivers reasonable
				 * results.  If the probe constant is equal to some histogram
				 * entry, we would have considered the bin to the left of that
				 * entry if probing with "&lt;" or "&gt;=", or the bin to the right
				 * if probing with "&lt;=" or "&gt;"; but binfrac would have come
				 * out as 1.0 in the first case and 0.0 in the second, leading
				 * to the same histfrac in either case.  For probe constants
				 * between histogram entries, we find the same bin and get the
				 * same estimate with any operator.
				 *
				 * The fact that the estimate corresponds to "x &lt;= constval"
				 * and not "x &lt; constval" is because of the way that ANALYZE
				 * constructs the histogram: each entry is, effectively, the
				 * rightmost value in its sample bucket.  So selectivity
				 * values that are exact multiples of 1/(histogram_size-1)
				 * should be understood as estimates including a histogram
				 * entry plus everything to its left.
				 *
				 * However, that breaks down for the first histogram entry,
				 * which necessarily is the leftmost value in its sample
				 * bucket.  That means the first histogram bin is slightly
				 * narrower than the rest, by an amount equal to eq_selec.
				 * Another way to say that is that we want "x &lt;= leftmost" to
				 * be estimated as eq_selec not zero.  So, if we're dealing
				 * with the first bin (i==1), rescale to make that true while
				 * adjusting the rest of that bin linearly.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>histfrac</name> <operator>+=</operator> <name>eq_selec</name> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>binfrac</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/*
				 * "x &lt;= constval" is good if we want an estimate for "&lt;=" or
				 * "&gt;", but if we are estimating for "&lt;" or "&gt;=", we now need
				 * to decrease the estimate by eq_selec.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>isgt</name> <operator>==</operator> <name>iseq</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>histfrac</name> <operator>-=</operator> <name>eq_selec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * Now the estimate is finished for "&lt;" and "&lt;=" cases.  If we are
			 * estimating for "&gt;" or "&gt;=", flip it.
			 */</comment>
			<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <ternary><condition><expr><name>isgt</name></expr> ?</condition><then> <expr><operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>histfrac</name><operator>)</operator></expr> </then><else>: <expr><name>histfrac</name></expr></else></ternary></expr>;</expr_stmt>

			<comment type="block">/*
			 * The histogram boundaries are only approximate to begin with,
			 * and may well be out of date anyway.  Therefore, don't believe
			 * extremely small or large selectivity estimates --- unless we
			 * got actual current endpoint values from the table, in which
			 * case just do the usual sanity clamp.  Somewhat arbitrarily, we
			 * set the cutoff for other cases at a hundredth of the histogram
			 * resolution.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>have_end</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>hist_selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>double</name></type>		<name>cutoff</name> <init>= <expr><literal type="number">0.01</literal> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name>hist_selec</name> <operator>&lt;</operator> <name>cutoff</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <name>cutoff</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>hist_selec</name> <operator>&gt;</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>cutoff</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>cutoff</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>hist_selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Common wrapper function for the selectivity estimators that simply
 * invoke scalarineqsel().
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>scalarineqsel_wrapper</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isgt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>iseq</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varRelid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>varonleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>constval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>consttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If expression is not variable op something or something op variable,
	 * then punt and return a default estimate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_restriction_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>other</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varonleft</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>DEFAULT_INEQ_SEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't do anything useful if the something is not a constant, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>DEFAULT_INEQ_SEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If the constant is NULL, assume operator is strict and return zero, ie,
	 * operator will never return TRUE.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>constval</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>consttype</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>consttype</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Force the var to be on the left to simplify logic in scalarineqsel.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>varonleft</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>operator</name> <operator>=</operator> <call><name>get_commutator</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>operator</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Use default selectivity (should we raise an error instead?) */</comment>
			<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>DEFAULT_INEQ_SEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>isgt</name> <operator>=</operator> <operator>!</operator><name>isgt</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* The rest of the work is done by scalarineqsel(). */</comment>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>scalarineqsel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>operator</name></expr></argument>, <argument><expr><name>isgt</name></expr></argument>, <argument><expr><name>iseq</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><name>constval</name></expr></argument>, <argument><expr><name>consttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		scalarltsel		- Selectivity of "&lt;" for scalars.
 */</comment>
<function><type><name>Datum</name></type>
<name>scalarltsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>scalarineqsel_wrapper</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		scalarlesel		- Selectivity of "&lt;=" for scalars.
 */</comment>
<function><type><name>Datum</name></type>
<name>scalarlesel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>scalarineqsel_wrapper</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		scalargtsel		- Selectivity of "&gt;" for scalars.
 */</comment>
<function><type><name>Datum</name></type>
<name>scalargtsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>scalarineqsel_wrapper</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		scalargesel		- Selectivity of "&gt;=" for scalars.
 */</comment>
<function><type><name>Datum</name></type>
<name>scalargesel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>scalarineqsel_wrapper</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		boolvarsel		- Selectivity of Boolean variable.
 *
 * This can actually be called on any boolean-valued expression.  If it
 * involves only Vars of the specified relation, and if there are statistics
 * about the Var or expression (the latter is possible if it's indexed) then
 * we'll produce a real estimate; otherwise it's just a default.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>boolvarsel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * A boolean variable V is equivalent to the clause V = 't', so we
		 * compute the selectivity as if that is what we have.
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>var_eq_const</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><name>BooleanEqualOperator</name></expr></argument>,
							 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>true</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Otherwise, the default estimate is 0.5 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		booltestsel		- Selectivity of BooleanTest Node.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>booltestsel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>BoolTestType</name></type> <name>booltesttype</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>freq_null</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>

		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name> <init>= <expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>freq_null</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
							 <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call>
			<operator>&amp;&amp;</operator> <name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>freq_true</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>double</name></type>		<name>freq_false</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Get first MCV frequency and derive frequency for true.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>freq_true</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>freq_true</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>-</operator> <name>freq_null</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/*
			 * Next derive frequency for false. Then use these as appropriate
			 * to derive frequency for each case.
			 */</comment>
			<expr_stmt><expr><name>freq_false</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>freq_true</name> <operator>-</operator> <name>freq_null</name></expr>;</expr_stmt>

			<switch>switch <condition>(<expr><name>booltesttype</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
					<comment type="block">/* select only NULL values */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>freq_null</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
					<comment type="block">/* select non-NULL values */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>freq_null</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>IS_TRUE</name></expr>:</case>
					<comment type="block">/* select only TRUE values */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>freq_true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
					<comment type="block">/* select non-TRUE values */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>freq_true</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>IS_FALSE</name></expr>:</case>
					<comment type="block">/* select only FALSE values */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>freq_false</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
					<comment type="block">/* select non-FALSE values */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>freq_false</name></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>booltesttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* Keep compiler quiet */</comment>
					<break>break;</break>
			</block_content>}</block></switch>

			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * No most-common-value info available. Still have null fraction
			 * information, so use it for IS [NOT] UNKNOWN. Otherwise adjust
			 * for null fraction and assume a 50-50 split of TRUE and FALSE.
			 */</comment>
			<switch>switch <condition>(<expr><name>booltesttype</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
					<comment type="block">/* select only NULL values */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>freq_null</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
					<comment type="block">/* select non-NULL values */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>freq_null</name></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>IS_TRUE</name></expr>:</case>
				<case>case <expr><name>IS_FALSE</name></expr>:</case>
					<comment type="block">/* Assume we select half of the non-NULL values */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>freq_null</name><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
					<break>break;</break>
				<case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
				<case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
					<comment type="block">/* Assume we select NULLs plus half of the non-NULLs */</comment>
					<comment type="block">/* equiv. to freq_null + (1.0 - freq_null) / 2.0 */</comment>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><name>freq_null</name> <operator>+</operator> <literal type="number">1.0</literal><operator>)</operator> <operator>/</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
						 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>booltesttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* Keep compiler quiet */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we can't get variable statistics for the argument, perhaps
		 * clause_selectivity can do something with it.  We ignore the
		 * possibility of a NULL value when using clause_selectivity, and just
		 * assume the value is either TRUE or FALSE.
		 */</comment>
		<switch>switch <condition>(<expr><name>booltesttype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>IS_UNKNOWN</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>DEFAULT_UNK_SEL</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_NOT_UNKNOWN</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>DEFAULT_NOT_UNK_SEL</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_TRUE</name></expr>:</case>
			<case>case <expr><name>IS_NOT_FALSE</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>clause_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>,
													<argument><expr><name>varRelid</name></expr></argument>,
													<argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
													<argument><expr><name>false</name></expr></argument> <comment type="block">/* use_damping */</comment>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_FALSE</name></expr>:</case>
			<case>case <expr><name>IS_NOT_TRUE</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <operator>(</operator><name>double</name><operator>)</operator> <call><name>clause_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>,
														  <argument><expr><name>varRelid</name></expr></argument>,
														  <argument><expr><name>jointype</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
														  <argument><expr><name>false</name></expr></argument> <comment type="block">/* use_damping */</comment>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized booltesttype: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>booltesttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* Keep compiler quiet */</comment>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* result should be in range, but make sure... */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		nulltestsel		- Selectivity of NullTest Node.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>nulltestsel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>NullTestType</name></type> <name>nulltesttype</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arg</name></decl></parameter>,
			<parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * GPDB_84_MERGE_NOTE: Following hack is removed in the upstream commit e006a24a.
	 * However, removing this causes cost differences for some ICG queries.
	 * Hence, keeping the hack in GPDB
	 * Special hack: an IS NULL test being applied at an outer join should not
	 * be taken at face value, since it's very likely being used to select the
	 * outer-side rows that don't have a match, and thus its selectivity has
	 * nothing whatever to do with the statistics of the original table
	 * column.	We do not have nearly enough context here to determine its
	 * true selectivity, so for the moment punt and guess at 0.5.  Eventually
	 * the planner should be made to provide enough info about the clause's
	 * context to let us do better.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_OUTER_JOIN</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>nulltesttype</name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0.5</literal></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name> <init>= <expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>freq_null</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>freq_null</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name>nulltesttype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>IS_NULL</name></expr>:</case>

				<comment type="block">/*
				 * Use freq_null directly.
				 */</comment>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>freq_null</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_NOT_NULL</name></expr>:</case>

				<comment type="block">/*
				 * Select not unknown (not null) values. Calculate from
				 * freq_null.
				 */</comment>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>freq_null</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>nulltesttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0</literal></expr>;</return> <comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>vardata</name><operator>.</operator><name>var</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>var</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>vardata</name><operator>.</operator><name>var</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * There are no stats for system columns, but we know they are never
		 * NULL.
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>nulltesttype</name> <operator>==</operator> <name>IS_NULL</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0.0</literal></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * No ANALYZE stats available, so make a guess
		 */</comment>
		<switch>switch <condition>(<expr><name>nulltesttype</name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>IS_NULL</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>DEFAULT_UNK_SEL</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>IS_NOT_NULL</name></expr>:</case>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>DEFAULT_NOT_UNK_SEL</name></expr>;</expr_stmt>
				<break>break;</break>
			<default>default:</default>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized nulltesttype: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>nulltesttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0</literal></expr>;</return> <comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></switch>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* result should be in range, but make sure... */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * strip_array_coercion - strip binary-compatible relabeling from an array expr
 *
 * For array values, the parser normally generates ArrayCoerceExpr conversions,
 * but it seems possible that RelabelType might show up.  Also, the planner
 * is not currently tense about collapsing stacked ArrayCoerceExpr nodes,
 * so we need to be ready to deal with more than one level.
 */</comment>
<function><type><specifier>static</specifier> <name>Node</name> <modifier>*</modifier></type>
<name>strip_array_coercion</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>ArrayCoerceExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ArrayCoerceExpr</name> <modifier>*</modifier></type><name>acoerce</name> <init>= <expr><operator>(</operator><name>ArrayCoerceExpr</name> <operator>*</operator><operator>)</operator> <name>node</name></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * If the per-element expression is just a RelabelType on top of
			 * CaseTestExpr, then we know it's a binary-compatible relabeling.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>acoerce</name><operator>-&gt;</operator><name>elemexpr</name></name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>IsA</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name><name>acoerce</name><operator>-&gt;</operator><name>elemexpr</name></name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr></argument>, <argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>acoerce</name><operator>-&gt;</operator><name>arg</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<break>break;</break></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name>node</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We don't really expect this case, but may as well cope */</comment>
			<expr_stmt><expr><name>node</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<break>break;</break></block_content></block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>node</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		scalararraysel		- Selectivity of ScalarArrayOpExpr Node.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>scalararraysel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			   <parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>is_join_clause</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>,
			   <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>,
			   <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><name><name>clause</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>useOr</name> <init>= <expr><name><name>clause</name><operator>-&gt;</operator><name>useOr</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isEquality</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isInequality</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>leftop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rightop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nominal_element_type</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>nominal_element_collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TypeCacheEntry</name> <modifier>*</modifier></type><name>typentry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RegProcedure</name></type> <name>oprsel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>oprselproc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>s1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>s1disjoint</name></decl>;</decl_stmt>

	<comment type="block">/* First, deconstruct the expression */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>leftop</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* aggressively reduce both sides to constants */</comment>
	<expr_stmt><expr><name>leftop</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>leftop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>rightop</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* get nominal (after relabeling) element type of rightop */</comment>
	<expr_stmt><expr><name>nominal_element_type</name> <operator>=</operator> <call><name>get_base_element_type</name><argument_list>(<argument><expr><call><name>exprType</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>nominal_element_type</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0.5</literal></expr>;</return></block_content></block></if></if_stmt>	<comment type="block">/* probably shouldn't happen */</comment>
	<comment type="block">/* get nominal collation, too, for generating constants */</comment>
	<expr_stmt><expr><name>nominal_element_collation</name> <operator>=</operator> <call><name>exprCollation</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* look through any binary-compatible relabeling of rightop */</comment>
	<expr_stmt><expr><name>rightop</name> <operator>=</operator> <call><name>strip_array_coercion</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Detect whether the operator is the default equality or inequality
	 * operator of the array element type.
	 */</comment>
	<expr_stmt><expr><name>typentry</name> <operator>=</operator> <call><name>lookup_type_cache</name><argument_list>(<argument><expr><name>nominal_element_type</name></expr></argument>, <argument><expr><name>TYPECACHE_EQ_OPR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>operator</name> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>isEquality</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>get_negator</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call> <operator>==</operator> <name><name>typentry</name><operator>-&gt;</operator><name>eq_opr</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>isInequality</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If it is equality or inequality, we might be able to estimate this as a
	 * form of array containment; for instance "const = ANY(column)" can be
	 * treated as "ARRAY[const] &lt;@ column".  scalararraysel_containment tries
	 * that, and returns the selectivity estimate if successful, or -1 if not.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>isEquality</name> <operator>||</operator> <name>isInequality</name><operator>)</operator> <operator>&amp;&amp;</operator> <operator>!</operator><name>is_join_clause</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>scalararraysel_containment</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>rightop</name></expr></argument>,
										<argument><expr><name>nominal_element_type</name></expr></argument>,
										<argument><expr><name>isEquality</name></expr></argument>, <argument><expr><name>useOr</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>s1</name> <operator>&gt;=</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>s1</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Look up the underlying operator's selectivity estimator. Punt if it
	 * hasn't got one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_join_clause</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>oprsel</name> <operator>=</operator> <call><name>get_oprjoin</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>oprsel</name> <operator>=</operator> <call><name>get_oprrest</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>oprsel</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0.5</literal></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>oprsel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>oprselproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * In the array-containment check above, we must only believe that an
	 * operator is equality or inequality if it is the default btree equality
	 * operator (or its negator) for the element type, since those are the
	 * operators that array containment will use.  But in what follows, we can
	 * be a little laxer, and also believe that any operators using eqsel() or
	 * neqsel() as selectivity estimator act like equality or inequality.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oprsel</name> <operator>==</operator> <name>F_EQSEL</name> <operator>||</operator> <name>oprsel</name> <operator>==</operator> <name>F_EQJOINSEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>isEquality</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>oprsel</name> <operator>==</operator> <name>F_NEQSEL</name> <operator>||</operator> <name>oprsel</name> <operator>==</operator> <name>F_NEQJOINSEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>isInequality</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * We consider three cases:
	 *
	 * 1. rightop is an Array constant: deconstruct the array, apply the
	 * operator's selectivity function for each array element, and merge the
	 * results in the same way that clausesel.c does for AND/OR combinations.
	 *
	 * 2. rightop is an ARRAY[] construct: apply the operator's selectivity
	 * function for each element of the ARRAY[] construct, and merge.
	 *
	 * 3. otherwise, make a guess ...
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rightop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>arraydatum</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>arrayisnull</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name>elmalign</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>num_elems</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elem_values</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elem_nulls</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>arrayisnull</name></expr>)</condition><block type="pseudo"><block_content>		<comment type="block">/* qual can't succeed if null array */</comment>
			<return>return <expr><operator>(</operator><name>Selectivity</name><operator>)</operator> <literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>,
						  <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
						  <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
						  <argument><expr><operator>&amp;</operator><name>elem_values</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elem_nulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>num_elems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * For generic operators, we assume the probability of success is
		 * independent for each array element.  But for "= ANY" or "&lt;&gt; ALL",
		 * if the array elements are distinct (which'd typically be the case)
		 * then the probabilities are disjoint, and we should just sum them.
		 *
		 * If we were being really tense we would try to confirm that the
		 * elements are all distinct, but that would be expensive and it
		 * doesn't seem to be worth the cycles; it would amount to penalizing
		 * well-written queries in favor of poorly-written ones.  However, we
		 * do protect ourselves a little bit by checking whether the
		 * disjointness assumption leads to an impossible (out of range)
		 * probability; if so, we fall back to the normal calculation.
		 */</comment>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1disjoint</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>useOr</name></expr> ?</condition><then> <expr><literal type="number">0.0</literal></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Selectivity</name></type> <name>s2</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>,
							  <argument><expr><call><name>makeConst</name><argument_list>(<argument><expr><name>nominal_element_type</name></expr></argument>,
										<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>,
										<argument><expr><name>nominal_element_collation</name></expr></argument>,
										<argument><expr><name>elmlen</name></expr></argument>,
										<argument><expr><name><name>elem_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										<argument><expr><name><name>elem_nulls</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										<argument><expr><name>elmbyval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>is_join_clause</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall5Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oprselproc</name></expr></argument>,
													  <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall4Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oprselproc</name></expr></argument>,
													  <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>varRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>useOr</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1</name> <operator>+</operator> <name>s2</name> <operator>-</operator> <name>s1</name> <operator>*</operator> <name>s2</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isEquality</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>s1disjoint</name> <operator>+=</operator> <name>s2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1</name> <operator>*</operator> <name>s2</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isInequality</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>s1disjoint</name> <operator>+=</operator> <name>s2</name> <operator>-</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* accept disjoint-probability estimate if in range */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name>useOr</name></expr> ?</condition><then> <expr><name>isEquality</name></expr> </then><else>: <expr><name>isInequality</name></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>s1disjoint</name> <operator>&gt;=</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <name>s1disjoint</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1disjoint</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>rightop</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <operator>!</operator><operator>(</operator><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>multidims</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ArrayExpr</name>  <modifier>*</modifier></type><name>arrayexpr</name> <init>= <expr><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>rightop</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>arrayexpr</name><operator>-&gt;</operator><name>element_typeid</name></name></expr></argument>,
						<argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We use the assumption of disjoint probabilities here too, although
		 * the odds of equal array elements are rather higher if the elements
		 * are not all constants (which they won't be, else constant folding
		 * would have reduced the ArrayExpr to a Const).  In this path it's
		 * critical to have the sanity check on the s1disjoint estimate.
		 */</comment>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1disjoint</name> <operator>=</operator> <operator>(</operator><ternary><condition><expr><name>useOr</name></expr> ?</condition><then> <expr><literal type="number">0.0</literal></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>arrayexpr-&gt;elements</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>elem</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Selectivity</name></type> <name>s2</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Theoretically, if elem isn't of nominal_element_type we should
			 * insert a RelabelType, but it seems unlikely that any operator
			 * estimation function would really care ...
			 */</comment>
			<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>elem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>is_join_clause</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall5Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oprselproc</name></expr></argument>,
													  <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall4Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oprselproc</name></expr></argument>,
													  <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>varRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>useOr</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1</name> <operator>+</operator> <name>s2</name> <operator>-</operator> <name>s1</name> <operator>*</operator> <name>s2</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isEquality</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>s1disjoint</name> <operator>+=</operator> <name>s2</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1</name> <operator>*</operator> <name>s2</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>isInequality</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>s1disjoint</name> <operator>+=</operator> <name>s2</name> <operator>-</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/* accept disjoint-probability estimate if in range */</comment>
		<if_stmt><if>if <condition>(<expr><operator>(</operator><ternary><condition><expr><name>useOr</name></expr> ?</condition><then> <expr><name>isEquality</name></expr> </then><else>: <expr><name>isInequality</name></expr></else></ternary><operator>)</operator> <operator>&amp;&amp;</operator>
			<name>s1disjoint</name> <operator>&gt;=</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <name>s1disjoint</name> <operator>&lt;=</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1disjoint</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>CaseTestExpr</name> <modifier>*</modifier></type><name>dummyexpr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>s2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * We need a dummy rightop to pass to the operator selectivity
		 * routine.  It can be pretty much anything that doesn't look like a
		 * constant; CaseTestExpr is a convenient choice.
		 */</comment>
		<expr_stmt><expr><name>dummyexpr</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>CaseTestExpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummyexpr</name><operator>-&gt;</operator><name>typeId</name></name> <operator>=</operator> <name>nominal_element_type</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummyexpr</name><operator>-&gt;</operator><name>typeMod</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>dummyexpr</name><operator>-&gt;</operator><name>collation</name></name> <operator>=</operator> <name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>args</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>dummyexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>is_join_clause</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall5Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oprselproc</name></expr></argument>,
												  <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
												  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>s2</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>FunctionCall4Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>oprselproc</name></expr></argument>,
												  <argument><expr><name><name>clause</name><operator>-&gt;</operator><name>inputcollid</name></name></expr></argument>,
												  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>varRelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <ternary><condition><expr><name>useOr</name></expr> ?</condition><then> <expr><literal type="number">0.0</literal></expr> </then><else>: <expr><literal type="number">1.0</literal></expr></else></ternary></expr>;</expr_stmt>

		<comment type="block">/*
		 * Arbitrarily assume 10 elements in the eventual array value (see
		 * also estimate_array_length).  We don't risk an assumption of
		 * disjoint probabilities here.
		 */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <literal type="number">10</literal></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>useOr</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1</name> <operator>+</operator> <name>s2</name> <operator>-</operator> <name>s1</name> <operator>*</operator> <name>s2</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>s1</name> <operator>=</operator> <name>s1</name> <operator>*</operator> <name>s2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* result should be in range, but make sure... */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>s1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>s1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate number of elements in the array yielded by an expression.
 *
 * It's important that this agree with scalararraysel.
 */</comment>
<function><type><name>int</name></type>
<name>estimate_array_length</name><parameter_list>(<parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>arrayexpr</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* look through any binary-compatible relabeling of arrayexpr */</comment>
	<expr_stmt><expr><name>arrayexpr</name> <operator>=</operator> <call><name>strip_array_coercion</name><argument_list>(<argument><expr><name>arrayexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>arrayexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arrayexpr</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>arraydatum</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arrayexpr</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>arrayisnull</name> <init>= <expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>arrayexpr</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>arrayisnull</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><name>arraydatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>ArrayGetNItems</name><argument_list>(<argument><expr><call><name>ARR_NDIM</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ARR_DIMS</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>arrayexpr</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>arrayexpr</name></expr></argument>, <argument><expr><name>ArrayExpr</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			 <operator>!</operator><operator>(</operator><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>arrayexpr</name><operator>)</operator><operator>-&gt;</operator><name>multidims</name></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><call><name>list_length</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>ArrayExpr</name> <operator>*</operator><operator>)</operator> <name>arrayexpr</name><operator>)</operator><operator>-&gt;</operator><name>elements</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* default guess --- see also scalararraysel */</comment>
		<return>return <expr><literal type="number">10</literal></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		rowcomparesel		- Selectivity of RowCompareExpr Node.
 *
 * We estimate RowCompare selectivity by considering just the first (high
 * order) columns, which makes it equivalent to an ordinary OpExpr.  While
 * this estimate could be refined by considering additional columns, it
 * seems unlikely that we could do a lot better without multi-column
 * statistics.
 */</comment>
<function><type><name>Selectivity</name></type>
<name>rowcomparesel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			  <parameter><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>, <parameter><decl><type><name>JoinType</name></type> <name>jointype</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>s1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>inputcollid</name> <init>= <expr><call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>inputcollids</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>opargs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_join_clause</name></decl>;</decl_stmt>

	<comment type="block">/* Build equivalent arg list for single operator */</comment>
	<expr_stmt><expr><name>opargs</name> <operator>=</operator> <call><name>list_make2</name><argument_list>(<argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>largs</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>linitial</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>rargs</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Decide if it's a join clause.  This should match clausesel.c's
	 * treat_as_join_clause(), except that we intentionally consider only the
	 * leading columns and not the rest of the clause.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>varRelid</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Caller is forcing restriction mode (eg, because we are examining an
		 * inner indexscan qual).
		 */</comment>
		<expr_stmt><expr><name>is_join_clause</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>sjinfo</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * It must be a restriction clause, since it's being evaluated at a
		 * scan node.
		 */</comment>
		<expr_stmt><expr><name>is_join_clause</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Otherwise, it's a join if there's more than one relation used.
		 */</comment>
		<expr_stmt><expr><name>is_join_clause</name> <operator>=</operator> <operator>(</operator><call><name>NumRelids</name><argument_list>(<argument><expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name>opargs</name></expr></argument>)</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_join_clause</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Estimate selectivity for a join clause. */</comment>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>join_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>opno</name></expr></argument>,
							  <argument><expr><name>opargs</name></expr></argument>,
							  <argument><expr><name>inputcollid</name></expr></argument>,
							  <argument><expr><name>jointype</name></expr></argument>,
							  <argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Estimate selectivity for a restriction clause. */</comment>
		<expr_stmt><expr><name>s1</name> <operator>=</operator> <call><name>restriction_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>opno</name></expr></argument>,
									 <argument><expr><name>opargs</name></expr></argument>,
									 <argument><expr><name>inputcollid</name></expr></argument>,
									 <argument><expr><name>varRelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>s1</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		eqjoinsel		- Join selectivity of "="
 */</comment>
<function><type><name>Datum</name></type>
<name>eqjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>jointype</name> <init>= <expr><operator>(</operator><name>JoinType</name><operator>)</operator> <call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec_inner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nd1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nd2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isdefault1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isdefault2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfuncoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats1</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats2</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_mcvs1</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_mcvs2</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>join_is_reversed</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_join_variables</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>join_is_reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>nd1</name> <operator>=</operator> <call><name>get_variable_numdistinct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdefault1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nd2</name> <operator>=</operator> <call><name>get_variable_numdistinct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdefault2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>opfuncoid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot1</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sslot1</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot2</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>sslot2</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata1</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* note we allow use of nullfrac regardless of security check */</comment>
		<expr_stmt><expr><name>stats1</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata1</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>, <argument><expr><name>opfuncoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>have_mcvs1</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot1</name></expr></argument>, <argument><expr><name><name>vardata1</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
										  <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata2</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* note we allow use of nullfrac regardless of security check */</comment>
		<expr_stmt><expr><name>stats2</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata2</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>, <argument><expr><name>opfuncoid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>have_mcvs2</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot2</name></expr></argument>, <argument><expr><name><name>vardata2</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
										  <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										  <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We need to compute the inner-join selectivity in all cases */</comment>
	<expr_stmt><expr><name>selec_inner</name> <operator>=</operator> <call><name>eqjoinsel_inner</name><argument_list>(<argument><expr><name>opfuncoid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>,
								  <argument><expr><name>nd1</name></expr></argument>, <argument><expr><name>nd2</name></expr></argument>,
								  <argument><expr><name>isdefault1</name></expr></argument>, <argument><expr><name>isdefault2</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>sslot1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sslot2</name></expr></argument>,
								  <argument><expr><name>stats1</name></expr></argument>, <argument><expr><name>stats2</name></expr></argument>,
								  <argument><expr><name>have_mcvs1</name></expr></argument>, <argument><expr><name>have_mcvs2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>selec_inner</name></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
		<case>case <expr><name>JOIN_LASJ_NOTIN</name></expr>:</case>

			<comment type="block">/*
			 * Look up the join's inner relation.  min_righthand is sufficient
			 * information because neither SEMI nor ANTI joins permit any
			 * reassociation into or out of their RHS, so the righthand will
			 * always be exactly that set of rels.
			 */</comment>
			<expr_stmt><expr><name>inner_rel</name> <operator>=</operator> <call><name>find_join_input_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>min_righthand</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>join_is_reversed</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>eqjoinsel_semi</name><argument_list>(<argument><expr><name>opfuncoid</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>,
									   <argument><expr><name>nd1</name></expr></argument>, <argument><expr><name>nd2</name></expr></argument>,
									   <argument><expr><name>isdefault1</name></expr></argument>, <argument><expr><name>isdefault2</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>sslot1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sslot2</name></expr></argument>,
									   <argument><expr><name>stats1</name></expr></argument>, <argument><expr><name>stats2</name></expr></argument>,
									   <argument><expr><name>have_mcvs1</name></expr></argument>, <argument><expr><name>have_mcvs2</name></expr></argument>,
									   <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>commop</name> <init>= <expr><call><name>get_commutator</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>commopfuncoid</name> <init>= <expr><ternary><condition><expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>commop</name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>commop</name></expr></argument>)</argument_list></call></expr> </then><else>: <expr><name>InvalidOid</name></expr></else></ternary></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>eqjoinsel_semi</name><argument_list>(<argument><expr><name>commopfuncoid</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>,
									   <argument><expr><name>nd2</name></expr></argument>, <argument><expr><name>nd1</name></expr></argument>,
									   <argument><expr><name>isdefault2</name></expr></argument>, <argument><expr><name>isdefault1</name></expr></argument>,
									   <argument><expr><operator>&amp;</operator><name>sslot2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>sslot1</name></expr></argument>,
									   <argument><expr><name>stats2</name></expr></argument>, <argument><expr><name>stats1</name></expr></argument>,
									   <argument><expr><name>have_mcvs2</name></expr></argument>, <argument><expr><name>have_mcvs1</name></expr></argument>,
									   <argument><expr><name>inner_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>

			<comment type="block">/*
			 * We should never estimate the output of a semijoin to be more
			 * rows than we estimate for an inner join with the same input
			 * rels and join condition; it's obviously impossible for that to
			 * happen.  The former estimate is N1 * Ssemi while the latter is
			 * N1 * N2 * Sinner, so we may clamp Ssemi &lt;= N2 * Sinner.  Doing
			 * this is worthwhile because of the shakier estimation rules we
			 * use in eqjoinsel_semi, particularly in cases where it has to
			 * punt entirely.
			 */</comment>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>selec</name></expr></argument>, <argument><expr><name><name>inner_rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>*</operator> <name>selec_inner</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* other values not expected here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * eqjoinsel_inner --- eqjoinsel for normal inner join
 *
 * We also use this for LEFT/FULL outer joins; it's not presently clear
 * that it's worth trying to distinguish them here.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>eqjoinsel_inner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfuncoid</name></decl></parameter>,
				<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata1</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata2</name></decl></parameter>,
				<parameter><decl><type><name>double</name></type> <name>nd1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>nd2</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>isdefault1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdefault2</name></decl></parameter>,
				<parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot1</name></decl></parameter>, <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot2</name></decl></parameter>,
				<parameter><decl><type><name>Form_pg_statistic</name></type> <name>stats1</name></decl></parameter>, <parameter><decl><type><name>Form_pg_statistic</name></type> <name>stats2</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>have_mcvs1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>have_mcvs2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_mcvs1</name> <operator>&amp;&amp;</operator> <name>have_mcvs2</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have most-common-value lists for both relations.  Run through
		 * the lists to see which MCVs actually join to each other with the
		 * given operator.  This allows us to determine the exact join
		 * selectivity for the portion of the relations represented by the MCV
		 * lists.  We still have to estimate for the remaining population, but
		 * in a skewed distribution this gives us a big leg up in accuracy.
		 * For motivation see the analysis in Y. Ioannidis and S.
		 * Christodoulakis, "On the propagation of errors in the size of join
		 * results", Technical Report 1018, Computer Science Dept., University
		 * of Wisconsin, Madison, March 1991 (available from ftp.cs.wisc.edu).
		 */</comment>
		<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>eqproc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>hasmatch1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>hasmatch2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac1</name> <init>= <expr><name><name>stats1</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac2</name> <init>= <expr><name><name>stats2</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>matchprodfreq</name></decl>,
					<decl><type ref="prev"/><name>matchfreq1</name></decl>,
					<decl><type ref="prev"/><name>matchfreq2</name></decl>,
					<decl><type ref="prev"/><name>unmatchfreq1</name></decl>,
					<decl><type ref="prev"/><name>unmatchfreq2</name></decl>,
					<decl><type ref="prev"/><name>otherfreq1</name></decl>,
					<decl><type ref="prev"/><name>otherfreq2</name></decl>,
					<decl><type ref="prev"/><name>totalsel1</name></decl>,
					<decl><type ref="prev"/><name>totalsel2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>nmatches</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>opfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasmatch1</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>sslot1</name><operator>-&gt;</operator><name>nvalues</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasmatch2</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>sslot2</name><operator>-&gt;</operator><name>nvalues</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note we assume that each MCV will match at most one member of the
		 * other MCV list.  If the operator isn't really equality, there could
		 * be multiple matches --- but we don't look for them, both for speed
		 * and because the math wouldn't add up...
		 */</comment>
		<expr_stmt><expr><name>matchprodfreq</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>nmatches</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name><name>sslot2</name><operator>-&gt;</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>hasmatch2</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eqproc</name></expr></argument>,
												   <argument><expr><name><name>sslot1</name><operator>-&gt;</operator><name>stacoll</name></name></expr></argument>,
												   <argument><expr><name><name>sslot1</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												   <argument><expr><name><name>sslot2</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>hasmatch1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>hasmatch2</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>matchprodfreq</name> <operator>+=</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>sslot2</name><operator>-&gt;</operator><name>numbers</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>nmatches</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>matchprodfreq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Sum up frequencies of matched and unmatched MCVs */</comment>
		<expr_stmt><expr><name>matchfreq1</name> <operator>=</operator> <name>unmatchfreq1</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hasmatch1</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>matchfreq1</name> <operator>+=</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>unmatchfreq1</name> <operator>+=</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>matchfreq1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>unmatchfreq1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>matchfreq2</name> <operator>=</operator> <name>unmatchfreq2</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot2</name><operator>-&gt;</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hasmatch2</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>matchfreq2</name> <operator>+=</operator> <name><name>sslot2</name><operator>-&gt;</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>unmatchfreq2</name> <operator>+=</operator> <name><name>sslot2</name><operator>-&gt;</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>matchfreq2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>unmatchfreq2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hasmatch1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hasmatch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Compute total frequency of non-null values that are not in the MCV
		 * lists.
		 */</comment>
		<expr_stmt><expr><name>otherfreq1</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name> <operator>-</operator> <name>matchfreq1</name> <operator>-</operator> <name>unmatchfreq1</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>otherfreq2</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac2</name> <operator>-</operator> <name>matchfreq2</name> <operator>-</operator> <name>unmatchfreq2</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>otherfreq1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>otherfreq2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * We can estimate the total selectivity from the point of view of
		 * relation 1 as: the known selectivity for matched MCVs, plus
		 * unmatched MCVs that are assumed to match against random members of
		 * relation 2's non-MCV population, plus non-MCV values that are
		 * assumed to match against random members of relation 2's unmatched
		 * MCVs plus non-MCV values.
		 */</comment>
		<expr_stmt><expr><name>totalsel1</name> <operator>=</operator> <name>matchprodfreq</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nd2</name> <operator>&gt;</operator> <name><name>sslot2</name><operator>-&gt;</operator><name>nvalues</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>totalsel1</name> <operator>+=</operator> <name>unmatchfreq1</name> <operator>*</operator> <name>otherfreq2</name> <operator>/</operator> <operator>(</operator><name>nd2</name> <operator>-</operator> <name><name>sslot2</name><operator>-&gt;</operator><name>nvalues</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nd2</name> <operator>&gt;</operator> <name>nmatches</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>totalsel1</name> <operator>+=</operator> <name>otherfreq1</name> <operator>*</operator> <operator>(</operator><name>otherfreq2</name> <operator>+</operator> <name>unmatchfreq2</name><operator>)</operator> <operator>/</operator>
				<operator>(</operator><name>nd2</name> <operator>-</operator> <name>nmatches</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/* Same estimate from the point of view of relation 2. */</comment>
		<expr_stmt><expr><name>totalsel2</name> <operator>=</operator> <name>matchprodfreq</name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nd1</name> <operator>&gt;</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>nvalues</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>totalsel2</name> <operator>+=</operator> <name>unmatchfreq2</name> <operator>*</operator> <name>otherfreq1</name> <operator>/</operator> <operator>(</operator><name>nd1</name> <operator>-</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>nvalues</name></name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>nd1</name> <operator>&gt;</operator> <name>nmatches</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>totalsel2</name> <operator>+=</operator> <name>otherfreq2</name> <operator>*</operator> <operator>(</operator><name>otherfreq1</name> <operator>+</operator> <name>unmatchfreq1</name><operator>)</operator> <operator>/</operator>
				<operator>(</operator><name>nd1</name> <operator>-</operator> <name>nmatches</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Use the smaller of the two estimates.  This can be justified in
		 * essentially the same terms as given below for the no-stats case: to
		 * a first approximation, we are estimating from the point of view of
		 * the relation with smaller nd.
		 */</comment>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>totalsel1</name> <operator>&lt;</operator> <name>totalsel2</name><operator>)</operator></expr> ?</condition><then> <expr><name>totalsel1</name></expr> </then><else>: <expr><name>totalsel2</name></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We do not have MCV lists for both sides.  Estimate the join
		 * selectivity as MIN(1/nd1,1/nd2)*(1-nullfrac1)*(1-nullfrac2). This
		 * is plausible if we assume that the join operator is strict and the
		 * non-null values are about equally distributed: a given non-null
		 * tuple of rel1 will join to either zero or N2*(1-nullfrac2)/nd2 rows
		 * of rel2, so total join rows are at most
		 * N1*(1-nullfrac1)*N2*(1-nullfrac2)/nd2 giving a join selectivity of
		 * not more than (1-nullfrac1)*(1-nullfrac2)/nd2. By the same logic it
		 * is not more than (1-nullfrac1)*(1-nullfrac2)/nd1, so the expression
		 * with MIN() is an upper bound.  Using the MIN() means we estimate
		 * from the point of view of the relation with smaller nd (since the
		 * larger nd is determining the MIN).  It is reasonable to assume that
		 * most tuples in this rel will have join partners, so the bound is
		 * probably reasonably tight and should be taken as-is.
		 *
		 * XXX Can we be smarter if we have an MCV list for just one side? It
		 * seems that if we assume equal distribution for the other side, we
		 * end up with the same answer anyway.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac1</name> <init>= <expr><ternary><condition><expr><name>stats1</name></expr> ?</condition><then> <expr><name><name>stats1</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr> </then><else>: <expr><literal type="number">0.0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac2</name> <init>= <expr><ternary><condition><expr><name>stats2</name></expr> ?</condition><then> <expr><name><name>stats2</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr> </then><else>: <expr><literal type="number">0.0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac2</name><operator>)</operator></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>nd1</name> <operator>&gt;</operator> <name>nd2</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>/=</operator> <name>nd1</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>/=</operator> <name>nd2</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * eqjoinsel_semi --- eqjoinsel for semi join
 *
 * (Also used for anti join, which we are supposed to estimate the same way.)
 * Caller has ensured that vardata1 is the LHS variable.
 * Unlike eqjoinsel_inner, we have to cope with opfuncoid being InvalidOid.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>eqjoinsel_semi</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>opfuncoid</name></decl></parameter>,
			   <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata1</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata2</name></decl></parameter>,
			   <parameter><decl><type><name>double</name></type> <name>nd1</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>nd2</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>isdefault1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>isdefault2</name></decl></parameter>,
			   <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot1</name></decl></parameter>, <parameter><decl><type><name>AttStatsSlot</name> <modifier>*</modifier></type><name>sslot2</name></decl></parameter>,
			   <parameter><decl><type><name>Form_pg_statistic</name></type> <name>stats1</name></decl></parameter>, <parameter><decl><type><name>Form_pg_statistic</name></type> <name>stats2</name></decl></parameter>,
			   <parameter><decl><type><name>bool</name></type> <name>have_mcvs1</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>have_mcvs2</name></decl></parameter>,
			   <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>inner_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We clamp nd2 to be not more than what we estimate the inner relation's
	 * size to be.  This is intuitively somewhat reasonable since obviously
	 * there can't be more than that many distinct values coming from the
	 * inner rel.  The reason for the asymmetry (ie, that we don't clamp nd1
	 * likewise) is that this is the only pathway by which restriction clauses
	 * applied to the inner rel will affect the join result size estimate,
	 * since set_joinrel_size_estimates will multiply SEMI/ANTI selectivity by
	 * only the outer rel's size.  If we clamped nd1 we'd be double-counting
	 * the selectivity of outer-rel restrictions.
	 *
	 * We can apply this clamping both with respect to the base relation from
	 * which the join variable comes (if there is just one), and to the
	 * immediate inner input relation of the current join.
	 *
	 * If we clamp, we can treat nd2 as being a non-default estimate; it's not
	 * great, maybe, but it didn't come out of nowhere either.  This is most
	 * helpful when the inner relation is empty and consequently has no stats.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vardata2</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>nd2</name> <operator>&gt;=</operator> <name><name>vardata2</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nd2</name> <operator>=</operator> <name><name>vardata2</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>isdefault2</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>nd2</name> <operator>&gt;=</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>rows</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>nd2</name> <operator>=</operator> <name><name>inner_rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>isdefault2</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>have_mcvs1</name> <operator>&amp;&amp;</operator> <name>have_mcvs2</name> <operator>&amp;&amp;</operator> <call><name>OidIsValid</name><argument_list>(<argument><expr><name>opfuncoid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have most-common-value lists for both relations.  Run through
		 * the lists to see which MCVs actually join to each other with the
		 * given operator.  This allows us to determine the exact join
		 * selectivity for the portion of the relations represented by the MCV
		 * lists.  We still have to estimate for the remaining population, but
		 * in a skewed distribution this gives us a big leg up in accuracy.
		 */</comment>
		<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>eqproc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>hasmatch1</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>hasmatch2</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac1</name> <init>= <expr><name><name>stats1</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>matchfreq1</name></decl>,
					<decl><type ref="prev"/><name>uncertainfrac</name></decl>,
					<decl><type ref="prev"/><name>uncertain</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
					<decl><type ref="prev"/><name>nmatches</name></decl>,
					<decl><type ref="prev"/><name>clamped_nvalues2</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * The clamping above could have resulted in nd2 being less than
		 * sslot2-&gt;nvalues; in which case, we assume that precisely the nd2
		 * most common values in the relation will appear in the join input,
		 * and so compare to only the first nd2 members of the MCV list.  Of
		 * course this is frequently wrong, but it's the best bet we can make.
		 */</comment>
		<expr_stmt><expr><name>clamped_nvalues2</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>sslot2</name><operator>-&gt;</operator><name>nvalues</name></name></expr></argument>, <argument><expr><name>nd2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>opfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>eqproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasmatch1</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name><name>sslot1</name><operator>-&gt;</operator><name>nvalues</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hasmatch2</name> <operator>=</operator> <operator>(</operator><name>bool</name> <operator>*</operator><operator>)</operator> <call><name>palloc0</name><argument_list>(<argument><expr><name>clamped_nvalues2</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>bool</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Note we assume that each MCV will match at most one member of the
		 * other MCV list.  If the operator isn't really equality, there could
		 * be multiple matches --- but we don't look for them, both for speed
		 * and because the math wouldn't add up...
		 */</comment>
		<expr_stmt><expr><name>nmatches</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j</name></decl>;</decl_stmt>

			<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>clamped_nvalues2</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>hasmatch2</name><index>[<expr><name>j</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<continue>continue;</continue></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>eqproc</name></expr></argument>,
												   <argument><expr><name><name>sslot1</name><operator>-&gt;</operator><name>stacoll</name></name></expr></argument>,
												   <argument><expr><name><name>sslot1</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
												   <argument><expr><name><name>sslot2</name><operator>-&gt;</operator><name>values</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>hasmatch1</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>hasmatch2</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<expr_stmt><expr><name>nmatches</name><operator>++</operator></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></for>
		<comment type="block">/* Sum up frequencies of matched MCVs */</comment>
		<expr_stmt><expr><name>matchfreq1</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>hasmatch1</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>matchfreq1</name> <operator>+=</operator> <name><name>sslot1</name><operator>-&gt;</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>matchfreq1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hasmatch1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>hasmatch2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now we need to estimate the fraction of relation 1 that has at
		 * least one join partner.  We know for certain that the matched MCVs
		 * do, so that gives us a lower bound, but we're really in the dark
		 * about everything else.  Our crude approach is: if nd1 &lt;= nd2 then
		 * assume all non-null rel1 rows have join partners, else assume for
		 * the uncertain rows that a fraction nd2/nd1 have join partners. We
		 * can discount the known-matched MCVs from the distinct-values counts
		 * before doing the division.
		 *
		 * Crude as the above is, it's completely useless if we don't have
		 * reliable ndistinct values for both sides.  Hence, if either nd1 or
		 * nd2 is default, punt and assume half of the uncertain rows have
		 * join partners.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isdefault1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isdefault2</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nd1</name> <operator>-=</operator> <name>nmatches</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nd2</name> <operator>-=</operator> <name>nmatches</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>nd1</name> <operator>&lt;=</operator> <name>nd2</name> <operator>||</operator> <name>nd2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>uncertainfrac</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>uncertainfrac</name> <operator>=</operator> <name>nd2</name> <operator>/</operator> <name>nd1</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>uncertainfrac</name> <operator>=</operator> <literal type="number">0.5</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>uncertain</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>matchfreq1</name> <operator>-</operator> <name>nullfrac1</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>uncertain</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>matchfreq1</name> <operator>+</operator> <name>uncertainfrac</name> <operator>*</operator> <name>uncertain</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Without MCV lists for both sides, we can only use the heuristic
		 * about nd1 vs nd2.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac1</name> <init>= <expr><ternary><condition><expr><name>stats1</name></expr> ?</condition><then> <expr><name><name>stats1</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr> </then><else>: <expr><literal type="number">0.0</literal></expr></else></ternary></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isdefault1</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>isdefault2</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>nd1</name> <operator>&lt;=</operator> <name>nd2</name> <operator>||</operator> <name>nd2</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><name>nd2</name> <operator>/</operator> <name>nd1</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0.5</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name><operator>)</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 *		neqjoinsel		- Join selectivity of "!="
 */</comment>
<function><type><name>Datum</name></type>
<name>neqjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>jointype</name> <init>= <expr><operator>(</operator><name>JoinType</name><operator>)</operator> <call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>float8</name></type>		<name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>jointype</name> <operator>==</operator> <name>JOIN_SEMI</name> <operator>||</operator> <name>jointype</name> <operator>==</operator> <name>JOIN_ANTI</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * For semi-joins, if there is more than one distinct value in the RHS
		 * relation then every non-null LHS row must find a row to join since
		 * it can only be equal to one of them.  We'll assume that there is
		 * always more than one distinct RHS value for the sake of stability,
		 * though in theory we could have special cases for empty RHS
		 * (selectivity = 0) and single-distinct-value RHS (selectivity =
		 * fraction of LHS that has the same value as the single RHS value).
		 *
		 * For anti-joins, if we use the same assumption that there is more
		 * than one distinct key in the RHS relation, then every non-null LHS
		 * row must be suppressed by the anti-join.
		 *
		 * So either way, the selectivity estimate should be 1 - nullfrac.
		 */</comment>
		<decl_stmt><decl><type><name>VariableStatData</name></type> <name>leftvar</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VariableStatData</name></type> <name>rightvar</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>reversed</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>statsTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>get_join_variables</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftvar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightvar</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>statsTuple</name> <operator>=</operator> <ternary><condition><expr><name>reversed</name></expr> ?</condition><then> <expr><name><name>rightvar</name><operator>.</operator><name>statsTuple</name></name></expr> </then><else>: <expr><name><name>leftvar</name><operator>.</operator><name>statsTuple</name></name></expr></else></ternary></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>statsTuple</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nullfrac</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>statsTuple</name></expr></argument>)</argument_list></call><operator>)</operator><operator>-&gt;</operator><name>stanullfrac</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>nullfrac</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>leftvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>rightvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We want 1 - eqjoinsel() where the equality operator is the one
		 * associated with this != operator, that is, its negator.
		 */</comment>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>eqop</name> <init>= <expr><call><name>get_negator</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>eqop</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall5</name><argument_list>(<argument><expr><name>eqjoinsel</name></expr></argument>,
														<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>eqop</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>jointype</name></expr></argument>)</argument_list></call></expr></argument>,
														<argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>sjinfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* Use default selectivity (should we raise an error instead?) */</comment>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>DEFAULT_EQ_SEL</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>-</operator> <name>result</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		scalarltjoinsel - Join selectivity of "&lt;" for scalars
 */</comment>
<function><type><name>Datum</name></type>
<name>scalarltjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>DEFAULT_INEQ_SEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		scalarlejoinsel - Join selectivity of "&lt;=" for scalars
 */</comment>
<function><type><name>Datum</name></type>
<name>scalarlejoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>DEFAULT_INEQ_SEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		scalargtjoinsel - Join selectivity of "&gt;" for scalars
 */</comment>
<function><type><name>Datum</name></type>
<name>scalargtjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>DEFAULT_INEQ_SEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 *		scalargejoinsel - Join selectivity of "&gt;=" for scalars
 */</comment>
<function><type><name>Datum</name></type>
<name>scalargejoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>DEFAULT_INEQ_SEL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * mergejoinscansel			- Scan selectivity of merge join.
 *
 * A merge join will stop as soon as it exhausts either input stream.
 * Therefore, if we can estimate the ranges of both input variables,
 * we can estimate how much of the input will actually be read.  This
 * can have a considerable impact on the cost when using indexscans.
 *
 * Also, we can estimate how much of each input has to be read before the
 * first join pair is found, which will affect the join's startup time.
 *
 * clause should be a clause already known to be mergejoinable.  opfamily,
 * strategy, and nulls_first specify the sort ordering being used.
 *
 * The outputs are:
 *		*leftstart is set to the fraction of the left-hand variable expected
 *		 to be scanned before the first join pair is found (0 to 1).
 *		*leftend is set to the fraction of the left-hand variable expected
 *		 to be scanned before the join terminates (0 to 1).
 *		*rightstart, *rightend similarly for the right-hand variable.
 */</comment>
<function><type><name>void</name></type>
<name>mergejoinscansel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
				 <parameter><decl><type><name>Oid</name></type> <name>opfamily</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>strategy</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>nulls_first</name></decl></parameter>,
				 <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>leftstart</name></decl></parameter>, <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>leftend</name></decl></parameter>,
				 <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>rightstart</name></decl></parameter>, <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>rightend</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>left</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>leftvar</name></decl>,
				<decl><type ref="prev"/><name>rightvar</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>op_strategy</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>op_lefttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>op_righttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opno</name></decl>,
				<decl><type ref="prev"/><name>lsortop</name></decl>,
				<decl><type ref="prev"/><name>rsortop</name></decl>,
				<decl><type ref="prev"/><name>lstatop</name></decl>,
				<decl><type ref="prev"/><name>rstatop</name></decl>,
				<decl><type ref="prev"/><name>ltop</name></decl>,
				<decl><type ref="prev"/><name>leop</name></decl>,
				<decl><type ref="prev"/><name>revltop</name></decl>,
				<decl><type ref="prev"/><name>revleop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isgt</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>leftmin</name></decl>,
				<decl><type ref="prev"/><name>leftmax</name></decl>,
				<decl><type ref="prev"/><name>rightmin</name></decl>,
				<decl><type ref="prev"/><name>rightmax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>

	<comment type="block">/* Set default results if we can't figure anything out. */</comment>
	<comment type="block">/* XXX should default "start" fraction be a bit more than 0? */</comment>
	<expr_stmt><expr><operator>*</operator><name>leftstart</name> <operator>=</operator> <operator>*</operator><name>rightstart</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>leftend</name> <operator>=</operator> <operator>*</operator><name>rightend</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>

	<comment type="block">/* Deconstruct the merge clause */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>is_opclause</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* shouldn't happen */</comment>
	<expr_stmt><expr><name>opno</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>opno</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>get_leftop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>get_rightop</name><argument_list>(<argument><expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>right</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>					<comment type="block">/* shouldn't happen */</comment>

	<comment type="block">/* Look for stats for the inputs */</comment>
	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Extract the operator's declared left/right datatypes */</comment>
	<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>opno</name></expr></argument>, <argument><expr><name>opfamily</name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>op_strategy</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>op_lefttype</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op_strategy</name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Look up the various operators we need.  If we don't find them all, it
	 * probably means the opfamily is broken, but we just fail silently.
	 *
	 * Note: we expect that pg_statistic histograms will be sorted by the '&lt;'
	 * operator, regardless of which sort direction we are considering.
	 */</comment>
	<switch>switch <condition>(<expr><name>strategy</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
			<expr_stmt><expr><name>isgt</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>op_lefttype</name> <operator>==</operator> <name>op_righttype</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* easy case */</comment>
				<expr_stmt><expr><name>ltop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
										   <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
										   <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>leop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
										   <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
										   <argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lsortop</name> <operator>=</operator> <name>ltop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rsortop</name> <operator>=</operator> <name>ltop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>lstatop</name> <operator>=</operator> <name>lsortop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rstatop</name> <operator>=</operator> <name>rsortop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>revltop</name> <operator>=</operator> <name>ltop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>revleop</name> <operator>=</operator> <name>leop</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>ltop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
										   <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
										   <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>leop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
										   <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
										   <argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lsortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>,
											  <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rsortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
											  <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lstatop</name> <operator>=</operator> <name>lsortop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rstatop</name> <operator>=</operator> <name>rsortop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>revltop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>,
											  <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>revleop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>,
											  <argument><expr><name>BTLessEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
			<comment type="block">/* descending-order case */</comment>
			<expr_stmt><expr><name>isgt</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>op_lefttype</name> <operator>==</operator> <name>op_righttype</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* easy case */</comment>
				<expr_stmt><expr><name>ltop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
										   <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
										   <argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>leop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
										   <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
										   <argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lsortop</name> <operator>=</operator> <name>ltop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>rsortop</name> <operator>=</operator> <name>ltop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>lstatop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>,
											  <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rstatop</name> <operator>=</operator> <name>lstatop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>revltop</name> <operator>=</operator> <name>ltop</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>revleop</name> <operator>=</operator> <name>leop</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>ltop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
										   <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
										   <argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>leop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
										   <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
										   <argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lsortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>,
											  <argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rsortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
											  <argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>lstatop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_lefttype</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>,
											  <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>rstatop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>,
											  <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>revltop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>,
											  <argument><expr><name>BTGreaterStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>revleop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name>opfamily</name></expr></argument>,
											  <argument><expr><name>op_righttype</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>,
											  <argument><expr><name>BTGreaterEqualStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<goto>goto <name>fail</name>;</goto>			<comment type="block">/* shouldn't get here */</comment>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>lsortop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rsortop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>lstatop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>rstatop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>ltop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>leop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>revltop</name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>revleop</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>				<comment type="block">/* insufficient info in catalogs */</comment>

	<comment type="block">/* Try to get ranges of both inputs */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isgt</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_variable_range</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftvar</name></expr></argument>, <argument><expr><name>lstatop</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>leftmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftmax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>			<comment type="block">/* no range available from stats */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_variable_range</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightvar</name></expr></argument>, <argument><expr><name>rstatop</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rightmin</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightmax</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>			<comment type="block">/* no range available from stats */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* need to swap the max and min */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_variable_range</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftvar</name></expr></argument>, <argument><expr><name>lstatop</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>leftmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>			<comment type="block">/* no range available from stats */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_variable_range</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightvar</name></expr></argument>, <argument><expr><name>rstatop</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>rightmax</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>fail</name>;</goto></block_content></block></if></if_stmt>			<comment type="block">/* no range available from stats */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now, the fraction of the left variable that will be scanned is the
	 * fraction that's &lt;= the right-side maximum value.  But only believe
	 * non-default estimates, else stick with our 1.0.
	 */</comment>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>scalarineqsel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>leop</name></expr></argument>, <argument><expr><name>isgt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftvar</name></expr></argument>,
						  <argument><expr><name>rightmax</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>!=</operator> <name>DEFAULT_INEQ_SEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>leftend</name> <operator>=</operator> <name>selec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And similarly for the right variable. */</comment>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>scalarineqsel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>revleop</name></expr></argument>, <argument><expr><name>isgt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightvar</name></expr></argument>,
						  <argument><expr><name>leftmax</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>!=</operator> <name>DEFAULT_INEQ_SEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>rightend</name> <operator>=</operator> <name>selec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Only one of the two "end" fractions can really be less than 1.0;
	 * believe the smaller estimate and reset the other one to exactly 1.0. If
	 * we get exactly equal estimates (as can easily happen with self-joins),
	 * believe neither.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>leftend</name> <operator>&gt;</operator> <operator>*</operator><name>rightend</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>leftend</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>leftend</name> <operator>&lt;</operator> <operator>*</operator><name>rightend</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>rightend</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>leftend</name> <operator>=</operator> <operator>*</operator><name>rightend</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Also, the fraction of the left variable that will be scanned before the
	 * first join pair is found is the fraction that's &lt; the right-side
	 * minimum value.  But only believe non-default estimates, else stick with
	 * our own default.
	 */</comment>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>scalarineqsel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>ltop</name></expr></argument>, <argument><expr><name>isgt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>leftvar</name></expr></argument>,
						  <argument><expr><name>rightmin</name></expr></argument>, <argument><expr><name>op_righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>!=</operator> <name>DEFAULT_INEQ_SEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>leftstart</name> <operator>=</operator> <name>selec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And similarly for the right variable. */</comment>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>scalarineqsel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>revltop</name></expr></argument>, <argument><expr><name>isgt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rightvar</name></expr></argument>,
						  <argument><expr><name>leftmin</name></expr></argument>, <argument><expr><name>op_lefttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>selec</name> <operator>!=</operator> <name>DEFAULT_INEQ_SEL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>rightstart</name> <operator>=</operator> <name>selec</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Only one of the two "start" fractions can really be more than zero;
	 * believe the larger estimate and reset the other one to exactly 0.0. If
	 * we get exactly equal estimates (as can easily happen with self-joins),
	 * believe neither.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>leftstart</name> <operator>&lt;</operator> <operator>*</operator><name>rightstart</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>leftstart</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><operator>*</operator><name>leftstart</name> <operator>&gt;</operator> <operator>*</operator><name>rightstart</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>rightstart</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>leftstart</name> <operator>=</operator> <operator>*</operator><name>rightstart</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * If the sort order is nulls-first, we're going to have to skip over any
	 * nulls too.  These would not have been counted by scalarineqsel, and we
	 * can safely add in this fraction regardless of whether we believe
	 * scalarineqsel's results or not.  But be sure to clamp the sum to 1.0!
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>nulls_first</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>leftStatsTuple</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>rightStatsTuple</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>leftStatsTuple</name> <operator>=</operator> <call><name>getStatsTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>leftvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>leftStatsTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>leftStatsTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>leftstart</name> <operator>+=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><operator>*</operator><name>leftstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>leftend</name> <operator>+=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><operator>*</operator><name>leftend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>rightStatsTuple</name> <operator>=</operator> <call><name>getStatsTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>rightvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>rightStatsTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>rightStatsTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rightstart</name> <operator>+=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><operator>*</operator><name>rightstart</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>rightend</name> <operator>+=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><operator>*</operator><name>rightend</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Disbelieve start &gt;= end, just in case that can happen */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>leftstart</name> <operator>&gt;=</operator> <operator>*</operator><name>leftend</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>leftstart</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>leftend</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>rightstart</name> <operator>&gt;=</operator> <operator>*</operator><name>rightend</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>rightstart</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>rightend</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

<label><name>fail</name>:</label>
	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>leftvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>rightvar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Helper routine for estimate_num_groups: add an item to a list of
 * GroupVarInfos, but only if it's not known equal to any of the existing
 * entries.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>var</name></decl>;</decl_stmt>			<comment type="block">/* might be an expression, not just a Var */</comment>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>			<comment type="block">/* relation it belongs to */</comment>
	<decl_stmt><decl><type><name>double</name></type>		<name>ndistinct</name></decl>;</decl_stmt>		<comment type="block">/* # distinct values */</comment>
}</block></struct></type> <name>GroupVarInfo</name>;</typedef>

<function><type><specifier>static</specifier> <name>List</name> <modifier>*</modifier></type>
<name>add_unique_group_var</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>varinfos</name></decl></parameter>,
					 <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>var</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GroupVarInfo</name> <modifier>*</modifier></type><name>varinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ndistinct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <call><name>get_variable_numdistinct</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* cannot use foreach here because of possible list_delete */</comment>
	<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name>varinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>lc</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>varinfo</name> <operator>=</operator> <operator>(</operator><name>GroupVarInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* must advance lc before list_delete possibly pfree's it */</comment>
		<expr_stmt><expr><name>lc</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Drop exact duplicates */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>varinfo</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>varinfos</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Drop known-equal vars, but only if they belong to different
		 * relations (see comments for estimate_num_groups)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>!=</operator> <name><name>varinfo</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator>
			<call><name>exprs_known_equal</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name><name>varinfo</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>varinfo</name><operator>-&gt;</operator><name>ndistinct</name></name> <operator>&lt;=</operator> <name>ndistinct</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* Keep older item, forget new one */</comment>
				<return>return <expr><name>varinfos</name></expr>;</return>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* Delete the older item */</comment>
				<expr_stmt><expr><name>varinfos</name> <operator>=</operator> <call><name>list_delete_ptr</name><argument_list>(<argument><expr><name>varinfos</name></expr></argument>, <argument><expr><name>varinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name>varinfo</name> <operator>=</operator> <operator>(</operator><name>GroupVarInfo</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>GroupVarInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>varinfo</name><operator>-&gt;</operator><name>var</name></name> <operator>=</operator> <name>var</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varinfo</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>varinfo</name><operator>-&gt;</operator><name>ndistinct</name></name> <operator>=</operator> <name>ndistinct</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>varinfos</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>varinfos</name></expr></argument>, <argument><expr><name>varinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>varinfos</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * estimate_num_groups		- Estimate number of groups in a grouped query
 *
 * Given a query having a GROUP BY clause, estimate how many groups there
 * will be --- ie, the number of distinct combinations of the GROUP BY
 * expressions.
 *
 * This routine is also used to estimate the number of rows emitted by
 * a DISTINCT filtering step; that is an isomorphic problem.  (Note:
 * actually, we only use it for DISTINCT when there's no grouping or
 * aggregation ahead of the DISTINCT.)
 *
 * Inputs:
 *	root - the query
 *	groupExprs - list of expressions being grouped by
 *	input_rows - number of rows estimated to arrive at the group/unique
 *		filter step
 *	pgset - NULL, or a List** pointing to a grouping set to filter the
 *		groupExprs against
 *
 * Given the lack of any cross-correlation statistics in the system, it's
 * impossible to do anything really trustworthy with GROUP BY conditions
 * involving multiple Vars.  We should however avoid assuming the worst
 * case (all possible cross-product terms actually appear as groups) since
 * very often the grouped-by Vars are highly correlated.  Our current approach
 * is as follows:
 *	1.  Expressions yielding boolean are assumed to contribute two groups,
 *		independently of their content, and are ignored in the subsequent
 *		steps.  This is mainly because tests like "col IS NULL" break the
 *		heuristic used in step 2 especially badly.
 *	2.  Reduce the given expressions to a list of unique Vars used.  For
 *		example, GROUP BY a, a + b is treated the same as GROUP BY a, b.
 *		It is clearly correct not to count the same Var more than once.
 *		It is also reasonable to treat f(x) the same as x: f() cannot
 *		increase the number of distinct values (unless it is volatile,
 *		which we consider unlikely for grouping), but it probably won't
 *		reduce the number of distinct values much either.
 *		As a special case, if a GROUP BY expression can be matched to an
 *		expressional index for which we have statistics, then we treat the
 *		whole expression as though it were just a Var.
 *	3.  If the list contains Vars of different relations that are known equal
 *		due to equivalence classes, then drop all but one of the Vars from each
 *		known-equal set, keeping the one with smallest estimated # of values
 *		(since the extra values of the others can't appear in joined rows).
 *		Note the reason we only consider Vars of different relations is that
 *		if we considered ones of the same rel, we'd be double-counting the
 *		restriction selectivity of the equality in the next step.
 *	4.  For Vars within a single source rel, we multiply together the numbers
 *		of values, clamp to the number of rows in the rel (divided by 10 if
 *		more than one Var), and then multiply by a factor based on the
 *		selectivity of the restriction clauses for that rel.  When there's
 *		more than one Var, the initial product is probably too high (it's the
 *		worst case) but clamping to a fraction of the rel's rows seems to be a
 *		helpful heuristic for not letting the estimate get out of hand.  (The
 *		factor of 10 is derived from pre-Postgres-7.4 practice.)  The factor
 *		we multiply by to adjust for the restriction selectivity assumes that
 *		the restriction clauses are independent of the grouping, which may not
 *		be a valid assumption, but it's hard to do better.
 *	5.  If there are Vars from multiple rels, we repeat step 4 for each such
 *		rel, and multiply the results together.
 * Note that rels not containing grouped Vars are ignored completely, as are
 * join clauses.  Such rels cannot increase the number of groups, and we
 * assume such clauses do not reduce the number either (somewhat bogus,
 * but we don't have the info to do better).
 */</comment>
<function><type><name>double</name></type>
<name>estimate_num_groups</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>groupExprs</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>input_rows</name></decl></parameter>,
					<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>pgset</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>varinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>srf_multiplier</name> <init>= <expr><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numdistinct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We don't ever want to return an estimate of zero groups, as that tends
	 * to lead to division-by-zero and other unpleasantness.  The input_rows
	 * estimate is usually already at least 1, but clamp it just in case it
	 * isn't.
	 */</comment>
	<expr_stmt><expr><name>input_rows</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>input_rows</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If no grouping columns, there's exactly one group.  (This can't happen
	 * for normal cases with GROUP BY or DISTINCT, but it is possible for
	 * corner cases with set operations.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>groupExprs</name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <operator>(</operator><name>pgset</name> <operator>&amp;&amp;</operator> <call><name>list_length</name><argument_list>(<argument><expr><operator>*</operator><name>pgset</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Count groups derived from boolean grouping expressions.  For other
	 * expressions, find the unique Vars used, treating an expression as a Var
	 * if we can find stats for it.  For each one, record the statistical
	 * estimate of number of distinct values (total in its table, without
	 * regard for filtering).
	 */</comment>
	<expr_stmt><expr><name>numdistinct</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>groupExprs</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>groupexpr</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>this_srf_multiplier</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>varshere</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l2</name></decl>;</decl_stmt>

		<comment type="block">/* is expression in this grouping set? */</comment>
		<if_stmt><if>if <condition>(<expr><name>pgset</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>list_member_int</name><argument_list>(<argument><expr><operator>*</operator><name>pgset</name></expr></argument>, <argument><expr><name>i</name><operator>++</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Set-returning functions in grouping columns are a bit problematic.
		 * The code below will effectively ignore their SRF nature and come up
		 * with a numdistinct estimate as though they were scalar functions.
		 * We compensate by scaling up the end result by the largest SRF
		 * rowcount estimate.  (This will be an overestimate if the SRF
		 * produces multiple copies of any output value, but it seems best to
		 * assume the SRF's outputs are distinct.  In any case, it's probably
		 * pointless to worry too much about this without much better
		 * estimates for SRF output rowcounts than we have today.)
		 */</comment>
		<expr_stmt><expr><name>this_srf_multiplier</name> <operator>=</operator> <call><name>expression_returns_set_rows</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>groupexpr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>srf_multiplier</name> <operator>&lt;</operator> <name>this_srf_multiplier</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>srf_multiplier</name> <operator>=</operator> <name>this_srf_multiplier</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Short-circuit for expressions returning boolean */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>exprType</name><argument_list>(<argument><expr><name>groupexpr</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BOOLOID</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numdistinct</name> <operator>*=</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If examine_variable is able to deduce anything about the GROUP BY
		 * expression, treat it as a single variable even if it's really more
		 * complicated.
		 */</comment>
		<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>groupexpr</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>||</operator> <name><name>vardata</name><operator>.</operator><name>isunique</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>varinfos</name> <operator>=</operator> <call><name>add_unique_group_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varinfos</name></expr></argument>,
											<argument><expr><name>groupexpr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Else pull out the component Vars.  Handle PlaceHolderVars by
		 * recursing into their arguments (effectively assuming that the
		 * PlaceHolderVar doesn't change the number of groups, which boils
		 * down to ignoring the possible addition of nulls to the result set).
		 */</comment>
		<expr_stmt><expr><name>varshere</name> <operator>=</operator> <call><name>pull_var_clause</name><argument_list>(<argument><expr><name>groupexpr</name></expr></argument>,
								   <argument><expr><name>PVC_RECURSE_AGGREGATES</name> <operator>|</operator>
								   <name>PVC_RECURSE_WINDOWFUNCS</name> <operator>|</operator>
								   <name>PVC_RECURSE_PLACEHOLDERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we find any variable-free GROUP BY item, then either it is a
		 * constant (and we can ignore it) or it contains a volatile function;
		 * in the latter case we punt and assume that each input row will
		 * yield a distinct group.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>varshere</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>contain_volatile_functions</name><argument_list>(<argument><expr><name>groupexpr</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>input_rows</name></expr>;</return></block_content></block></if></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Else add variables to varinfos list
		 */</comment>
		<macro><name>foreach</name><argument_list>(<argument>l2</argument>, <argument>varshere</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>varinfos</name> <operator>=</operator> <call><name>add_unique_group_var</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varinfos</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/*
	 * If now no Vars, we must have an all-constant or all-boolean GROUP BY
	 * list.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>varinfos</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Apply SRF multiplier as we would do in the long path */</comment>
		<expr_stmt><expr><name>numdistinct</name> <operator>*=</operator> <name>srf_multiplier</name></expr>;</expr_stmt>
		<comment type="block">/* Round off */</comment>
		<expr_stmt><expr><name>numdistinct</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>numdistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Guard against out-of-range answers */</comment>
		<if_stmt><if>if <condition>(<expr><name>numdistinct</name> <operator>&gt;</operator> <name>input_rows</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numdistinct</name> <operator>=</operator> <name>input_rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>numdistinct</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numdistinct</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><name>numdistinct</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Group Vars by relation and estimate total numdistinct.
	 *
	 * For each iteration of the outer loop, we process the frontmost Var in
	 * varinfos, plus all other Vars in the same relation.  We remove these
	 * Vars from the newvarinfos list for the next iteration. This is the
	 * easiest way to group Vars of same rel together.
	 */</comment>
	<do>do
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupVarInfo</name> <modifier>*</modifier></type><name>varinfo1</name> <init>= <expr><operator>(</operator><name>GroupVarInfo</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>varinfos</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>varinfo1</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>reldistinct</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>relmaxndistinct</name> <init>= <expr><name>reldistinct</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>relvarcount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newvarinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>relvarinfos</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/*
		 * Split the list of varinfos in two - one for the current rel, one
		 * for remaining Vars on other rels.
		 */</comment>
		<expr_stmt><expr><name>relvarinfos</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>varinfo1</name></expr></argument>, <argument><expr><name>relvarinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<macro><name>for_each_cell</name><argument_list>(<argument>l</argument>, <argument>lnext(list_head(varinfos))</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupVarInfo</name> <modifier>*</modifier></type><name>varinfo2</name> <init>= <expr><operator>(</operator><name>GroupVarInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>varinfo2</name><operator>-&gt;</operator><name>rel</name></name> <operator>==</operator> <name><name>varinfo1</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* varinfos on current rel */</comment>
				<expr_stmt><expr><name>relvarinfos</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>varinfo2</name></expr></argument>, <argument><expr><name>relvarinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* not time to process varinfo2 yet */</comment>
				<expr_stmt><expr><name>newvarinfos</name> <operator>=</operator> <call><name>lcons</name><argument_list>(<argument><expr><name>varinfo2</name></expr></argument>, <argument><expr><name>newvarinfos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>

		<comment type="block">/*
		 * Get the numdistinct estimate for the Vars of this rel.  We
		 * iteratively search for multivariate n-distinct with maximum number
		 * of vars; assuming that each var group is independent of the others,
		 * we multiply them together.  Any remaining relvarinfos after no more
		 * multivariate matches are found are assumed independent too, so
		 * their individual ndistinct estimates are multiplied also.
		 *
		 * While iterating, count how many separate numdistinct values we
		 * apply.  We apply a fudge factor below, but only if we multiplied
		 * more than one such values.
		 */</comment>
		<while>while <condition>(<expr><name>relvarinfos</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>mvndistinct</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>estimate_multivariate_ndistinct</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>relvarinfos</name></expr></argument>,
												<argument><expr><operator>&amp;</operator><name>mvndistinct</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>reldistinct</name> <operator>*=</operator> <name>mvndistinct</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>relmaxndistinct</name> <operator>&lt;</operator> <name>mvndistinct</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>relmaxndistinct</name> <operator>=</operator> <name>mvndistinct</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>relvarcount</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>relvarinfos</argument>)</argument_list></macro>
				<block>{<block_content>
					<decl_stmt><decl><type><name>GroupVarInfo</name> <modifier>*</modifier></type><name>varinfo2</name> <init>= <expr><operator>(</operator><name>GroupVarInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><name>reldistinct</name> <operator>*=</operator> <name><name>varinfo2</name><operator>-&gt;</operator><name>ndistinct</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>relmaxndistinct</name> <operator>&lt;</operator> <name><name>varinfo2</name><operator>-&gt;</operator><name>ndistinct</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>relmaxndistinct</name> <operator>=</operator> <name><name>varinfo2</name><operator>-&gt;</operator><name>ndistinct</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>relvarcount</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block>

				<comment type="block">/* we're done with this relation */</comment>
				<expr_stmt><expr><name>relvarinfos</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></while>

		<comment type="block">/*
		 * Sanity check --- don't divide by zero if empty relation.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IS_SIMPLE_REL</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Clamp to size of rel, or size of rel / 10 if multiple Vars. The
			 * fudge factor is because the Vars are probably correlated but we
			 * don't know by how much.  We should never clamp to less than the
			 * largest ndistinct value for any of the Vars, though, since
			 * there will surely be at least that many groups.
			 */</comment>
			<decl_stmt><decl><type><name>double</name></type>		<name>clamp</name> <init>= <expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>relvarcount</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>clamp</name> <operator>*=</operator> <literal type="number">0.1</literal></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name>clamp</name> <operator>&lt;</operator> <name>relmaxndistinct</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>clamp</name> <operator>=</operator> <name>relmaxndistinct</name></expr>;</expr_stmt>
					<comment type="block">/* for sanity in case some ndistinct is too large: */</comment>
					<if_stmt><if>if <condition>(<expr><name>clamp</name> <operator>&gt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>clamp</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><name>reldistinct</name> <operator>&gt;</operator> <name>clamp</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>reldistinct</name> <operator>=</operator> <name>clamp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Update the estimate based on the restriction selectivity,
			 * guarding against division by zero when reldistinct is zero.
			 * Also skip this if we know that we are returning all rows.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>reldistinct</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>&lt;</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Given a table containing N rows with n distinct values in a
				 * uniform distribution, if we select p rows at random then
				 * the expected number of distinct values selected is
				 *
				 * n * (1 - product((N-N/n-i)/(N-i), i=0..p-1))
				 *
				 * = n * (1 - (N-N/n)! / (N-N/n-p)! * (N-p)! / N!)
				 *
				 * See "Approximating block accesses in database
				 * organizations", S. B. Yao, Communications of the ACM,
				 * Volume 20 Issue 4, April 1977 Pages 260-261.
				 *
				 * Alternatively, re-arranging the terms from the factorials,
				 * this may be written as
				 *
				 * n * (1 - product((N-p-i)/(N-i), i=0..N/n-1))
				 *
				 * This form of the formula is more efficient to compute in
				 * the common case where p is larger than N/n.  Additionally,
				 * as pointed out by Dell'Era, if i &lt;&lt; N for all terms in the
				 * product, it can be approximated by
				 *
				 * n * (1 - ((N-p)/N)^(N/n))
				 *
				 * See "Expected distinct values when selecting from a bag
				 * without replacement", Alberto Dell'Era,
				 * http://www.adellera.it/investigations/distinct_balls/.
				 *
				 * The condition i &lt;&lt; N is equivalent to n &gt;&gt; 1, so this is a
				 * good approximation when the number of distinct values in
				 * the table is large.  It turns out that this formula also
				 * works well even when n is small.
				 */</comment>
				<expr_stmt><expr><name>reldistinct</name> <operator>*=</operator>
					<operator>(</operator><literal type="number">1</literal> <operator>-</operator> <call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>-</operator> <name><name>rel</name><operator>-&gt;</operator><name>rows</name></name><operator>)</operator> <operator>/</operator> <name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>,
							 <argument><expr><name><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>/</operator> <name>reldistinct</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>reldistinct</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>reldistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Update estimate of total distinct groups.
			 */</comment>
			<expr_stmt><expr><name>numdistinct</name> <operator>*=</operator> <name>reldistinct</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>varinfos</name> <operator>=</operator> <name>newvarinfos</name></expr>;</expr_stmt>
	</block_content>}</block> while <condition>(<expr><name>varinfos</name> <operator>!=</operator> <name>NIL</name></expr>)</condition>;</do>

	<comment type="block">/* Now we can account for the effects of any SRFs */</comment>
	<expr_stmt><expr><name>numdistinct</name> <operator>*=</operator> <name>srf_multiplier</name></expr>;</expr_stmt>

	<comment type="block">/* Round off */</comment>
	<expr_stmt><expr><name>numdistinct</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>numdistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Guard against out-of-range answers */</comment>
	<if_stmt><if>if <condition>(<expr><name>numdistinct</name> <operator>&gt;</operator> <name>input_rows</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numdistinct</name> <operator>=</operator> <name>input_rows</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>numdistinct</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numdistinct</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>numdistinct</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate hash bucket statistics when the specified expression is used
 * as a hash key for the given number of buckets.
 *
 * This attempts to determine two values:
 *
 * 1. The frequency of the most common value of the expression (returns
 * zero into *mcv_freq if we can't get that).
 *
 * 2. The "bucketsize fraction", ie, average number of entries in a bucket
 * divided by total tuples in relation.
 *
 * XXX This is really pretty bogus since we're effectively assuming that the
 * distribution of hash keys will be the same after applying restriction
 * clauses as it was in the underlying relation.  However, we are not nearly
 * smart enough to figure out how the restrict clauses might change the
 * distribution, so this will have to do for now.
 *
 * We are passed the number of buckets the executor will use for the given
 * input relation.  If the data were perfectly distributed, with the same
 * number of tuples going into each available bucket, then the bucketsize
 * fraction would be 1/nbuckets.  But this happy state of affairs will occur
 * only if (a) there are at least nbuckets distinct data values, and (b)
 * we have a not-too-skewed data distribution.  Otherwise the buckets will
 * be nonuniformly occupied.  If the other relation in the join has a key
 * distribution similar to this one's, then the most-loaded buckets are
 * exactly those that will be probed most often.  Therefore, the "average"
 * bucket size for costing purposes should really be taken as something close
 * to the "worst case" bucket size.  We try to estimate this by adjusting the
 * fraction if there are too few distinct data values, and then scaling up
 * by the ratio of the most common value's frequency to the average frequency.
 *
 * If no statistics are available, use a default estimate of 0.1.  This will
 * discourage use of a hash rather strongly if the inner relation is large,
 * which is what we want.  We do not want to hash unless we know that the
 * inner rel is well-dispersed (or the alternatives seem much worse).
 *
 * The caller should also check that the mcv_freq is not so large that the
 * most common value would by itself require an impractically large bucket.
 * In a hash join, the executor can split buckets if they get too big, but
 * obviously that doesn't help for a bucket that contains many duplicates of
 * the same value.
 */</comment>
<function><type><name>void</name></type>
<name>estimate_hash_bucket_stats</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>hashkey</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>nbuckets</name></decl></parameter>,
						   <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>mcv_freq</name></decl></parameter>,
						   <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>bucketsize_frac</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>estfract</name></decl>,
				<decl><type ref="prev"/><name>ndistinct</name></decl>,
				<decl><type ref="prev"/><name>stanullfrac</name></decl>,
				<decl><type ref="prev"/><name>avgfreq</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isdefault</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>hashkey</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Look up the frequency of the most common value, if available */</comment>
	<expr_stmt><expr><operator>*</operator><name>mcv_freq</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
							 <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The first MCV stat is for the most common value.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>mcv_freq</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Get number of distinct values */</comment>
	<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <call><name>get_variable_numdistinct</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isdefault</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If ndistinct isn't real, punt.  We normally return 0.1, but if the
	 * mcv_freq is known to be even higher than that, use it instead.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>isdefault</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>bucketsize_frac</name> <operator>=</operator> <operator>(</operator><name>Selectivity</name><operator>)</operator> <call><name>Max</name><argument_list>(<argument><expr><literal type="number">0.1</literal></expr></argument>, <argument><expr><operator>*</operator><name>mcv_freq</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name> <init>= <expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stanullfrac</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>stanullfrac</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Compute avg freq of all distinct data values in raw relation */</comment>
	<expr_stmt><expr><name>avgfreq</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>stanullfrac</name><operator>)</operator> <operator>/</operator> <name>ndistinct</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Adjust ndistinct to account for restriction clauses.  Observe we are
	 * assuming that the data distribution is affected uniformly by the
	 * restriction clauses!
	 *
	 * XXX Possibly better way, but much more expensive: multiply by
	 * selectivity of rel's restriction clauses that mention the target Var.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>.</operator><name>rel</name></name> <operator>&amp;&amp;</operator> <name><name>vardata</name><operator>.</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>ndistinct</name> <operator>*=</operator> <name><name>vardata</name><operator>.</operator><name>rel</name><operator>-&gt;</operator><name>rows</name></name> <operator>/</operator> <name><name>vardata</name><operator>.</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>ndistinct</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>ndistinct</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Initial estimate of bucketsize fraction is 1/nbuckets as long as the
	 * number of buckets is less than the expected number of distinct values;
	 * otherwise it is 1/ndistinct.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ndistinct</name> <operator>&gt;</operator> <name>nbuckets</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>estfract</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>nbuckets</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>estfract</name> <operator>=</operator> <literal type="number">1.0</literal> <operator>/</operator> <name>ndistinct</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Adjust estimated bucketsize upward to account for skewed distribution.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>avgfreq</name> <operator>&gt;</operator> <literal type="number">0.0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>mcv_freq</name> <operator>&gt;</operator> <name>avgfreq</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>estfract</name> <operator>*=</operator> <operator>*</operator><name>mcv_freq</name> <operator>/</operator> <name>avgfreq</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Clamp bucketsize to sane range (the above adjustment could easily
	 * produce an out-of-range result).  We set the lower bound a little above
	 * zero, since zero isn't a very sane result.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>estfract</name> <operator>&lt;</operator> <literal type="number">1.0e-6</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>estfract</name> <operator>=</operator> <literal type="number">1.0e-6</literal></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>estfract</name> <operator>&gt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>estfract</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>bucketsize_frac</name> <operator>=</operator> <operator>(</operator><name>Selectivity</name><operator>)</operator> <name>estfract</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * estimate_hashagg_tablesize
 *	  estimate the number of bytes that a hash aggregate hashtable will
 *	  require based on the agg_costs, path width and number of groups.
 *
 * We return the result as "double" to forestall any possible overflow
 * problem in the multiplication by dNumGroups.
 *
 * XXX this may be over-estimating the size now that hashagg knows to omit
 * unneeded columns from the hashtable.  Also for mixed-mode grouping sets,
 * grouping columns not in the hashed set are counted here even though hashagg
 * won't store them.  Is this a problem?
 */</comment>
<function><type><name>double</name></type>
<name>estimate_hashagg_tablesize</name><parameter_list>(<parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>AggClauseCosts</name> <modifier>*</modifier></type><name>agg_costs</name></decl></parameter>,
						   <parameter><decl><type><name>double</name></type> <name>dNumGroups</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>hashentrysize</name> <init>= <expr><call><name>hash_agg_entry_size</name><argument_list>(
		<argument><expr><name><name>agg_costs</name><operator>-&gt;</operator><name>numAggs</name></name></expr></argument>, <argument><expr><name><name>path</name><operator>-&gt;</operator><name>pathtarget</name><operator>-&gt;</operator><name>width</name></name></expr></argument>, <argument><expr><name><name>agg_costs</name><operator>-&gt;</operator><name>transitionSpace</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Note that this disregards the effect of fill-factor and growth policy
	 * of the hash table.  That's probably ok, given that the default
	 * fill-factor is relatively high.  It'd be hard to meaningfully factor in
	 * "double-in-size" growth policies here.
	 */</comment>
	<return>return <expr><name>hashentrysize</name> <operator>*</operator> <name>dNumGroups</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *
 * Support routines
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Find applicable ndistinct statistics for the given list of VarInfos (which
 * must all belong to the given rel), and update *ndistinct to the estimate of
 * the MVNDistinctItem that best matches.  If a match it found, *varinfos is
 * updated to remove the list of matched varinfos.
 *
 * Varinfos that aren't for simple Vars are ignored.
 *
 * Return true if we're able to find a match, false otherwise.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>estimate_multivariate_ndistinct</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl></parameter>,
								<parameter><decl><type><name>List</name> <modifier>*</modifier><modifier>*</modifier></type><name>varinfos</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>ndistinct</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>attnums</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nmatches</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>statOid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>MVNDistinct</name> <modifier>*</modifier></type><name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>matched</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name>		<modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>

	<comment type="block">/* bail out immediately if the table has no extended statistics */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>rel</name><operator>-&gt;</operator><name>statlist</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * When dealing with regular inheritance trees, ignore extended stats
	 * (which were built without data from child rels, and thus do not
	 * represent them). For partitioned tables data there's no data in the
	 * non-leaf relations, so we build stats only for the inheritance tree.
	 * So for partitioned tables we do consider extended stats.
	 */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator> <name><name>rte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>!=</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Determine the attnums we're looking for */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>*varinfos</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GroupVarInfo</name> <modifier>*</modifier></type><name>varinfo</name> <init>= <expr><operator>(</operator><name>GroupVarInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>varinfo</name><operator>-&gt;</operator><name>rel</name></name> <operator>==</operator> <name>rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>varinfo</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>attnums</name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name>attnums</name></expr></argument>,
									 <argument><expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>varinfo</name><operator>-&gt;</operator><name>var</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* look for the ndistinct statistics matching the most vars */</comment>
	<expr_stmt><expr><name>nmatches</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>				<comment type="block">/* we require at least two matches */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;statlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StatisticExtInfo</name> <modifier>*</modifier></type><name>info</name> <init>= <expr><operator>(</operator><name>StatisticExtInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Bitmapset</name>  <modifier>*</modifier></type><name>shared</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>nshared</name></decl>;</decl_stmt>

		<comment type="block">/* skip statistics of other kinds */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>info</name><operator>-&gt;</operator><name>kind</name></name> <operator>!=</operator> <name>STATS_EXT_NDISTINCT</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* compute attnums shared by the vars and the statistics object */</comment>
		<expr_stmt><expr><name>shared</name> <operator>=</operator> <call><name>bms_intersect</name><argument_list>(<argument><expr><name><name>info</name><operator>-&gt;</operator><name>keys</name></name></expr></argument>, <argument><expr><name>attnums</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nshared</name> <operator>=</operator> <call><name>bms_num_members</name><argument_list>(<argument><expr><name>shared</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Does this statistics object match more columns than the currently
		 * best object?  If so, use this one instead.
		 *
		 * XXX This should break ties using name of the object, or something
		 * like that, to make the outcome stable.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>nshared</name> <operator>&gt;</operator> <name>nmatches</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>statOid</name> <operator>=</operator> <name><name>info</name><operator>-&gt;</operator><name>statOid</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>nmatches</name> <operator>=</operator> <name>nshared</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>matched</name> <operator>=</operator> <name>shared</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* No match? */</comment>
	<if_stmt><if>if <condition>(<expr><name>statOid</name> <operator>==</operator> <name>InvalidOid</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>nmatches</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>matched</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>stats</name> <operator>=</operator> <call><name>statext_ndistinct_load</name><argument_list>(<argument><expr><name>statOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have a match, search it for the specific item that matches (there
	 * must be one), and construct the output values.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stats</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>newlist</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>MVNDistinctItem</name> <modifier>*</modifier></type><name>item</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Find the specific item that exactly matches the combination */</comment>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>stats</name><operator>-&gt;</operator><name>nitems</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>MVNDistinctItem</name> <modifier>*</modifier></type><name>tmpitem</name> <init>= <expr><operator>&amp;</operator><name><name>stats</name><operator>-&gt;</operator><name>items</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>bms_subset_compare</name><argument_list>(<argument><expr><name><name>tmpitem</name><operator>-&gt;</operator><name>attrs</name></name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>BMS_EQUAL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>item</name> <operator>=</operator> <name>tmpitem</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<comment type="block">/* make sure we found an item */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>item</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"corrupt MVNDistinct entry"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/* Form the output varinfo list, keeping only unmatched ones */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>*varinfos</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>GroupVarInfo</name> <modifier>*</modifier></type><name>varinfo</name> <init>= <expr><operator>(</operator><name>GroupVarInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name><name>varinfo</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>, <argument><expr><name>varinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>varinfo</name><operator>-&gt;</operator><name>var</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>bms_is_member</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>, <argument><expr><name>matched</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>newlist</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>newlist</name></expr></argument>, <argument><expr><name>varinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block>

		<expr_stmt><expr><operator>*</operator><name>varinfos</name> <operator>=</operator> <name>newlist</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>ndistinct</name> <operator>=</operator> <name><name>item</name><operator>-&gt;</operator><name>ndistinct</name></name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * convert_to_scalar
 *	  Convert non-NULL values of the indicated types to the comparison
 *	  scale needed by scalarineqsel().
 *	  Returns "true" if successful.
 *
 * XXX this routine is a hack: ideally we should look up the conversion
 * subroutines in pg_type.
 *
 * All numeric datatypes are simply converted to their equivalent
 * "double" values.  (NUMERIC values that are outside the range of "double"
 * are clamped to +/- HUGE_VAL.)
 *
 * String datatypes are converted to have hi and lo bound be constants, with
 *    the scaledvalue equally either hi or lo, depending on the value of isgt
 *    (done so that the caller will include the entire bucket in the final
 *     computed selectivity, even after inverting for the isgt case)
 *
 * The bytea datatype is just enough different from strings that it has
 * to be treated separately.
 *
 * The several datatypes representing absolute times are all converted
 * to Timestamp, which is actually a double, and then we just use that
 * double value.  Note this will give correct results even for the "special"
 * values of Timestamp, since those are chosen to compare correctly;
 * see timestamp_cmp.
 *
 * The several datatypes representing relative times (intervals) are all
 * converted to measurements expressed in seconds.
 *
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>convert_to_scalar</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>valuetypid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledvalue</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name></type> <name>lobound</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>hibound</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>boundstypid</name></decl></parameter>,
				  <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledlobound</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledhibound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>failure</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Both the valuetypid and the boundstypid should exactly match the
	 * declared input type(s) of the operator we are invoked for.  However,
	 * extensions might try to use scalarineqsel as estimator for operators
	 * with input type(s) we don't handle here; in such cases, we want to
	 * return false, not fail.  In any case, we mustn't assume that valuetypid
	 * and boundstypid are identical.
	 *
	 * XXX The histogram we are interpolating between points of could belong
	 * to a column that's only binary-compatible with the declared type. In
	 * essence we are assuming that the semantics of binary-compatible types
	 * are enough alike that we can use a histogram generated with one type's
	 * operators to estimate selectivity for the other's.  This is outright
	 * wrong in some cases --- in particular signed versus unsigned
	 * interpretation could trip us up.  But it's useful enough in the
	 * majority of cases that we do it anyway.  Should think about more
	 * rigorous ways to do it.
	 */</comment>
	<switch>switch <condition>(<expr><name>valuetypid</name></expr>)</condition>
	<block>{<block_content>
			<comment type="block">/*
			 * Built-in numeric types
			 */</comment>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
		<case>case <expr><name>INT2OID</name></expr>:</case>
		<case>case <expr><name>INT4OID</name></expr>:</case>
		<case>case <expr><name>INT8OID</name></expr>:</case>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
		<case>case <expr><name>OIDOID</name></expr>:</case>
		<case>case <expr><name>REGPROCOID</name></expr>:</case>
		<case>case <expr><name>REGPROCEDUREOID</name></expr>:</case>
		<case>case <expr><name>REGOPEROID</name></expr>:</case>
		<case>case <expr><name>REGOPERATOROID</name></expr>:</case>
		<case>case <expr><name>REGCLASSOID</name></expr>:</case>
		<case>case <expr><name>REGTYPEOID</name></expr>:</case>
		<case>case <expr><name>REGCONFIGOID</name></expr>:</case>
		<case>case <expr><name>REGDICTIONARYOID</name></expr>:</case>
		<case>case <expr><name>REGROLEOID</name></expr>:</case>
		<case>case <expr><name>REGNAMESPACEOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>scaledvalue</name> <operator>=</operator> <call><name>convert_numeric_to_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>valuetypid</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>scaledlobound</name> <operator>=</operator> <call><name>convert_numeric_to_scalar</name><argument_list>(<argument><expr><name>lobound</name></expr></argument>, <argument><expr><name>boundstypid</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>scaledhibound</name> <operator>=</operator> <call><name>convert_numeric_to_scalar</name><argument_list>(<argument><expr><name>hibound</name></expr></argument>, <argument><expr><name>boundstypid</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>!</operator><name>failure</name></expr>;</return>

			<comment type="block">/*
			 * Built-in string types
			 */</comment>
		<case>case <expr><name>CHAROID</name></expr>:</case>
		<case>case <expr><name>BPCHAROID</name></expr>:</case>
		<case>case <expr><name>VARCHAROID</name></expr>:</case>
		<case>case <expr><name>TEXTOID</name></expr>:</case>
		<case>case <expr><name>NAMEOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>valstr</name> <init>= <expr><call><name>convert_string_datum</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>valuetypid</name></expr></argument>,
														  <argument><expr><name>collid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>lostr</name> <init>= <expr><call><name>convert_string_datum</name><argument_list>(<argument><expr><name>lobound</name></expr></argument>, <argument><expr><name>boundstypid</name></expr></argument>,
														 <argument><expr><name>collid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>histr</name> <init>= <expr><call><name>convert_string_datum</name><argument_list>(<argument><expr><name>hibound</name></expr></argument>, <argument><expr><name>boundstypid</name></expr></argument>,
														 <argument><expr><name>collid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Bail out if any of the values is not of string type.  We
				 * might leak converted strings for the other value(s), but
				 * that's not worth troubling over.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>failure</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>convert_string_to_scalar</name><argument_list>(<argument><expr><name>valstr</name></expr></argument>, <argument><expr><name>scaledvalue</name></expr></argument>,
										 <argument><expr><name>lostr</name></expr></argument>, <argument><expr><name>scaledlobound</name></expr></argument>,
										 <argument><expr><name>histr</name></expr></argument>, <argument><expr><name>scaledhibound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>valstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>lostr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>histr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/*
			 * Built-in bytea type
			 */</comment>
		<case>case <expr><name>BYTEAOID</name></expr>:</case>
			<block>{<block_content>
				<comment type="block">/* We only support bytea vs bytea comparison */</comment>
				<if_stmt><if>if <condition>(<expr><name>boundstypid</name> <operator>!=</operator> <name>BYTEAOID</name></expr>)</condition><block type="pseudo"><block_content>
					<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>convert_bytea_to_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>scaledvalue</name></expr></argument>,
										<argument><expr><name>lobound</name></expr></argument>, <argument><expr><name>scaledlobound</name></expr></argument>,
										<argument><expr><name>hibound</name></expr></argument>, <argument><expr><name>scaledhibound</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<return>return <expr><name>true</name></expr>;</return>
			</block_content>}</block>

			<comment type="block">/*
			 * Built-in time types
			 */</comment>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
		<case>case <expr><name>DATEOID</name></expr>:</case>
		<case>case <expr><name>INTERVALOID</name></expr>:</case>
		<case>case <expr><name>TIMEOID</name></expr>:</case>
		<case>case <expr><name>TIMETZOID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>scaledvalue</name> <operator>=</operator> <call><name>convert_timevalue_to_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>valuetypid</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>scaledlobound</name> <operator>=</operator> <call><name>convert_timevalue_to_scalar</name><argument_list>(<argument><expr><name>lobound</name></expr></argument>, <argument><expr><name>boundstypid</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>scaledhibound</name> <operator>=</operator> <call><name>convert_timevalue_to_scalar</name><argument_list>(<argument><expr><name>hibound</name></expr></argument>, <argument><expr><name>boundstypid</name></expr></argument>,
														 <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>!</operator><name>failure</name></expr>;</return>

			<comment type="block">/*
			 * Built-in network types
			 */</comment>
		<case>case <expr><name>INETOID</name></expr>:</case>
		<case>case <expr><name>CIDROID</name></expr>:</case>
		<case>case <expr><name>MACADDROID</name></expr>:</case>
		<case>case <expr><name>MACADDR8OID</name></expr>:</case>
			<expr_stmt><expr><operator>*</operator><name>scaledvalue</name> <operator>=</operator> <call><name>convert_network_to_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>valuetypid</name></expr></argument>,
													 <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>scaledlobound</name> <operator>=</operator> <call><name>convert_network_to_scalar</name><argument_list>(<argument><expr><name>lobound</name></expr></argument>, <argument><expr><name>boundstypid</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>scaledhibound</name> <operator>=</operator> <call><name>convert_network_to_scalar</name><argument_list>(<argument><expr><name>hibound</name></expr></argument>, <argument><expr><name>boundstypid</name></expr></argument>,
													   <argument><expr><operator>&amp;</operator><name>failure</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><operator>!</operator><name>failure</name></expr>;</return>
	</block_content>}</block></switch>
	<comment type="block">/* Don't know how to convert */</comment>
	<expr_stmt><expr><operator>*</operator><name>scaledvalue</name> <operator>=</operator> <operator>*</operator><name>scaledlobound</name> <operator>=</operator> <operator>*</operator><name>scaledhibound</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do convert_to_scalar()'s work for any numeric data type.
 *
 * On failure (e.g., unsupported typid), set *failure to true;
 * otherwise, that variable is not changed.
 */</comment>
<function><type><specifier>static</specifier> <name>double</name></type>
<name>convert_numeric_to_scalar</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>failure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BOOLOID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <call><name>DatumGetBool</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT2OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <call><name>DatumGetInt16</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT4OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <call><name>DatumGetInt32</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INT8OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>FLOAT4OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <call><name>DatumGetFloat4</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>FLOAT8OID</name></expr>:</case>
			<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <call><name>DatumGetFloat8</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>NUMERICOID</name></expr>:</case>
			<comment type="block">/* Note: out-of-range values will be clamped to +-HUGE_VAL */</comment>
			<return>return <expr><operator>(</operator><name>double</name><operator>)</operator>
				<call><name>DatumGetFloat8</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_float8_no_overflow</name></expr></argument>,
												   <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>OIDOID</name></expr>:</case>
		<case>case <expr><name>REGPROCOID</name></expr>:</case>
		<case>case <expr><name>REGPROCEDUREOID</name></expr>:</case>
		<case>case <expr><name>REGOPEROID</name></expr>:</case>
		<case>case <expr><name>REGOPERATOROID</name></expr>:</case>
		<case>case <expr><name>REGCLASSOID</name></expr>:</case>
		<case>case <expr><name>REGTYPEOID</name></expr>:</case>
		<case>case <expr><name>REGCONFIGOID</name></expr>:</case>
		<case>case <expr><name>REGDICTIONARYOID</name></expr>:</case>
		<case>case <expr><name>REGROLEOID</name></expr>:</case>
		<case>case <expr><name>REGNAMESPACEOID</name></expr>:</case>
			<comment type="block">/* we can treat OIDs as integers... */</comment>
			<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <call><name>DatumGetObjectId</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></switch>

	<expr_stmt><expr><operator>*</operator><name>failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do convert_to_scalar()'s work for any character-string data type.
 *
 * String datatypes are converted to a scale that ranges from 0 to 1,
 * where we visualize the bytes of the string as fractional digits.
 *
 * We do not want the base to be 256, however, since that tends to
 * generate inflated selectivity estimates; few databases will have
 * occurrences of all 256 possible byte values at each position.
 * Instead, use the smallest and largest byte values seen in the bounds
 * as the estimated range for each byte, after some fudging to deal with
 * the fact that we probably aren't going to see the full range that way.
 *
 * An additional refinement is that we discard any common prefix of the
 * three strings before computing the scaled values.  This allows us to
 * "zoom in" when we encounter a narrow data range.  An example is a phone
 * number database where all the values begin with the same area code.
 * (Actually, the bounds will be adjacent histogram-bin-boundary values,
 * so this is more likely to happen than you might think.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_string_to_scalar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>,
						 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledvalue</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lobound</name></decl></parameter>,
						 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledlobound</name></decl></parameter>,
						 <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>hibound</name></decl></parameter>,
						 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledhibound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>rangelo</name></decl>,
				<decl><type ref="prev"/><name>rangehi</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>sptr</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>rangelo</name> <operator>=</operator> <name>rangehi</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>hibound</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>sptr</name> <operator>=</operator> <name>lobound</name></expr>;</init> <condition><expr><operator>*</operator><name>sptr</name></expr>;</condition> <incr><expr><name>sptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rangelo</name> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>sptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangelo</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>sptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>rangehi</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>sptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangehi</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>sptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<for>for <control>(<init><expr><name>sptr</name> <operator>=</operator> <name>hibound</name></expr>;</init> <condition><expr><operator>*</operator><name>sptr</name></expr>;</condition> <incr><expr><name>sptr</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rangelo</name> <operator>&gt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>sptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangelo</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>sptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>rangehi</name> <operator>&lt;</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>sptr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangehi</name> <operator>=</operator> <operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>sptr</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<comment type="block">/* If range includes any upper-case ASCII chars, make it include all */</comment>
	<if_stmt><if>if <condition>(<expr><name>rangelo</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal> <operator>&amp;&amp;</operator> <name>rangehi</name> <operator>&gt;=</operator> <literal type="char">'A'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rangelo</name> <operator>&gt;</operator> <literal type="char">'A'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangelo</name> <operator>=</operator> <literal type="char">'A'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>rangehi</name> <operator>&lt;</operator> <literal type="char">'Z'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangehi</name> <operator>=</operator> <literal type="char">'Z'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Ditto lower-case */</comment>
	<if_stmt><if>if <condition>(<expr><name>rangelo</name> <operator>&lt;=</operator> <literal type="char">'z'</literal> <operator>&amp;&amp;</operator> <name>rangehi</name> <operator>&gt;=</operator> <literal type="char">'a'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rangelo</name> <operator>&gt;</operator> <literal type="char">'a'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangelo</name> <operator>=</operator> <literal type="char">'a'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>rangehi</name> <operator>&lt;</operator> <literal type="char">'z'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangehi</name> <operator>=</operator> <literal type="char">'z'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
	<comment type="block">/* Ditto digits */</comment>
	<if_stmt><if>if <condition>(<expr><name>rangelo</name> <operator>&lt;=</operator> <literal type="char">'9'</literal> <operator>&amp;&amp;</operator> <name>rangehi</name> <operator>&gt;=</operator> <literal type="char">'0'</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>rangelo</name> <operator>&gt;</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangelo</name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>rangehi</name> <operator>&lt;</operator> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>rangehi</name> <operator>=</operator> <literal type="char">'9'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If range includes less than 10 chars, assume we have not got enough
	 * data, and make it include regular ASCII set.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>rangehi</name> <operator>-</operator> <name>rangelo</name> <operator>&lt;</operator> <literal type="number">9</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>rangelo</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>rangehi</name> <operator>=</operator> <literal type="number">127</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now strip any common prefix of the three strings.
	 */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>lobound</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>lobound</name> <operator>!=</operator> <operator>*</operator><name>hibound</name> <operator>||</operator> <operator>*</operator><name>lobound</name> <operator>!=</operator> <operator>*</operator><name>value</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>lobound</name><operator>++</operator></expr><operator>,</operator> <expr><name>hibound</name><operator>++</operator></expr><operator>,</operator> <expr><name>value</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>

	<comment type="block">/*
	 * Now we can do the conversions.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>scaledvalue</name> <operator>=</operator> <call><name>convert_one_string_to_scalar</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>rangelo</name></expr></argument>, <argument><expr><name>rangehi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>scaledlobound</name> <operator>=</operator> <call><name>convert_one_string_to_scalar</name><argument_list>(<argument><expr><name>lobound</name></expr></argument>, <argument><expr><name>rangelo</name></expr></argument>, <argument><expr><name>rangehi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>scaledhibound</name> <operator>=</operator> <call><name>convert_one_string_to_scalar</name><argument_list>(<argument><expr><name>hibound</name></expr></argument>, <argument><expr><name>rangelo</name></expr></argument>, <argument><expr><name>rangehi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>convert_one_string_to_scalar</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangelo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangehi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>slen</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>num</name></decl>,
				<decl><type ref="prev"/><name>denom</name></decl>,
				<decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* empty string has scalar value 0 */</comment>

	<comment type="block">/*
	 * There seems little point in considering more than a dozen bytes from
	 * the string.  Since base is at least 10, that will give us nominal
	 * resolution of at least 12 decimal digits, which is surely far more
	 * precision than this estimation technique has got anyway (especially in
	 * non-C locales).  Also, even with the maximum possible base of 256, this
	 * ensures denom cannot grow larger than 256^13 = 2.03e31, which will not
	 * overflow on any known machine.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>slen</name> <operator>&gt;</operator> <literal type="number">12</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>slen</name> <operator>=</operator> <literal type="number">12</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert initial characters to fraction */</comment>
	<expr_stmt><expr><name>base</name> <operator>=</operator> <name>rangehi</name> <operator>-</operator> <name>rangelo</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>denom</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>slen</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ch</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>value</name><operator>++</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <name>rangelo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>rangelo</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&gt;</operator> <name>rangehi</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>rangehi</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>ch</name> <operator>-</operator> <name>rangelo</name><operator>)</operator><operator>)</operator> <operator>/</operator> <name>denom</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>denom</name> <operator>*=</operator> <name>base</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Convert a string-type Datum into a palloc'd, null-terminated string.
 *
 * On failure (e.g., unsupported typid), set *failure to true;
 * otherwise, that variable is not changed.  (We'll return NULL on failure.)
 *
 * When using a non-C locale, we must pass the string through strxfrm()
 * before continuing, so as to generate correct locale-specific results.
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>convert_string_datum</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>failure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><name>typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>CHAROID</name></expr>:</case>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>val</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>=</operator> <call><name>DatumGetChar</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>val</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BPCHAROID</name></expr>:</case>
		<case>case <expr><name>VARCHAROID</name></expr>:</case>
		<case>case <expr><name>TEXTOID</name></expr>:</case>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>TextDatumGetCString</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>NAMEOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NameData</name>   <modifier>*</modifier></type><name>nm</name> <init>= <expr><operator>(</operator><name>NameData</name> <operator>*</operator><operator>)</operator> <call><name>DatumGetPointer</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>pstrdup</name><argument_list>(<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><operator>*</operator><name>nm</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block>
		<default>default:</default>
			<expr_stmt><expr><operator>*</operator><name>failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<return>return <expr><name>NULL</name></expr>;</return>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>lc_collate_is_c</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>xfrmstr</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name></type>		<name>xfrmlen</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>size_t</name>		<name>xfrmlen2</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * XXX: We could guess at a suitable output buffer size and only call
		 * strxfrm twice if our guess is too small.
		 *
		 * XXX: strxfrm doesn't support UTF-8 encoding on Win32, it can return
		 * bogus data or set an error. This is not really a problem unless it
		 * crashes since it will only give an estimation error and nothing
		 * fatal.
		 */</comment>
<cpp:if>#<cpp:directive>if</cpp:directive> <expr><name>_MSC_VER</name> <operator>==</operator> <literal type="number">1400</literal></expr></cpp:if>			<comment type="block">/* VS.Net 2005 */</comment>

		<comment type="block">/*
		 *
		 * http://connect.microsoft.com/VisualStudio/feedback/ViewFeedback.aspx?FeedbackID=99694
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name></type>		<name><name>x</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

			<expr_stmt><expr><name>xfrmlen</name> <operator>=</operator> <call><name>strxfrm</name><argument_list>(<argument><expr><name>x</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
		<expr_stmt><expr><name>xfrmlen</name> <operator>=</operator> <call><name>strxfrm</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>WIN32</name></cpp:ifdef>

		<comment type="block">/*
		 * On Windows, strxfrm returns INT_MAX when an error occurs. Instead
		 * of trying to allocate this much memory (and fail), just return the
		 * original string unmodified as if we were in the C locale.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>xfrmlen</name> <operator>==</operator> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>val</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name>xfrmstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>xfrmlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>xfrmlen2</name> <operator>=</operator> <call><name>strxfrm</name><argument_list>(<argument><expr><name>xfrmstr</name></expr></argument>, <argument><expr><name>val</name></expr></argument>, <argument><expr><name>xfrmlen</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Some systems (e.g., glibc) can return a smaller value from the
		 * second call than the first; thus the Assert must be &lt;= not ==.
		 */</comment>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>xfrmlen2</name> <operator>&lt;=</operator> <name>xfrmlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <name>xfrmstr</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do convert_to_scalar()'s work for any bytea data type.
 *
 * Very similar to the old convert_string_to_scalar except we can't assume
 * null-termination and therefore pass explicit lengths around.
 *
 * Also, assumptions about likely "normal" ranges of characters have been
 * removed - a data range of 0..255 is always used, for now.  (Perhaps
 * someday we will add information about actual byte data range to
 * pg_statistic.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>convert_bytea_to_scalar</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>,
						<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledvalue</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>lobound</name></decl></parameter>,
						<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledlobound</name></decl></parameter>,
						<parameter><decl><type><name>Datum</name></type> <name>hibound</name></decl></parameter>,
						<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>scaledhibound</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>valuep</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>loboundp</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>lobound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bytea</name>	   <modifier>*</modifier></type><name>hiboundp</name> <init>= <expr><call><name>DatumGetByteaPP</name><argument_list>(<argument><expr><name>hibound</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>rangelo</name></decl>,
				<decl><type ref="prev"/><name>rangehi</name></decl>,
				<decl><type ref="prev"/><name>valuelen</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>valuep</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>loboundlen</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>loboundp</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>hiboundlen</name> <init>= <expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>hiboundp</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>i</name></decl>,
				<decl><type ref="prev"/><name>minlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>valstr</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>valuep</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>lostr</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>loboundp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>histr</name> <init>= <expr><operator>(</operator><name>unsigned</name> <name>char</name> <operator>*</operator><operator>)</operator> <call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>hiboundp</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Assume bytea data is uniformly distributed across all byte values.
	 */</comment>
	<expr_stmt><expr><name>rangelo</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>rangehi</name> <operator>=</operator> <literal type="number">255</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now strip any common prefix of the three strings.
	 */</comment>
	<expr_stmt><expr><name>minlen</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>Min</name><argument_list>(<argument><expr><name>valuelen</name></expr></argument>, <argument><expr><name>loboundlen</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>hiboundlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>minlen</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>lostr</name> <operator>!=</operator> <operator>*</operator><name>histr</name> <operator>||</operator> <operator>*</operator><name>lostr</name> <operator>!=</operator> <operator>*</operator><name>valstr</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>lostr</name><operator>++</operator></expr><operator>,</operator> <expr><name>histr</name><operator>++</operator></expr><operator>,</operator> <expr><name>valstr</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>loboundlen</name><operator>--</operator></expr><operator>,</operator> <expr><name>hiboundlen</name><operator>--</operator></expr><operator>,</operator> <expr><name>valuelen</name><operator>--</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Now we can do the conversions.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>scaledvalue</name> <operator>=</operator> <call><name>convert_one_bytea_to_scalar</name><argument_list>(<argument><expr><name>valstr</name></expr></argument>, <argument><expr><name>valuelen</name></expr></argument>, <argument><expr><name>rangelo</name></expr></argument>, <argument><expr><name>rangehi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>scaledlobound</name> <operator>=</operator> <call><name>convert_one_bytea_to_scalar</name><argument_list>(<argument><expr><name>lostr</name></expr></argument>, <argument><expr><name>loboundlen</name></expr></argument>, <argument><expr><name>rangelo</name></expr></argument>, <argument><expr><name>rangehi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>scaledhibound</name> <operator>=</operator> <call><name>convert_one_bytea_to_scalar</name><argument_list>(<argument><expr><name>histr</name></expr></argument>, <argument><expr><name>hiboundlen</name></expr></argument>, <argument><expr><name>rangelo</name></expr></argument>, <argument><expr><name>rangehi</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>double</name></type>
<name>convert_one_bytea_to_scalar</name><parameter_list>(<parameter><decl><type><name>unsigned</name> <name>char</name> <modifier>*</modifier></type><name>value</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>valuelen</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>rangelo</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>rangehi</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>num</name></decl>,
				<decl><type ref="prev"/><name>denom</name></decl>,
				<decl><type ref="prev"/><name>base</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>valuelen</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* empty string has scalar value 0 */</comment>

	<comment type="block">/*
	 * Since base is 256, need not consider more than about 10 chars (even
	 * this many seems like overkill)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>valuelen</name> <operator>&gt;</operator> <literal type="number">10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>valuelen</name> <operator>=</operator> <literal type="number">10</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Convert initial characters to fraction */</comment>
	<expr_stmt><expr><name>base</name> <operator>=</operator> <name>rangehi</name> <operator>-</operator> <name>rangelo</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>num</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>denom</name> <operator>=</operator> <name>base</name></expr>;</expr_stmt>
	<while>while <condition>(<expr><name>valuelen</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>ch</name> <init>= <expr><operator>*</operator><name>value</name><operator>++</operator></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>ch</name> <operator>&lt;</operator> <name>rangelo</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>rangelo</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>ch</name> <operator>&gt;</operator> <name>rangehi</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>ch</name> <operator>=</operator> <name>rangehi</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>num</name> <operator>+=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name>ch</name> <operator>-</operator> <name>rangelo</name><operator>)</operator><operator>)</operator> <operator>/</operator> <name>denom</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>denom</name> <operator>*=</operator> <name>base</name></expr>;</expr_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>num</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Do convert_to_scalar()'s work for any timevalue data type.
 *
 * On failure (e.g., unsupported typid), set *failure to true;
 * otherwise, that variable is not changed.
 */</comment>
<function><type><name>double</name></type>
<name>convert_timevalue_to_scalar</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typid</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>failure</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>typid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>TIMESTAMPOID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetTimestamp</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMESTAMPTZOID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetTimestampTz</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>DATEOID</name></expr>:</case>
			<return>return <expr><call><name>date2timestamp_no_overflow</name><argument_list>(<argument><expr><call><name>DatumGetDateADT</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>INTERVALOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>interval</name> <init>= <expr><call><name>DatumGetIntervalP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/*
				 * Convert the month part of Interval to days using assumed
				 * average month length of 365.25/12.0 days.  Not too
				 * accurate, but plenty good enough for our purposes.
				 */</comment>
				<return>return <expr><name><name>interval</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <name><name>interval</name><operator>-&gt;</operator><name>day</name></name> <operator>*</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>USECS_PER_DAY</name> <operator>+</operator>
					<name><name>interval</name><operator>-&gt;</operator><name>month</name></name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>DAYS_PER_YEAR</name> <operator>/</operator> <operator>(</operator><name>double</name><operator>)</operator> <name>MONTHS_PER_YEAR</name><operator>)</operator> <operator>*</operator> <name>USECS_PER_DAY</name><operator>)</operator></expr>;</return>
			</block_content>}</block>
		<case>case <expr><name>TIMEOID</name></expr>:</case>
			<return>return <expr><call><name>DatumGetTimeADT</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</return>
		<case>case <expr><name>TIMETZOID</name></expr>:</case>
			<block>{<block_content>
				<decl_stmt><decl><type><name>TimeTzADT</name>  <modifier>*</modifier></type><name>timetz</name> <init>= <expr><call><name>DatumGetTimeTzADTP</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<comment type="block">/* use GMT-equivalent time */</comment>
				<return>return <expr><operator>(</operator><name>double</name><operator>)</operator> <operator>(</operator><name><name>timetz</name><operator>-&gt;</operator><name>time</name></name> <operator>+</operator> <operator>(</operator><name><name>timetz</name><operator>-&gt;</operator><name>zone</name></name> <operator>*</operator> <literal type="number">1000000.0</literal><operator>)</operator><operator>)</operator></expr>;</return>
			</block_content>}</block>
	</block_content>}</block></switch>

	<expr_stmt><expr><operator>*</operator><name>failure</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_restriction_variable
 *		Examine the args of a restriction clause to see if it's of the
 *		form (variable op pseudoconstant) or (pseudoconstant op variable),
 *		where "variable" could be either a Var or an expression in vars of a
 *		single relation.  If so, extract information about the variable,
 *		and also indicate which side it was on and the other argument.
 *
 * Inputs:
 *	root: the planner info
 *	args: clause argument list
 *	varRelid: see specs for restriction selectivity functions
 *
 * Outputs: (these are valid only if true is returned)
 *	*vardata: gets information about variable (see examine_variable)
 *	*other: gets other clause argument, aggressively reduced to a constant
 *	*varonleft: set true if variable is on the left, false if on the right
 *
 * Returns true if a variable is identified, otherwise false.
 *
 * Note: if there are Vars on both sides of the clause, we must fail, because
 * callers are expecting that the other side will act like a pseudoconstant.
 */</comment>
<function><type><name>bool</name></type>
<name>get_restriction_variable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>,
						 <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier><modifier>*</modifier></type><name>other</name></decl></parameter>,
						 <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>varonleft</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>left</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>rdata</name></decl>;</decl_stmt>

	<comment type="block">/* Fail if not a binary opclause (probably shouldn't happen) */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Examine both sides.  Note that when varRelid is nonzero, Vars of other
	 * relations will be treated as pseudoconstants.
	 */</comment>
	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>rdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If one side is a variable and the other not, we win.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator> <name><name>rdata</name><operator>.</operator><name>rel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>varonleft</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>other</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>rdata</name><operator>.</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Assume we need no ReleaseVariableStats(rdata) here */</comment>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>==</operator> <name>NULL</name> <operator>&amp;&amp;</operator> <name><name>rdata</name><operator>.</operator><name>rel</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>varonleft</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>other</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>var</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Assume we need no ReleaseVariableStats(*vardata) here */</comment>
		<expr_stmt><expr><operator>*</operator><name>vardata</name> <operator>=</operator> <name>rdata</name></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Oops, clause has wrong structure (probably var op var) */</comment>
	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><operator>*</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>rdata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_join_variables
 *		Apply examine_variable() to each side of a join clause.
 *		Also, attempt to identify whether the join clause has the same
 *		or reversed sense compared to the SpecialJoinInfo.
 *
 * We consider the join clause "normal" if it is "lhs_var OP rhs_var",
 * or "reversed" if it is "rhs_var OP lhs_var".  In complicated cases
 * where we can't tell for sure, we default to assuming it's normal.
 */</comment>
<function><type><name>void</name></type>
<name>get_join_variables</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>args</name></decl></parameter>, <parameter><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name></decl></parameter>,
				   <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata1</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata2</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>join_is_reversed</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>left</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"join operator should take two arguments"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>left</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>linitial</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>right</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name>args</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>left</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>vardata1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>examine_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>vardata2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>vardata1</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator>
		<call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>vardata1</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_righthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>join_is_reversed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* var1 is on RHS */</comment>
	<if type="elseif">else if <condition>(<expr><name><name>vardata2</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator>
			 <call><name>bms_is_subset</name><argument_list>(<argument><expr><name><name>vardata2</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relids</name></name></expr></argument>, <argument><expr><name><name>sjinfo</name><operator>-&gt;</operator><name>syn_lefthand</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>join_is_reversed</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* var2 is on LHS */</comment>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>join_is_reversed</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * This method returns a pointer to the largest child relation for an inherited (incl partitioned)
 * relation. If there are multiple levels in the hierarchy, we delve down recursively till we
 * find the largest (as determined from the path structure).
 * Input: a partitioned table
 * Output: largest child partition. If there are no child partition because all of them have been eliminated, then
 *         returns NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>largest_child_relation</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Path</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>recursing</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>subpaths</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>subpath_lc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>largest_child_in_subpath</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>max_rows</name> <init>= <expr><operator>-</operator><literal type="number">1.0</literal></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Guard against stack overflow due to overly complex inheritance trees */</comment>
	<expr_stmt><expr><call><name>check_stack_depth</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<while>while <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>ProjectionPath</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>path</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>ProjectionPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpath</name></expr>;</expr_stmt></block_content></block></while>

	<comment type="block">/*
	 * Add the children of an Append or MergeAppend path to the list
	 * of paths to process.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>AppendPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>subpaths</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>AppendPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpaths</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>path</name></expr></argument>, <argument><expr><name>MergeAppendPath</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>subpaths</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>MergeAppendPath</name> <operator>*</operator><operator>)</operator> <name>path</name><operator>)</operator><operator>-&gt;</operator><name>subpaths</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>recursing</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name><name>path</name><operator>-&gt;</operator><name>parent</name></name></expr>;</return></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<return>return <expr><name>NULL</name></expr>;</return></block_content></block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>subpath_lc</argument>, <argument>subpaths</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Path</name>	   <modifier>*</modifier></type><name>subpath</name> <init>= <expr><call><name>lfirst</name><argument_list>(<argument><expr><name>subpath_lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>candidate_child</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>candidate_child</name> <operator>=</operator> <call><name>largest_child_relation</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>subpath</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>candidate_child</name> <operator>&amp;&amp;</operator> <name><name>candidate_child</name><operator>-&gt;</operator><name>rows</name></name> <operator>&gt;</operator> <name>max_rows</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>max_rows</name> <operator>=</operator> <name><name>candidate_child</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>largest_child_in_subpath</name> <operator>=</operator> <name>candidate_child</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<return>return <expr><name>largest_child_in_subpath</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * The purpose of this method is to make the statistics (on a specific column) of a child partition
 * representative of the parent relation. This entails the following assumptions:
 * 1.  if ndistinct&lt;=-1.0 in child partition, the column is a unique column in the child partition. We
 * 	   expect the column to remain distinct in the master as well.
 * 2.  if -1.0 &lt; ndistinct &lt; 0.0, the absolute number of ndistinct values in the child partition is a fraction
 *     of the number of rows in the partition. We expect that the absolute number of ndistinct in the master
 *     to stay the same. Therefore, we convert this to a positive number.
 *     The method get_variable_numdistinct will multiply this by the number of tuples in the master relation.
 * 3.  if ndistinct is positive, it indicates a small absolute number of distinct values. We expect these
 * 	   values to be repeated in all partitions. Therefore, we expect no change in the ndistinct in the master.
 *
 * Input:
 * 	   statsTuple, which is a heaptuple representing statistics on a child relation. It expects statstuple to be non-null.
 * 	   scalefactor, which is in the range (0.0,1.0]
 *
 * Output:
 * 	   This method modifies the tuple passed to it.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name> <specifier>inline</specifier></type> <name>adjust_partition_table_statistic_for_parent</name><parameter_list>(<parameter><decl><type><name>HeapTuple</name></type> <name>statsTuple</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>childtuples</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>statsTuple</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>statsTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&lt;=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Case 1 as described above.
		 */</comment>

		<return>return;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Case 2 as described above.
		 */</comment>

		<expr_stmt><expr><name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>double</name><operator>)</operator> <operator>-</operator><literal type="number">1.0</literal><operator>)</operator> <operator>*</operator> <name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name> <operator>*</operator> <name>childtuples</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block" format="doxygen">/**
		 * Case 3 as described above.
		 */</comment>

		<return>return;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * examine_variable
 *		Try to look up statistical data about an expression.
 *		Fill in a VariableStatData struct to describe the expression.
 *
 * Inputs:
 *	root: the planner info
 *	node: the expression tree to examine
 *	varRelid: see specs for restriction selectivity functions
 *
 * Outputs: *vardata is filled as follows:
 *	var: the input expression (with any binary relabeling stripped, if
 *		it is or contains a variable; but otherwise the type is preserved)
 *	rel: RelOptInfo for relation containing variable; NULL if expression
 *		contains no Vars (NOTE this could point to a RelOptInfo of a
 *		subquery, not one in the current query).
 *	statsTuple: the pg_statistic entry for the variable, if one exists;
 *		otherwise NULL.
 *	freefunc: pointer to a function to release statsTuple with.
 *	vartype: exposed type of the expression; this should always match
 *		the declared input type of the operator we are estimating for.
 *	atttype, atttypmod: actual type/typmod of the "var" expression.  This is
 *		commonly the same as the exposed type of the variable argument,
 *		but can be different in binary-compatible-type cases.
 *	isunique: true if we were able to match the var to a unique index or a
 *		single-column DISTINCT clause, implying its values are unique for
 *		this query.  (Caution: this should be trusted for statistical
 *		purposes only, since we do not check indimmediate nor verify that
 *		the exact same definition of equality applies.)
 *	acl_ok: true if current user has permission to read the column(s)
 *		underlying the pg_statistic entry.  This is consulted by
 *		statistic_proc_security_check().
 *
 * Caller is responsible for doing ReleaseVariableStats() before exiting.
 */</comment>
<function><type><name>void</name></type>
<name>examine_variable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Node</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>varRelid</name></decl></parameter>,
				 <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>basenode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relids</name></type>		<name>varnos</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>onerel</name></decl>;</decl_stmt>

	<comment type="block">/* Make sure we don't return dangling pointers in vardata */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>VariableStatData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save the exposed type of the expression */</comment>
	<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>vartype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>numdistinctFromPrimaryKey</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt> <comment type="block">/* ignore by default*/</comment>

	<comment type="block">/* Look inside any binary-compatible relabeling */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>basenode</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>node</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>basenode</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Fast path for a simple Var */</comment>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>basenode</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>varRelid</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>varRelid</name> <operator>==</operator> <operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>basenode</name><operator>)</operator><operator>-&gt;</operator><name>varno</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Var</name>		   <modifier>*</modifier></type><name>var</name> <init>= <expr><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name>basenode</name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Set up result fields other than the stats tuple */</comment>
		<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>var</name></name> <operator>=</operator> <name>basenode</name></expr>;</expr_stmt>	<comment type="block">/* return Var without relabeling */</comment>
		<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttype</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartype</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <name><name>var</name><operator>-&gt;</operator><name>vartypmod</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <call><name>has_unique_index</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Try to locate some stats */</comment>
		<expr_stmt><expr><call><name>examine_simple_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Okay, it's a more complicated expression.  Determine variable
	 * membership.  Note that when varRelid isn't zero, only vars of that
	 * relation are considered "real" vars.
	 */</comment>
	<expr_stmt><expr><name>varnos</name> <operator>=</operator> <call><name>pull_varnos</name><argument_list>(<argument><expr><name>basenode</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>onerel</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name>varnos</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BMS_EMPTY_SET</name></expr>:</case>
			<comment type="block">/* No Vars at all ... must be pseudo-constant clause */</comment>
			<break>break;</break>
		<case>case <expr><name>BMS_SINGLETON</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>varRelid</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>bms_is_member</name><argument_list>(<argument><expr><name>varRelid</name></expr></argument>, <argument><expr><name>varnos</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>onerel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
									   <argument><expr><operator>(</operator><ternary><condition><expr><name>varRelid</name></expr> ?</condition><then> <expr><name>varRelid</name></expr> </then><else>: <expr><call><name>bms_singleton_member</name><argument_list>(<argument><expr><name>varnos</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <name>onerel</name></expr>;</expr_stmt>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <name>basenode</name></expr>;</expr_stmt>	<comment type="block">/* strip any relabeling */</comment>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* else treat it as a constant */</comment>
			<break>break;</break>
		<case>case <expr><name>BMS_MULTIPLE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>varRelid</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* treat it as a variable of a join relation */</comment>
				<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <call><name>find_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <name>basenode</name></expr>;</expr_stmt>	<comment type="block">/* strip any relabeling */</comment>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>bms_is_member</name><argument_list>(<argument><expr><name>varRelid</name></expr></argument>, <argument><expr><name>varnos</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/* ignore the vars belonging to other relations */</comment>
				<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>node</name> <operator>=</operator> <name>basenode</name></expr>;</expr_stmt>	<comment type="block">/* strip any relabeling */</comment>
				<comment type="block">/* note: no point in expressional-index search here */</comment>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* else treat it as a constant */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>bms_free</name><argument_list>(<argument><expr><name>varnos</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>var</name></name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttype</name></name> <operator>=</operator> <call><name>exprType</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttypmod</name></name> <operator>=</operator> <call><name>exprTypmod</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>onerel</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We have an expression in vars of a single relation.  Try to match
		 * it to expressional index columns, in hopes of finding some
		 * statistics.
		 *
		 * Note that we consider all index columns including INCLUDE columns,
		 * since there could be stats for such columns.  But the test for
		 * uniqueness needs to be warier.
		 *
		 * XXX it's conceivable that there are multiple matches with different
		 * index opfamilies; if so, we need to pick one that matches the
		 * operator we are estimating for.  FIXME later.
		 */</comment>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>ilist</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>ilist</argument>, <argument>onerel-&gt;indexlist</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><operator>(</operator><name>IndexOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>ilist</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>indexpr_item</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>pos</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>list_head</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
				<continue>continue;</continue></block_content></block></if></if_stmt>		<comment type="block">/* no expressions here... */</comment>

			<for>for <control>(<init><expr><name>pos</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>pos</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>ncolumns</name></name></expr>;</condition> <incr><expr><name>pos</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name>pos</name></expr>]</index></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>indexkey</name></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><name>indexpr_item</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"too few entries in indexprs list"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>indexkey</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>indexkey</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>indexkey</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>indexkey</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<if_stmt><if>if <condition>(<expr><call><name>equal</name><argument_list>(<argument><expr><name>node</name></expr></argument>, <argument><expr><name>indexkey</name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<comment type="block">/*
						 * Found a match ... is it a unique index? Tests here
						 * should match has_unique_index().
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>&amp;&amp;</operator>
							<name><name>index</name><operator>-&gt;</operator><name>nkeycolumns</name></name> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
							<name>pos</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator>
							<operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>indpred</name></name> <operator>==</operator> <name>NIL</name> <operator>||</operator> <name><name>index</name><operator>-&gt;</operator><name>predOK</name></name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

						<comment type="block">/*
						 * Has it got stats?  We only consider stats for
						 * non-partial indexes, since partial indexes probably
						 * don't reflect whole-relation statistics; the above
						 * check for uniqueness is the only info we take from
						 * a partial index.
						 *
						 * An index stats hook, however, must make its own
						 * decisions about what to do with partial indexes.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><name>get_index_stats_hook</name> <operator>&amp;&amp;</operator>
							<call>(<modifier>*</modifier><name>get_index_stats_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>,
													 <argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>)</condition>
						<block>{<block_content>
							<comment type="block">/*
							 * The hook took control of acquiring a stats
							 * tuple.  If it did supply a tuple, it'd better
							 * have supplied a freefunc.
							 */</comment>
							<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
								<operator>!</operator><name><name>vardata</name><operator>-&gt;</operator><name>freefunc</name></name></expr>)</condition><block type="pseudo"><block_content>
								<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no function provided to release variable stats with"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
						</block_content>}</block></if>
						<if type="elseif">else if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indpred</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition>
						<block>{<block_content>
							<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name> <operator>=</operator>
								<call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
												<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>pos</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>ReleaseSysCache</name></expr>;</expr_stmt>

							<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
							<block>{<block_content>
								<comment type="block">/* Get index's table for permission check */</comment>
								<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
								<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>

								<expr_stmt><expr><name>rte</name> <operator>=</operator> <call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

								<comment type="block">/*
								 * Use checkAsUser if it's set, in case we're
								 * accessing the table via a view.
								 */</comment>
								<expr_stmt><expr><name>userid</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

								<comment type="block">/*
								 * For simplicity, we insist on the whole
								 * table being selectable, rather than trying
								 * to identify which column(s) the index
								 * depends on.  Also require all rows to be
								 * selectable --- there must be no
								 * securityQuals from security barrier views
								 * or RLS policies.
								 */</comment>
								<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>acl_ok</name></name> <operator>=</operator>
									<name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
									<operator>(</operator><call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>userid</name></expr></argument>,
													   <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ACLCHECK_OK</name><operator>)</operator></expr>;</expr_stmt>
							</block_content>}</block></if>
							<else>else
							<block>{<block_content>
								<comment type="block">/* suppress leakproofness checks later */</comment>
								<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>acl_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>
						</block_content>}</block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr>)</condition><block type="pseudo"><block_content>
							<break>break;</break></block_content></block></if></if_stmt>
					</block_content>}</block></if></if_stmt>
					<expr_stmt><expr><name>indexpr_item</name> <operator>=</operator> <call><name>lnext</name><argument_list>(<argument><expr><name>indexpr_item</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * examine_simple_variable
 *		Handle a simple Var for examine_variable
 *
 * This is split out as a subroutine so that we can recurse to deal with
 * Vars referencing subqueries.
 *
 * We already filled in all the fields of *vardata except for the stats tuple.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>examine_simple_variable</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Var</name> <modifier>*</modifier></type><name>var</name></decl></parameter>,
						<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>rte</name></expr></argument>, <argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If this attribute has a foreign key relationship, then first look
	 * at primary key statistics. If there exist stats on that attribute,
	 * we utilize those. If not, continue.
	 */</comment>

	<if_stmt><if>if <condition>(<expr><name>gp_statistics_use_fkeys</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>         <name>pkrelid</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>  <name>pkattno</name> <init>= <expr><operator>-</operator><literal type="number">1</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>ConstraintGetPrimaryKeyOf</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkrelid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>pkattno</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>pkStatsTuple</name></decl>;</decl_stmt>

			<comment type="block">/* SELECT reltuples FROM pg_class */</comment>

			<expr_stmt><expr><name>pkStatsTuple</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>RELOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>pkrelid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>pkStatsTuple</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Form_pg_class</name></type> <name>classForm</name> <init>= <expr><operator>(</operator><name>Form_pg_class</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>pkStatsTuple</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>classForm</name><operator>-&gt;</operator><name>reltuples</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>numdistinctFromPrimaryKey</name></name> <operator>=</operator> <name><name>classForm</name><operator>-&gt;</operator><name>reltuples</name></name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>pkStatsTuple</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt> 

	<if_stmt><if>if <condition>(<expr><name>get_relation_stats_hook</name> <operator>&amp;&amp;</operator>
		<call>(<modifier>*</modifier><name>get_relation_stats_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The hook took control of acquiring a stats tuple.  If it did supply
		 * a tuple, it'd better have supplied a freefunc.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<operator>!</operator><name><name>vardata</name><operator>-&gt;</operator><name>freefunc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no function provided to release variable stats with"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Plain table or parent of an inheritance appendrel, so look up the
		 * column in pg_statistic
		 */</comment>
		<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name> <operator>&amp;&amp;</operator> <name>gp_statistics_pullup_from_child_partition</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * GPDB: #13467
			 * If var-&gt;varattno is 0 (e.g.,SELECT DISTINCT &lt;Table_name&gt; FROM &lt;Table_name&gt;),
			 * we will get an ERROR when we invoke get_attname with missing_ok == false,
			 * so the NULL string is all we need.
			 */</comment>
			<decl_stmt><decl><type><name>bool</name></type> <name>missing_ok</name> <init>= <expr><ternary><condition><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>true</name></expr> </then><else>: <expr><name>false</name></expr></else></ternary></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name>  <init>= <expr><call><name>get_attname</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>missing_ok</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<comment type="block">/*
			 * The GUC gp_statistics_pullup_from_child_partition is
			 * set false defaultly. If it is true, we always try
			 * to use largest child's stat.
			 */</comment>
			<expr_stmt><expr><call><name>try_fetch_largest_child_stats</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
												  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr></argument>,
												  <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>ReleaseSysCache</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>userid</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Check if user has permission to read this column.  We require
			 * all rows to be accessible, so there must be no securityQuals
			 * from security barrier views or RLS policies.  Use checkAsUser
			 * if it's set, in case we're accessing the table via a view.
			 */</comment>
			<expr_stmt><expr><name>userid</name> <operator>=</operator> <ternary><condition><expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> ?</condition><then> <expr><name><name>rte</name><operator>-&gt;</operator><name>checkAsUser</name></name></expr> </then><else>: <expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></else></ternary></expr>;</expr_stmt>

			<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>acl_ok</name></name> <operator>=</operator>
				<name><name>rte</name><operator>-&gt;</operator><name>securityQuals</name></name> <operator>==</operator> <name>NIL</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><operator>(</operator><call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>userid</name></expr></argument>,
									<argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ACLCHECK_OK</name><operator>)</operator> <operator>||</operator>
				 <operator>(</operator><call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>, <argument><expr><name>userid</name></expr></argument>,
										<argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>ACLCHECK_OK</name><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* suppress any possible leakproofness checks later */</comment>
			<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>acl_ok</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_SUBQUERY</name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Plain subquery (not one that was converted to an appendrel).
		 */</comment>
		<decl_stmt><decl><type><name>Query</name>	   <modifier>*</modifier></type><name>subquery</name> <init>= <expr><name><name>rte</name><operator>-&gt;</operator><name>subquery</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TargetEntry</name> <modifier>*</modifier></type><name>ste</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Punt if it's a whole-row var rather than a plain column reference.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name> <operator>==</operator> <name>InvalidAttrNumber</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Punt if subquery uses set operations or GROUP BY, as these will
		 * mash underlying columns' stats beyond recognition.  (Set ops are
		 * particularly nasty; if we forged ahead, we would return stats
		 * relevant to only the leftmost subselect...)	DISTINCT is also
		 * problematic, but we check that later because there is a possibility
		 * of learning something even with it.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>setOperations</name></name> <operator>||</operator>
			<name><name>subquery</name><operator>-&gt;</operator><name>groupClause</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * OK, fetch RelOptInfo for subquery.  Note that we don't change the
		 * rel returned in vardata, since caller expects it to be a rel of the
		 * caller's query level.  Because we might already be recursing, we
		 * can't use that rel pointer either, but have to look up the Var's
		 * rel afresh.
		 */</comment>
		<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* If the subquery hasn't been planned yet, we have to punt */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name>PlannerInfo</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Switch our attention to the subquery as mangled by the planner. It
		 * was okay to look at the pre-planning version for the tests above,
		 * but now we need a Var that will refer to the subroot's live
		 * RelOptInfos.  For instance, if any subquery pullup happened during
		 * planning, Vars in the targetlist might have gotten replaced, and we
		 * need to see the replacement expressions.
		 */</comment>
		<expr_stmt><expr><name>subquery</name> <operator>=</operator> <name><name>rel</name><operator>-&gt;</operator><name>subroot</name><operator>-&gt;</operator><name>parse</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>IsA</name><argument_list>(<argument><expr><name>subquery</name></expr></argument>, <argument><expr><name>Query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Get the subquery output expression referenced by the upper Var */</comment>
		<expr_stmt><expr><name>ste</name> <operator>=</operator> <call><name>get_tle_by_resno</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>targetList</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>ste</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>ste</name><operator>-&gt;</operator><name>resjunk</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"subquery %s does not have attribute %d"</literal></expr></argument>,
				 <argument><expr><name><name>rte</name><operator>-&gt;</operator><name>eref</name><operator>-&gt;</operator><name>aliasname</name></name></expr></argument>, <argument><expr><name><name>var</name><operator>-&gt;</operator><name>varattno</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>var</name> <operator>=</operator> <operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>ste</name><operator>-&gt;</operator><name>expr</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * If subquery uses DISTINCT, we can't make use of any stats for the
		 * variable ... but, if it's the only DISTINCT column, we are entitled
		 * to consider it unique.  We do the test this way so that it works
		 * for cases involving DISTINCT ON.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>list_length</name><argument_list>(<argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
				<call><name>targetIsInSortList</name><argument_list>(<argument><expr><name>ste</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name><name>subquery</name><operator>-&gt;</operator><name>distinctClause</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>isunique</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<comment type="block">/* cannot go further */</comment>
			<return>return;</return>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * If the sub-query originated from a view with the security_barrier
		 * attribute, we must not look at the variable's statistics, though it
		 * seems all right to notice the existence of a DISTINCT clause. So
		 * stop here.
		 *
		 * This is probably a harsher restriction than necessary; it's
		 * certainly OK for the selectivity estimator (which is a C function,
		 * and therefore omnipotent anyway) to look at the statistics.  But
		 * many selectivity estimators will happily *invoke the operator
		 * function* to try to work out a good estimate - and that's not OK.
		 * So for now, don't dig down for stats.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>rte</name><operator>-&gt;</operator><name>security_barrier</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<comment type="block">/* Can only handle a simple Var of subquery's query level */</comment>
		<if_stmt><if>if <condition>(<expr><name>var</name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name>var</name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<name><name>var</name><operator>-&gt;</operator><name>varlevelsup</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * OK, recurse into the subquery.  Note that the original setting
			 * of vardata-&gt;isunique (which will surely be false) is left
			 * unchanged in this situation.  That's what we want, since even
			 * if the underlying column is unique, the subquery may have
			 * joined to other tables in a way that creates duplicates.
			 */</comment>
			<expr_stmt><expr><call><name>examine_simple_variable</name><argument_list>(<argument><expr><name><name>rel</name><operator>-&gt;</operator><name>subroot</name></name></expr></argument>, <argument><expr><name>var</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Otherwise, the Var comes from a FUNCTION, VALUES, or CTE RTE.  (We
		 * won't see RTE_JOIN here because join alias Vars have already been
		 * flattened.)	There's not much we can do with function outputs, but
		 * maybe someday try to be smarter about VALUES and/or CTEs.
		 */</comment>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check whether it is permitted to call func_oid passing some of the
 * pg_statistic data in vardata.  We allow this either if the user has SELECT
 * privileges on the table or column underlying the pg_statistic data or if
 * the function is marked leak-proof.
 */</comment>
<function><type><name>bool</name></type>
<name>statistic_proc_security_check</name><parameter_list>(<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>func_oid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>acl_ok</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>get_func_leakproof</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>DEBUG2</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errmsg_internal</name><argument_list>(<argument><expr><literal type="string">"not using statistics because function \"%s\" is not leak-proof"</literal></expr></argument>,
							 <argument><expr><call><name>get_func_name</name><argument_list>(<argument><expr><name>func_oid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>false</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_variable_numdistinct
 *	  Estimate the number of distinct values of a variable.
 *
 * vardata: results of examine_variable
 * *isdefault: set to true if the result is a default rather than based on
 * anything meaningful.
 *
 * NB: be careful to produce a positive integral result, since callers may
 * compare the result to exact integer counts, or might divide by it.
 */</comment>
<function><type><name>double</name></type>
<name>get_variable_numdistinct</name><parameter_list>(<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>isdefault</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>stadistinct</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>stanullfrac</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>ntuples</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>isdefault</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block" format="doxygen">/**
	 * If we have an estimate from the primary key, then that is the most accurate value.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>gp_statistics_use_fkeys</name> <operator>&amp;&amp;</operator>
			<name><name>vardata</name><operator>-&gt;</operator><name>numdistinctFromPrimaryKey</name></name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<return>return <expr><name><name>vardata</name><operator>-&gt;</operator><name>numdistinctFromPrimaryKey</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Determine the stadistinct value to use.  There are cases where we can
	 * get an estimate even without a pg_statistic entry, or can get a better
	 * value than is in pg_statistic.  Grab stanullfrac too if we can find it
	 * (otherwise, assume no nulls, for lack of any better idea).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Use the pg_statistic entry */</comment>
		<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type> <name>tp</name> <init>= <expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stadistinct</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>stanullfrac</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>vartype</name></name> <operator>==</operator> <name>BOOLOID</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Special-case boolean columns: presumably, two distinct values.
		 *
		 * Are there any other datatypes we should wire in special estimates
		 * for?
		 */</comment>
		<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">2.0</literal></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>&amp;&amp;</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_VALUES</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If the Var represents a column of a VALUES RTE, assume it's unique.
		 * This could of course be very wrong, but it should tend to be true
		 * in well-written queries.  We could consider examining the VALUES'
		 * contents to get some real statistics; but that only works if the
		 * entries are all constants, and it would be pretty expensive anyway.
		 */</comment>
		<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt>		<comment type="block">/* unique (and all non null) */</comment>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We don't keep statistics for system columns, but in some cases we
		 * can infer distinctness anyway.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>var</name></name> <operator>&amp;&amp;</operator> <call><name>IsA</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><name>Var</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<switch>switch <condition>(<expr><operator>(</operator><operator>(</operator><name>Var</name> <operator>*</operator><operator>)</operator> <name><name>vardata</name><operator>-&gt;</operator><name>var</name></name><operator>)</operator><operator>-&gt;</operator><name>varattno</name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>SelfItemPointerAttributeNumber</name></expr>:</case>
					<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal></expr>;</expr_stmt> <comment type="block">/* unique (and all non null) */</comment>
					<break>break;</break>
				<case>case <expr><name>TableOidAttributeNumber</name></expr>:</case>
					<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>	<comment type="block">/* only 1 value */</comment>
					<break>break;</break>
				<case>case <expr><name>GpSegmentIdAttributeNumber</name></expr>:</case>   <comment type="block">/*CDB*/</comment>
					<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <call><name>getgpsegmentCount</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
					<break>break;</break>
				<default>default:</default>
					<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>	<comment type="block">/* means "unknown" */</comment>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* means "unknown" */</comment>

		<comment type="block">/*
		 * XXX consider using estimate_num_groups on expressions?
		 */</comment>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If there is a unique index or DISTINCT clause for the variable, assume
	 * it is unique no matter what pg_statistic says; the statistics could be
	 * out of date, or we might have found a partial unique index that proves
	 * the var is unique for this query.  However, we'd better still believe
	 * the null-fraction statistic.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>isunique</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>stadistinct</name> <operator>=</operator> <operator>-</operator><literal type="number">1.0</literal> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>stanullfrac</name><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If we had an absolute estimate, use that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&gt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><name>stadistinct</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise we need to get the relation size; punt if not available.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isdefault</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>DEFAULT_NUM_DISTINCT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>ntuples</name> <operator>=</operator> <name><name>vardata</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>ntuples</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>isdefault</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<return>return <expr><name>DEFAULT_NUM_DISTINCT</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we had a relative estimate, use that.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>stadistinct</name> <operator>&lt;</operator> <literal type="number">0.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><operator>-</operator><name>stadistinct</name> <operator>*</operator> <name>ntuples</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * With no data, estimate ndistinct = ntuples if the table is small, else
	 * use default.  We use DEFAULT_NUM_DISTINCT as the cutoff for "small" so
	 * that the behavior isn't discontinuous.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ntuples</name> <operator>&lt;</operator> <name>DEFAULT_NUM_DISTINCT</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>clamp_row_est</name><argument_list>(<argument><expr><name>ntuples</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>isdefault</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<return>return <expr><name>DEFAULT_NUM_DISTINCT</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * get_variable_range
 *		Estimate the minimum and maximum value of the specified variable.
 *		If successful, store values in *min and *max, and return true.
 *		If no data available, return false.
 *
 * sortop is the "&lt;" comparison operator to use.  This should generally
 * be "&lt;" not "&gt;", as only the former is likely to be found in pg_statistic.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_variable_range</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>sortop</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmin</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>tmax</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>typLen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>typByVal</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>opfuncoid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name> <init>= <expr><call><name>getStatsTuple</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * XXX It's very tempting to try to use the actual column min and max, if
	 * we can get them relatively-cheaply with an index probe.  However, since
	 * this function is called many times during join planning, that could
	 * have unpleasant effects on planning speed.  Need more investigation
	 * before enabling this.
	 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<if_stmt><if>if <condition>(<expr><call><name>get_actual_variable_range</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>, <argument><expr><name>min</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* no stats available, so default result */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we can't apply the sortop to the stats data, just fail.  In
	 * principle, if there's a histogram and no MCVs, we could return the
	 * histogram endpoints without ever applying the sortop ... but it's
	 * probably not worth trying, because whatever the caller wants to do with
	 * the endpoints would likely fail the security check too.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>statistic_proc_security_check</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>,
									   <argument><expr><operator>(</operator><name>opfuncoid</name> <operator>=</operator> <call><name>get_opcode</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a histogram, grab the first and last values.
	 *
	 * If there is a histogram that is sorted with some other operator than
	 * the one we want, fail --- this suggests that there is data we can't
	 * use.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
						 <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>,
						 <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * GPDB: GPDB allows users to modify pg_statistics.stavalues with
		 * UPDATEs (PostgreSQL complaints about the table row type not
		 * matching). So just in case that the type of the values in
		 * pg_statistics isn't what we'd expect, give an error rather than
		 * crash. That shouldn't happen, but better safe than sorry.
		 *
		 * GPDB_91_MERGE_FIXME: this is the second place we've added this. Does
		 * it need to be pulled into get_attstatsslot() itself?
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>valuetype</name></name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid histogram of type %s, for attribute of type %s"</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>valuetype</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>tmin</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>tmax</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name><name>sslot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>have_data</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
							  <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
							  <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If we have most-common-values info, look for extreme MCVs.  This is
	 * needed even if we also have a histogram, since the histogram excludes
	 * the MCVs.  However, usually the MCVs will not be the extreme values, so
	 * avoid unnecessary data copying.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
						 <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>bool</name></type>		<name>tmin_is_mcv</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>tmax_is_mcv</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>opproc</name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><name>opfuncoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * GPDB: See the identical check, above, for histogram data.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>valuetype</name></name></expr></argument>, <argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttype</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"invalid MCV array of type %s, for attribute of type %s"</literal></expr></argument>,
				 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>valuetype</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttype</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sslot</name><operator>.</operator><name>nvalues</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>have_data</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tmin</name> <operator>=</operator> <name>tmax</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmin_is_mcv</name> <operator>=</operator> <name>tmax_is_mcv</name> <operator>=</operator> <name>have_data</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<continue>continue;</continue>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>,
											   <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
											   <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>tmin</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tmin</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmin_is_mcv</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name>opproc</name></expr></argument>,
											   <argument><expr><name><name>sslot</name><operator>.</operator><name>stacoll</name></name></expr></argument>,
											   <argument><expr><name>tmax</name></expr></argument>, <argument><expr><name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>tmax</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>tmax_is_mcv</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>
		<if_stmt><if>if <condition>(<expr><name>tmin_is_mcv</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tmin</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>tmin</name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name>tmax_is_mcv</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tmax</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name>tmax</name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <name>tmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <name>tmax</name></expr>;</expr_stmt>
	<return>return <expr><name>have_data</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * get_actual_variable_range
 *		Attempt to identify the current *actual* minimum and/or maximum
 *		of the specified variable, by looking for a suitable btree index
 *		and fetching its low and/or high values.
 *		If successful, store values in *min and *max, and return true.
 *		(Either pointer can be NULL if that endpoint isn't needed.)
 *		If no data available, return false.
 *
 * sortop is the "&lt;" comparison operator to use.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>get_actual_variable_range</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata</name></decl></parameter>,
						  <parameter><decl><type><name>Oid</name></type> <name>sortop</name></decl></parameter>,
						  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>min</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>have_data</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name><name>vardata</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/* No hope if no relation or it doesn't have indexes */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name> <operator>||</operator> <name><name>rel</name><operator>-&gt;</operator><name>indexlist</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
	<comment type="block">/* If it has indexes it must be a plain relation */</comment>
	<expr_stmt><expr><name>rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Search through the indexes to see if any match our problem */</comment>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>rel-&gt;indexlist</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><operator>(</operator><name>IndexOptInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ScanDirection</name></type> <name>indexscandir</name></decl>;</decl_stmt>

		<comment type="block">/* Ignore non-btree indexes */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>relam</name></name> <operator>!=</operator> <name>BTREE_AM_OID</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Ignore partial indexes --- we only want stats that cover the entire
		 * relation.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indpred</name></name> <operator>!=</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The index list might include hypothetical indexes inserted by a
		 * get_relation_info hook --- don't try to access them.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>hypothetical</name></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * The first index column must match the desired variable and sort
		 * operator --- but we can use a descending-order index.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>match_index_to_operand</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>var</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>
		<switch>switch <condition>(<expr><call><name>get_op_opfamily_strategy</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>sortopfamily</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>BTLessStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>indexscandir</name> <operator>=</operator> <name>BackwardScanDirection</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>indexscandir</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<case>case <expr><name>BTGreaterStrategyNumber</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>indexscandir</name> <operator>=</operator> <name>ForwardScanDirection</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>indexscandir</name> <operator>=</operator> <name>BackwardScanDirection</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<break>break;</break>
			<default>default:</default>
				<comment type="block">/* index doesn't match the sortop */</comment>
				<continue>continue;</continue>
		</block_content>}</block></switch>

		<comment type="block">/*
		 * Found a suitable index to extract data from.  We'll need an EState
		 * and a bunch of other infrastructure.
		 */</comment>
		<block>{<block_content>
			<decl_stmt><decl><type><name>EState</name>	   <modifier>*</modifier></type><name>estate</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ExprContext</name> <modifier>*</modifier></type><name>econtext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>tmpcontext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>MemoryContext</name></type> <name>oldcontext</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>heapRel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexInfo</name>  <modifier>*</modifier></type><name>indexInfo</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int16</name></type>		<name>typLen</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>typByVal</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>ScanKeyData</name></type> <name><name>scankeys</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>IndexScanDesc</name></type> <name>index_scan</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name><name>values</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name><name>isnull</name><index>[<expr><name>INDEX_MAX_KEYS</name></expr>]</index></name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>SnapshotData</name></type> <name>SnapshotNonVacuumable</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>estate</name> <operator>=</operator> <call><name>CreateExecutorState</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>econtext</name> <operator>=</operator> <call><name>GetPerTupleExprContext</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<comment type="block">/* Make sure any cruft is generated in the econtext's memory */</comment>
			<expr_stmt><expr><name>tmpcontext</name> <operator>=</operator> <name><name>econtext</name><operator>-&gt;</operator><name>ecxt_per_tuple_memory</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>oldcontext</name> <operator>=</operator> <call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Open the table and index so we can read from them.  We should
			 * already have some type of lock on each.
			 */</comment>
			<expr_stmt><expr><name>heapRel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* extract index key information from the index's pg_index info */</comment>
			<expr_stmt><expr><name>indexInfo</name> <operator>=</operator> <call><name>BuildIndexInfo</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* some other stuff */</comment>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>table_slot_create</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>econtext</name><operator>-&gt;</operator><name>ecxt_scantuple</name></name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>get_typlenbyval</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>atttype</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typLen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typByVal</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>InitNonVacuumableSnapshot</name><argument_list>(<argument><expr><name>SnapshotNonVacuumable</name></expr></argument>, <argument><expr><name>RecentGlobalXmin</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* set up an IS NOT NULL scan key so that we ignore nulls */</comment>
			<expr_stmt><expr><call><name>ScanKeyEntryInitialize</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>scankeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
								   <argument><expr><name>SK_ISNULL</name> <operator>|</operator> <name>SK_SEARCHNOTNULL</name></expr></argument>,
								   <argument><expr><literal type="number">1</literal></expr></argument>,	<comment type="block">/* index col to scan */</comment>
								   <argument><expr><name>InvalidStrategy</name></expr></argument>, <comment type="block">/* no strategy */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no strategy subtype */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no collation */</comment>
								   <argument><expr><name>InvalidOid</name></expr></argument>,	<comment type="block">/* no reg proc for this */</comment>
								   <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* constant */</comment>

			<expr_stmt><expr><name>have_data</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

			<comment type="block">/* If min is requested ... */</comment>
			<if_stmt><if>if <condition>(<expr><name>min</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In principle, we should scan the index with our current
				 * active snapshot, which is the best approximation we've got
				 * to what the query will see when executed.  But that won't
				 * be exact if a new snap is taken before running the query,
				 * and it can be very expensive if a lot of recently-dead or
				 * uncommitted rows exist at the beginning or end of the index
				 * (because we'll laboriously fetch each one and reject it).
				 * Instead, we use SnapshotNonVacuumable.  That will accept
				 * recently-dead and uncommitted rows as well as normal
				 * visible rows.  On the other hand, it will reject known-dead
				 * rows, and thus not give a bogus answer when the extreme
				 * value has been deleted (unless the deletion was quite
				 * recent); that case motivates not using SnapshotAny here.
				 *
				 * A crucial point here is that SnapshotNonVacuumable, with
				 * RecentGlobalXmin as horizon, yields the inverse of the
				 * condition that the indexscan will use to decide that index
				 * entries are killable (see heap_hot_search_buffer()).
				 * Therefore, if the snapshot rejects a tuple and we have to
				 * continue scanning past it, we know that the indexscan will
				 * mark that index entry killed.  That means that the next
				 * get_actual_variable_range() call will not have to visit
				 * that heap entry.  In this way we avoid repetitive work when
				 * this function is used a lot during planning.
				 */</comment>
				<expr_stmt><expr><name>index_scan</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>indexRel</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>SnapshotNonVacuumable</name></expr></argument>,
											 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>, <argument><expr><name>scankeys</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Fetch first tuple in sortop's direction */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>index_getnext_slot</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>, <argument><expr><name>indexscandir</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Extract the index column values from the slot */</comment>
					<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
								   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Shouldn't have got a null, but be careful */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found unexpected null value in index \"%s\""</literal></expr></argument>,
							 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Copy the index column value out to caller's context */</comment>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>min</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>have_data</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* If max is requested, and we didn't find the index is empty */</comment>
			<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&amp;&amp;</operator> <name>have_data</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>index_scan</name> <operator>=</operator> <call><name>index_beginscan</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>indexRel</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>SnapshotNonVacuumable</name></expr></argument>,
											 <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>index_rescan</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>, <argument><expr><name>scankeys</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* Fetch first tuple in reverse direction */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>index_getnext_slot</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>, <argument><expr><operator>-</operator><name>indexscandir</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* Extract the index column values from the slot */</comment>
					<expr_stmt><expr><call><name>FormIndexDatum</name><argument_list>(<argument><expr><name>indexInfo</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>estate</name></expr></argument>,
								   <argument><expr><name>values</name></expr></argument>, <argument><expr><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

					<comment type="block">/* Shouldn't have got a null, but be careful */</comment>
					<if_stmt><if>if <condition>(<expr><name><name>isnull</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"found unexpected null value in index \"%s\""</literal></expr></argument>,
							 <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

					<comment type="block">/* Copy the index column value out to caller's context */</comment>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><operator>*</operator><name>max</name> <operator>=</operator> <call><name>datumCopy</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>, <argument><expr><name>typByVal</name></expr></argument>, <argument><expr><name>typLen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>tmpcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>have_data</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>index_endscan</name><argument_list>(<argument><expr><name>index_scan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

			<comment type="block">/* Clean everything up */</comment>
			<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>heapRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemoryContextSwitchTo</name><argument_list>(<argument><expr><name>oldcontext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>FreeExecutorState</name><argument_list>(<argument><expr><name>estate</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/* And we're done */</comment>
			<break>break;</break>
		</block_content>}</block>
	</block_content>}</block>

	<return>return <expr><name>have_data</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * find_join_input_rel
 *		Look up the input relation for a join.
 *
 * We assume that the input relation's RelOptInfo must have been constructed
 * already.
 */</comment>
<function><type><specifier>static</specifier> <name>RelOptInfo</name> <modifier>*</modifier></type>
<name>find_join_input_rel</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Relids</name></type> <name>relids</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>rel</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<switch>switch <condition>(<expr><call><name>bms_membership</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>BMS_EMPTY_SET</name></expr>:</case>
			<comment type="block">/* should not happen */</comment>
			<break>break;</break>
		<case>case <expr><name>BMS_SINGLETON</name></expr>:</case>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><call><name>bms_singleton_member</name><argument_list>(<argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>BMS_MULTIPLE</name></expr>:</case>
			<expr_stmt><expr><name>rel</name> <operator>=</operator> <call><name>find_join_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><name>rel</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not find RelOptInfo for given relids"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>rel</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*-------------------------------------------------------------------------
 *
 * Index cost estimation functions
 *
 *-------------------------------------------------------------------------
 */</comment>

<comment type="block">/*
 * Extract the actual indexquals (as RestrictInfos) from an IndexClause list
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>get_quals_from_indexclauses</name><parameter_list>(<parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexclauses</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>result</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>iclause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>IndexClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>iclause-&gt;indexquals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the total evaluation cost of the comparison operands in a list
 * of index qual expressions.  Since we know these will be evaluated just
 * once per scan, there's no need to distinguish startup from per-row cost.
 *
 * This can be used either on the result of get_quals_from_indexclauses(),
 * or directly on an indexorderbys list.  In both cases, we expect that the
 * index key expression is on the left side of binary clauses.
 */</comment>
<function><type><name>Cost</name></type>
<name>index_other_operands_eval_cost</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexquals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>qual_arg_cost</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>indexquals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><operator>(</operator><name>Expr</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>other_operand</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>QualCost</name></type>	<name>index_qual_cost</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Index quals will have RestrictInfos, indexorderbys won't.  Look
		 * through RestrictInfo if present.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RestrictInfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>clause</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <name>clause</name><operator>)</operator><operator>-&gt;</operator><name>clause</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>other_operand</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>op</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>other_operand</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <name><name>rc</name><operator>-&gt;</operator><name>rargs</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>other_operand</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>other_operand</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported indexqual type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>other_operand</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><call><name>cost_qual_eval_node</name><argument_list>(<argument><expr><operator>&amp;</operator><name>index_qual_cost</name></expr></argument>, <argument><expr><name>other_operand</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>qual_arg_cost</name> <operator>+=</operator> <name><name>index_qual_cost</name><operator>.</operator><name>startup</name></name> <operator>+</operator> <name><name>index_qual_cost</name><operator>.</operator><name>per_tuple</name></name></expr>;</expr_stmt>
	</block_content>}</block>
	<return>return <expr><name>qual_arg_cost</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>genericcostestimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
					<parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
					<parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
					<parameter><decl><type><name>GenericCosts</name> <modifier>*</modifier></type><name>costs</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexQuals</name> <init>= <expr><call><name>get_quals_from_indexclauses</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexclauses</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexOrderBys</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexorderbys</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>indexStartupCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>indexTotalCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>indexSelectivity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>indexCorrelation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numIndexPages</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numIndexTuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>spc_random_page_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>num_sa_scans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>num_outer_scans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>num_scans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>qual_op_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>qual_arg_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>selectivityQuals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If the index is partial, AND the index predicate with the explicitly
	 * given indexquals to produce a more accurate idea of the index
	 * selectivity.
	 */</comment>
	<expr_stmt><expr><name>selectivityQuals</name> <operator>=</operator> <call><name>add_predicate_to_index_quals</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check for ScalarArrayOpExpr index quals, and estimate the number of
	 * index scans that will be performed.
	 */</comment>
	<expr_stmt><expr><name>num_sa_scans</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>indexQuals</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><operator>(</operator><name>RestrictInfo</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>alength</name> <init>= <expr><call><name>estimate_array_length</name><argument_list>(<argument><expr><call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><name>alength</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>num_sa_scans</name> <operator>*=</operator> <name>alength</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>

	<comment type="block">/* Estimate the fraction of main-table tuples that will be visited */</comment>
	<expr_stmt><expr><name>indexSelectivity</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>selectivityQuals</name></expr></argument>,
											  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
											  <argument><expr><name>JOIN_INNER</name></expr></argument>,
											  <argument><expr><name>NULL</name></expr></argument>,
											  <argument><expr><name>false</name></expr></argument> <comment type="block">/* use_damping */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If caller didn't give us an estimate, estimate the number of index
	 * tuples that will be visited.  We do it in this rather peculiar-looking
	 * way in order to get the right answer for partial indexes.
	 */</comment>
	<expr_stmt><expr><name>numIndexTuples</name> <operator>=</operator> <name><name>costs</name><operator>-&gt;</operator><name>numIndexTuples</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>numIndexTuples</name> <operator>&lt;=</operator> <literal type="number">0.0</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>numIndexTuples</name> <operator>=</operator> <name>indexSelectivity</name> <operator>*</operator> <name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * The above calculation counts all the tuples visited across all
		 * scans induced by ScalarArrayOpExpr nodes.  We want to consider the
		 * average per-indexscan number, so adjust.  This is a handy place to
		 * round to integer, too.  (If caller supplied tuple estimate, it's
		 * responsible for handling these considerations.)
		 */</comment>
		<expr_stmt><expr><name>numIndexTuples</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>numIndexTuples</name> <operator>/</operator> <name>num_sa_scans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We can bound the number of tuples by the index size in any case. Also,
	 * always estimate at least one tuple is touched, even when
	 * indexSelectivity estimate is tiny.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>numIndexTuples</name> <operator>&gt;</operator> <name><name>index</name><operator>-&gt;</operator><name>tuples</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numIndexTuples</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>numIndexTuples</name> <operator>&lt;</operator> <literal type="number">1.0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numIndexTuples</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Estimate the number of index pages that will be retrieved.
	 *
	 * We use the simplistic method of taking a pro-rata fraction of the total
	 * number of index pages.  In effect, this counts only leaf pages and not
	 * any overhead such as index metapage or upper tree levels.
	 *
	 * In practice access to upper index levels is often nearly free because
	 * those tend to stay in cache under load; moreover, the cost involved is
	 * highly dependent on index type.  We therefore ignore such costs here
	 * and leave it to the caller to add a suitable charge if needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>pages</name></name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator> <name><name>index</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numIndexPages</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>numIndexTuples</name> <operator>*</operator> <name><name>index</name><operator>-&gt;</operator><name>pages</name></name> <operator>/</operator> <name><name>index</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>numIndexPages</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* fetch estimated page cost for tablespace containing index */</comment>
	<expr_stmt><expr><call><name>get_tablespace_page_costs</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_random_page_cost</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now compute the disk access costs.
	 *
	 * The above calculations are all per-index-scan.  However, if we are in a
	 * nestloop inner scan, we can expect the scan to be repeated (with
	 * different search keys) for each row of the outer relation.  Likewise,
	 * ScalarArrayOpExpr quals result in multiple index scans.  This creates
	 * the potential for cache effects to reduce the number of disk page
	 * fetches needed.  We want to estimate the average per-scan I/O cost in
	 * the presence of caching.
	 *
	 * We use the Mackert-Lohman formula (see costsize.c for details) to
	 * estimate the total number of page fetches that occur.  While this
	 * wasn't what it was designed for, it seems a reasonable model anyway.
	 * Note that we are counting pages not tuples anymore, so we take N = T =
	 * index size, as if there were one "tuple" per page.
	 */</comment>
	<expr_stmt><expr><name>num_outer_scans</name> <operator>=</operator> <name>loop_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_scans</name> <operator>=</operator> <name>num_sa_scans</name> <operator>*</operator> <name>num_outer_scans</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_scans</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>pages_fetched</name></decl>;</decl_stmt>

		<comment type="block">/* total page fetches ignoring cache effects */</comment>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <name>numIndexPages</name> <operator>*</operator> <name>num_scans</name></expr>;</expr_stmt>

		<comment type="block">/* use Mackert and Lohman formula to adjust for cache effects */</comment>
		<expr_stmt><expr><name>pages_fetched</name> <operator>=</operator> <call><name>index_pages_fetched</name><argument_list>(<argument><expr><name>pages_fetched</name></expr></argument>,
											<argument><expr><name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>,
											<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>,
											<argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Now compute the total disk access cost, and then report a pro-rated
		 * share for each outer scan.  (Don't pro-rate for ScalarArrayOpExpr,
		 * since that's internal to the indexscan.)
		 */</comment>
		<expr_stmt><expr><name>indexTotalCost</name> <operator>=</operator> <operator>(</operator><name>pages_fetched</name> <operator>*</operator> <name>spc_random_page_cost</name><operator>)</operator>
			<operator>/</operator> <name>num_outer_scans</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * For a single index scan, we just charge spc_random_page_cost per
		 * page touched.
		 */</comment>
		<expr_stmt><expr><name>indexTotalCost</name> <operator>=</operator> <name>numIndexPages</name> <operator>*</operator> <name>spc_random_page_cost</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * CPU cost: any complex expressions in the indexquals will need to be
	 * evaluated once at the start of the scan to reduce them to runtime keys
	 * to pass to the index AM (see nodeIndexscan.c).  We model the per-tuple
	 * CPU costs as cpu_index_tuple_cost plus one cpu_operator_cost per
	 * indexqual operator.  Because we have numIndexTuples as a per-scan
	 * number, we have to multiply by num_sa_scans to get the correct result
	 * for ScalarArrayOpExpr cases.  Similarly add in costs for any index
	 * ORDER BY expressions.
	 *
	 * Note: this neglects the possible costs of rechecking lossy operators.
	 * Detecting that that might be needed seems more expensive than it's
	 * worth, though, considering all the other inaccuracies here ...
	 */</comment>
	<expr_stmt><expr><name>qual_arg_cost</name> <operator>=</operator> <call><name>index_other_operands_eval_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>indexQuals</name></expr></argument>)</argument_list></call> <operator>+</operator>
		<call><name>index_other_operands_eval_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>indexOrderBys</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qual_op_cost</name> <operator>=</operator> <name>cpu_operator_cost</name> <operator>*</operator>
		<operator>(</operator><call><name>list_length</name><argument_list>(<argument><expr><name>indexQuals</name></expr></argument>)</argument_list></call> <operator>+</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexOrderBys</name></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name>indexStartupCost</name> <operator>=</operator> <name>qual_arg_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexTotalCost</name> <operator>+=</operator> <name>qual_arg_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexTotalCost</name> <operator>+=</operator> <name>numIndexTuples</name> <operator>*</operator> <name>num_sa_scans</name> <operator>*</operator> <operator>(</operator><name>cpu_index_tuple_cost</name> <operator>+</operator> <name>qual_op_cost</name><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generic assumption about index correlation: there isn't any.
	 */</comment>
	<expr_stmt><expr><name>indexCorrelation</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return everything to caller.
	 */</comment>
	<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>indexStartupCost</name></name> <operator>=</operator> <name>indexStartupCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>indexTotalCost</name></name> <operator>=</operator> <name>indexTotalCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>indexSelectivity</name></name> <operator>=</operator> <name>indexSelectivity</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>indexCorrelation</name></name> <operator>=</operator> <name>indexCorrelation</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>numIndexPages</name></name> <operator>=</operator> <name>numIndexPages</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>numIndexTuples</name></name> <operator>=</operator> <name>numIndexTuples</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>spc_random_page_cost</name></name> <operator>=</operator> <name>spc_random_page_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>-&gt;</operator><name>num_sa_scans</name></name> <operator>=</operator> <name>num_sa_scans</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * If the index is partial, add its predicate to the given qual list.
 *
 * ANDing the index predicate with the explicitly given indexquals produces
 * a more accurate idea of the index's selectivity.  However, we need to be
 * careful not to insert redundant clauses, because clauselist_selectivity()
 * is easily fooled into computing a too-low selectivity estimate.  Our
 * approach is to add only the predicate clause(s) that cannot be proven to
 * be implied by the given indexquals.  This successfully handles cases such
 * as a qual "x = 42" used with a partial index "WHERE x &gt;= 40 AND x &lt; 50".
 * There are many other cases where we won't detect redundancy, leading to a
 * too-low selectivity estimate, which will bias the system in favor of using
 * partial indexes where possible.  That is not necessarily bad though.
 *
 * Note that indexQuals contains RestrictInfo nodes while the indpred
 * does not, so the output list will be mixed.  This is OK for both
 * predicate_implied_by() and clauselist_selectivity(), but might be
 * problematic if the result were passed to other things.
 */</comment>
<function><type><name>List</name> <modifier>*</modifier></type>
<name>add_predicate_to_index_quals</name><parameter_list>(<parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>List</name> <modifier>*</modifier></type><name>indexQuals</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>predExtraQuals</name> <init>= <expr><name>NIL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indpred</name></name> <operator>==</operator> <name>NIL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>indexQuals</name></expr>;</return></block_content></block></if></if_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>index-&gt;indpred</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>predQual</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lfirst</name><argument_list>(<argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>oneQual</name> <init>= <expr><call><name>list_make1</name><argument_list>(<argument><expr><name>predQual</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>predicate_implied_by</name><argument_list>(<argument><expr><name>oneQual</name></expr></argument>, <argument><expr><name>indexQuals</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>predExtraQuals</name> <operator>=</operator> <call><name>list_concat</name><argument_list>(<argument><expr><name>predExtraQuals</name></expr></argument>, <argument><expr><name>oneQual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block>
	<comment type="block">/* list_concat avoids modifying the passed-in indexQuals list */</comment>
	<return>return <expr><call><name>list_concat</name><argument_list>(<argument><expr><name>predExtraQuals</name></expr></argument>, <argument><expr><name>indexQuals</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<function><type><name>void</name></type>
<name>btcostestimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
			   <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexStartupCost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexTotalCost</name></decl></parameter>,
			   <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>indexSelectivity</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexCorrelation</name></decl></parameter>,
			   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexPages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GenericCosts</name></type> <name>costs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>relid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>colnum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numIndexTuples</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>descentCost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexBoundQuals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>indexcol</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>eqQualHere</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_saop</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found_is_null_op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>num_sa_scans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * For a btree scan, only leading '=' quals plus inequality quals for the
	 * immediately next attribute contribute to index selectivity (these are
	 * the "boundary quals" that determine the starting and stopping points of
	 * the index scan).  Additional quals can suppress visits to the heap, so
	 * it's OK to count them in indexSelectivity, but they should not count
	 * for estimating numIndexTuples.  So we must examine the given indexquals
	 * to find out which ones count as boundary quals.  We rely on the
	 * knowledge that they are given in index column order.
	 *
	 * For a RowCompareExpr, we consider only the first column, just as
	 * rowcomparesel() does.
	 *
	 * If there's a ScalarArrayOpExpr in the quals, we'll actually perform N
	 * index scans not one, but the ScalarArrayOpExpr's operator can be
	 * considered to act the same as it normally does.
	 */</comment>
	<expr_stmt><expr><name>indexBoundQuals</name> <operator>=</operator> <name>NIL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>indexcol</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>eqQualHere</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>found_saop</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>found_is_null_op</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_sa_scans</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>path-&gt;indexclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>iclause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>IndexClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>indexcol</name> <operator>!=</operator> <name><name>iclause</name><operator>-&gt;</operator><name>indexcol</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Beginning of a new column's quals */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>eqQualHere</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* done if no '=' qual for indexcol */</comment>
			<expr_stmt><expr><name>eqQualHere</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>indexcol</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>indexcol</name> <operator>!=</operator> <name><name>iclause</name><operator>-&gt;</operator><name>indexcol</name></name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>			<comment type="block">/* no quals at all for indexcol */</comment>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Examine each indexqual associated with this index clause */</comment>
		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>iclause-&gt;indexquals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>clause_op</name> <init>= <expr><name>InvalidOid</name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>op_strategy</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>OpExpr</name>	   <modifier>*</modifier></type><name>op</name> <init>= <expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>clause_op</name> <operator>=</operator> <name><name>op</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>RowCompareExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>RowCompareExpr</name> <modifier>*</modifier></type><name>rc</name> <init>= <expr><operator>(</operator><name>RowCompareExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>clause_op</name> <operator>=</operator> <call><name>linitial_oid</name><argument_list>(<argument><expr><name><name>rc</name><operator>-&gt;</operator><name>opnos</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>saop</name> <init>= <expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>other_operand</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>saop</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>int</name></type>			<name>alength</name> <init>= <expr><call><name>estimate_array_length</name><argument_list>(<argument><expr><name>other_operand</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

				<expr_stmt><expr><name>clause_op</name> <operator>=</operator> <name><name>saop</name><operator>-&gt;</operator><name>opno</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>found_saop</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<comment type="block">/* count number of SA scans induced by indexBoundQuals only */</comment>
				<if_stmt><if>if <condition>(<expr><name>alength</name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>num_sa_scans</name> <operator>*=</operator> <name>alength</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>NullTest</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>NullTest</name>   <modifier>*</modifier></type><name>nt</name> <init>= <expr><operator>(</operator><name>NullTest</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>nt</name><operator>-&gt;</operator><name>nulltesttype</name></name> <operator>==</operator> <name>IS_NULL</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>found_is_null_op</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
					<comment type="block">/* IS NULL is like = for selectivity purposes */</comment>
					<expr_stmt><expr><name>eqQualHere</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported indexqual type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<comment type="block">/* check for equality operator */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>op_strategy</name> <operator>=</operator> <call><name>get_op_opfamily_strategy</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>,
													   <argument><expr><name><name>index</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>indexcol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>op_strategy</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* not a member of opfamily?? */</comment>
				<if_stmt><if>if <condition>(<expr><name>op_strategy</name> <operator>==</operator> <name>BTEqualStrategyNumber</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>eqQualHere</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>indexBoundQuals</name> <operator>=</operator> <call><name>lappend</name><argument_list>(<argument><expr><name>indexBoundQuals</name></expr></argument>, <argument><expr><name>rinfo</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/*
	 * If index is unique and we found an '=' clause for each column, we can
	 * just assume numIndexTuples = 1 and skip the expensive
	 * clauselist_selectivity calculations.  However, a ScalarArrayOp or
	 * NullTest invalidates that theory, even though it sets eqQualHere.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>unique</name></name> <operator>&amp;&amp;</operator>
		<name>indexcol</name> <operator>==</operator> <name><name>index</name><operator>-&gt;</operator><name>nkeycolumns</name></name> <operator>-</operator> <literal type="number">1</literal> <operator>&amp;&amp;</operator>
		<name>eqQualHere</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>found_saop</name> <operator>&amp;&amp;</operator>
		<operator>!</operator><name>found_is_null_op</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numIndexTuples</name> <operator>=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt></block_content></block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>selectivityQuals</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>btreeSelectivity</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * If the index is partial, AND the index predicate with the
		 * index-bound quals to produce a more accurate idea of the number of
		 * rows covered by the bound conditions.
		 */</comment>
		<expr_stmt><expr><name>selectivityQuals</name> <operator>=</operator> <call><name>add_predicate_to_index_quals</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexBoundQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>btreeSelectivity</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>selectivityQuals</name></expr></argument>,
												  <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
												  <argument><expr><name>JOIN_INNER</name></expr></argument>,
												  <argument><expr><name>NULL</name></expr></argument>,
												  <argument><expr><name>false</name></expr></argument> <comment type="block">/* use_damping */</comment>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numIndexTuples</name> <operator>=</operator> <name>btreeSelectivity</name> <operator>*</operator> <name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>tuples</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * As in genericcostestimate(), we have to adjust for any
		 * ScalarArrayOpExpr quals included in indexBoundQuals, and then round
		 * to integer.
		 */</comment>
		<expr_stmt><expr><name>numIndexTuples</name> <operator>=</operator> <call><name>rint</name><argument_list>(<argument><expr><name>numIndexTuples</name> <operator>/</operator> <name>num_sa_scans</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Now do generic index cost estimation.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>costs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>numIndexTuples</name></name> <operator>=</operator> <name>numIndexTuples</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>genericcostestimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add a CPU-cost component to represent the costs of initial btree
	 * descent.  We don't charge any I/O cost for touching upper btree levels,
	 * since they tend to stay in cache, but we still have to do about log2(N)
	 * comparisons to descend a btree of N leaf tuples.  We charge one
	 * cpu_operator_cost per comparison.
	 *
	 * If there are ScalarArrayOpExprs, charge this once per SA scan.  The
	 * ones after the first one are not startup cost so far as the overall
	 * plan is concerned, so add them only to "total" cost.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>		<comment type="block">/* avoid computing log(0) */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>descentCost</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>log</name><argument_list>(<argument><expr><literal type="number">2.0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name> <operator>+=</operator> <name>descentCost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name> <operator>+=</operator> <name><name>costs</name><operator>.</operator><name>num_sa_scans</name></name> <operator>*</operator> <name>descentCost</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Even though we're not charging I/O cost for touching upper btree pages,
	 * it's still reasonable to charge some CPU cost per page descended
	 * through.  Moreover, if we had no such charge at all, bloated indexes
	 * would appear to have the same search cost as unbloated ones, at least
	 * in cases where only a single leaf page is expected to be visited.  This
	 * cost is somewhat arbitrarily set at 50x cpu_operator_cost per page
	 * touched.  The number of such pages is btree tree height plus one (ie,
	 * we charge for the leaf page too).  As above, charge once per SA scan.
	 */</comment>
	<expr_stmt><expr><name>descentCost</name> <operator>=</operator> <operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">50.0</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name> <operator>+=</operator> <name>descentCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name> <operator>+=</operator> <name><name>costs</name><operator>.</operator><name>num_sa_scans</name></name> <operator>*</operator> <name>descentCost</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we can get an estimate of the first column's ordering correlation C
	 * from pg_statistic, estimate the index correlation as C for a
	 * single-column index, or C * 0.75 for multiple columns. (The idea here
	 * is that multiple columns dilute the importance of the first column's
	 * ordering, but don't negate it entirely.  Before 8.0 we divided the
	 * correlation by the number of columns, but that seems too strong.)
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Simple variable --- look to stats for the underlying table */</comment>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>relid</name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>colnum</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>get_relation_stats_hook</name> <operator>&amp;&amp;</operator>
			<call>(<modifier>*</modifier><name>get_relation_stats_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>colnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The hook took control of acquiring a stats tuple.  If it did
			 * supply a tuple, it'd better have supplied a freefunc.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>vardata</name><operator>.</operator><name>freefunc</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no function provided to release variable stats with"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
												 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>colnum</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vardata</name><operator>.</operator><name>freefunc</name></name> <operator>=</operator> <name>ReleaseSysCache</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* Expression --- maybe there are stats for the index itself */</comment>
		<expr_stmt><expr><name>relid</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>colnum</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>get_index_stats_hook</name> <operator>&amp;&amp;</operator>
			<call>(<modifier>*</modifier><name>get_index_stats_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>relid</name></expr></argument>, <argument><expr><name>colnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * The hook took control of acquiring a stats tuple.  If it did
			 * supply a tuple, it'd better have supplied a freefunc.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<operator>!</operator><name><name>vardata</name><operator>.</operator><name>freefunc</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no function provided to release variable stats with"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
												 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>relid</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>colnum</name></expr></argument>)</argument_list></call></expr></argument>,
												 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>vardata</name><operator>.</operator><name>freefunc</name></name> <operator>=</operator> <name>ReleaseSysCache</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>sortop</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>sortop</name> <operator>=</operator> <call><name>get_opfamily_member</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>index</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name><name>index</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>,
									 <argument><expr><name>BTLessStrategyNumber</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>sortop</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
			<call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
							 <argument><expr><name>STATISTIC_KIND_CORRELATION</name></expr></argument>, <argument><expr><name>sortop</name></expr></argument>,
							 <argument><expr><name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>varCorrelation</name></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>==</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>varCorrelation</name> <operator>=</operator> <name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>reverse_sort</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>varCorrelation</name> <operator>=</operator> <operator>-</operator><name>varCorrelation</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>nkeycolumns</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexCorrelation</name></name> <operator>=</operator> <name>varCorrelation</name> <operator>*</operator> <literal type="number">0.75</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexCorrelation</name></name> <operator>=</operator> <name>varCorrelation</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexSelectivity</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexSelectivity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexCorrelation</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexCorrelation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexPages</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>numIndexPages</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>hashcostestimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
				 <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexStartupCost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexTotalCost</name></decl></parameter>,
				 <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>indexSelectivity</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexCorrelation</name></decl></parameter>,
				 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexPages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>GenericCosts</name></type> <name>costs</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>costs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>genericcostestimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * A hash index has no descent costs as such, since the index AM can go
	 * directly to the target bucket after computing the hash value.  There
	 * are a couple of other hash-specific costs that we could conceivably add
	 * here, though:
	 *
	 * Ideally we'd charge spc_random_page_cost for each page in the target
	 * bucket, not just the numIndexPages pages that genericcostestimate
	 * thought we'd visit.  However in most cases we don't know which bucket
	 * that will be.  There's no point in considering the average bucket size
	 * because the hash AM makes sure that's always one page.
	 *
	 * Likewise, we could consider charging some CPU for each index tuple in
	 * the bucket, if we knew how many there were.  But the per-tuple cost is
	 * just a hash value comparison, not a general datatype-dependent
	 * comparison, so any such charge ought to be quite a bit less than
	 * cpu_operator_cost; which makes it probably not worth worrying about.
	 *
	 * A bigger issue is that chance hash-value collisions will result in
	 * wasted probes into the heap.  We don't currently attempt to model this
	 * cost on the grounds that it's rare, but maybe it's not rare enough.
	 * (Any fix for this ought to consider the generic lossy-operator problem,
	 * though; it's not entirely hash-specific.)
	 */</comment>

	<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexSelectivity</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexSelectivity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexCorrelation</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexCorrelation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexPages</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>numIndexPages</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>gistcostestimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
				 <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexStartupCost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexTotalCost</name></decl></parameter>,
				 <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>indexSelectivity</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexCorrelation</name></decl></parameter>,
				 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexPages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GenericCosts</name></type> <name>costs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>descentCost</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>costs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>genericcostestimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We model index descent costs similarly to those for btree, but to do
	 * that we first need an idea of the tree height.  We somewhat arbitrarily
	 * assume that the fanout is 100, meaning the tree height is at most
	 * log100(index-&gt;pages).
	 *
	 * Although this computation isn't really expensive enough to require
	 * caching, we might as well use index-&gt;tree_height to cache it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <comment type="block">/* unknown? */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>pages</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* avoid computing log(0) */</comment>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>log</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>log</name><argument_list>(<argument><expr><literal type="number">100.0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add a CPU-cost component to represent the costs of initial descent. We
	 * just use log(N) here not log2(N) since the branching factor isn't
	 * necessarily two anyway.  As for btree, charge once per SA scan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>		<comment type="block">/* avoid computing log(0) */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>descentCost</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name> <operator>+=</operator> <name>descentCost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name> <operator>+=</operator> <name><name>costs</name><operator>.</operator><name>num_sa_scans</name></name> <operator>*</operator> <name>descentCost</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Likewise add a per-page charge, calculated the same as for btrees.
	 */</comment>
	<expr_stmt><expr><name>descentCost</name> <operator>=</operator> <operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">50.0</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name> <operator>+=</operator> <name>descentCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name> <operator>+=</operator> <name><name>costs</name><operator>.</operator><name>num_sa_scans</name></name> <operator>*</operator> <name>descentCost</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexSelectivity</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexSelectivity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexCorrelation</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexCorrelation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexPages</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>numIndexPages</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>spgcostestimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
				<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexStartupCost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexTotalCost</name></decl></parameter>,
				<parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>indexSelectivity</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexCorrelation</name></decl></parameter>,
				<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexPages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GenericCosts</name></type> <name>costs</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>descentCost</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>costs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>genericcostestimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We model index descent costs similarly to those for btree, but to do
	 * that we first need an idea of the tree height.  We somewhat arbitrarily
	 * assume that the fanout is 100, meaning the tree height is at most
	 * log100(index-&gt;pages).
	 *
	 * Although this computation isn't really expensive enough to require
	 * caching, we might as well use index-&gt;tree_height to cache it.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition> <comment type="block">/* unknown? */</comment>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>pages</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* avoid computing log(0) */</comment>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><call><name>log</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <call><name>log</name><argument_list>(<argument><expr><literal type="number">100.0</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Add a CPU-cost component to represent the costs of initial descent. We
	 * just use log(N) here not log2(N) since the branching factor isn't
	 * necessarily two anyway.  As for btree, charge once per SA scan.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>index</name><operator>-&gt;</operator><name>tuples</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>		<comment type="block">/* avoid computing log(0) */</comment>
	<block>{<block_content>
		<expr_stmt><expr><name>descentCost</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><call><name>log</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name> <operator>+=</operator> <name>descentCost</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name> <operator>+=</operator> <name><name>costs</name><operator>.</operator><name>num_sa_scans</name></name> <operator>*</operator> <name>descentCost</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Likewise add a per-page charge, calculated the same as for btrees.
	 */</comment>
	<expr_stmt><expr><name>descentCost</name> <operator>=</operator> <operator>(</operator><name><name>index</name><operator>-&gt;</operator><name>tree_height</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">50.0</literal> <operator>*</operator> <name>cpu_operator_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name> <operator>+=</operator> <name>descentCost</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name> <operator>+=</operator> <name><name>costs</name><operator>.</operator><name>num_sa_scans</name></name> <operator>*</operator> <name>descentCost</name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexSelectivity</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexSelectivity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexCorrelation</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexCorrelation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexPages</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>numIndexPages</name></name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * Support routines for gincostestimate
 */</comment>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>haveFullScan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>partialEntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>exactEntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>searchEntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>arrayScans</name></decl>;</decl_stmt>
}</block></struct></type> <name>GinQualCounts</name>;</typedef>

<comment type="block">/*
 * Estimate the number of index terms that need to be searched for while
 * testing the given GIN query, and increment the counts in *counts
 * appropriately.  If the query is unsatisfiable, return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gincost_pattern</name><parameter_list>(<parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>indexcol</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>clause_op</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>query</name></decl></parameter>,
				<parameter><decl><type><name>GinQualCounts</name> <modifier>*</modifier></type><name>counts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>extractProcOid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>collation</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>strategy_op</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>,
				<decl><type ref="prev"/><name>righttype</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>nentries</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>partial_matches</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Pointer</name>    <modifier>*</modifier></type><name>extra_data</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>nullFlags</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>searchMode</name> <init>= <expr><name>GIN_SEARCH_MODE_DEFAULT</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>indexcol</name> <operator>&lt;</operator> <name><name>index</name><operator>-&gt;</operator><name>nkeycolumns</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the operator's strategy number and declared input data types within
	 * the index opfamily.  (We don't need the latter, but we use
	 * get_op_opfamily_properties because it will throw error if it fails to
	 * find a matching pg_amop entry.)
	 */</comment>
	<expr_stmt><expr><call><name>get_op_opfamily_properties</name><argument_list>(<argument><expr><name>clause_op</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>indexcol</name></expr>]</index></name></expr></argument>, <argument><expr><name>false</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name>strategy_op</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * GIN always uses the "default" support functions, which are those with
	 * lefttype == righttype == the opclass' opcintype (see
	 * IndexSupportInitialize in relcache.c).
	 */</comment>
	<expr_stmt><expr><name>extractProcOid</name> <operator>=</operator> <call><name>get_opfamily_proc</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>opfamily</name><index>[<expr><name>indexcol</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>index</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>indexcol</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name><name>index</name><operator>-&gt;</operator><name>opcintype</name><index>[<expr><name>indexcol</name></expr>]</index></name></expr></argument>,
									   <argument><expr><name>GIN_EXTRACTQUERY_PROC</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>extractProcOid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* should not happen; throw same error as index_getprocinfo */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"missing support function %d for attribute %d of index \"%s\""</literal></expr></argument>,
			 <argument><expr><name>GIN_EXTRACTQUERY_PROC</name></expr></argument>, <argument><expr><name>indexcol</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>,
			 <argument><expr><call><name>get_rel_name</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Choose collation to pass to extractProc (should match initGinState).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>indexcol</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>collation</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>indexcollations</name><index>[<expr><name>indexcol</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>collation</name> <operator>=</operator> <name>DEFAULT_COLLATION_OID</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><call><name>OidFunctionCall7Coll</name><argument_list>(<argument><expr><name>extractProcOid</name></expr></argument>,
						 <argument><expr><name>collation</name></expr></argument>,
						 <argument><expr><name>query</name></expr></argument>,
						 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nentries</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>UInt16GetDatum</name><argument_list>(<argument><expr><name>strategy_op</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>partial_matches</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>extra_data</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>nullFlags</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><operator>&amp;</operator><name>searchMode</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>nentries</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>searchMode</name> <operator>==</operator> <name>GIN_SEARCH_MODE_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No match is possible */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nentries</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * For partial match we haven't any information to estimate number of
		 * matched entries in index, so, we just estimate it as 100
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>partial_matches</name> <operator>&amp;&amp;</operator> <name><name>partial_matches</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>partialEntries</name></name> <operator>+=</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>exactEntries</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>searchEntries</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>searchMode</name> <operator>==</operator> <name>GIN_SEARCH_MODE_INCLUDE_EMPTY</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Treat "include empty" like an exact-match item */</comment>
		<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>exactEntries</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>searchEntries</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name>searchMode</name> <operator>!=</operator> <name>GIN_SEARCH_MODE_DEFAULT</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* It's GIN_SEARCH_MODE_ALL */</comment>
		<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>haveFullScan</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the number of index terms that need to be searched for while
 * testing the given GIN index clause, and increment the counts in *counts
 * appropriately.  If the query is unsatisfiable, return false.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gincost_opexpr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			   <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
			   <parameter><decl><type><name>int</name></type> <name>indexcol</name></decl></parameter>,
			   <parameter><decl><type><name>OpExpr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
			   <parameter><decl><type><name>GinQualCounts</name> <modifier>*</modifier></type><name>counts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>clause_op</name> <init>= <expr><name><name>clause</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>operand</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* aggressively reduce to a constant, and look through relabeling */</comment>
	<expr_stmt><expr><name>operand</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>operand</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>operand</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>operand</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It's impossible to call extractQuery method for unknown operand. So
	 * unless operand is a Const we can't do much; just assume there will be
	 * one ordinary search entry from the operand at runtime.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>operand</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>exactEntries</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>searchEntries</name></name><operator>++</operator></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If Const is null, there can be no matches */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>operand</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise, apply extractQuery and get the actual term counts */</comment>
	<return>return <expr><call><name>gincost_pattern</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexcol</name></expr></argument>, <argument><expr><name>clause_op</name></expr></argument>,
						   <argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>operand</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>,
						   <argument><expr><name>counts</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the number of index terms that need to be searched for while
 * testing the given GIN index clause, and increment the counts in *counts
 * appropriately.  If the query is unsatisfiable, return false.
 *
 * A ScalarArrayOpExpr will give rise to N separate indexscans at runtime,
 * each of which involves one value from the RHS array, plus all the
 * non-array quals (if any).  To model this, we average the counts across
 * the RHS elements, and add the averages to the counts in *counts (which
 * correspond to per-indexscan costs).  We also multiply counts-&gt;arrayScans
 * by N, causing gincostestimate to scale up its estimates accordingly.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>gincost_scalararrayopexpr</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
						  <parameter><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name></decl></parameter>,
						  <parameter><decl><type><name>int</name></type> <name>indexcol</name></decl></parameter>,
						  <parameter><decl><type><name>ScalarArrayOpExpr</name> <modifier>*</modifier></type><name>clause</name></decl></parameter>,
						  <parameter><decl><type><name>double</name></type> <name>numIndexEntries</name></decl></parameter>,
						  <parameter><decl><type><name>GinQualCounts</name> <modifier>*</modifier></type><name>counts</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>clause_op</name> <init>= <expr><name><name>clause</name><operator>-&gt;</operator><name>opno</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>rightop</name> <init>= <expr><operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <call><name>lsecond</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>args</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ArrayType</name>  <modifier>*</modifier></type><name>arrayval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int16</name></type>		<name>elmlen</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>elmbyval</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name>elmalign</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numElems</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name>	   <modifier>*</modifier></type><name>elemValues</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name>	   <modifier>*</modifier></type><name>elemNulls</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinQualCounts</name></type> <name>arraycounts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>numPossible</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>clause</name><operator>-&gt;</operator><name>useOr</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* aggressively reduce to a constant, and look through relabeling */</comment>
	<expr_stmt><expr><name>rightop</name> <operator>=</operator> <call><name>estimate_expression_value</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>RelabelType</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>rightop</name> <operator>=</operator> <operator>(</operator><name>Node</name> <operator>*</operator><operator>)</operator> <operator>(</operator><operator>(</operator><name>RelabelType</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>arg</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * It's impossible to call extractQuery method for unknown operand. So
	 * unless operand is a Const we can't do much; just assume there will be
	 * one ordinary search entry from each array entry at runtime, and fall
	 * back on a probably-bad estimate of the number of array entries.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>exactEntries</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>searchEntries</name></name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>arrayScans</name></name> <operator>*=</operator> <call><name>estimate_array_length</name><argument_list>(<argument><expr><name>rightop</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* If Const is null, there can be no matches */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Otherwise, extract the array elements and iterate over them */</comment>
	<expr_stmt><expr><name>arrayval</name> <operator>=</operator> <call><name>DatumGetArrayTypeP</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>rightop</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>get_typlenbyvalalign</name><argument_list>(<argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><operator>&amp;</operator><name>elmlen</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmbyval</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elmalign</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>deconstruct_array</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>,
					  <argument><expr><call><name>ARR_ELEMTYPE</name><argument_list>(<argument><expr><name>arrayval</name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><name>elmlen</name></expr></argument>, <argument><expr><name>elmbyval</name></expr></argument>, <argument><expr><name>elmalign</name></expr></argument>,
					  <argument><expr><operator>&amp;</operator><name>elemValues</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>elemNulls</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>numElems</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>arraycounts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>arraycounts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>numElems</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>GinQualCounts</name></type> <name>elemcounts</name></decl>;</decl_stmt>

		<comment type="block">/* NULL can't match anything, so ignore, as the executor will */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>elemNulls</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<comment type="block">/* Otherwise, apply extractQuery and get the actual term counts */</comment>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>elemcounts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>elemcounts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>gincost_pattern</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexcol</name></expr></argument>, <argument><expr><name>clause_op</name></expr></argument>, <argument><expr><name><name>elemValues</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><operator>&amp;</operator><name>elemcounts</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* We ignore array elements that are unsatisfiable patterns */</comment>
			<expr_stmt><expr><name>numPossible</name><operator>++</operator></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>elemcounts</name><operator>.</operator><name>haveFullScan</name></name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * Full index scan will be required.  We treat this as if
				 * every key in the index had been listed in the query; is
				 * that reasonable?
				 */</comment>
				<expr_stmt><expr><name><name>elemcounts</name><operator>.</operator><name>partialEntries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>elemcounts</name><operator>.</operator><name>exactEntries</name></name> <operator>=</operator> <name>numIndexEntries</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>elemcounts</name><operator>.</operator><name>searchEntries</name></name> <operator>=</operator> <name>numIndexEntries</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>arraycounts</name><operator>.</operator><name>partialEntries</name></name> <operator>+=</operator> <name><name>elemcounts</name><operator>.</operator><name>partialEntries</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>arraycounts</name><operator>.</operator><name>exactEntries</name></name> <operator>+=</operator> <name><name>elemcounts</name><operator>.</operator><name>exactEntries</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>arraycounts</name><operator>.</operator><name>searchEntries</name></name> <operator>+=</operator> <name><name>elemcounts</name><operator>.</operator><name>searchEntries</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>numPossible</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* No satisfiable patterns in the array */</comment>
		<return>return <expr><name>false</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now add the averages to the global counts.  This will give us an
	 * estimate of the average number of terms searched for in each indexscan,
	 * including contributions from both array and non-array quals.
	 */</comment>
	<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>partialEntries</name></name> <operator>+=</operator> <name><name>arraycounts</name><operator>.</operator><name>partialEntries</name></name> <operator>/</operator> <name>numPossible</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>exactEntries</name></name> <operator>+=</operator> <name><name>arraycounts</name><operator>.</operator><name>exactEntries</name></name> <operator>/</operator> <name>numPossible</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>searchEntries</name></name> <operator>+=</operator> <name><name>arraycounts</name><operator>.</operator><name>searchEntries</name></name> <operator>/</operator> <name>numPossible</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>counts</name><operator>-&gt;</operator><name>arrayScans</name></name> <operator>*=</operator> <name>numPossible</name></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * GIN has search behavior completely different from other index types
 */</comment>
<function><type><name>void</name></type>
<name>gincostestimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
				<parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexStartupCost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexTotalCost</name></decl></parameter>,
				<parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>indexSelectivity</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexCorrelation</name></decl></parameter>,
				<parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexPages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexQuals</name> <init>= <expr><call><name>get_quals_from_indexclauses</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexclauses</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>selectivityQuals</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numPages</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr></init></decl>,
				<decl><type ref="prev"/><name>numTuples</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>tuples</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numEntryPages</name></decl>,
				<decl><type ref="prev"/><name>numDataPages</name></decl>,
				<decl><type ref="prev"/><name>numPendingPages</name></decl>,
				<decl><type ref="prev"/><name>numEntries</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinQualCounts</name></type> <name>counts</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>matchPossible</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>partialScale</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>entryPagesFetched</name></decl>,
				<decl><type ref="prev"/><name>dataPagesFetched</name></decl>,
				<decl><type ref="prev"/><name>dataPagesFetchedBySel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>qual_op_cost</name></decl>,
				<decl><type ref="prev"/><name>qual_arg_cost</name></decl>,
				<decl><type ref="prev"/><name>spc_random_page_cost</name></decl>,
				<decl><type ref="prev"/><name>outer_scans</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GinStatsData</name></type> <name>ginStats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Obtain statistical information from the meta page, if possible.  Else
	 * set ginStats to zeroes, and we'll cope below.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>index</name><operator>-&gt;</operator><name>hypothetical</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Lock should have already been obtained in plancat.c */</comment>
		<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ginGetStats</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>ginStats</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ginStats</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ginStats</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Assuming we got valid (nonzero) stats at all, nPendingPages can be
	 * trusted, but the other fields are data as of the last VACUUM.  We can
	 * scale them up to account for growth since then, but that method only
	 * goes so far; in the worst case, the stats might be for a completely
	 * empty index, and scaling them will produce pretty bogus numbers.
	 * Somewhat arbitrarily, set the cutoff for doing scaling at 4X growth; if
	 * it's grown more than that, fall back to estimating things only from the
	 * assumed-accurate index size.  But we'll trust nPendingPages in any case
	 * so long as it's not clearly insane, ie, more than the index size.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>ginStats</name><operator>.</operator><name>nPendingPages</name></name> <operator>&lt;</operator> <name>numPages</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numPendingPages</name> <operator>=</operator> <name><name>ginStats</name><operator>.</operator><name>nPendingPages</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>numPendingPages</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>numPages</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ginStats</name><operator>.</operator><name>nTotalPages</name></name> <operator>&lt;=</operator> <name>numPages</name> <operator>&amp;&amp;</operator>
		<name><name>ginStats</name><operator>.</operator><name>nTotalPages</name></name> <operator>&gt;</operator> <name>numPages</name> <operator>/</operator> <literal type="number">4</literal> <operator>&amp;&amp;</operator>
		<name><name>ginStats</name><operator>.</operator><name>nEntryPages</name></name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>ginStats</name><operator>.</operator><name>nEntries</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * OK, the stats seem close enough to sane to be trusted.  But we
		 * still need to scale them by the ratio numPages / nTotalPages to
		 * account for growth since the last VACUUM.
		 */</comment>
		<decl_stmt><decl><type><name>double</name></type>		<name>scale</name> <init>= <expr><name>numPages</name> <operator>/</operator> <name><name>ginStats</name><operator>.</operator><name>nTotalPages</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>numEntryPages</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>ginStats</name><operator>.</operator><name>nEntryPages</name></name> <operator>*</operator> <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numDataPages</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>ginStats</name><operator>.</operator><name>nDataPages</name></name> <operator>*</operator> <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numEntries</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>ginStats</name><operator>.</operator><name>nEntries</name></name> <operator>*</operator> <name>scale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* ensure we didn't round up too much */</comment>
		<expr_stmt><expr><name>numEntryPages</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>numEntryPages</name></expr></argument>, <argument><expr><name>numPages</name> <operator>-</operator> <name>numPendingPages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numDataPages</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>numDataPages</name></expr></argument>,
						   <argument><expr><name>numPages</name> <operator>-</operator> <name>numPendingPages</name> <operator>-</operator> <name>numEntryPages</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We might get here because it's a hypothetical index, or an index
		 * created pre-9.1 and never vacuumed since upgrading (in which case
		 * its stats would read as zeroes), or just because it's grown too
		 * much since the last VACUUM for us to put our faith in scaling.
		 *
		 * Invent some plausible internal statistics based on the index page
		 * count (and clamp that to at least 10 pages, just in case).  We
		 * estimate that 90% of the index is entry pages, and the rest is data
		 * pages.  Estimate 100 entries per entry page; this is rather bogus
		 * since it'll depend on the size of the keys, but it's more robust
		 * than trying to predict the number of entries per heap tuple.
		 */</comment>
		<expr_stmt><expr><name>numPages</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><name>numPages</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numEntryPages</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><operator>(</operator><name>numPages</name> <operator>-</operator> <name>numPendingPages</name><operator>)</operator> <operator>*</operator> <literal type="number">0.90</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numDataPages</name> <operator>=</operator> <name>numPages</name> <operator>-</operator> <name>numPendingPages</name> <operator>-</operator> <name>numEntryPages</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>numEntries</name> <operator>=</operator> <call><name>floor</name><argument_list>(<argument><expr><name>numEntryPages</name> <operator>*</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* In an empty index, numEntries could be zero.  Avoid divide-by-zero */</comment>
	<if_stmt><if>if <condition>(<expr><name>numEntries</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numEntries</name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If the index is partial, AND the index predicate with the index-bound
	 * quals to produce a more accurate idea of the number of rows covered by
	 * the bound conditions.
	 */</comment>
	<expr_stmt><expr><name>selectivityQuals</name> <operator>=</operator> <call><name>add_predicate_to_index_quals</name><argument_list>(<argument><expr><name>index</name></expr></argument>, <argument><expr><name>indexQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate the fraction of main-table tuples that will be visited */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexSelectivity</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>selectivityQuals</name></expr></argument>,
											   <argument><expr><name><name>index</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
											   <argument><expr><name>JOIN_INNER</name></expr></argument>,
											   <argument><expr><name>NULL</name></expr></argument>,
											   <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fetch estimated page cost for tablespace containing index */</comment>
	<expr_stmt><expr><call><name>get_tablespace_page_costs</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_random_page_cost</name></expr></argument>,
							  <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Generic assumption about index correlation: there isn't any.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexCorrelation</name> <operator>=</operator> <literal type="number">0.0</literal></expr>;</expr_stmt>

	<comment type="block">/*
	 * Examine quals to estimate number of search entries &amp; partial matches
	 */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>counts</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>counts</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>counts</name><operator>.</operator><name>arrayScans</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>matchPossible</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>lc</argument>, <argument>path-&gt;indexclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>iclause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>IndexClause</name></expr></argument>, <argument><expr><name>lc</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>lc2</name></decl>;</decl_stmt>

		<macro><name>foreach</name><argument_list>(<argument>lc2</argument>, <argument>iclause-&gt;indexquals</argument>)</argument_list></macro>
		<block>{<block_content>
			<decl_stmt><decl><type><name>RestrictInfo</name> <modifier>*</modifier></type><name>rinfo</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>RestrictInfo</name></expr></argument>, <argument><expr><name>lc2</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Expr</name>	   <modifier>*</modifier></type><name>clause</name> <init>= <expr><name><name>rinfo</name><operator>-&gt;</operator><name>clause</name></name></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>OpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>matchPossible</name> <operator>=</operator> <call><name>gincost_opexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
											   <argument><expr><name>index</name></expr></argument>,
											   <argument><expr><name><name>iclause</name><operator>-&gt;</operator><name>indexcol</name></name></expr></argument>,
											   <argument><expr><operator>(</operator><name>OpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
											   <argument><expr><operator>&amp;</operator><name>counts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matchPossible</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IsA</name><argument_list>(<argument><expr><name>clause</name></expr></argument>, <argument><expr><name>ScalarArrayOpExpr</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>matchPossible</name> <operator>=</operator> <call><name>gincost_scalararrayopexpr</name><argument_list>(<argument><expr><name>root</name></expr></argument>,
														  <argument><expr><name>index</name></expr></argument>,
														  <argument><expr><name><name>iclause</name><operator>-&gt;</operator><name>indexcol</name></name></expr></argument>,
														  <argument><expr><operator>(</operator><name>ScalarArrayOpExpr</name> <operator>*</operator><operator>)</operator> <name>clause</name></expr></argument>,
														  <argument><expr><name>numEntries</name></expr></argument>,
														  <argument><expr><operator>&amp;</operator><name>counts</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matchPossible</name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* shouldn't be anything else for a GIN index */</comment>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unsupported GIN indexqual type: %d"</literal></expr></argument>,
					 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>nodeTag</name><argument_list>(<argument><expr><name>clause</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block>
	</block_content>}</block>

	<comment type="block">/* Fall out if there were any provably-unsatisfiable quals */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>matchPossible</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>indexSelectivity</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<return>return;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>counts</name><operator>.</operator><name>haveFullScan</name></name> <operator>||</operator> <name>indexQuals</name> <operator>==</operator> <name>NIL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Full index scan will be required.  We treat this as if every key in
		 * the index had been listed in the query; is that reasonable?
		 */</comment>
		<expr_stmt><expr><name><name>counts</name><operator>.</operator><name>partialEntries</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counts</name><operator>.</operator><name>exactEntries</name></name> <operator>=</operator> <name>numEntries</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>counts</name><operator>.</operator><name>searchEntries</name></name> <operator>=</operator> <name>numEntries</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Will we have more than one iteration of a nestloop scan? */</comment>
	<expr_stmt><expr><name>outer_scans</name> <operator>=</operator> <name>loop_count</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute cost to begin scan, first of all, pay attention to pending
	 * list.
	 */</comment>
	<expr_stmt><expr><name>entryPagesFetched</name> <operator>=</operator> <name>numPendingPages</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Estimate number of entry pages read.  We need to do
	 * counts.searchEntries searches.  Use a power function as it should be,
	 * but tuples on leaf pages usually is much greater. Here we include all
	 * searches in entry tree, including search of first entry in partial
	 * match algorithm
	 */</comment>
	<expr_stmt><expr><name>entryPagesFetched</name> <operator>+=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name><name>counts</name><operator>.</operator><name>searchEntries</name></name> <operator>*</operator> <call><name>rint</name><argument_list>(<argument><expr><call><name>pow</name><argument_list>(<argument><expr><name>numEntryPages</name></expr></argument>, <argument><expr><literal type="number">0.15</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add an estimate of entry pages read by partial match algorithm. It's a
	 * scan over leaf pages in entry tree.  We haven't any useful stats here,
	 * so estimate it as proportion.  Because counts.partialEntries is really
	 * pretty bogus (see code above), it's possible that it is more than
	 * numEntries; clamp the proportion to ensure sanity.
	 */</comment>
	<expr_stmt><expr><name>partialScale</name> <operator>=</operator> <name><name>counts</name><operator>.</operator><name>partialEntries</name></name> <operator>/</operator> <name>numEntries</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>partialScale</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>partialScale</name></expr></argument>, <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>entryPagesFetched</name> <operator>+=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>numEntryPages</name> <operator>*</operator> <name>partialScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Partial match algorithm reads all data pages before doing actual scan,
	 * so it's a startup cost.  Again, we haven't any useful stats here, so
	 * estimate it as proportion.
	 */</comment>
	<expr_stmt><expr><name>dataPagesFetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>numDataPages</name> <operator>*</operator> <name>partialScale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate cache effects if more than one scan due to nestloops or array
	 * quals.  The result is pro-rated per nestloop scan, but the array qual
	 * factor shouldn't be pro-rated (compare genericcostestimate).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_scans</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>counts</name><operator>.</operator><name>arrayScans</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>entryPagesFetched</name> <operator>*=</operator> <name>outer_scans</name> <operator>*</operator> <name><name>counts</name><operator>.</operator><name>arrayScans</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>entryPagesFetched</name> <operator>=</operator> <call><name>index_pages_fetched</name><argument_list>(<argument><expr><name>entryPagesFetched</name></expr></argument>,
												<argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>numEntryPages</name></expr></argument>,
												<argument><expr><name>numEntryPages</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>entryPagesFetched</name> <operator>/=</operator> <name>outer_scans</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dataPagesFetched</name> <operator>*=</operator> <name>outer_scans</name> <operator>*</operator> <name><name>counts</name><operator>.</operator><name>arrayScans</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dataPagesFetched</name> <operator>=</operator> <call><name>index_pages_fetched</name><argument_list>(<argument><expr><name>dataPagesFetched</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>numDataPages</name></expr></argument>,
											   <argument><expr><name>numDataPages</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dataPagesFetched</name> <operator>/=</operator> <name>outer_scans</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Here we use random page cost because logically-close pages could be far
	 * apart on disk.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>=</operator> <operator>(</operator><name>entryPagesFetched</name> <operator>+</operator> <name>dataPagesFetched</name><operator>)</operator> <operator>*</operator> <name>spc_random_page_cost</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now compute the number of data pages fetched during the scan.
	 *
	 * We assume every entry to have the same number of items, and that there
	 * is no overlap between them. (XXX: tsvector and array opclasses collect
	 * statistics on the frequency of individual keys; it would be nice to use
	 * those here.)
	 */</comment>
	<expr_stmt><expr><name>dataPagesFetched</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>numDataPages</name> <operator>*</operator> <name><name>counts</name><operator>.</operator><name>exactEntries</name></name> <operator>/</operator> <name>numEntries</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If there is a lot of overlap among the entries, in particular if one of
	 * the entries is very frequent, the above calculation can grossly
	 * under-estimate.  As a simple cross-check, calculate a lower bound based
	 * on the overall selectivity of the quals.  At a minimum, we must read
	 * one item pointer for each matching entry.
	 *
	 * The width of each item pointer varies, based on the level of
	 * compression.  We don't have statistics on that, but an average of
	 * around 3 bytes per item is fairly typical.
	 */</comment>
	<expr_stmt><expr><name>dataPagesFetchedBySel</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><operator>*</operator><name>indexSelectivity</name> <operator>*</operator>
								 <operator>(</operator><name>numTuples</name> <operator>/</operator> <operator>(</operator><name>BLCKSZ</name> <operator>/</operator> <literal type="number">3</literal><operator>)</operator><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>dataPagesFetchedBySel</name> <operator>&gt;</operator> <name>dataPagesFetched</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>dataPagesFetched</name> <operator>=</operator> <name>dataPagesFetchedBySel</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Account for cache effects, the same as above */</comment>
	<if_stmt><if>if <condition>(<expr><name>outer_scans</name> <operator>&gt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>counts</name><operator>.</operator><name>arrayScans</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>dataPagesFetched</name> <operator>*=</operator> <name>outer_scans</name> <operator>*</operator> <name><name>counts</name><operator>.</operator><name>arrayScans</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dataPagesFetched</name> <operator>=</operator> <call><name>index_pages_fetched</name><argument_list>(<argument><expr><name>dataPagesFetched</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>BlockNumber</name><operator>)</operator> <name>numDataPages</name></expr></argument>,
											   <argument><expr><name>numDataPages</name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>dataPagesFetched</name> <operator>/=</operator> <name>outer_scans</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* And apply random_page_cost as the cost per page */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>=</operator> <operator>*</operator><name>indexStartupCost</name> <operator>+</operator>
		<name>dataPagesFetched</name> <operator>*</operator> <name>spc_random_page_cost</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Add on index qual eval costs, much as in genericcostestimate.  But we
	 * can disregard indexorderbys, since GIN doesn't support those.
	 */</comment>
	<expr_stmt><expr><name>qual_arg_cost</name> <operator>=</operator> <call><name>index_other_operands_eval_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>indexQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>qual_op_cost</name> <operator>=</operator> <name>cpu_operator_cost</name> <operator>*</operator> <call><name>list_length</name><argument_list>(<argument><expr><name>indexQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>+=</operator> <name>qual_arg_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>+=</operator> <name>qual_arg_cost</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>+=</operator> <operator>(</operator><name>numTuples</name> <operator>*</operator> <operator>*</operator><name>indexSelectivity</name><operator>)</operator> <operator>*</operator> <operator>(</operator><name>cpu_index_tuple_cost</name> <operator>+</operator> <name>qual_op_cost</name><operator>)</operator></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexPages</name> <operator>=</operator> <name>dataPagesFetched</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>bmcostestimate</name><parameter_list>(<parameter><decl><type><name><name>struct</name> <name>PlannerInfo</name></name> <modifier>*</modifier></type><name>root</name></decl></parameter>,
			   <parameter><decl><type><name><name>struct</name> <name>IndexPath</name></name> <modifier>*</modifier></type><name>path</name></decl></parameter>,
			   <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
			   <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexStartupCost</name></decl></parameter>,
			   <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexTotalCost</name></decl></parameter>,
			   <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>indexSelectivity</name></decl></parameter>,
			   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexCorrelation</name></decl></parameter>,
			   <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexPages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier><name>rte</name></type> <name>PG_USED_FOR_ASSERTS_ONLY</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>GenericCosts</name></type> <name>costs</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name> <operator>!=</operator> <name>InvalidOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now do generic index cost estimation.
	 */</comment>
	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>costs</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We create a LOV for each distinct key in bitmap index. And the LOV point
	 * to the bitmap vector pages. Since each bitmap vector has the same length,
	 * although we do compress for the bits, but we can assume each distinct
	 * key has approximately same number of bitmap vector pages(although there
	 * must be some counterexamples). So the indexPages should be:
	 * selectedDistinctValues / numDistinctValues * index-&gt;pages.
	 *
	 * But the issue is we can't estimate both of the distinct values from stats
	 * through estimate_num_groups since it produces larger estimates. Especially
	 * for selectedDistinctValues.
	 *
	 * Image below cases:
	 * 1. indexSelectivity also correspond to how may distinct values get selected.
	 * Then the result of genericcostestimate's indexPages will be accurate.
	 * 2. indexSelectivity is high but only match a small number of distinct values.
	 * This means the bitmap vector is sparse. So the total index pages number should
	 * be small.
	 * 3. indexSelectivity is low but match lots of distinct values. This also means
	 * the bitmap vector is sparse, and the total index pages number should be small.
	 *
	 * The estimate in genericcostestimate should works fine for above cases although
	 * it's not accurate.
	 */</comment>

	<expr_stmt><expr><call><name>genericcostestimate</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>path</name></expr></argument>, <argument><expr><name>loop_count</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>costs</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexStartupCost</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexTotalCost</name></name></expr>;</expr_stmt>
	<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>FAULT_INJECTOR</name></cpp:ifdef>
		<comment type="block">/* Simulate an bitmapAnd plan by changing bitmap cost. */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>FaultInjector_InjectFaultIfSet</name><argument_list>(<argument><expr><literal type="string">"simulate_bitmap_and"</literal></expr></argument>,
									<argument><expr><name>DDLNotSpecified</name></expr></argument>,
									<argument><expr><literal type="string">""</literal></expr></argument>,
									<argument><expr><literal type="string">""</literal></expr></argument>)</argument_list></call> <operator>==</operator> <name>FaultInjectorTypeSkip</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><operator>*</operator><name>indexSelectivity</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexSelectivity</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexCorrelation</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>indexCorrelation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexPages</name> <operator>=</operator> <name><name>costs</name><operator>.</operator><name>numIndexPages</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * BRIN has search behavior completely different from other index types
 */</comment>
<function><type><name>void</name></type>
<name>brincostestimate</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>IndexPath</name> <modifier>*</modifier></type><name>path</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>loop_count</name></decl></parameter>,
				 <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexStartupCost</name></decl></parameter>, <parameter><decl><type><name>Cost</name> <modifier>*</modifier></type><name>indexTotalCost</name></decl></parameter>,
				 <parameter><decl><type><name>Selectivity</name> <modifier>*</modifier></type><name>indexSelectivity</name></decl></parameter>, <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexCorrelation</name></decl></parameter>,
				 <parameter><decl><type><name>double</name> <modifier>*</modifier></type><name>indexPages</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>IndexOptInfo</name> <modifier>*</modifier></type><name>index</name> <init>= <expr><name><name>path</name><operator>-&gt;</operator><name>indexinfo</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>indexQuals</name> <init>= <expr><call><name>get_quals_from_indexclauses</name><argument_list>(<argument><expr><name><name>path</name><operator>-&gt;</operator><name>indexclauses</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>numPages</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>baserel</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>rel</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name> <init>= <expr><call><name>planner_rt_fetch</name><argument_list>(<argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>root</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>spc_seq_page_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Cost</name></type>		<name>spc_random_page_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>qual_arg_cost</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>qualSelectivity</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>BrinStatsData</name></type> <name>statsData</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>indexRanges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>minimalRanges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>estimatedRanges</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>indexRel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ListCell</name>   <modifier>*</modifier></type><name>l</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>==</operator> <name>RTE_RELATION</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fetch estimated page cost for the tablespace containing the index */</comment>
	<expr_stmt><expr><call><name>get_tablespace_page_costs</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>reltablespace</name></name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_random_page_cost</name></expr></argument>,
							  <argument><expr><operator>&amp;</operator><name>spc_seq_page_cost</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Obtain some data from the index itself.  A lock should have already
	 * been obtained on the index in plancat.c.
	 */</comment>
	<expr_stmt><expr><name>indexRel</name> <operator>=</operator> <call><name>index_open</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>brinGetStats</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>statsData</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>index_close</name><argument_list>(<argument><expr><name>indexRel</name></expr></argument>, <argument><expr><name>NoLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute index correlation
	 *
	 * Because we can use all index quals equally when scanning, we can use
	 * the largest correlation (in absolute value) among columns used by the
	 * query.  Start at zero, the worst possible case.  If we cannot find any
	 * correlation statistics, we will keep it as 0.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexCorrelation</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<macro><name>foreach</name><argument_list>(<argument>l</argument>, <argument>path-&gt;indexclauses</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>IndexClause</name> <modifier>*</modifier></type><name>iclause</name> <init>= <expr><call><name>lfirst_node</name><argument_list>(<argument><expr><name>IndexClause</name></expr></argument>, <argument><expr><name>l</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>AttrNumber</name></type>	<name>attnum</name> <init>= <expr><name><name>index</name><operator>-&gt;</operator><name>indexkeys</name><index>[<expr><name><name>iclause</name><operator>-&gt;</operator><name>indexcol</name></name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<comment type="block">/* attempt to lookup stats in relation for this index column */</comment>
		<if_stmt><if>if <condition>(<expr><name>attnum</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Simple variable -- look to stats for the underlying table */</comment>
			<if_stmt><if>if <condition>(<expr><name>get_relation_stats_hook</name> <operator>&amp;&amp;</operator>
				<call>(<modifier>*</modifier><name>get_relation_stats_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>rte</name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The hook took control of acquiring a stats tuple.  If it
				 * did supply a tuple, it'd better have supplied a freefunc.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>vardata</name><operator>.</operator><name>freefunc</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						 <argument><expr><literal type="string">"no function provided to release variable stats with"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name> <operator>=</operator>
					<call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
									<argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vardata</name><operator>.</operator><name>freefunc</name></name> <operator>=</operator> <name>ReleaseSysCache</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Looks like we've found an expression column in the index. Let's
			 * see if there's any stats for it.
			 */</comment>

			<comment type="block">/* get the attnum from the 0-based index. */</comment>
			<expr_stmt><expr><name>attnum</name> <operator>=</operator> <name><name>iclause</name><operator>-&gt;</operator><name>indexcol</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>get_index_stats_hook</name> <operator>&amp;&amp;</operator>
				<call>(<modifier>*</modifier><name>get_index_stats_hook</name>) <argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>, <argument><expr><name>attnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The hook took control of acquiring a stats tuple.  If it
				 * did supply a tuple, it'd better have supplied a freefunc.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					<operator>!</operator><name><name>vardata</name><operator>.</operator><name>freefunc</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no function provided to release variable stats with"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
													 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>index</name><operator>-&gt;</operator><name>indexoid</name></name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attnum</name></expr></argument>)</argument_list></call></expr></argument>,
													 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>vardata</name><operator>.</operator><name>freefunc</name></name> <operator>=</operator> <name>ReleaseSysCache</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>sslot</name></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
								 <argument><expr><name>STATISTIC_KIND_CORRELATION</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
								 <argument><expr><name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>double</name></type>		<name>varCorrelation</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>

				<if_stmt><if>if <condition>(<expr><name><name>sslot</name><operator>.</operator><name>nnumbers</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>varCorrelation</name> <operator>=</operator> <call><name>Abs</name><argument_list>(<argument><expr><name><name>sslot</name><operator>.</operator><name>numbers</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<if_stmt><if>if <condition>(<expr><name>varCorrelation</name> <operator>&gt;</operator> <operator>*</operator><name>indexCorrelation</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>indexCorrelation</name> <operator>=</operator> <name>varCorrelation</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>sslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block>

	<expr_stmt><expr><name>qualSelectivity</name> <operator>=</operator> <call><name>clauselist_selectivity</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>indexQuals</name></expr></argument>,
											 <argument><expr><name><name>baserel</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>,
											 <argument><expr><name>JOIN_INNER</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
											 <argument><expr><name>false</name></expr></argument> <comment type="block">/* use_damping */</comment>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* work out the actual number of ranges in the index */</comment>
	<expr_stmt><expr><name>indexRanges</name> <operator>=</operator> <call><name>Max</name><argument_list>(<argument><expr><call><name>ceil</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>baserel</name><operator>-&gt;</operator><name>pages</name></name> <operator>/</operator> <name><name>statsData</name><operator>.</operator><name>pagesPerRange</name></name></expr></argument>)</argument_list></call></expr></argument>,
					  <argument><expr><literal type="number">1.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now calculate the minimum possible ranges we could match with if all of
	 * the rows were in the perfect order in the table's heap.
	 */</comment>
	<expr_stmt><expr><name>minimalRanges</name> <operator>=</operator> <call><name>ceil</name><argument_list>(<argument><expr><name>indexRanges</name> <operator>*</operator> <name>qualSelectivity</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Now estimate the number of ranges that we'll touch by using the
	 * indexCorrelation from the stats. Careful not to divide by zero (note
	 * we're using the absolute value of the correlation).
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>indexCorrelation</name> <operator>&lt;</operator> <literal type="number">1.0e-10</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>estimatedRanges</name> <operator>=</operator> <name>indexRanges</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>estimatedRanges</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name>minimalRanges</name> <operator>/</operator> <operator>*</operator><name>indexCorrelation</name></expr></argument>, <argument><expr><name>indexRanges</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* we expect to visit this portion of the table */</comment>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>estimatedRanges</name> <operator>/</operator> <name>indexRanges</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>indexSelectivity</name> <operator>=</operator> <name>selec</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the index qual costs, much as in genericcostestimate, to add to
	 * the index costs.  We can disregard indexorderbys, since BRIN doesn't
	 * support those.
	 */</comment>
	<expr_stmt><expr><name>qual_arg_cost</name> <operator>=</operator> <call><name>index_other_operands_eval_cost</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>indexQuals</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compute the startup cost as the cost to read the whole revmap
	 * sequentially, including the cost to execute the index quals.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>=</operator>
		<name>spc_seq_page_cost</name> <operator>*</operator> <name><name>statsData</name><operator>.</operator><name>revmapNumPages</name></name> <operator>*</operator> <name>loop_count</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>indexStartupCost</name> <operator>+=</operator> <name>qual_arg_cost</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * To read a BRIN index there might be a bit of back and forth over
	 * regular pages, as revmap might point to them out of sequential order;
	 * calculate the total cost as reading the whole index in random order.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>=</operator> <operator>*</operator><name>indexStartupCost</name> <operator>+</operator>
		<name>spc_random_page_cost</name> <operator>*</operator> <operator>(</operator><name>numPages</name> <operator>-</operator> <name><name>statsData</name><operator>.</operator><name>revmapNumPages</name></name><operator>)</operator> <operator>*</operator> <name>loop_count</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Charge a small amount per range tuple which we expect to match to. This
	 * is meant to reflect the costs of manipulating the bitmap. The BRIN scan
	 * will set a bit for each page in the range when we find a matching
	 * range, so we must multiply the charge by the number of pages in the
	 * range.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>indexTotalCost</name> <operator>+=</operator> <literal type="number">0.1</literal> <operator>*</operator> <name>cpu_operator_cost</name> <operator>*</operator> <name>estimatedRanges</name> <operator>*</operator>
		<name><name>statsData</name><operator>.</operator><name>pagesPerRange</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><operator>*</operator><name>indexPages</name> <operator>=</operator> <name><name>index</name><operator>-&gt;</operator><name>pages</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * estimate_num_groups_on_segment
 *
 *   - groupNum   : the number of groups globally
 *   - rows       : the number of tuples globally
 *   - locus      : how are the groups distributed?
 *
 * Estimate how many groups are on each segment, when the group keys do not contain
 * distribution keys. Understand such condition, we can consider data is roughly
 * random-distributed among all segments. The accurate formula to compute the
 * expectation is (1-((numsegments-1)/numsegments)^(rows/groupNum))*groupNum.
 *
 * The above formula can be deduced using indicate-variable method. Let's focus on
 * one specific segment, say seg0, and let Xi be a random variable:
 *   - Xi = 1, seg0 contains tuple from group i
 *   - Xi = 0, seg0 does not contain tuple from group i
 * E(X1+X2+...+X_groupNum) is just what we want to compute. Thus the formula
 * is easy to prove.
 */</comment>
<function><type><name>double</name></type>
<name>estimate_num_groups_on_segment</name><parameter_list>(<parameter><decl><type><name>double</name></type> <name>dNumGroupsTotal</name></decl></parameter>, <parameter><decl><type><name>double</name></type> <name>rows</name></decl></parameter>, <parameter><decl><type><name>CdbPathLocus</name></type> <name>locus</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>CdbPathLocus_IsPartitioned</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>numsegments</name> <init>= <expr><call><name>CdbPathLocus_NumSegments</name><argument_list>(<argument><expr><name>locus</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>totalrows</name> <init>= <expr><name>rows</name> <operator>*</operator> <name>numsegments</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>numPerGroup</name> <init>= <expr><name>totalrows</name> <operator>/</operator> <name>dNumGroupsTotal</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>double</name></type>		<name>group_num</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>group_num</name> <operator>=</operator> <operator>(</operator><literal type="number">1</literal><operator>-</operator><call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><name>numsegments</name><operator>-</operator><literal type="number">1</literal><operator>)</operator><operator>/</operator><name>numsegments</name></expr></argument>, <argument><expr><name>numPerGroup</name></expr></argument>)</argument_list></call><operator>)</operator><operator>*</operator><name>dNumGroupsTotal</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>group_num</name> <operator>=</operator> <call><name>clamp_row_est</name><argument_list>(<argument><expr><name>group_num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>group_num</name></expr>;</return>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>dNumGroupsTotal</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_fetch_rel_stats</name><parameter_list>(<parameter><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>rte</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name><modifier>*</modifier></type> <name>vardata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>AttrNumber</name></type> <name>attno</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>rte</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* attname may be NULL when 'SELECT DISTINCT &lt;table_name&gt; from &lt;table_name&gt;', and attno is set zero directly */</comment>
	<if_stmt><if>if <condition>(<expr><name>attname</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>attno</name> <operator>=</operator> <name>InvalidAttrNumber</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>attno</name> <operator>=</operator> <call><name>get_attnum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><name>attname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name> <operator>=</operator> <call><name>SearchSysCache3</name><argument_list>(<argument><expr><name>STATRELATTINH</name></expr></argument>,
										  <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>Int16GetDatum</name><argument_list>(<argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr></argument>,
										  <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name><name>rte</name><operator>-&gt;</operator><name>inh</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>vardata</name><operator>-&gt;</operator><name>freefunc</name></name> <operator>=</operator> <name>ReleaseSysCache</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>try_fetch_largest_child_stats</name><parameter_list>(<parameter><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name></decl></parameter>, <parameter><decl><type><name>Index</name></type> <name>parent_rti</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>attname</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name><modifier>*</modifier></type> <name>vardata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>parent_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RelOptInfo</name> <modifier>*</modifier></type><name>child_rel</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>parent_rel</name> <operator>=</operator> <call><name>find_base_rel</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>parent_rti</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>child_rel</name> <operator>=</operator> <call><name>largest_child_relation</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name><name>parent_rel</name><operator>-&gt;</operator><name>cheapest_total_path</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>child_rel</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>child_rte</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>child_rte</name> <operator>=</operator> <name><name>root</name><operator>-&gt;</operator><name>simple_rte_array</name><index>[<expr><name><name>child_rel</name><operator>-&gt;</operator><name>relid</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>try_fetch_rel_stats</name><argument_list>(<argument><expr><name>child_rte</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>adjust_partition_table_statistic_for_parent</name><argument_list>(<argument><expr><name><name>vardata</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
														<argument><expr><name><name>child_rel</name><operator>-&gt;</operator><name>tuples</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
