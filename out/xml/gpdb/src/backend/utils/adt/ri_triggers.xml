<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/ri_triggers.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * ri_triggers.c
 *
 *	Generic trigger procedures for referential integrity constraint
 *	checks.
 *
 *	Note about memory management: the private hashtables kept here live
 *	across query and transaction boundaries, in fact they live as long as
 *	the backend does.  This works because the hashtable structures
 *	themselves are allocated by dynahash.c in its permanent DynaHashCxt,
 *	and the SPI plans they point to are saved using SPI_keepplan().
 *	There is not currently any provision for throwing away a no-longer-needed
 *	plan --- consider improving this someday.
 *
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 *
 * src/backend/utils/adt/ri_triggers.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/sysattr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/table.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/tableam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_constraint.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_type.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"commands/trigger.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/executor.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"executor/spi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/ilist.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_coerce.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"parser/parse_relation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/bufmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/acl.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datum.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/fmgroids.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inval.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rel.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/rls.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/ruleutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/syscache.h"</cpp:file></cpp:include>


<comment type="block">/*
 * Local definitions
 */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_MAX_NUMKEYS</name></cpp:macro>					<cpp:value>INDEX_MAX_KEYS</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_INIT_CONSTRAINTHASHSIZE</name></cpp:macro>		<cpp:value>64</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_INIT_QUERYHASHSIZE</name></cpp:macro>			<cpp:value>(RI_INIT_CONSTRAINTHASHSIZE * 4)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_KEYS_ALL_NULL</name></cpp:macro>				<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_KEYS_SOME_NULL</name></cpp:macro>				<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_KEYS_NONE_NULL</name></cpp:macro>				<cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* RI query type codes */</comment>
<comment type="block">/* these queries are executed against the PK (referenced) table: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_PLAN_CHECK_LOOKUPPK</name></cpp:macro>			<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_PLAN_CHECK_LOOKUPPK_FROM_PK</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_PLAN_LAST_ON_PK</name></cpp:macro>				<cpp:value>RI_PLAN_CHECK_LOOKUPPK_FROM_PK</cpp:value></cpp:define>
<comment type="block">/* these queries are executed against the FK (referencing) table: */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_PLAN_CASCADE_DEL_DODELETE</name></cpp:macro>	<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_PLAN_CASCADE_UPD_DOUPDATE</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_PLAN_RESTRICT_CHECKREF</name></cpp:macro>		<cpp:value>5</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_PLAN_SETNULL_DOUPDATE</name></cpp:macro>		<cpp:value>6</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_PLAN_SETDEFAULT_DOUPDATE</name></cpp:macro>		<cpp:value>7</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_QUOTED_NAME_LEN</name></cpp:macro>  <cpp:value>(NAMEDATALEN*2+3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_QUOTED_REL_NAME_LEN</name></cpp:macro>  <cpp:value>(MAX_QUOTED_NAME_LEN*2)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIAttName</name><parameter_list>(<parameter><type><name>rel</name></type></parameter>, <parameter><type><name>attnum</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>NameStr(*attnumAttName(rel, attnum))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIAttType</name><parameter_list>(<parameter><type><name>rel</name></type></parameter>, <parameter><type><name>attnum</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>attnumTypeId(rel, attnum)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RIAttCollation</name><parameter_list>(<parameter><type><name>rel</name></type></parameter>, <parameter><type><name>attnum</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>attnumCollationId(rel, attnum)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_TRIGTYPE_INSERT</name></cpp:macro> <cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_TRIGTYPE_UPDATE</name></cpp:macro> <cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>RI_TRIGTYPE_DELETE</name></cpp:macro> <cpp:value>3</cpp:value></cpp:define>


<comment type="block">/*
 * RI_ConstraintInfo
 *
 * Information extracted from an FK pg_constraint entry.  This is cached in
 * ri_constraint_cache.
 */</comment>
<typedef>typedef <type><struct>struct <name>RI_ConstraintInfo</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constraint_id</name></decl>;</decl_stmt>	<comment type="block">/* OID of pg_constraint entry (hash key) */</comment>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>			<comment type="block">/* successfully initialized? */</comment>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>oidHashValue</name></decl>;</decl_stmt>	<comment type="block">/* hash value of pg_constraint OID */</comment>
	<decl_stmt><decl><type><name>NameData</name></type>	<name>conname</name></decl>;</decl_stmt>		<comment type="block">/* name of the FK constraint */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_relid</name></decl>;</decl_stmt>		<comment type="block">/* referenced relation */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_relid</name></decl>;</decl_stmt>		<comment type="block">/* referencing relation */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>confupdtype</name></decl>;</decl_stmt>	<comment type="block">/* foreign key's ON UPDATE action */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>confdeltype</name></decl>;</decl_stmt>	<comment type="block">/* foreign key's ON DELETE action */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name>confmatchtype</name></decl>;</decl_stmt>	<comment type="block">/* foreign key's match type */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>nkeys</name></decl>;</decl_stmt>			<comment type="block">/* number of key columns */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name><name>pk_attnums</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* attnums of referenced cols */</comment>
	<decl_stmt><decl><type><name>int16</name></type>		<name><name>fk_attnums</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* attnums of referencing cols */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>pf_eq_oprs</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* equality operators (PK = FK) */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>pp_eq_oprs</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* equality operators (PK = PK) */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name><name>ff_eq_oprs</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt> <comment type="block">/* equality operators (FK = FK) */</comment>
	<decl_stmt><decl><type><name>dlist_node</name></type>	<name>valid_link</name></decl>;</decl_stmt>		<comment type="block">/* Link in list of valid entries */</comment>
}</block></struct></type> <name>RI_ConstraintInfo</name>;</typedef>

<comment type="block">/*
 * RI_QueryKey
 *
 * The key identifying a prepared SPI plan in our query hashtable
 */</comment>
<typedef>typedef <type><struct>struct <name>RI_QueryKey</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constr_id</name></decl>;</decl_stmt>		<comment type="block">/* OID of pg_constraint entry */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>constr_queryno</name></decl>;</decl_stmt> <comment type="block">/* query type ID, see RI_PLAN_XXX above */</comment>
}</block></struct></type> <name>RI_QueryKey</name>;</typedef>

<comment type="block">/*
 * RI_QueryHashEntry
 */</comment>
<typedef>typedef <type><struct>struct <name>RI_QueryHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>RI_QueryKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>
}</block></struct></type> <name>RI_QueryHashEntry</name>;</typedef>

<comment type="block">/*
 * RI_CompareKey
 *
 * The key identifying an entry showing how to compare two values
 */</comment>
<typedef>typedef <type><struct>struct <name>RI_CompareKey</name>
<block>{
	<decl_stmt><decl><type><name>Oid</name></type>			<name>eq_opr</name></decl>;</decl_stmt>			<comment type="block">/* the equality operator to apply */</comment>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>typeid</name></decl>;</decl_stmt>			<comment type="block">/* the data type to apply it to */</comment>
}</block></struct></type> <name>RI_CompareKey</name>;</typedef>

<comment type="block">/*
 * RI_CompareHashEntry
 */</comment>
<typedef>typedef <type><struct>struct <name>RI_CompareHashEntry</name>
<block>{
	<decl_stmt><decl><type><name>RI_CompareKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>			<comment type="block">/* successfully initialized? */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>eq_opr_finfo</name></decl>;</decl_stmt>	<comment type="block">/* call info for equality fn */</comment>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>cast_func_finfo</name></decl>;</decl_stmt>	<comment type="block">/* in case we must coerce input */</comment>
}</block></struct></type> <name>RI_CompareHashEntry</name>;</typedef>


<comment type="block">/*
 * Local data
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ri_constraint_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ri_query_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>ri_compare_cache</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>dlist_head</name></type> <name>ri_constraint_cache_valid_list</name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>ri_constraint_cache_valid_count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>


<comment type="block">/*
 * Local function prototypes
 */</comment>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ri_Check_Pk_Match</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>,
							  <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ri_restrict</name><parameter_list>(<parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_no_action</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Datum</name></type> <name>ri_set</name><parameter_list>(<parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_set_null</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>quoteOneName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>quoteRelationName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ri_GenerateQual</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>leftop</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>leftoptype</name></decl></parameter>,
							<parameter><decl><type><name>Oid</name></type> <name>opoid</name></decl></parameter>,
							<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rightop</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rightoptype</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ri_GenerateQualCollation</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>ri_NullCheck</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rel_is_pk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ri_BuildQueryKey</name><parameter_list>(<parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>,
							 <parameter><decl><type><name>int32</name></type> <name>constr_queryno</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ri_KeysEqual</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rel_is_pk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ri_AttributesEqual</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>eq_opr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeid</name></decl></parameter>,
							   <parameter><decl><type><name>Datum</name></type> <name>oldvalue</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>newvalue</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ri_InitHashTables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>InvalidateConstraintCacheCallBack</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type> <name>ri_FetchPreparedPlan</name><parameter_list>(<parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ri_HashPreparedPlan</name><parameter_list>(<parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>RI_CompareHashEntry</name> <modifier>*</modifier></type><name>ri_HashCompareOp</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>eq_opr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeid</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ri_CheckTrigger</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>,
							<parameter><decl><type><name>int</name></type> <name>tgkind</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>ri_FetchConstraintInfo</name><parameter_list>(<parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>,
													   <parameter><decl><type><name>Relation</name></type> <name>trig_rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rel_is_pk</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>ri_LoadConstraintInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SPIPlanPtr</name></type> <name>ri_PlanCheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querystr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
							   <parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>qkey</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>,
							   <parameter><decl><type><name>bool</name></type> <name>cache_plan</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>ri_PerformCheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>,
							<parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>qkey</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>qplan</name></decl></parameter>,
							<parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>,
							<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>,
							<parameter><decl><type><name>bool</name></type> <name>detectNewRows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expect_OK</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ri_ExtractValues</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
							 <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rel_is_pk</name></decl></parameter>,
							 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>ri_ReportViolation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>,
							   <parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>,
							   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>violatorslot</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
							   <parameter><decl><type><name>int</name></type> <name>queryno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>partgone</name></decl></parameter>)</parameter_list> pg_attribute_noreturn<parameter_list>()</parameter_list>;</function_decl>


<comment type="block">/*
 * RI_FKey_check -
 *
 * Check foreign key existence (combined for INSERT and UPDATE).
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>RI_FKey_check</name><parameter_list>(<parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>fk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RI_QueryKey</name></type> <name>qkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>qplan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_FetchConstraintInfo</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name></name></expr></argument>,
									<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>newslot</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_newslot</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>newslot</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigslot</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * We should not even consider checking the row if it is no longer valid,
	 * since it was either deleted (so the deferred check should be skipped)
	 * or updated (in which case only the latest version of the row should be
	 * checked).  Test its liveness according to SnapshotSelf.  We need pin
	 * and lock on the buffer to call HeapTupleSatisfiesVisibility.  Caller
	 * should be holding pin, but not lock.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>table_tuple_satisfies_snapshot</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>SnapshotSelf</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Get the relation descriptors of the FK and PK tables.
	 *
	 * pk_rel is opened in RowShareLock mode since that's what our eventual
	 * SELECT FOR KEY SHARE will get on it.
	 */</comment>
	<expr_stmt><expr><name>fk_rel</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>pk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_relid</name></name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><call><name>ri_NullCheck</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RI_KEYS_ALL_NULL</name></expr>:</case>

			<comment type="block">/*
			 * No further check needed - an all-NULL key passes every type of
			 * foreign key constraint.
			 */</comment>
			<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

		<case>case <expr><name>RI_KEYS_SOME_NULL</name></expr>:</case>

			<comment type="block">/*
			 * This is the only case that differs between the three kinds of
			 * MATCH.
			 */</comment>
			<switch>switch <condition>(<expr><name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>FKCONSTR_MATCH_FULL</name></expr>:</case>

					<comment type="block">/*
					 * Not allowed - MATCH FULL says either all or none of the
					 * attributes can be NULLs
					 */</comment>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FOREIGN_KEY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insert or update on table \"%s\" violates foreign key constraint \"%s\""</literal></expr></argument>,
									<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"MATCH FULL does not allow mixing of null and nonnull key values."</literal></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>,
												<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

				<case>case <expr><name>FKCONSTR_MATCH_SIMPLE</name></expr>:</case>

					<comment type="block">/*
					 * MATCH SIMPLE - if ANY column is null, the key passes
					 * the constraint.
					 */</comment>
					<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
				<case>case <expr><name>FKCONSTR_MATCH_PARTIAL</name></expr>:</case>

					<comment type="block">/*
					 * MATCH PARTIAL - all non-null columns must match. (not
					 * implemented, can be done by modifying the query below
					 * to only include non-null columns, or by writing a
					 * special version here)
					 */</comment>
					<break>break;</break>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			</block_content>}</block></switch>

		<case>case <expr><name>RI_KEYS_NONE_NULL</name></expr>:</case>

			<comment type="block">/*
			 * Have a full qualified key - continue below for all three kinds
			 * of MATCH.
			 */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch or prepare a saved plan for the real check */</comment>
	<expr_stmt><expr><call><name>ri_BuildQueryKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>RI_PLAN_CHECK_LOOKUPPK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qplan</name> <operator>=</operator> <call><name>ri_FetchPreparedPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>querybuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>pkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>attname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>paramname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querysep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>queryoids</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pk_only</name></decl>;</decl_stmt>

		<comment type="block">/* ----------
		 * The query string built is
		 *	SELECT 1 FROM [ONLY] &lt;pktable&gt; x WHERE pkatt1 = $1 [AND ...]
		 *		   FOR KEY SHARE OF x
		 * The type id's for the $ parameters are those of the
		 * corresponding FK attributes.
		 * ----------
		 */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pk_only</name> <operator>=</operator> <ternary><condition><expr><name><name>pk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
			<expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>pkrelname</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM %s%s x"</literal></expr></argument>,
						 <argument><expr><name>pk_only</name></expr></argument>, <argument><expr><name>pkrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">"WHERE"</literal></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>attname</name></expr></argument>,
						 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>paramname</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ri_GenerateQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>querysep</name></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>, <argument><expr><name>pk_type</name></expr></argument>,
							<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pf_eq_oprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>paramname</name></expr></argument>, <argument><expr><name>fk_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryoids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>fk_type</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">" FOR KEY SHARE OF x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare and save the plan */</comment>
		<expr_stmt><expr><name>qplan</name> <operator>=</operator> <call><name>ri_PlanCheck</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>queryoids</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Now check that foreign key exists in PK table
	 */</comment>
	<expr_stmt><expr><call><name>ri_PerformCheck</name><argument_list>(<argument><expr><name>riinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>qplan</name></expr></argument>,
					<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>,
					<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>,
					<argument><expr><name>false</name></expr></argument>,
					<argument><expr><name>SPI_OK_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RI_FKey_check_ins -
 *
 * Check foreign key existence at insert event on FK table.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_check_ins</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_check_ins"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_INSERT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with UPDATE case. */</comment>
	<return>return <expr><call><name>RI_FKey_check</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RI_FKey_check_upd -
 *
 * Check foreign key existence at update event on FK table.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_check_upd</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_check_upd"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with INSERT case. */</comment>
	<return>return <expr><call><name>RI_FKey_check</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ri_Check_Pk_Match
 *
 * Check to see if another PK row has been created that provides the same
 * key values as the "oldslot" that's been modified or deleted in our trigger
 * event.  Returns true if a match is found in the PK table.
 *
 * We assume the caller checked that the oldslot contains no NULL key values,
 * since otherwise a match is impossible.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ri_Check_Pk_Match</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>,
				  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>,
				  <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>qplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RI_QueryKey</name></type> <name>qkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>result</name></decl>;</decl_stmt>

	<comment type="block">/* Only called for non-null rows */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>ri_NullCheck</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>RI_KEYS_NONE_NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch or prepare a saved plan for checking PK table with values coming
	 * from a PK row
	 */</comment>
	<expr_stmt><expr><call><name>ri_BuildQueryKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>RI_PLAN_CHECK_LOOKUPPK_FROM_PK</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qplan</name> <operator>=</operator> <call><name>ri_FetchPreparedPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>querybuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>pkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>attname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>paramname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querysep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pk_only</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>queryoids</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt>

		<comment type="block">/* ----------
		 * The query string built is
		 *	SELECT 1 FROM [ONLY] &lt;pktable&gt; x WHERE pkatt1 = $1 [AND ...]
		 *		   FOR KEY SHARE OF x
		 * The type id's for the $ parameters are those of the
		 * PK attributes themselves.
		 * ----------
		 */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>pk_only</name> <operator>=</operator> <ternary><condition><expr><name><name>pk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
			<expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>pkrelname</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM %s%s x"</literal></expr></argument>,
						 <argument><expr><name>pk_only</name></expr></argument>, <argument><expr><name>pkrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">"WHERE"</literal></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>attname</name></expr></argument>,
						 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>paramname</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ri_GenerateQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>querysep</name></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>, <argument><expr><name>pk_type</name></expr></argument>,
							<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pp_eq_oprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>paramname</name></expr></argument>, <argument><expr><name>pk_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryoids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pk_type</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">" FOR KEY SHARE OF x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare and save the plan */</comment>
		<expr_stmt><expr><name>qplan</name> <operator>=</operator> <call><name>ri_PlanCheck</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>queryoids</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have a plan now. Run it.
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>ri_PerformCheck</name><argument_list>(<argument><expr><name>riinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>qplan</name></expr></argument>,
							 <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>,
							 <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
							 <argument><expr><name>true</name></expr></argument>,	<comment type="block">/* treat like update */</comment>
							 <argument><expr><name>SPI_OK_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RI_FKey_noaction_del -
 *
 * Give an error and roll back the current transaction if the
 * delete has resulted in a violation of the given referential
 * integrity constraint.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_noaction_del</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_noaction_del"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with RESTRICT/UPDATE cases. */</comment>
	<return>return <expr><call><name>ri_restrict</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RI_FKey_restrict_del -
 *
 * Restrict delete from PK table to rows unreferenced by foreign key.
 *
 * The SQL standard intends that this referential action occur exactly when
 * the delete is performed, rather than after.  This appears to be
 * the only difference between "NO ACTION" and "RESTRICT".  In Postgres
 * we still implement this as an AFTER trigger, but it's non-deferrable.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_restrict_del</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_restrict_del"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with NO ACTION/UPDATE cases. */</comment>
	<return>return <expr><call><name>ri_restrict</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RI_FKey_noaction_upd -
 *
 * Give an error and roll back the current transaction if the
 * update has resulted in a violation of the given referential
 * integrity constraint.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_noaction_upd</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_noaction_upd"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with RESTRICT/DELETE cases. */</comment>
	<return>return <expr><call><name>ri_restrict</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RI_FKey_restrict_upd -
 *
 * Restrict update of PK to rows unreferenced by foreign key.
 *
 * The SQL standard intends that this referential action occur exactly when
 * the update is performed, rather than after.  This appears to be
 * the only difference between "NO ACTION" and "RESTRICT".  In Postgres
 * we still implement this as an AFTER trigger, but it's non-deferrable.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_restrict_upd</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_restrict_upd"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with NO ACTION/DELETE cases. */</comment>
	<return>return <expr><call><name>ri_restrict</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ri_restrict -
 *
 * Common code for ON DELETE RESTRICT, ON DELETE NO ACTION,
 * ON UPDATE RESTRICT, and ON UPDATE NO ACTION.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ri_restrict</name><parameter_list>(<parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_no_action</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>fk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RI_QueryKey</name></type> <name>qkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>qplan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_FetchConstraintInfo</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name></name></expr></argument>,
									<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the relation descriptors of the FK and PK tables and the old tuple.
	 *
	 * fk_rel is opened in RowShareLock mode since that's what our eventual
	 * SELECT FOR KEY SHARE will get on it.
	 */</comment>
	<expr_stmt><expr><name>fk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_relid</name></name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pk_rel</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldslot</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigslot</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If another PK row now exists providing the old key values, we should
	 * not do anything.  However, this check should only be made in the NO
	 * ACTION case; in RESTRICT cases we don't wish to allow another row to be
	 * substituted.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_no_action</name> <operator>&amp;&amp;</operator>
		<call><name>ri_Check_Pk_Match</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch or prepare a saved plan for the restrict lookup (it's the same
	 * query for delete and update cases)
	 */</comment>
	<expr_stmt><expr><call><name>ri_BuildQueryKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>RI_PLAN_RESTRICT_CHECKREF</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qplan</name> <operator>=</operator> <call><name>ri_FetchPreparedPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>querybuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>attname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>paramname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querysep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>queryoids</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fk_only</name></decl>;</decl_stmt>

		<comment type="block">/* ----------
		 * The query string built is
		 *	SELECT 1 FROM [ONLY] &lt;fktable&gt; x WHERE $1 = fkatt1 [AND ...]
		 *		   FOR KEY SHARE OF x
		 * The type id's for the $ parameters are those of the
		 * corresponding PK attributes.
		 * ----------
		 */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fk_only</name> <operator>=</operator> <ternary><condition><expr><name><name>fk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
			<expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>fkrelname</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"SELECT 1 FROM %s%s x"</literal></expr></argument>,
						 <argument><expr><name>fk_only</name></expr></argument>, <argument><expr><name>fkrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">"WHERE"</literal></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>attname</name></expr></argument>,
						 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>paramname</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ri_GenerateQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>querysep</name></expr></argument>,
							<argument><expr><name>paramname</name></expr></argument>, <argument><expr><name>pk_type</name></expr></argument>,
							<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pf_eq_oprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>, <argument><expr><name>fk_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pk_coll</name> <operator>!=</operator> <name>fk_coll</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_collation_isdeterministic</name><argument_list>(<argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ri_GenerateQualCollation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryoids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pk_type</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">" FOR KEY SHARE OF x"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare and save the plan */</comment>
		<expr_stmt><expr><name>qplan</name> <operator>=</operator> <call><name>ri_PlanCheck</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>queryoids</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have a plan now. Run it to check for existing references.
	 */</comment>
	<expr_stmt><expr><call><name>ri_PerformCheck</name><argument_list>(<argument><expr><name>riinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>qplan</name></expr></argument>,
					<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>,
					<argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					<argument><expr><name>true</name></expr></argument>,		<comment type="block">/* must detect new rows */</comment>
					<argument><expr><name>SPI_OK_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>RowShareLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RI_FKey_cascade_del -
 *
 * Cascaded delete foreign key references at delete event on PK table.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_cascade_del</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>fk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RI_QueryKey</name></type> <name>qkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>qplan</name></decl>;</decl_stmt>

	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_cascade_del"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_FetchConstraintInfo</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name></name></expr></argument>,
									<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the relation descriptors of the FK and PK tables and the old tuple.
	 *
	 * fk_rel is opened in RowExclusiveLock mode since that's what our
	 * eventual DELETE will get on it.
	 */</comment>
	<expr_stmt><expr><name>fk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_relid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pk_rel</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldslot</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigslot</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch or prepare a saved plan for the cascaded delete */</comment>
	<expr_stmt><expr><call><name>ri_BuildQueryKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>RI_PLAN_CASCADE_DEL_DODELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qplan</name> <operator>=</operator> <call><name>ri_FetchPreparedPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>querybuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>attname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>paramname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querysep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>queryoids</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fk_only</name></decl>;</decl_stmt>

		<comment type="block">/* ----------
		 * The query string built is
		 *	DELETE FROM [ONLY] &lt;fktable&gt; WHERE $1 = fkatt1 [AND ...]
		 * The type id's for the $ parameters are those of the
		 * corresponding PK attributes.
		 * ----------
		 */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fk_only</name> <operator>=</operator> <ternary><condition><expr><name><name>fk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
			<expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>fkrelname</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"DELETE FROM %s%s"</literal></expr></argument>,
						 <argument><expr><name>fk_only</name></expr></argument>, <argument><expr><name>fkrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">"WHERE"</literal></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>attname</name></expr></argument>,
						 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>paramname</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ri_GenerateQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>querysep</name></expr></argument>,
							<argument><expr><name>paramname</name></expr></argument>, <argument><expr><name>pk_type</name></expr></argument>,
							<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pf_eq_oprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>, <argument><expr><name>fk_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pk_coll</name> <operator>!=</operator> <name>fk_coll</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_collation_isdeterministic</name><argument_list>(<argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ri_GenerateQualCollation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryoids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pk_type</name></expr>;</expr_stmt>
		</block_content>}</block></for>

		<comment type="block">/* Prepare and save the plan */</comment>
		<expr_stmt><expr><name>qplan</name> <operator>=</operator> <call><name>ri_PlanCheck</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>queryoids</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have a plan now. Build up the arguments from the key values in the
	 * deleted PK tuple and delete the referencing rows
	 */</comment>
	<expr_stmt><expr><call><name>ri_PerformCheck</name><argument_list>(<argument><expr><name>riinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>qplan</name></expr></argument>,
					<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>,
					<argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					<argument><expr><name>true</name></expr></argument>,		<comment type="block">/* must detect new rows */</comment>
					<argument><expr><name>SPI_OK_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RI_FKey_cascade_upd -
 *
 * Cascaded update foreign key references at update event on PK table.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_cascade_upd</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>fk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RI_QueryKey</name></type> <name>qkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>qplan</name></decl>;</decl_stmt>

	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_cascade_upd"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_FetchConstraintInfo</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name></name></expr></argument>,
									<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the relation descriptors of the FK and PK tables and the new and
	 * old tuple.
	 *
	 * fk_rel is opened in RowExclusiveLock mode since that's what our
	 * eventual UPDATE will get on it.
	 */</comment>
	<expr_stmt><expr><name>fk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_relid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pk_rel</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>newslot</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_newslot</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldslot</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigslot</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Fetch or prepare a saved plan for the cascaded update */</comment>
	<expr_stmt><expr><call><name>ri_BuildQueryKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>RI_PLAN_CASCADE_UPD_DOUPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qplan</name> <operator>=</operator> <call><name>ri_FetchPreparedPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>querybuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>qualbuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>attname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>paramname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querysep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qualsep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>queryoids</name><index>[<expr><name>RI_MAX_NUMKEYS</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fk_only</name></decl>;</decl_stmt>

		<comment type="block">/* ----------
		 * The query string built is
		 *	UPDATE [ONLY] &lt;fktable&gt; SET fkatt1 = $1 [, ...]
		 *			WHERE $n = fkatt1 [AND ...]
		 * The type id's for the $ parameters are those of the
		 * corresponding PK attributes.  Note that we are assuming
		 * there is an assignment cast from the PK to the FK type;
		 * else the parser will fail.
		 * ----------
		 */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qualbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fk_only</name> <operator>=</operator> <ternary><condition><expr><name><name>fk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
			<expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>fkrelname</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE %s%s SET"</literal></expr></argument>,
						 <argument><expr><name>fk_only</name></expr></argument>, <argument><expr><name>fkrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>qualsep</name> <operator>=</operator> <literal type="string">"WHERE"</literal></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>, <decl><type ref="prev"/><name>j</name> <init>= <expr><name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr><operator>,</operator> <expr><name>j</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>attname</name></expr></argument>,
						 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
							 <argument><expr><literal type="string">"%s %s = $%d"</literal></expr></argument>,
							 <argument><expr><name>querysep</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>paramname</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>j</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ri_GenerateQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qualbuf</name></expr></argument>, <argument><expr><name>qualsep</name></expr></argument>,
							<argument><expr><name>paramname</name></expr></argument>, <argument><expr><name>pk_type</name></expr></argument>,
							<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pf_eq_oprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>, <argument><expr><name>fk_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pk_coll</name> <operator>!=</operator> <name>fk_coll</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_collation_isdeterministic</name><argument_list>(<argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ri_GenerateQualCollation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>qualsep</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryoids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pk_type</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryoids</name><index>[<expr><name>j</name></expr>]</index></name> <operator>=</operator> <name>pk_type</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name><name>qualbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare and save the plan */</comment>
		<expr_stmt><expr><name>qplan</name> <operator>=</operator> <call><name>ri_PlanCheck</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>queryoids</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have a plan now. Run it to update the existing references.
	 */</comment>
	<expr_stmt><expr><call><name>ri_PerformCheck</name><argument_list>(<argument><expr><name>riinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>qplan</name></expr></argument>,
					<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>,
					<argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>,
					<argument><expr><name>true</name></expr></argument>,		<comment type="block">/* must detect new rows */</comment>
					<argument><expr><name>SPI_OK_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * RI_FKey_setnull_del -
 *
 * Set foreign key references to NULL values at delete event on PK table.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_setnull_del</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_setnull_del"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with UPDATE case */</comment>
	<return>return <expr><call><name>ri_set</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RI_FKey_setnull_upd -
 *
 * Set foreign key references to NULL at update event on PK table.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_setnull_upd</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_setnull_upd"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with DELETE case */</comment>
	<return>return <expr><call><name>ri_set</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RI_FKey_setdefault_del -
 *
 * Set foreign key references to defaults at delete event on PK table.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_setdefault_del</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_setdefault_del"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_DELETE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with UPDATE case */</comment>
	<return>return <expr><call><name>ri_set</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RI_FKey_setdefault_upd -
 *
 * Set foreign key references to defaults at update event on PK table.
 */</comment>
<function><type><name>Datum</name></type>
<name>RI_FKey_setdefault_upd</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Check that this is a valid trigger call on the right time and event. */</comment>
	<expr_stmt><expr><call><name>ri_CheckTrigger</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>, <argument><expr><literal type="string">"RI_FKey_setdefault_upd"</literal></expr></argument>, <argument><expr><name>RI_TRIGTYPE_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Share code with DELETE case */</comment>
	<return>return <expr><call><name>ri_set</name><argument_list>(<argument><expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ri_set -
 *
 * Common code for ON DELETE SET NULL, ON DELETE SET DEFAULT, ON UPDATE SET
 * NULL, and ON UPDATE SET DEFAULT.
 */</comment>
<function><type><specifier>static</specifier> <name>Datum</name></type>
<name>ri_set</name><parameter_list>(<parameter><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_set_null</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>fk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>pk_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RI_QueryKey</name></type> <name>qkey</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>qplan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_FetchConstraintInfo</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigger</name></name></expr></argument>,
									<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Get the relation descriptors of the FK and PK tables and the old tuple.
	 *
	 * fk_rel is opened in RowExclusiveLock mode since that's what our
	 * eventual UPDATE will get on it.
	 */</comment>
	<expr_stmt><expr><name>fk_rel</name> <operator>=</operator> <call><name>table_open</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_relid</name></name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>pk_rel</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_relation</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldslot</name> <operator>=</operator> <name><name>trigdata</name><operator>-&gt;</operator><name>tg_trigslot</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch or prepare a saved plan for the set null/default operation (it's
	 * the same query for delete and update cases)
	 */</comment>
	<expr_stmt><expr><call><name>ri_BuildQueryKey</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>,
					 <argument><expr><operator>(</operator><ternary><condition><expr><name>is_set_null</name></expr>
					  ?</condition><then> <expr><name>RI_PLAN_SETNULL_DOUPDATE</name></expr>
					  </then><else>: <expr><name>RI_PLAN_SETDEFAULT_DOUPDATE</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>qplan</name> <operator>=</operator> <call><name>ri_FetchPreparedPlan</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>querybuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>StringInfoData</name></type> <name>qualbuf</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>fkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>attname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>paramname</name><index>[<expr><literal type="number">16</literal></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querysep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>qualsep</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name><name>queryoids</name><index>[<expr><name>RI_MAX_NUMKEYS</name></expr>]</index></name></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fk_only</name></decl>;</decl_stmt>

		<comment type="block">/* ----------
		 * The query string built is
		 *	UPDATE [ONLY] &lt;fktable&gt; SET fkatt1 = {NULL|DEFAULT} [, ...]
		 *			WHERE $1 = fkatt1 [AND ...]
		 * The type id's for the $ parameters are those of the
		 * corresponding PK attributes.
		 * ----------
		 */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qualbuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fk_only</name> <operator>=</operator> <ternary><condition><expr><name><name>fk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
			<expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>fkrelname</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"UPDATE %s%s SET"</literal></expr></argument>,
						 <argument><expr><name>fk_only</name></expr></argument>, <argument><expr><name>fkrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>qualsep</name> <operator>=</operator> <literal type="string">"WHERE"</literal></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>attname</name></expr></argument>,
						 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
							 <argument><expr><literal type="string">"%s %s = %s"</literal></expr></argument>,
							 <argument><expr><name>querysep</name></expr></argument>, <argument><expr><name>attname</name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name>is_set_null</name></expr> ?</condition><then> <expr><literal type="string">"NULL"</literal></expr> </then><else>: <expr><literal type="string">"DEFAULT"</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>paramname</name></expr></argument>, <argument><expr><literal type="string">"$%d"</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>ri_GenerateQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>qualbuf</name></expr></argument>, <argument><expr><name>qualsep</name></expr></argument>,
							<argument><expr><name>paramname</name></expr></argument>, <argument><expr><name>pk_type</name></expr></argument>,
							<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pf_eq_oprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
							<argument><expr><name>attname</name></expr></argument>, <argument><expr><name>fk_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pk_coll</name> <operator>!=</operator> <name>fk_coll</name> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>get_collation_isdeterministic</name><argument_list>(<argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ri_GenerateQualCollation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>querysep</name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>qualsep</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>queryoids</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>pk_type</name></expr>;</expr_stmt>
		</block_content>}</block></for>
		<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name><name>qualbuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Prepare and save the plan */</comment>
		<expr_stmt><expr><name>qplan</name> <operator>=</operator> <call><name>ri_PlanCheck</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>queryoids</name></expr></argument>,
							 <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * We have a plan now. Run it to update the existing references.
	 */</comment>
	<expr_stmt><expr><call><name>ri_PerformCheck</name><argument_list>(<argument><expr><name>riinfo</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>qkey</name></expr></argument>, <argument><expr><name>qplan</name></expr></argument>,
					<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>,
					<argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
					<argument><expr><name>true</name></expr></argument>,		<comment type="block">/* must detect new rows */</comment>
					<argument><expr><name>SPI_OK_UPDATE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>table_close</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>RowExclusiveLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_set_null</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>PointerGetDatum</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * If we just deleted or updated the PK row whose key was equal to the
		 * FK columns' default values, and a referencing row exists in the FK
		 * table, we would have updated that row to the same values it already
		 * had --- and RI_FKey_fk_upd_check_required would hence believe no
		 * check is necessary.  So we need to do another lookup now and in
		 * case a reference still exists, abort the operation.  That is
		 * already implemented in the NO ACTION trigger, so just run it. (This
		 * recheck is only needed in the SET DEFAULT case, since CASCADE would
		 * remove such rows in case of a DELETE operation or would change the
		 * FK key values in case of an UPDATE, while SET NULL is certain to
		 * result in rows that satisfy the FK constraint.)
		 */</comment>
		<return>return <expr><call><name>ri_restrict</name><argument_list>(<argument><expr><name>trigdata</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * RI_FKey_pk_upd_check_required -
 *
 * Check if we really need to fire the RI trigger for an update or delete to a PK
 * relation.  This is called by the AFTER trigger queue manager to see if
 * it can skip queuing an instance of an RI trigger.  Returns true if the
 * trigger must be fired, false if we can prove the constraint will still
 * be satisfied.
 *
 * newslot will be NULL if this is called for a delete.
 */</comment>
<function><type><name>bool</name></type>
<name>RI_FKey_pk_upd_check_required</name><parameter_list>(<parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_FetchConstraintInfo</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If any old key value is NULL, the row could not have been referenced by
	 * an FK row, so no check is needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ri_NullCheck</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RI_KEYS_NONE_NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If all old and new key values are equal, no check is needed */</comment>
	<if_stmt><if>if <condition>(<expr><name>newslot</name> <operator>&amp;&amp;</operator> <call><name>ri_KeysEqual</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else we need to fire the trigger. */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RI_FKey_fk_upd_check_required -
 *
 * Check if we really need to fire the RI trigger for an update to an FK
 * relation.  This is called by the AFTER trigger queue manager to see if
 * it can skip queuing an instance of an RI trigger.  Returns true if the
 * trigger must be fired, false if we can prove the constraint will still
 * be satisfied.
 */</comment>
<function><type><name>bool</name></type>
<name>RI_FKey_fk_upd_check_required</name><parameter_list>(<parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>,
							  <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>ri_nullcheck</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>xminDatum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_FetchConstraintInfo</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>ri_nullcheck</name> <operator>=</operator> <call><name>ri_NullCheck</name><argument_list>(<argument><expr><call><name>RelationGetDescr</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If all new key values are NULL, the row satisfies the constraint, so no
	 * check is needed.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ri_nullcheck</name> <operator>==</operator> <name>RI_KEYS_ALL_NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>

	<comment type="block">/*
	 * If some new key values are NULL, the behavior depends on the match
	 * type.
	 */</comment>
	<if type="elseif">else if <condition>(<expr><name>ri_nullcheck</name> <operator>==</operator> <name>RI_KEYS_SOME_NULL</name></expr>)</condition>
	<block>{<block_content>
		<switch>switch <condition>(<expr><name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>FKCONSTR_MATCH_SIMPLE</name></expr>:</case>

				<comment type="block">/*
				 * If any new key value is NULL, the row must satisfy the
				 * constraint, so no check is needed.
				 */</comment>
				<return>return <expr><name>false</name></expr>;</return>

			<case>case <expr><name>FKCONSTR_MATCH_PARTIAL</name></expr>:</case>

				<comment type="block">/*
				 * Don't know, must run full check.
				 */</comment>
				<break>break;</break>

			<case>case <expr><name>FKCONSTR_MATCH_FULL</name></expr>:</case>

				<comment type="block">/*
				 * If some new key values are NULL, the row fails the
				 * constraint.  We must not throw error here, because the row
				 * might get invalidated before the constraint is to be
				 * checked, but we should queue the event to apply the check
				 * later.
				 */</comment>
				<return>return <expr><name>true</name></expr>;</return>
		</block_content>}</block></switch>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Continues here for no new key values are NULL, or we couldn't decide
	 * yet.
	 */</comment>

	<comment type="block">/*
	 * If the original row was inserted by our own transaction, we must fire
	 * the trigger whether or not the keys are equal.  This is because our
	 * UPDATE will invalidate the INSERT so that the INSERT RI trigger will
	 * not do anything; so we had better do the UPDATE check.  (We could skip
	 * this if we knew the INSERT trigger already fired, but there is no easy
	 * way to know that.)
	 */</comment>
	<expr_stmt><expr><name>xminDatum</name> <operator>=</operator> <call><name>slot_getsysattr</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>MinTransactionIdAttributeNumber</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>DatumGetTransactionId</name><argument_list>(<argument><expr><name>xminDatum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If all old and new key values are equal, no check is needed */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>ri_KeysEqual</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Else we need to fire the trigger. */</comment>
	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RI_Initial_Check -
 *
 * Check an entire table for non-matching values using a single query.
 * This is not a trigger procedure, but is called during ALTER TABLE
 * ADD FOREIGN KEY to validate the initial table contents.
 *
 * We expect that the caller has made provision to prevent any problems
 * caused by concurrent actions. This could be either by locking rel and
 * pkrel at ShareRowExclusiveLock or higher, or by otherwise ensuring
 * that triggers implementing the checks are already active.
 * Hence, we do not need to lock individual rows for the check.
 *
 * If the check fails because the current user doesn't have permissions
 * to read both tables, return false to let our caller know that they will
 * need to do something else to check the constraint.
 */</comment>
<function><type><name>bool</name></type>
<name>RI_Initial_Check</name><parameter_list>(<parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>querybuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pkattname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fkattname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>pkrte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RangeTblEntry</name> <modifier>*</modifier></type><name>fkrte</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fk_only</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pk_only</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workmembuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spi_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>qplan</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_FetchConstraintInfo</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Check to make sure current user has enough permissions to do the test
	 * query.  (If not, caller can fall back to the trigger method, which
	 * works because it changes user IDs on the fly.)
	 *
	 * XXX are there any other show-stopper conditions to check?
	 */</comment>
	<expr_stmt><expr><name>pkrte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pkrte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pkrte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pkrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>pk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pkrte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pkrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>fkrte</name> <operator>=</operator> <call><name>makeNode</name><argument_list>(<argument><expr><name>RangeTblEntry</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fkrte</name><operator>-&gt;</operator><name>rtekind</name></name> <operator>=</operator> <name>RTE_RELATION</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fkrte</name><operator>-&gt;</operator><name>relid</name></name> <operator>=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fkrte</name><operator>-&gt;</operator><name>relkind</name></name> <operator>=</operator> <name><name>fk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fkrte</name><operator>-&gt;</operator><name>rellockmode</name></name> <operator>=</operator> <name>AccessShareLock</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>fkrte</name><operator>-&gt;</operator><name>requiredPerms</name></name> <operator>=</operator> <name>ACL_SELECT</name></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>attno</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>pkrte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>pkrte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>attno</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <name>FirstLowInvalidHeapAttributeNumber</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>fkrte</name><operator>-&gt;</operator><name>selectedCols</name></name> <operator>=</operator> <call><name>bms_add_member</name><argument_list>(<argument><expr><name><name>fkrte</name><operator>-&gt;</operator><name>selectedCols</name></name></expr></argument>, <argument><expr><name>attno</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ExecCheckRTPerms</name><argument_list>(<argument><expr><call><name>list_make2</name><argument_list>(<argument><expr><name>fkrte</name></expr></argument>, <argument><expr><name>pkrte</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Also punt if RLS is enabled on either table unless this role has the
	 * bypassrls right or is the table owner of the table(s) involved which
	 * have RLS enabled.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>has_bypassrls_privilege</name><argument_list>(<argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<operator>(</operator><operator>(</operator><name><name>pk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name> <operator>&amp;&amp;</operator>
		  <operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name><name>pkrte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator> <operator>||</operator>
		 <operator>(</operator><name><name>fk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relrowsecurity</name></name> <operator>&amp;&amp;</operator>
		  <operator>!</operator><call><name>pg_class_ownercheck</name><argument_list>(<argument><expr><name><name>fkrte</name><operator>-&gt;</operator><name>relid</name></name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*----------
	 * The query string built is:
	 *	SELECT fk.keycols FROM [ONLY] relname fk
	 *	 LEFT OUTER JOIN [ONLY] pkrelname pk
	 *	 ON (pk.pkkeycol1=fk.keycol1 [AND ...])
	 *	 WHERE pk.pkkeycol1 IS NULL AND
	 * For MATCH SIMPLE:
	 *	 (fk.keycol1 IS NOT NULL [AND ...])
	 * For MATCH FULL:
	 *	 (fk.keycol1 IS NOT NULL [OR ...])
	 *
	 * We attach COLLATE clauses to the operators when comparing columns
	 * that have different collations.
	 *----------
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>fkattname</name></expr></argument>,
					 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"%sfk.%s"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>fkattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>pkrelname</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>fkrelname</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fk_only</name> <operator>=</operator> <ternary><condition><expr><name><name>fk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
		<expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><name>pk_only</name> <operator>=</operator> <ternary><condition><expr><name><name>pk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
		<expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
					 <argument><expr><literal type="string">" FROM %s%s fk LEFT OUTER JOIN %s%s pk ON"</literal></expr></argument>,
					 <argument><expr><name>fk_only</name></expr></argument>, <argument><expr><name>fkrelname</name></expr></argument>, <argument><expr><name>pk_only</name></expr></argument>, <argument><expr><name>pkrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>pkattname</name></expr></argument>, <argument><expr><literal type="string">"pk."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>fkattname</name></expr></argument>, <argument><expr><literal type="string">"fk."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">"("</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>pkattname</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>,
					 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>fkattname</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>,
					 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ri_GenerateQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>,
						<argument><expr><name>pkattname</name></expr></argument>, <argument><expr><name>pk_type</name></expr></argument>,
						<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pf_eq_oprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						<argument><expr><name>fkattname</name></expr></argument>, <argument><expr><name>fk_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pk_coll</name> <operator>!=</operator> <name>fk_coll</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ri_GenerateQualCollation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * It's sufficient to test any one pk attribute for null to detect a join
	 * failure.
	 */</comment>
	<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>pkattname</name></expr></argument>, <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">") WHERE pk.%s IS NULL AND ("</literal></expr></argument>, <argument><expr><name>pkattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>fkattname</name></expr></argument>, <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
						 <argument><expr><literal type="string">"%sfk.%s IS NOT NULL"</literal></expr></argument>,
						 <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>fkattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>FKCONSTR_MATCH_SIMPLE</name></expr>:</case>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">" AND "</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>FKCONSTR_MATCH_FULL</name></expr>:</case>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">" OR "</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Temporarily increase work_mem so that the check query can be executed
	 * more efficiently.  It seems okay to do this because the query is simple
	 * enough to not use a multiple of work_mem, and one typically would not
	 * have many large foreign-key validations happening concurrently.  So
	 * this seems to meet the criteria for being considered a "maintenance"
	 * operation, and accordingly we use maintenance_work_mem.
	 *
	 * We use the equivalent of a function SET option to allow the setting to
	 * persist for exactly the duration of the check query.  guc.c also takes
	 * care of undoing the setting on error.
	 */</comment>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>workmembuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workmembuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>maintenance_work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><name>workmembuf</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
							 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Generate the plan.  We don't need to cache it, and there are no
	 * arguments to the plan.
	 */</comment>
	<expr_stmt><expr><name>qplan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>qplan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare returned %s for %s"</literal></expr></argument>,
			 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Run the plan.  For safety we force a current snapshot to be used. (In
	 * transaction-snapshot mode, this arguably violates transaction isolation
	 * rules, but we really haven't got much choice.) We don't need to
	 * register the snapshot, because SPI_execute_snapshot will see to it. We
	 * need at most one tuple returned, so pass limit = 1.
	 */</comment>
	<expr_stmt><expr><name>spi_result</name> <operator>=</operator> <call><name>SPI_execute_snapshot</name><argument_list>(<argument><expr><name>qplan</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>InvalidSnapshot</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check result */</comment>
	<if_stmt><if>if <condition>(<expr><name>spi_result</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute_snapshot returned %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>spi_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Did we find a tuple violating the constraint? */</comment>
	<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RI_ConstraintInfo</name></type> <name>fake_riinfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
						  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The columns to look at in the result tuple are 1..N, not whatever
		 * they are in the fk_rel.  Hack up riinfo so that the subroutines
		 * called here will behave properly.
		 *
		 * In addition to this, we have to pass the correct tupdesc to
		 * ri_ReportViolation, overriding its normal habit of using the pk_rel
		 * or fk_rel's tupdesc.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fake_riinfo</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RI_ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fake_riinfo</name><operator>.</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fake_riinfo</name><operator>.</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

		<comment type="block">/*
		 * If it's MATCH FULL, and there are any nulls in the FK keys,
		 * complain about that rather than the lack of a match.  MATCH FULL
		 * disallows partially-null FK rows.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>fake_riinfo</name><operator>.</operator><name>confmatchtype</name></name> <operator>==</operator> <name>FKCONSTR_MATCH_FULL</name> <operator>&amp;&amp;</operator>
			<call><name>ri_NullCheck</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>slot</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fake_riinfo</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RI_KEYS_NONE_NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FOREIGN_KEY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insert or update on table \"%s\" violates foreign key constraint \"%s\""</literal></expr></argument>,
							<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
							<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>fake_riinfo</name><operator>.</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"MATCH FULL does not allow mixing of null and nonnull key values."</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>,
										<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>fake_riinfo</name><operator>.</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * We tell ri_ReportViolation we were doing the RI_PLAN_CHECK_LOOKUPPK
		 * query, which isn't true, but will cause it to use
		 * fake_riinfo.fk_attnums as we need.
		 */</comment>
		<expr_stmt><expr><call><name>ri_ReportViolation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fake_riinfo</name></expr></argument>,
						   <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>,
						   <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
						   <argument><expr><name>RI_PLAN_CHECK_LOOKUPPK</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ExecDropSingleTupleTableSlot</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Restore work_mem.
	 */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * RI_PartitionRemove_Check -
 *
 * Verify no referencing values exist, when a partition is detached on
 * the referenced side of a foreign key constraint.
 */</comment>
<function><type><name>void</name></type>
<name>RI_PartitionRemove_Check</name><parameter_list>(<parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>querybuf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>constraintDef</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fkrelname</name><index>[<expr><name>MAX_QUOTED_REL_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>pkattname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>fkattname</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name> <operator>+</operator> <literal type="number">3</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>fk_only</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_nestlevel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>workmembuf</name><index>[<expr><literal type="number">32</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spi_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>qplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_FetchConstraintInfo</name><argument_list>(<argument><expr><name>trigger</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We don't check permissions before displaying the error message, on the
	 * assumption that the user detaching the partition must have enough
	 * privileges to examine the table contents anyhow.
	 */</comment>

	<comment type="block">/*----------
	 * The query string built is:
	 *  SELECT fk.keycols FROM [ONLY] relname fk
	 *    JOIN pkrelname pk
	 *    ON (pk.pkkeycol1=fk.keycol1 [AND ...])
	 *    WHERE (&lt;partition constraint&gt;) AND
	 * For MATCH SIMPLE:
	 *   (fk.keycol1 IS NOT NULL [AND ...])
	 * For MATCH FULL:
	 *   (fk.keycol1 IS NOT NULL [OR ...])
	 *
	 * We attach COLLATE clauses to the operators when comparing columns
	 * that have different collations.
	 *----------
	 */</comment>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"SELECT "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>fkattname</name></expr></argument>,
					 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">"%sfk.%s"</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>fkattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">", "</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>pkrelname</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>quoteRelationName</name><argument_list>(<argument><expr><name>fkrelname</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fk_only</name> <operator>=</operator> <ternary><condition><expr><name><name>fk_rel</name><operator>-&gt;</operator><name>rd_rel</name><operator>-&gt;</operator><name>relkind</name></name> <operator>==</operator> <name>RELKIND_PARTITIONED_TABLE</name></expr> ?</condition><then>
		<expr><literal type="string">""</literal></expr> </then><else>: <expr><literal type="string">"ONLY "</literal></expr></else></ternary></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
					 <argument><expr><literal type="string">" FROM %s%s fk JOIN %s pk ON"</literal></expr></argument>,
					 <argument><expr><name>fk_only</name></expr></argument>, <argument><expr><name>fkrelname</name></expr></argument>, <argument><expr><name>pkrelname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>pkattname</name></expr></argument>, <argument><expr><literal type="string">"pk."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>fkattname</name></expr></argument>, <argument><expr><literal type="string">"fk."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">"("</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_type</name> <init>= <expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>pk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>fk_coll</name> <init>= <expr><call><name>RIAttCollation</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>pkattname</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>,
					 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>fkattname</name> <operator>+</operator> <literal type="number">3</literal></expr></argument>,
					 <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ri_GenerateQual</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>sep</name></expr></argument>,
						<argument><expr><name>pkattname</name></expr></argument>, <argument><expr><name>pk_type</name></expr></argument>,
						<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pf_eq_oprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
						<argument><expr><name>fkattname</name></expr></argument>, <argument><expr><name>fk_type</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>pk_coll</name> <operator>!=</operator> <name>fk_coll</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ri_GenerateQualCollation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><name>pk_coll</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">"AND"</literal></expr>;</expr_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Start the WHERE clause with the partition constraint (except if this is
	 * the default partition and there's no other partition, because the
	 * partition constraint is the empty string in that case.)
	 */</comment>
	<expr_stmt><expr><name>constraintDef</name> <operator>=</operator> <call><name>pg_get_partconstrdef_string</name><argument_list>(<argument><expr><call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"pk"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>constraintDef</name> <operator>&amp;&amp;</operator> <name><name>constraintDef</name><index>[<expr><literal type="number">0</literal></expr>]</index></name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">") WHERE %s AND ("</literal></expr></argument>,
						 <argument><expr><name>constraintDef</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="string">") WHERE ("</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">""</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>fkattname</name></expr></argument>, <argument><expr><call><name>RIAttName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>,
						 <argument><expr><literal type="string">"%sfk.%s IS NOT NULL"</literal></expr></argument>,
						 <argument><expr><name>sep</name></expr></argument>, <argument><expr><name>fkattname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<switch>switch <condition>(<expr><name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>FKCONSTR_MATCH_SIMPLE</name></expr>:</case>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">" AND "</literal></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>FKCONSTR_MATCH_FULL</name></expr>:</case>
				<expr_stmt><expr><name>sep</name> <operator>=</operator> <literal type="string">" OR "</literal></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>querybuf</name></expr></argument>, <argument><expr><literal type="char">')'</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Temporarily increase work_mem so that the check query can be executed
	 * more efficiently.  It seems okay to do this because the query is simple
	 * enough to not use a multiple of work_mem, and one typically would not
	 * have many large foreign-key validations happening concurrently.  So
	 * this seems to meet the criteria for being considered a "maintenance"
	 * operation, and accordingly we use maintenance_work_mem.
	 *
	 * We use the equivalent of a function SET option to allow the setting to
	 * persist for exactly the duration of the check query.  guc.c also takes
	 * care of undoing the setting on error.
	 */</comment>
	<expr_stmt><expr><name>save_nestlevel</name> <operator>=</operator> <call><name>NewGUCNestLevel</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>snprintf</name><argument_list>(<argument><expr><name>workmembuf</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>workmembuf</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>maintenance_work_mem</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>(</operator><name>void</name><operator>)</operator> <call><name>set_config_option</name><argument_list>(<argument><expr><literal type="string">"work_mem"</literal></expr></argument>, <argument><expr><name>workmembuf</name></expr></argument>,
							 <argument><expr><name>PGC_USERSET</name></expr></argument>, <argument><expr><name>PGC_S_SESSION</name></expr></argument>,
							 <argument><expr><name>GUC_ACTION_SAVE</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_connect</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_CONNECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_connect failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Generate the plan.  We don't need to cache it, and there are no
	 * arguments to the plan.
	 */</comment>
	<expr_stmt><expr><name>qplan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>qplan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare returned %s for %s"</literal></expr></argument>,
			 <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name><name>querybuf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Run the plan.  For safety we force a current snapshot to be used. (In
	 * transaction-snapshot mode, this arguably violates transaction isolation
	 * rules, but we really haven't got much choice.) We don't need to
	 * register the snapshot, because SPI_execute_snapshot will see to it. We
	 * need at most one tuple returned, so pass limit = 1.
	 */</comment>
	<expr_stmt><expr><name>spi_result</name> <operator>=</operator> <call><name>SPI_execute_snapshot</name><argument_list>(<argument><expr><name>qplan</name></expr></argument>,
									  <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>,
									  <argument><expr><call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr></argument>,
									  <argument><expr><name>InvalidSnapshot</name></expr></argument>,
									  <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check result */</comment>
	<if_stmt><if>if <condition>(<expr><name>spi_result</name> <operator>!=</operator> <name>SPI_OK_SELECT</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute_snapshot returned %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>spi_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Did we find a tuple that would violate the constraint? */</comment>
	<if_stmt><if>if <condition>(<expr><name>SPI_processed</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tuple</name> <init>= <expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>vals</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>TupleDesc</name></type>	<name>tupdesc</name> <init>= <expr><name><name>SPI_tuptable</name><operator>-&gt;</operator><name>tupdesc</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>RI_ConstraintInfo</name></type> <name>fake_riinfo</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>MakeSingleTupleTableSlot</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>TTSOpsVirtual</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>heap_deform_tuple</name><argument_list>(<argument><expr><name>tuple</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>,
						  <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_values</name></name></expr></argument>, <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>tts_isnull</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ExecStoreVirtualTuple</name><argument_list>(<argument><expr><name>slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * The columns to look at in the result tuple are 1..N, not whatever
		 * they are in the fk_rel.  Hack up riinfo so that ri_ReportViolation
		 * will behave properly.
		 *
		 * In addition to this, we have to pass the correct tupdesc to
		 * ri_ReportViolation, overriding its normal habit of using the pk_rel
		 * or fk_rel's tupdesc.
		 */</comment>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fake_riinfo</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>RI_ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>fake_riinfo</name><operator>.</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>fake_riinfo</name><operator>.</operator><name>pk_attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>i</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>

		<expr_stmt><expr><call><name>ri_ReportViolation</name><argument_list>(<argument><expr><operator>&amp;</operator><name>fake_riinfo</name></expr></argument>, <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>,
						   <argument><expr><name>slot</name></expr></argument>, <argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>SPI_finish</name><argument_list>()</argument_list></call> <operator>!=</operator> <name>SPI_OK_FINISH</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_finish failed"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Restore work_mem.
	 */</comment>
	<expr_stmt><expr><call><name>AtEOXact_GUC</name><argument_list>(<argument><expr><name>true</name></expr></argument>, <argument><expr><name>save_nestlevel</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* ----------
 * Local functions below
 * ----------
 */</comment>


<comment type="block">/*
 * quoteOneName --- safely quote a single SQL name
 *
 * buffer must be MAX_QUOTED_NAME_LEN long (includes room for \0)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>quoteOneName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Rather than trying to be smart, just always quote it. */</comment>
	<expr_stmt><expr><operator>*</operator><name>buffer</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
	<while>while <condition>(<expr><operator>*</operator><name>name</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>buffer</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><operator>*</operator><name>buffer</name><operator>++</operator> <operator>=</operator> <operator>*</operator><name>name</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<expr_stmt><expr><operator>*</operator><name>buffer</name><operator>++</operator> <operator>=</operator> <literal type="char">'"'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>buffer</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * quoteRelationName --- safely quote a fully qualified relation name
 *
 * buffer must be MAX_QUOTED_REL_NAME_LEN long (includes room for \0)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>quoteRelationName</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>buffer</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><call><name>RelationGetNamespace</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>buffer</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>buffer</name><operator>++</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>buffer</name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ri_GenerateQual --- generate a WHERE clause equating two variables
 *
 * This basically appends " sep leftop op rightop" to buf, adding casts
 * and schema qualification as needed to ensure that the parser will select
 * the operator we specify.  leftop and rightop should be parenthesized
 * if they aren't variables or parameters.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ri_GenerateQual</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>sep</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>leftop</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>leftoptype</name></decl></parameter>,
				<parameter><decl><type><name>Oid</name></type> <name>opoid</name></decl></parameter>,
				<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>rightop</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>rightoptype</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" %s "</literal></expr></argument>, <argument><expr><name>sep</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>generate_operator_clause</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>leftop</name></expr></argument>, <argument><expr><name>leftoptype</name></expr></argument>, <argument><expr><name>opoid</name></expr></argument>,
							 <argument><expr><name>rightop</name></expr></argument>, <argument><expr><name>rightoptype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * ri_GenerateQualCollation --- add a COLLATE spec to a WHERE clause
 *
 * At present, we intentionally do not use this function for RI queries that
 * compare a variable to a $n parameter.  Since parameter symbols always have
 * default collation, the effect will be to use the variable's collation.
 * Now that is only strictly correct when testing the referenced column, since
 * the SQL standard specifies that RI comparisons should use the referenced
 * column's collation.  However, so long as all collations have the same
 * notion of equality (which they do, because texteq reduces to bitwise
 * equality), there's no visible semantic impact from using the referencing
 * column's collation when testing it, and this is a good thing to do because
 * it lets us use a normal index on the referencing column.  However, we do
 * have to use this function when directly comparing the referencing and
 * referenced columns, if they are of different collations; else the parser
 * will fail to resolve the collation to use.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ri_GenerateQualCollation</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collation</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_collation</name></type> <name>colltup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>collname</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>onename</name><index>[<expr><name>MAX_QUOTED_NAME_LEN</name></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/* Nothing to do if it's a noncollatable data type */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>tp</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>COLLOID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for collation %u"</literal></expr></argument>, <argument><expr><name>collation</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>colltup</name> <operator>=</operator> <operator>(</operator><name>Form_pg_collation</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>collname</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>colltup</name><operator>-&gt;</operator><name>collname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We qualify the name always, for simplicity and to ensure the query is
	 * not search-path-dependent.
	 */</comment>
	<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>onename</name></expr></argument>, <argument><expr><call><name>get_namespace_name</name><argument_list>(<argument><expr><name><name>colltup</name><operator>-&gt;</operator><name>collnamespace</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">" COLLATE %s"</literal></expr></argument>, <argument><expr><name>onename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>quoteOneName</name><argument_list>(<argument><expr><name>onename</name></expr></argument>, <argument><expr><name>collname</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="string">".%s"</literal></expr></argument>, <argument><expr><name>onename</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * ri_BuildQueryKey -
 *
 *	Construct a hashtable key for a prepared SPI plan of an FK constraint.
 *
 *		key: output argument, *key is filled in based on the other arguments
 *		riinfo: info from pg_constraint entry
 *		constr_queryno: an internal number identifying the query type
 *			(see RI_PLAN_XXX constants at head of file)
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ri_BuildQueryKey</name><parameter_list>(<parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>,
				 <parameter><decl><type><name>int32</name></type> <name>constr_queryno</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * We assume struct RI_QueryKey contains no padding bytes, else we'd need
	 * to use memset to clear them.
	 */</comment>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>constr_id</name></name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>constraint_id</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>-&gt;</operator><name>constr_queryno</name></name> <operator>=</operator> <name>constr_queryno</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Check that RI trigger function was called in expected context
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ri_CheckTrigger</name><parameter_list>(<parameter><decl><type><name>FunctionCallInfo</name></type> <name>fcinfo</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>funcname</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>tgkind</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TriggerData</name> <modifier>*</modifier></type><name>trigdata</name> <init>= <expr><operator>(</operator><name>TriggerData</name> <operator>*</operator><operator>)</operator> <name><name>fcinfo</name><operator>-&gt;</operator><name>context</name></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>CALLED_AS_TRIGGER</name><argument_list>(<argument><expr><name>fcinfo</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" was not called by trigger manager"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check proper event
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_AFTER</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call> <operator>||</operator>
		<operator>!</operator><call><name>TRIGGER_FIRED_FOR_ROW</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" must be fired AFTER ROW"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>tgkind</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>RI_TRIGTYPE_INSERT</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_BY_INSERT</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" must be fired for INSERT"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RI_TRIGTYPE_UPDATE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_BY_UPDATE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" must be fired for UPDATE"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
		<case>case <expr><name>RI_TRIGTYPE_DELETE</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TRIGGER_FIRED_BY_DELETE</name><argument_list>(<argument><expr><name><name>trigdata</name><operator>-&gt;</operator><name>tg_event</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_E_R_I_E_TRIGGER_PROTOCOL_VIOLATED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"function \"%s\" must be fired for DELETE"</literal></expr></argument>, <argument><expr><name>funcname</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>


<comment type="block">/*
 * Fetch the RI_ConstraintInfo struct for the trigger's FK constraint.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type>
<name>ri_FetchConstraintInfo</name><parameter_list>(<parameter><decl><type><name>Trigger</name> <modifier>*</modifier></type><name>trigger</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>trig_rel</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rel_is_pk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>constraintOid</name> <init>= <expr><name><name>trigger</name><operator>-&gt;</operator><name>tgconstraint</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Check that the FK constraint's OID is available; it might not be if
	 * we've been invoked via an ordinary trigger or an old-style "constraint
	 * trigger".
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_OBJECT_DEFINITION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"no pg_constraint entry for trigger \"%s\" on table \"%s\""</literal></expr></argument>,
						<argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>trig_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Remove this referential integrity trigger and its mates, then do ALTER TABLE ADD CONSTRAINT."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Find or create a hashtable entry for the constraint */</comment>
	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <call><name>ri_LoadConstraintInfo</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Do some easy cross-checks against the trigger call data */</comment>
	<if_stmt><if>if <condition>(<expr><name>rel_is_pk</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_relid</name></name> <operator>!=</operator> <name><name>trigger</name><operator>-&gt;</operator><name>tgconstrrelid</name></name> <operator>||</operator>
			<name><name>riinfo</name><operator>-&gt;</operator><name>pk_relid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>trig_rel</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong pg_constraint entry for trigger \"%s\" on table \"%s\""</literal></expr></argument>,
				 <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>trig_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_relid</name></name> <operator>!=</operator> <call><name>RelationGetRelid</name><argument_list>(<argument><expr><name>trig_rel</name></expr></argument>)</argument_list></call> <operator>||</operator>
			<name><name>riinfo</name><operator>-&gt;</operator><name>pk_relid</name></name> <operator>!=</operator> <name><name>trigger</name><operator>-&gt;</operator><name>tgconstrrelid</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"wrong pg_constraint entry for trigger \"%s\" on table \"%s\""</literal></expr></argument>,
				 <argument><expr><name><name>trigger</name><operator>-&gt;</operator><name>tgname</name></name></expr></argument>, <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>trig_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name> <operator>!=</operator> <name>FKCONSTR_MATCH_FULL</name> <operator>&amp;&amp;</operator>
		<name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name> <operator>!=</operator> <name>FKCONSTR_MATCH_PARTIAL</name> <operator>&amp;&amp;</operator>
		<name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name> <operator>!=</operator> <name>FKCONSTR_MATCH_SIMPLE</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized confmatchtype: %d"</literal></expr></argument>,
			 <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name> <operator>==</operator> <name>FKCONSTR_MATCH_PARTIAL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"MATCH PARTIAL not yet implemented"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>riinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Fetch or create the RI_ConstraintInfo struct for an FK constraint.
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type>
<name>ri_LoadConstraintInfo</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>constraintOid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>HeapTuple</name></type>	<name>tup</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_constraint</name></type> <name>conForm</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On the first call initialize the hashtable
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ri_constraint_cache</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ri_InitHashTables</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find or create a hash entry.  If we find a valid one, just return it.
	 */</comment>
	<expr_stmt><expr><name>riinfo</name> <operator>=</operator> <operator>(</operator><name>RI_ConstraintInfo</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ri_constraint_cache</name></expr></argument>,
											   <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>constraintOid</name></expr></argument>,
											   <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>riinfo</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name><name>riinfo</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>riinfo</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Fetch the pg_constraint row so we can fill in the entry.
	 */</comment>
	<expr_stmt><expr><name>tup</name> <operator>=</operator> <call><name>SearchSysCache1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>, <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"cache lookup failed for constraint %u"</literal></expr></argument>, <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>conForm</name> <operator>=</operator> <operator>(</operator><name>Form_pg_constraint</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>conForm</name><operator>-&gt;</operator><name>contype</name></name> <operator>!=</operator> <name>CONSTRAINT_FOREIGN</name></expr>)</condition><block type="pseudo"><block_content> <comment type="block">/* should not happen */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"constraint %u is not a foreign key constraint"</literal></expr></argument>,
			 <argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* And extract data */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>constraint_id</name></name> <operator>==</operator> <name>constraintOid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>riinfo</name><operator>-&gt;</operator><name>oidHashValue</name></name> <operator>=</operator> <call><name>GetSysCacheHashValue1</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
												 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>constraintOid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>riinfo</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>conForm</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NameData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_relid</name></name> <operator>=</operator> <name><name>conForm</name><operator>-&gt;</operator><name>confrelid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_relid</name></name> <operator>=</operator> <name><name>conForm</name><operator>-&gt;</operator><name>conrelid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>riinfo</name><operator>-&gt;</operator><name>confupdtype</name></name> <operator>=</operator> <name><name>conForm</name><operator>-&gt;</operator><name>confupdtype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>riinfo</name><operator>-&gt;</operator><name>confdeltype</name></name> <operator>=</operator> <name><name>conForm</name><operator>-&gt;</operator><name>confdeltype</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>riinfo</name><operator>-&gt;</operator><name>confmatchtype</name></name> <operator>=</operator> <name><name>conForm</name><operator>-&gt;</operator><name>confmatchtype</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>DeconstructFkConstraintRow</name><argument_list>(<argument><expr><name>tup</name></expr></argument>,
							   <argument><expr><operator>&amp;</operator><name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>,
							   <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name></name></expr></argument>,
							   <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name></name></expr></argument>,
							   <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pf_eq_oprs</name></name></expr></argument>,
							   <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>pp_eq_oprs</name></name></expr></argument>,
							   <argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>ff_eq_oprs</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseSysCache</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * For efficient processing of invalidation messages below, we keep a
	 * doubly-linked list, and a count, of all currently valid entries.
	 */</comment>
	<expr_stmt><expr><call><name>dlist_push_tail</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ri_constraint_cache_valid_list</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>riinfo</name><operator>-&gt;</operator><name>valid_link</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>ri_constraint_cache_valid_count</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>riinfo</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

	<return>return <expr><name>riinfo</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Callback for pg_constraint inval events
 *
 * While most syscache callbacks just flush all their entries, pg_constraint
 * gets enough update traffic that it's probably worth being smarter.
 * Invalidate any ri_constraint_cache entry associated with the syscache
 * entry with the specified hash value, or all entries if hashvalue == 0.
 *
 * Note: at the time a cache invalidation message is processed there may be
 * active references to the cache.  Because of this we never remove entries
 * from the cache, but only mark them invalid, which is harmless to active
 * uses.  (Any query using an entry should hold a lock sufficient to keep that
 * data from changing under it --- but we may get cache flushes anyway.)
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>InvalidateConstraintCacheCallBack</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>arg</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>cacheid</name></decl></parameter>, <parameter><decl><type><name>uint32</name></type> <name>hashvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dlist_mutable_iter</name></type> <name>iter</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>ri_constraint_cache</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the list of currently valid entries gets excessively large, we mark
	 * them all invalid so we can empty the list.  This arrangement avoids
	 * O(N^2) behavior in situations where a session touches many foreign keys
	 * and also does many ALTER TABLEs, such as a restore from pg_dump.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>ri_constraint_cache_valid_count</name> <operator>&gt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hashvalue</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>			<comment type="block">/* pretend it's a cache reset */</comment>

	<macro><name>dlist_foreach_modify</name><argument_list>(<argument>iter</argument>, <argument>&amp;ri_constraint_cache_valid_list</argument>)</argument_list></macro>
	<block>{<block_content>
		<decl_stmt><decl><type><name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name> <init>= <expr><call><name>dlist_container</name><argument_list>(<argument><expr><name>RI_ConstraintInfo</name></expr></argument>,
													<argument><expr><name>valid_link</name></expr></argument>, <argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>hashvalue</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>oidHashValue</name></name> <operator>==</operator> <name>hashvalue</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>riinfo</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
			<comment type="block">/* Remove invalidated entries from the list, too */</comment>
			<expr_stmt><expr><call><name>dlist_delete</name><argument_list>(<argument><expr><name><name>iter</name><operator>.</operator><name>cur</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>ri_constraint_cache_valid_count</name><operator>--</operator></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block>
</block_content>}</block></function>


<comment type="block">/*
 * Prepare execution plan for a query to enforce an RI restriction
 *
 * If cache_plan is true, the plan is saved into our plan hashtable
 * so that we don't need to plan it again.
 */</comment>
<function><type><specifier>static</specifier> <name>SPIPlanPtr</name></type>
<name>ri_PlanCheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>querystr</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nargs</name></decl></parameter>, <parameter><decl><type><name>Oid</name> <modifier>*</modifier></type><name>argtypes</name></decl></parameter>,
			 <parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>qkey</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>,
			 <parameter><decl><type><name>bool</name></type> <name>cache_plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>qplan</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>query_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use the query type code to determine whether the query is run against
	 * the PK or FK table; we'll do the check as that table's owner
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qkey</name><operator>-&gt;</operator><name>constr_queryno</name></name> <operator>&lt;=</operator> <name>RI_PLAN_LAST_ON_PK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>query_rel</name> <operator>=</operator> <name>pk_rel</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>query_rel</name> <operator>=</operator> <name>fk_rel</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Switch to proper UID to perform check as */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>query_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relowner</name></expr></argument>,
						   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name> <operator>|</operator>
						   <name>SECURITY_NOFORCE_RLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Create the plan */</comment>
	<expr_stmt><expr><name>qplan</name> <operator>=</operator> <call><name>SPI_prepare</name><argument_list>(<argument><expr><name>querystr</name></expr></argument>, <argument><expr><name>nargs</name></expr></argument>, <argument><expr><name>argtypes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>qplan</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_prepare returned %s for %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>SPI_result</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>querystr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Restore UID and security context */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Save the plan if requested */</comment>
	<if_stmt><if>if <condition>(<expr><name>cache_plan</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>SPI_keepplan</name><argument_list>(<argument><expr><name>qplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ri_HashPreparedPlan</name><argument_list>(<argument><expr><name>qkey</name></expr></argument>, <argument><expr><name>qplan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>qplan</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a query to enforce an RI restriction
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ri_PerformCheck</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>,
				<parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>qkey</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>qplan</name></decl></parameter>,
				<parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>,
				<parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>,
				<parameter><decl><type><name>bool</name></type> <name>detectNewRows</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>expect_OK</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Relation</name></type>	<name>query_rel</name></decl>,
				<decl><type ref="prev"/><name>source_rel</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>source_is_pk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>test_snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>crosscheck_snapshot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>limit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>spi_result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>save_userid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>save_sec_context</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name><name>vals</name><index>[<expr><name>RI_MAX_NUMKEYS</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>nulls</name><index>[<expr><name>RI_MAX_NUMKEYS</name> <operator>*</operator> <literal type="number">2</literal></expr>]</index></name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Use the query type code to determine whether the query is run against
	 * the PK or FK table; we'll do the check as that table's owner
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qkey</name><operator>-&gt;</operator><name>constr_queryno</name></name> <operator>&lt;=</operator> <name>RI_PLAN_LAST_ON_PK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>query_rel</name> <operator>=</operator> <name>pk_rel</name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>query_rel</name> <operator>=</operator> <name>fk_rel</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * The values for the query are taken from the table on which the trigger
	 * is called - it is normally the other one with respect to query_rel. An
	 * exception is ri_Check_Pk_Match(), which uses the PK table for both (and
	 * sets queryno to RI_PLAN_CHECK_LOOKUPPK_FROM_PK).  We might eventually
	 * need some less klugy way to determine this.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qkey</name><operator>-&gt;</operator><name>constr_queryno</name></name> <operator>==</operator> <name>RI_PLAN_CHECK_LOOKUPPK</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>source_rel</name> <operator>=</operator> <name>fk_rel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>source_is_pk</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>source_rel</name> <operator>=</operator> <name>pk_rel</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>source_is_pk</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* Extract the parameters to be passed into the query */</comment>
	<if_stmt><if>if <condition>(<expr><name>newslot</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ri_ExtractValues</name><argument_list>(<argument><expr><name>source_rel</name></expr></argument>, <argument><expr><name>newslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>source_is_pk</name></expr></argument>,
						 <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oldslot</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ri_ExtractValues</name><argument_list>(<argument><expr><name>source_rel</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>source_is_pk</name></expr></argument>,
							 <argument><expr><name>vals</name> <operator>+</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>, <argument><expr><name>nulls</name> <operator>+</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>ri_ExtractValues</name><argument_list>(<argument><expr><name>source_rel</name></expr></argument>, <argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name>riinfo</name></expr></argument>, <argument><expr><name>source_is_pk</name></expr></argument>,
						 <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * In READ COMMITTED mode, we just need to use an up-to-date regular
	 * snapshot, and we will see all rows that could be interesting. But in
	 * transaction-snapshot mode, we can't change the transaction snapshot. If
	 * the caller passes detectNewRows == false then it's okay to do the query
	 * with the transaction snapshot; otherwise we use a current snapshot, and
	 * tell the executor to error out if it finds any rows under the current
	 * snapshot that wouldn't be visible per the transaction snapshot.  Note
	 * that SPI_execute_snapshot will register the snapshots, so we don't need
	 * to bother here.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IsolationUsesXactSnapshot</name><argument_list>()</argument_list></call> <operator>&amp;&amp;</operator> <name>detectNewRows</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CommandCounterIncrement</name><argument_list>()</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* be sure all my own work is visible */</comment>
		<expr_stmt><expr><name>test_snapshot</name> <operator>=</operator> <call><name>GetLatestSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>crosscheck_snapshot</name> <operator>=</operator> <call><name>GetTransactionSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/* the default SPI behavior is okay */</comment>
		<expr_stmt><expr><name>test_snapshot</name> <operator>=</operator> <name>InvalidSnapshot</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>crosscheck_snapshot</name> <operator>=</operator> <name>InvalidSnapshot</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * If this is a select query (e.g., for a 'no action' or 'restrict'
	 * trigger), we only need to see if there is a single row in the table,
	 * matching the key.  Otherwise, limit = 0 - because we want the query to
	 * affect ALL the matching rows.
	 */</comment>
	<expr_stmt><expr><name>limit</name> <operator>=</operator> <ternary><condition><expr><operator>(</operator><name>expect_OK</name> <operator>==</operator> <name>SPI_OK_SELECT</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr>;</expr_stmt>

	<comment type="block">/* Switch to proper UID to perform check as */</comment>
	<expr_stmt><expr><call><name>GetUserIdAndSecContext</name><argument_list>(<argument><expr><operator>&amp;</operator><name>save_userid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><call><name>RelationGetForm</name><argument_list>(<argument><expr><name>query_rel</name></expr></argument>)</argument_list></call><operator>-&gt;</operator><name>relowner</name></expr></argument>,
						   <argument><expr><name>save_sec_context</name> <operator>|</operator> <name>SECURITY_LOCAL_USERID_CHANGE</name> <operator>|</operator>
						   <name>SECURITY_NOFORCE_RLS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Finally we can run the query. */</comment>
	<expr_stmt><expr><name>spi_result</name> <operator>=</operator> <call><name>SPI_execute_snapshot</name><argument_list>(<argument><expr><name>qplan</name></expr></argument>,
									  <argument><expr><name>vals</name></expr></argument>, <argument><expr><name>nulls</name></expr></argument>,
									  <argument><expr><name>test_snapshot</name></expr></argument>, <argument><expr><name>crosscheck_snapshot</name></expr></argument>,
									  <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>limit</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Restore UID and security context */</comment>
	<expr_stmt><expr><call><name>SetUserIdAndSecContext</name><argument_list>(<argument><expr><name>save_userid</name></expr></argument>, <argument><expr><name>save_sec_context</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Check result */</comment>
	<if_stmt><if>if <condition>(<expr><name>spi_result</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"SPI_execute_snapshot returned %s"</literal></expr></argument>, <argument><expr><call><name>SPI_result_code_string</name><argument_list>(<argument><expr><name>spi_result</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>expect_OK</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>spi_result</name> <operator>!=</operator> <name>expect_OK</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INTERNAL_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"referential integrity query on \"%s\" from constraint \"%s\" on \"%s\" gave unexpected result"</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"This is most likely due to a rule having rewritten the query."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* XXX wouldn't it be clearer to do this part at the caller? */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>qkey</name><operator>-&gt;</operator><name>constr_queryno</name></name> <operator>!=</operator> <name>RI_PLAN_CHECK_LOOKUPPK_FROM_PK</name> <operator>&amp;&amp;</operator>
		<name>expect_OK</name> <operator>==</operator> <name>SPI_OK_SELECT</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name>SPI_processed</name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator> <operator>==</operator> <operator>(</operator><name><name>qkey</name><operator>-&gt;</operator><name>constr_queryno</name></name> <operator>==</operator> <name>RI_PLAN_CHECK_LOOKUPPK</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ri_ReportViolation</name><argument_list>(<argument><expr><name>riinfo</name></expr></argument>,
						   <argument><expr><name>pk_rel</name></expr></argument>, <argument><expr><name>fk_rel</name></expr></argument>,
						   <argument><expr><ternary><condition><expr><name>newslot</name></expr> ?</condition><then> <expr><name>newslot</name></expr> </then><else>: <expr><name>oldslot</name></expr></else></ternary></expr></argument>,
						   <argument><expr><name>NULL</name></expr></argument>,
						   <argument><expr><name><name>qkey</name><operator>-&gt;</operator><name>constr_queryno</name></name></expr></argument>, <argument><expr><name>false</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>SPI_processed</name> <operator>!=</operator> <literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Extract fields from a tuple into Datum/nulls arrays
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ri_ExtractValues</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
				 <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rel_is_pk</name></decl></parameter>,
				 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>vals</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>nulls</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rel_is_pk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name><name>vals</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>nulls</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <ternary><condition><expr><name>isnull</name></expr> ?</condition><then> <expr><literal type="char">'n'</literal></expr> </then><else>: <expr><literal type="char">' '</literal></expr></else></ternary></expr>;</expr_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Produce an error report
 *
 * If the failed constraint was on insert/update to the FK table,
 * we want the key names and values extracted from there, and the error
 * message to look like 'key blah is not present in PK'.
 * Otherwise, the attr names and values come from the PK table and the
 * message looks like 'key blah is still referenced from FK'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ri_ReportViolation</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>,
				   <parameter><decl><type><name>Relation</name></type> <name>pk_rel</name></decl></parameter>, <parameter><decl><type><name>Relation</name></type> <name>fk_rel</name></decl></parameter>,
				   <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>violatorslot</name></decl></parameter>, <parameter><decl><type><name>TupleDesc</name></type> <name>tupdesc</name></decl></parameter>,
				   <parameter><decl><type><name>int</name></type> <name>queryno</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>partgone</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>key_names</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>key_values</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>onfk</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>rel_oid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AclResult</name></type>	<name>aclresult</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>has_perm</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/*
	 * Determine which relation to complain about.  If tupdesc wasn't passed
	 * by caller, assume the violator tuple came from there.
	 */</comment>
	<expr_stmt><expr><name>onfk</name> <operator>=</operator> <operator>(</operator><name>queryno</name> <operator>==</operator> <name>RI_PLAN_CHECK_LOOKUPPK</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>onfk</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel_oid</name> <operator>=</operator> <name><name>fk_rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>fk_rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>rel_oid</name> <operator>=</operator> <name><name>pk_rel</name><operator>-&gt;</operator><name>rd_id</name></name></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>tupdesc</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>tupdesc</name> <operator>=</operator> <name><name>pk_rel</name><operator>-&gt;</operator><name>rd_att</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/*
	 * Check permissions- if the user does not have access to view the data in
	 * any of the key columns then we don't include the errdetail() below.
	 *
	 * Check if RLS is enabled on the relation first.  If so, we don't return
	 * any specifics to avoid leaking data.
	 *
	 * Check table-level permissions next and, failing that, column-level
	 * privileges.
	 *
	 * When a partition at the referenced side is being detached/dropped, we
	 * needn't check, since the user must be the table owner anyway.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>partgone</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>has_perm</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>check_enable_rls</name><argument_list>(<argument><expr><name>rel_oid</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>, <argument><expr><name>true</name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>RLS_ENABLED</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_class_aclcheck</name><argument_list>(<argument><expr><name>rel_oid</name></expr></argument>, <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Try for column-level permissions */</comment>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>aclresult</name> <operator>=</operator> <call><name>pg_attribute_aclcheck</name><argument_list>(<argument><expr><name>rel_oid</name></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>idx</name></expr>]</index></name></expr></argument>,
												  <argument><expr><call><name>GetUserId</name><argument_list>()</argument_list></call></expr></argument>,
												  <argument><expr><name>ACL_SELECT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/* No access to the key */</comment>
				<if_stmt><if>if <condition>(<expr><name>aclresult</name> <operator>!=</operator> <name>ACLCHECK_OK</name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>has_perm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>has_perm</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>has_perm</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Get printable versions of the keys involved */</comment>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_names</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_values</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>idx</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>idx</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>idx</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>fnum</name> <init>= <expr><name><name>attnums</name><index>[<expr><name>idx</name></expr>]</index></name></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name>tupdesc</name></expr></argument>, <argument><expr><name>fnum</name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>name</name></decl>,
					   <decl><type ref="prev"><modifier>*</modifier></type><name>val</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Datum</name></type>		<name>datum</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>name</name> <operator>=</operator> <call><name>NameStr</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>attname</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><name>datum</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>violatorslot</name></expr></argument>, <argument><expr><name>fnum</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>isnull</name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>Oid</name></type>			<name>foutoid</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>bool</name></type>		<name>typisvarlena</name></decl>;</decl_stmt>

				<expr_stmt><expr><call><name>getTypeOutputInfo</name><argument_list>(<argument><expr><name><name>att</name><operator>-&gt;</operator><name>atttypid</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>foutoid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>typisvarlena</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>OidOutputFunctionCall</name><argument_list>(<argument><expr><name>foutoid</name></expr></argument>, <argument><expr><name>datum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="string">"null"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<if_stmt><if>if <condition>(<expr><name>idx</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_names</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_values</name></expr></argument>, <argument><expr><literal type="string">", "</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_names</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>key_values</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>partgone</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FOREIGN_KEY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"removing partition \"%s\" violates foreign key constraint \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key (%s)=(%s) still referenced from table \"%s\"."</literal></expr></argument>,
						   <argument><expr><name><name>key_names</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>key_values</name><operator>.</operator><name>data</name></name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>onfk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FOREIGN_KEY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"insert or update on table \"%s\" violates foreign key constraint \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>has_perm</name></expr> ?</condition><then>
				 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key (%s)=(%s) is not present in table \"%s\"."</literal></expr></argument>,
						   <argument><expr><name><name>key_names</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>key_values</name><operator>.</operator><name>data</name></name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key is not present in table \"%s\"."</literal></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FOREIGN_KEY_VIOLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"update or delete on table \"%s\" violates foreign key constraint \"%s\" on table \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>pk_rel</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <ternary><condition><expr><name>has_perm</name></expr> ?</condition><then>
				 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key (%s)=(%s) is still referenced from table \"%s\"."</literal></expr></argument>,
						   <argument><expr><name><name>key_names</name><operator>.</operator><name>data</name></name></expr></argument>, <argument><expr><name><name>key_values</name><operator>.</operator><name>data</name></name></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr> </then><else>:
				 <expr><call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Key is still referenced from table \"%s\"."</literal></expr></argument>,
						   <argument><expr><call><name>RelationGetRelationName</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></else></ternary><operator>,</operator>
				 <call><name>errtableconstraint</name><argument_list>(<argument><expr><name>fk_rel</name></expr></argument>, <argument><expr><call><name>NameStr</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>conname</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ri_NullCheck -
 *
 * Determine the NULL state of all key values in a tuple
 *
 * Returns one of RI_KEYS_ALL_NULL, RI_KEYS_NONE_NULL or RI_KEYS_SOME_NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>ri_NullCheck</name><parameter_list>(<parameter><decl><type><name>TupleDesc</name></type> <name>tupDesc</name></decl></parameter>,
			 <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rel_is_pk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>allnull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>nonenull</name> <init>= <expr><name>true</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rel_is_pk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>slot_attisnull</name><argument_list>(<argument><expr><name>slot</name></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>nonenull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>allnull</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>allnull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>RI_KEYS_ALL_NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>nonenull</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>RI_KEYS_NONE_NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>RI_KEYS_SOME_NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ri_InitHashTables -
 *
 * Initialize our internal hash tables.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ri_InitHashTables</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>ctl</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>Oid</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RI_ConstraintInfo</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>ri_constraint_cache</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"RI constraint cache"</literal></expr></argument>,
									  <argument><expr><name>RI_INIT_CONSTRAINTHASHSIZE</name></expr></argument>,
									  <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Arrange to flush cache on pg_constraint changes */</comment>
	<expr_stmt><expr><call><name>CacheRegisterSyscacheCallback</name><argument_list>(<argument><expr><name>CONSTROID</name></expr></argument>,
								  <argument><expr><name>InvalidateConstraintCacheCallBack</name></expr></argument>,
								  <argument><expr><operator>(</operator><name>Datum</name><operator>)</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RI_QueryKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RI_QueryHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>ri_query_cache</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"RI query cache"</literal></expr></argument>,
								 <argument><expr><name>RI_INIT_QUERYHASHSIZE</name></expr></argument>,
								 <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RI_CompareKey</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>RI_CompareHashEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>ri_compare_cache</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"RI compare cache"</literal></expr></argument>,
								   <argument><expr><name>RI_INIT_QUERYHASHSIZE</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>ctl</name></expr></argument>, <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ri_FetchPreparedPlan -
 *
 * Lookup for a query key in our private hash table of prepared
 * and saved SPI execution plans. Return the plan if found or NULL.
 */</comment>
<function><type><specifier>static</specifier> <name>SPIPlanPtr</name></type>
<name>ri_FetchPreparedPlan</name><parameter_list>(<parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RI_QueryHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SPIPlanPtr</name></type>	<name>plan</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On the first call initialize the hashtable
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ri_query_cache</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ri_InitHashTables</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Lookup for the key
	 */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>RI_QueryHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ri_query_cache</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>,
											  <argument><expr><name>HASH_FIND</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>entry</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Check whether the plan is still valid.  If it isn't, we don't want to
	 * simply rely on plancache.c to regenerate it; rather we should start
	 * from scratch and rebuild the query text too.  This is to cover cases
	 * such as table/column renames.  We depend on the plancache machinery to
	 * detect possible invalidations, though.
	 *
	 * CAUTION: this check is only trustworthy if the caller has already
	 * locked both FK and PK rels.
	 */</comment>
	<expr_stmt><expr><name>plan</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>plan</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>plan</name> <operator>&amp;&amp;</operator> <call><name>SPI_plan_is_valid</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>plan</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise we might as well flush the cached plan now, to free a little
	 * memory space before we make a new one.
	 */</comment>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>plan</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>SPI_freeplan</name><argument_list>(<argument><expr><name>plan</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ri_HashPreparedPlan -
 *
 * Add another plan to our private SPI query plan hashtable.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>ri_HashPreparedPlan</name><parameter_list>(<parameter><decl><type><name>RI_QueryKey</name> <modifier>*</modifier></type><name>key</name></decl></parameter>, <parameter><decl><type><name>SPIPlanPtr</name></type> <name>plan</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RI_QueryHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On the first call initialize the hashtable
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ri_query_cache</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ri_InitHashTables</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add the new plan.  We might be overwriting an entry previously found
	 * invalid by ri_FetchPreparedPlan.
	 */</comment>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>RI_QueryHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ri_query_cache</name></expr></argument>,
											  <argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <name>key</name></expr></argument>,
											  <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>found</name> <operator>||</operator> <name><name>entry</name><operator>-&gt;</operator><name>plan</name></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>plan</name></name> <operator>=</operator> <name>plan</name></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/*
 * ri_KeysEqual -
 *
 * Check if all key values in OLD and NEW are equal.
 *
 * Note: at some point we might wish to redefine this as checking for
 * "IS NOT DISTINCT" rather than "=", that is, allow two nulls to be
 * considered equal.  Currently there is no need since all callers have
 * previously found at least one of the rows to contain no nulls.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ri_KeysEqual</name><parameter_list>(<parameter><decl><type><name>Relation</name></type> <name>rel</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>oldslot</name></decl></parameter>, <parameter><decl><type><name>TupleTableSlot</name> <modifier>*</modifier></type><name>newslot</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>RI_ConstraintInfo</name> <modifier>*</modifier></type><name>riinfo</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>rel_is_pk</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>int16</name> <modifier>*</modifier></type><name>attnums</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>rel_is_pk</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>pk_attnums</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>attnums</name> <operator>=</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>fk_attnums</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* XXX: could be worthwhile to fetch all necessary attrs at once */</comment>
	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>riinfo</name><operator>-&gt;</operator><name>nkeys</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>oldvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Datum</name></type>		<name>newvalue</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>isnull</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get one attribute's oldvalue. If it is NULL - they're not equal.
		 */</comment>
		<expr_stmt><expr><name>oldvalue</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>oldslot</name></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Get one attribute's newvalue. If it is NULL - they're not equal.
		 */</comment>
		<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>slot_getattr</name><argument_list>(<argument><expr><name>newslot</name></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>isnull</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>isnull</name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>rel_is_pk</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If we are looking at the PK table, then do a bytewise
			 * comparison.  We must propagate PK changes if the value is
			 * changed to one that "looks" different but would compare as
			 * equal using the equality operator.  This only makes a
			 * difference for ON UPDATE CASCADE, but for consistency we treat
			 * all changes to the PK the same.
			 */</comment>
			<decl_stmt><decl><type><name>Form_pg_attribute</name></type> <name>att</name> <init>= <expr><call><name>TupleDescAttr</name><argument_list>(<argument><expr><name><name>oldslot</name><operator>-&gt;</operator><name>tts_tupleDescriptor</name></name></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name> <operator>-</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>datum_image_eq</name><argument_list>(<argument><expr><name>oldvalue</name></expr></argument>, <argument><expr><name>newvalue</name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attbyval</name></name></expr></argument>, <argument><expr><name><name>att</name><operator>-&gt;</operator><name>attlen</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * For the FK table, compare with the appropriate equality
			 * operator.  Changes that compare equal will still satisfy the
			 * constraint after the update.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>ri_AttributesEqual</name><argument_list>(<argument><expr><name><name>riinfo</name><operator>-&gt;</operator><name>ff_eq_oprs</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><call><name>RIAttType</name><argument_list>(<argument><expr><name>rel</name></expr></argument>, <argument><expr><name><name>attnums</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>,
									<argument><expr><name>oldvalue</name></expr></argument>, <argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * ri_AttributesEqual -
 *
 * Call the appropriate equality comparison operator for two values.
 *
 * NB: we have already checked that neither value is null.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>ri_AttributesEqual</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>eq_opr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeid</name></decl></parameter>,
				   <parameter><decl><type><name>Datum</name></type> <name>oldvalue</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>newvalue</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RI_CompareHashEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>ri_HashCompareOp</name><argument_list>(<argument><expr><name>eq_opr</name></expr></argument>, <argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Do we need to cast the values? */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name><name>entry</name><operator>-&gt;</operator><name>cast_func_finfo</name><operator>.</operator><name>fn_oid</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>oldvalue</name> <operator>=</operator> <call><name>FunctionCall3</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>cast_func_finfo</name></name></expr></argument>,
								 <argument><expr><name>oldvalue</name></expr></argument>,
								 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* typmod */</comment>
								 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* implicit coercion */</comment>
		<expr_stmt><expr><name>newvalue</name> <operator>=</operator> <call><name>FunctionCall3</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>cast_func_finfo</name></name></expr></argument>,
								 <argument><expr><name>newvalue</name></expr></argument>,
								 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></argument>, <comment type="block">/* typmod */</comment>
								 <argument><expr><call><name>BoolGetDatum</name><argument_list>(<argument><expr><name>false</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* implicit coercion */</comment>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Apply the comparison operator.
	 *
	 * Note: This function is part of a call stack that determines whether an
	 * update to a row is significant enough that it needs checking or action
	 * on the other side of a foreign-key constraint.  Therefore, the
	 * comparison here would need to be done with the collation of the *other*
	 * table.  For simplicity (e.g., we might not even have the other table
	 * open), we'll just use the default collation here, which could lead to
	 * some false negatives.  All this would break if we ever allow
	 * database-wide collations to be nondeterministic.
	 */</comment>
	<return>return <expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2Coll</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>eq_opr_finfo</name></name></expr></argument>,
										  <argument><expr><name>DEFAULT_COLLATION_OID</name></expr></argument>,
										  <argument><expr><name>oldvalue</name></expr></argument>, <argument><expr><name>newvalue</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ri_HashCompareOp -
 *
 * See if we know how to compare two values, and create a new hash entry
 * if not.
 */</comment>
<function><type><specifier>static</specifier> <name>RI_CompareHashEntry</name> <modifier>*</modifier></type>
<name>ri_HashCompareOp</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>eq_opr</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>typeid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>RI_CompareKey</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>RI_CompareHashEntry</name> <modifier>*</modifier></type><name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * On the first call initialize the hashtable
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>ri_compare_cache</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ri_InitHashTables</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Find or create a hash entry.  Note we're assuming RI_CompareKey
	 * contains no struct padding.
	 */</comment>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>eq_opr</name></name> <operator>=</operator> <name>eq_opr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>typeid</name></name> <operator>=</operator> <name>typeid</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>RI_CompareHashEntry</name> <operator>*</operator><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>ri_compare_cache</name></expr></argument>,
												<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
												<argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If not already initialized, do so.  Since we'll keep this hash entry
	 * for the life of the backend, put any subsidiary info for the function
	 * cache structs into TopMemoryContext.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>entry</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Oid</name></type>			<name>lefttype</name></decl>,
					<decl><type ref="prev"/><name>righttype</name></decl>,
					<decl><type ref="prev"/><name>castfunc</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>CoercionPathType</name></type> <name>pathtype</name></decl>;</decl_stmt>

		<comment type="block">/* We always need to know how to call the equality operator */</comment>
		<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>eq_opr</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>eq_opr_finfo</name></name></expr></argument>,
					  <argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * If we chose to use a cast from FK to PK type, we may have to apply
		 * the cast function to get to the operator's input type.
		 *
		 * XXX eventually it would be good to support array-coercion cases
		 * here and in ri_AttributesEqual().  At the moment there is no point
		 * because cases involving nonidentical array types will be rejected
		 * at constraint creation time.
		 *
		 * XXX perhaps also consider supporting CoerceViaIO?  No need at the
		 * moment since that will never be generated for implicit coercions.
		 */</comment>
		<expr_stmt><expr><call><name>op_input_types</name><argument_list>(<argument><expr><name>eq_opr</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>lefttype</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>lefttype</name> <operator>==</operator> <name>righttype</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>typeid</name> <operator>==</operator> <name>lefttype</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>castfunc</name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* simplest case */</comment>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>pathtype</name> <operator>=</operator> <call><name>find_coercion_pathway</name><argument_list>(<argument><expr><name>lefttype</name></expr></argument>, <argument><expr><name>typeid</name></expr></argument>,
											 <argument><expr><name>COERCION_IMPLICIT</name></expr></argument>,
											 <argument><expr><operator>&amp;</operator><name>castfunc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_FUNC</name> <operator>&amp;&amp;</operator>
				<name>pathtype</name> <operator>!=</operator> <name>COERCION_PATH_RELABELTYPE</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * The declared input type of the eq_opr might be a
				 * polymorphic type such as ANYARRAY or ANYENUM, or other
				 * special cases such as RECORD; find_coercion_pathway
				 * currently doesn't subsume these special cases.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsBinaryCoercible</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>, <argument><expr><name>lefttype</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no conversion function from %s to %s"</literal></expr></argument>,
						 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>typeid</name></expr></argument>)</argument_list></call></expr></argument>,
						 <argument><expr><call><name>format_type_be</name><argument_list>(<argument><expr><name>lefttype</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<if_stmt><if>if <condition>(<expr><call><name>OidIsValid</name><argument_list>(<argument><expr><name>castfunc</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>fmgr_info_cxt</name><argument_list>(<argument><expr><name>castfunc</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>entry</name><operator>-&gt;</operator><name>cast_func_finfo</name></name></expr></argument>,
						  <argument><expr><name>TopMemoryContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>cast_func_finfo</name><operator>.</operator><name>fn_oid</name></name> <operator>=</operator> <name>InvalidOid</name></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><name>entry</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Given a trigger function OID, determine whether it is an RI trigger,
 * and if so whether it is attached to PK or FK relation.
 */</comment>
<function><type><name>int</name></type>
<name>RI_FKey_trigger_type</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>tgfoid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>tgfoid</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>F_RI_FKEY_CASCADE_DEL</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_CASCADE_UPD</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_RESTRICT_DEL</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_RESTRICT_UPD</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_SETNULL_DEL</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_SETNULL_UPD</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_SETDEFAULT_DEL</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_SETDEFAULT_UPD</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_NOACTION_DEL</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_NOACTION_UPD</name></expr>:</case>
			<return>return <expr><name>RI_TRIGGER_PK</name></expr>;</return>

		<case>case <expr><name>F_RI_FKEY_CHECK_INS</name></expr>:</case>
		<case>case <expr><name>F_RI_FKEY_CHECK_UPD</name></expr>:</case>
			<return>return <expr><name>RI_TRIGGER_FK</name></expr>;</return>
	</block_content>}</block></switch>

	<return>return <expr><name>RI_TRIGGER_NONE</name></expr>;</return>
</block_content>}</block></function>
</unit>
