<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/formatting.c"><comment type="block">/* -----------------------------------------------------------------------
 * formatting.c
 *
 * src/backend/utils/adt/formatting.c
 *
 *
 *	 Portions Copyright (c) 1999-2019, PostgreSQL Global Development Group
 *
 *
 *	 TO_CHAR(); TO_TIMESTAMP(); TO_DATE(); TO_NUMBER();
 *
 *	 The PostgreSQL routines for a timestamp/int/float/numeric formatting,
 *	 inspired by the Oracle TO_CHAR() / TO_DATE() / TO_NUMBER() routines.
 *
 *
 *	 Cache &amp; Memory:
 *	Routines use (itself) internal cache for format pictures.
 *
 *	The cache uses a static buffer and is persistent across transactions.  If
 *	the format-picture is bigger than the cache buffer, the parser is called
 *	always.
 *
 *	 NOTE for Number version:
 *	All in this version is implemented as keywords ( =&gt; not used
 *	suffixes), because a format picture is for *one* item (number)
 *	only. It not is as a timestamp version, where each keyword (can)
 *	has suffix.
 *
 *	 NOTE for Timestamp routines:
 *	In this module the POSIX 'struct tm' type is *not* used, but rather
 *	PgSQL type, which has tm_mon based on one (*non* zero) and
 *	year *not* based on 1900, but is used full year number.
 *	Module supports AD / BC / AM / PM.
 *
 *	Supported types for to_char():
 *
 *		Timestamp, Numeric, int4, int8, float4, float8
 *
 *	Supported types for reverse conversion:
 *
 *		Timestamp	- to_timestamp()
 *		Date		- to_date()
 *		Numeric		- to_number()
 *
 *
 *	Karel Zak
 *
 * TODO
 *	- better number building (formatting) / parsing, now it isn't
 *		  ideal code
 *	- use Assert()
 *	- add support for roman number to standard number conversion
 *	- add support for number spelling
 *	- add support for string to string formatting (we must be better
 *	  than Oracle :-),
 *		to_char('Hello', 'X X X X X') -&gt; 'H e l l o'
 *
 * -----------------------------------------------------------------------
 */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_elog_output</name></cpp:macro>	<cpp:value>DEBUG3</cpp:value></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;ctype.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unistd.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;float.h&gt;</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;limits.h&gt;</cpp:file></cpp:include>

<comment type="block">/*
 * towlower() and friends should be in &lt;wctype.h&gt;, but some pre-C99 systems
 * declare them in &lt;wchar.h&gt;.
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCHAR_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wchar.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_WCTYPE_H</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;wctype.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;unicode/ustring.h&gt;</cpp:file></cpp:include>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_collation.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"mb/pg_wchar.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/date.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/datetime.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/float.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/formatting.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/int8.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/numeric.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/pg_locale.h"</cpp:file></cpp:include>

<comment type="block">/* ----------
 * Routines type
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_TYPE</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>		<comment type="block">/* DATE-TIME version	*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_TYPE</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>		<comment type="block">/* NUMBER version	*/</comment>

<comment type="block">/* ----------
 * KeyWord Index (ascii from position 32 (' ') to 126 (~))
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KeyWord_INDEX_SIZE</name></cpp:macro>		<cpp:value>('~' - ' ')</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>KeyWord_INDEX_FILTER</name><parameter_list>(<parameter><type><name>_c</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((_c) &lt;= ' ' || (_c) &gt;= '~' ? 0 : 1)</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Maximal length of one node
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_MAX_ITEM_SIZ</name></cpp:macro>	   <cpp:value>12</cpp:value></cpp:define>	<comment type="block">/* max localized day name		*/</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_MAX_ITEM_SIZ</name></cpp:macro>		<cpp:value>8</cpp:value></cpp:define>	<comment type="block">/* roman number (RN has 15 chars)	*/</comment>


<comment type="block">/* ----------
 * Format parser structs
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>			<comment type="block">/* suffix string		*/</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>,			<comment type="block">/* suffix length		*/</comment>
				<name>id</name>,				<comment type="block">/* used in node-&gt;suffix */</comment>
				<name>type</name>;</decl_stmt>			<comment type="block">/* prefix / postfix		*/</comment>
}</block></struct></type> <name>KeySuffix</name>;</typedef>

<comment type="block">/* ----------
 * FromCharDateMode
 * ----------
 *
 * This value is used to nominate one of several distinct (and mutually
 * exclusive) date conventions that a keyword can belong to.
 */</comment>
<typedef>typedef <type><enum>enum
<block>{
	<decl><name>FROM_CHAR_DATE_NONE</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,	<comment type="block">/* Value does not affect date mode. */</comment>
	<decl><name>FROM_CHAR_DATE_GREGORIAN</name></decl>,	<comment type="block">/* Gregorian (day, month, year) style date */</comment>
	<decl><name>FROM_CHAR_DATE_ISOWEEK</name></decl>		<comment type="block">/* ISO 8601 week date */</comment>
}</block></enum></type> <name>FromCharDateMode</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>name</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>id</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_digit</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FromCharDateMode</name></type> <name>date_mode</name></decl>;</decl_stmt>
}</block></struct></type> <name>KeyWord</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>uint8</name></type>		<name>type</name></decl>;</decl_stmt>			<comment type="block">/* NODE_TYPE_XXX, see below */</comment>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>character</name><index>[<expr><name>MAX_MULTIBYTE_CHAR_LEN</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>	<comment type="block">/* if type is CHAR */</comment>
	<decl_stmt><decl><type><name>uint8</name></type>		<name>suffix</name></decl>;</decl_stmt>			<comment type="block">/* keyword prefix/suffix code, if any */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type><name>key</name></decl>;</decl_stmt>			<comment type="block">/* if type is ACTION */</comment>
}</block></struct></type> <name>FormatNode</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_TYPE_END</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_TYPE_ACTION</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_TYPE_CHAR</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_TYPE_SEPARATOR</name></cpp:macro>	<cpp:value>4</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NODE_TYPE_SPACE</name></cpp:macro>		<cpp:value>5</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUFFTYPE_PREFIX</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SUFFTYPE_POSTFIX</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOCK_24_HOUR</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CLOCK_12_HOUR</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>


<comment type="block">/* ----------
 * Full months
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>months_full</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"January"</literal></expr>, <expr><literal type="string">"February"</literal></expr>, <expr><literal type="string">"March"</literal></expr>, <expr><literal type="string">"April"</literal></expr>, <expr><literal type="string">"May"</literal></expr>, <expr><literal type="string">"June"</literal></expr>, <expr><literal type="string">"July"</literal></expr>,
	<expr><literal type="string">"August"</literal></expr>, <expr><literal type="string">"September"</literal></expr>, <expr><literal type="string">"October"</literal></expr>, <expr><literal type="string">"November"</literal></expr>, <expr><literal type="string">"December"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>days_short</name><index>[]</index></name> <init>= <expr><block>{
	<expr><literal type="string">"Sun"</literal></expr>, <expr><literal type="string">"Mon"</literal></expr>, <expr><literal type="string">"Tue"</literal></expr>, <expr><literal type="string">"Wed"</literal></expr>, <expr><literal type="string">"Thu"</literal></expr>, <expr><literal type="string">"Fri"</literal></expr>, <expr><literal type="string">"Sat"</literal></expr>, <expr><name>NULL</name></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * AD / BC
 * ----------
 *	There is no 0 AD.  Years go from 1 BC to 1 AD, so we make it
 *	positive and map year == -1 to year zero, and shift all negative
 *	years up one.  For interval years, we just return the year.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ADJUST_YEAR</name><parameter_list>(<parameter><type><name>year</name></type></parameter>, <parameter><type><name>is_interval</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((is_interval) ? (year) : ((year) &lt;= 0 ? -((year) - 1) : (year)))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>A_D_STR</name></cpp:macro>		<cpp:value>"A.D."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>a_d_STR</name></cpp:macro>		<cpp:value>"a.d."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AD_STR</name></cpp:macro>		<cpp:value>"AD"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ad_STR</name></cpp:macro>		<cpp:value>"ad"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>B_C_STR</name></cpp:macro>		<cpp:value>"B.C."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>b_c_STR</name></cpp:macro>		<cpp:value>"b.c."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>BC_STR</name></cpp:macro>		<cpp:value>"BC"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>bc_STR</name></cpp:macro>		<cpp:value>"bc"</cpp:value></cpp:define>

<comment type="block">/*
 * AD / BC strings for seq_search.
 *
 * These are given in two variants, a long form with periods and a standard
 * form without.
 *
 * The array is laid out such that matches for AD have an even index, and
 * matches for BC have an odd index.  So the boolean value for BC is given by
 * taking the array index of the match, modulo 2.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>adbc_strings</name><index>[]</index></name> <init>= <expr><block>{<expr><name>ad_STR</name></expr>, <expr><name>bc_STR</name></expr>, <expr><name>AD_STR</name></expr>, <expr><name>BC_STR</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>adbc_strings_long</name><index>[]</index></name> <init>= <expr><block>{<expr><name>a_d_STR</name></expr>, <expr><name>b_c_STR</name></expr>, <expr><name>A_D_STR</name></expr>, <expr><name>B_C_STR</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * AM / PM
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>A_M_STR</name></cpp:macro>		<cpp:value>"A.M."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>a_m_STR</name></cpp:macro>		<cpp:value>"a.m."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AM_STR</name></cpp:macro>		<cpp:value>"AM"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>am_STR</name></cpp:macro>		<cpp:value>"am"</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>P_M_STR</name></cpp:macro>		<cpp:value>"P.M."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>p_m_STR</name></cpp:macro>		<cpp:value>"p.m."</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>PM_STR</name></cpp:macro>		<cpp:value>"PM"</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>pm_STR</name></cpp:macro>		<cpp:value>"pm"</cpp:value></cpp:define>

<comment type="block">/*
 * AM / PM strings for seq_search.
 *
 * These are given in two variants, a long form with periods and a standard
 * form without.
 *
 * The array is laid out such that matches for AM have an even index, and
 * matches for PM have an odd index.  So the boolean value for PM is given by
 * taking the array index of the match, modulo 2.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>ampm_strings</name><index>[]</index></name> <init>= <expr><block>{<expr><name>am_STR</name></expr>, <expr><name>pm_STR</name></expr>, <expr><name>AM_STR</name></expr>, <expr><name>PM_STR</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>ampm_strings_long</name><index>[]</index></name> <init>= <expr><block>{<expr><name>a_m_STR</name></expr>, <expr><name>p_m_STR</name></expr>, <expr><name>A_M_STR</name></expr>, <expr><name>P_M_STR</name></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Months in roman-numeral
 * (Must be in reverse order for seq_search (in FROM_CHAR), because
 *	'VIII' must have higher precedence than 'V')
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>rm_months_upper</name><index>[]</index></name> <init>=
<expr><block>{<expr><literal type="string">"XII"</literal></expr>, <expr><literal type="string">"XI"</literal></expr>, <expr><literal type="string">"X"</literal></expr>, <expr><literal type="string">"IX"</literal></expr>, <expr><literal type="string">"VIII"</literal></expr>, <expr><literal type="string">"VII"</literal></expr>, <expr><literal type="string">"VI"</literal></expr>, <expr><literal type="string">"V"</literal></expr>, <expr><literal type="string">"IV"</literal></expr>, <expr><literal type="string">"III"</literal></expr>, <expr><literal type="string">"II"</literal></expr>, <expr><literal type="string">"I"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>rm_months_lower</name><index>[]</index></name> <init>=
<expr><block>{<expr><literal type="string">"xii"</literal></expr>, <expr><literal type="string">"xi"</literal></expr>, <expr><literal type="string">"x"</literal></expr>, <expr><literal type="string">"ix"</literal></expr>, <expr><literal type="string">"viii"</literal></expr>, <expr><literal type="string">"vii"</literal></expr>, <expr><literal type="string">"vi"</literal></expr>, <expr><literal type="string">"v"</literal></expr>, <expr><literal type="string">"iv"</literal></expr>, <expr><literal type="string">"iii"</literal></expr>, <expr><literal type="string">"ii"</literal></expr>, <expr><literal type="string">"i"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Roman numbers
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>rm1</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"I"</literal></expr>, <expr><literal type="string">"II"</literal></expr>, <expr><literal type="string">"III"</literal></expr>, <expr><literal type="string">"IV"</literal></expr>, <expr><literal type="string">"V"</literal></expr>, <expr><literal type="string">"VI"</literal></expr>, <expr><literal type="string">"VII"</literal></expr>, <expr><literal type="string">"VIII"</literal></expr>, <expr><literal type="string">"IX"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>rm10</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"X"</literal></expr>, <expr><literal type="string">"XX"</literal></expr>, <expr><literal type="string">"XXX"</literal></expr>, <expr><literal type="string">"XL"</literal></expr>, <expr><literal type="string">"L"</literal></expr>, <expr><literal type="string">"LX"</literal></expr>, <expr><literal type="string">"LXX"</literal></expr>, <expr><literal type="string">"LXXX"</literal></expr>, <expr><literal type="string">"XC"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>rm100</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"C"</literal></expr>, <expr><literal type="string">"CC"</literal></expr>, <expr><literal type="string">"CCC"</literal></expr>, <expr><literal type="string">"CD"</literal></expr>, <expr><literal type="string">"D"</literal></expr>, <expr><literal type="string">"DC"</literal></expr>, <expr><literal type="string">"DCC"</literal></expr>, <expr><literal type="string">"DCCC"</literal></expr>, <expr><literal type="string">"CM"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Ordinal postfixes
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>numTH</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"ST"</literal></expr>, <expr><literal type="string">"ND"</literal></expr>, <expr><literal type="string">"RD"</literal></expr>, <expr><literal type="string">"TH"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier></type> <name><name>numth</name><index>[]</index></name> <init>= <expr><block>{<expr><literal type="string">"st"</literal></expr>, <expr><literal type="string">"nd"</literal></expr>, <expr><literal type="string">"rd"</literal></expr>, <expr><literal type="string">"th"</literal></expr>, <expr><name>NULL</name></expr>}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Flags &amp; Options:
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ONE_UPPER</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>		<comment type="block">/* Name */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALL_UPPER</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>		<comment type="block">/* NAME */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ALL_LOWER</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>		<comment type="block">/* name */</comment>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>FULL_SIZ</name></cpp:macro>		<cpp:value>0</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MONTH_LEN</name></cpp:macro>	<cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_MON_LEN</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DAY_LEN</name></cpp:macro>		<cpp:value>9</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_DY_LEN</name></cpp:macro>		<cpp:value>3</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_RM_LEN</name></cpp:macro>		<cpp:value>4</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TH_UPPER</name></cpp:macro>		<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TH_LOWER</name></cpp:macro>		<cpp:value>2</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Number description struct
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>int</name></type>			<name>pre</name></decl>,			<comment type="block">/* (count) numbers before decimal */</comment>
				<name>post</name>,			<comment type="block">/* (count) numbers after decimal  */</comment>
				<name>lsign</name>,			<comment type="block">/* want locales sign		  */</comment>
				<name>flag</name>,			<comment type="block">/* number parameters		  */</comment>
				<name>pre_lsign_num</name>,	<comment type="block">/* tmp value for lsign		  */</comment>
				<name>multi</name>,			<comment type="block">/* multiplier for 'V'		  */</comment>
				<name>zero_start</name>,		<comment type="block">/* position of first zero	  */</comment>
				<name>zero_end</name>,		<comment type="block">/* position of last zero	  */</comment>
				<name>need_locale</name>;</decl_stmt>	<comment type="block">/* needs it locale		  */</comment>
}</block></struct></type> <name>NUMDesc</name>;</typedef>

<comment type="block">/* ----------
 * Flags for NUMBER version
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_DECIMAL</name></cpp:macro>		<cpp:value>(1 &lt;&lt; 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_LDECIMAL</name></cpp:macro>		<cpp:value>(1 &lt;&lt; 2)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_ZERO</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 3)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_BLANK</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 4)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_FILLMODE</name></cpp:macro>		<cpp:value>(1 &lt;&lt; 5)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_LSIGN</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 6)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_BRACKET</name></cpp:macro>		<cpp:value>(1 &lt;&lt; 7)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_MINUS</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 8)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_PLUS</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 9)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_ROMAN</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 10)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_MULTI</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 11)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_PLUS_POST</name></cpp:macro>		<cpp:value>(1 &lt;&lt; 12)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_MINUS_POST</name></cpp:macro>	<cpp:value>(1 &lt;&lt; 13)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_F_EEEE</name></cpp:macro>			<cpp:value>(1 &lt;&lt; 14)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_LSIGN_PRE</name></cpp:macro>	<cpp:value>(-1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_LSIGN_POST</name></cpp:macro>	<cpp:value>1</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_LSIGN_NONE</name></cpp:macro>	<cpp:value>0</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Tests
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_DECIMAL</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((_f)-&gt;flag &amp; NUM_F_DECIMAL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LDECIMAL</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_f)-&gt;flag &amp; NUM_F_LDECIMAL)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ZERO</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_f)-&gt;flag &amp; NUM_F_ZERO)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_BLANK</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((_f)-&gt;flag &amp; NUM_F_BLANK)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_FILLMODE</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_f)-&gt;flag &amp; NUM_F_FILLMODE)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_BRACKET</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((_f)-&gt;flag &amp; NUM_F_BRACKET)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_MINUS</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((_f)-&gt;flag &amp; NUM_F_MINUS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_LSIGN</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((_f)-&gt;flag &amp; NUM_F_LSIGN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_PLUS</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_f)-&gt;flag &amp; NUM_F_PLUS)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_ROMAN</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((_f)-&gt;flag &amp; NUM_F_ROMAN)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_MULTI</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((_f)-&gt;flag &amp; NUM_F_MULTI)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_EEEE</name><parameter_list>(<parameter><type><name>_f</name></type></parameter>)</parameter_list></cpp:macro>		<cpp:value>((_f)-&gt;flag &amp; NUM_F_EEEE)</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Format picture cache
 *
 * We will cache datetime format pictures up to DCH_CACHE_SIZE bytes long;
 * likewise number format pictures up to NUM_CACHE_SIZE bytes long.
 *
 * For simplicity, the cache entries are fixed-size, so they allow for the
 * worst case of a FormatNode for each byte in the picture string.
 *
 * The CACHE_SIZE constants are computed to make sizeof(DCHCacheEntry) and
 * sizeof(NUMCacheEntry) be powers of 2, or just less than that, so that
 * we don't waste too much space by palloc'ing them individually.  Be sure
 * to adjust those macros if you add fields to those structs.
 *
 * The max number of entries in each cache is DCH_CACHE_ENTRIES
 * resp. NUM_CACHE_ENTRIES.
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_CACHE_OVERHEAD</name></cpp:macro> \
	<cpp:value>MAXALIGN(sizeof(bool) + sizeof(int))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CACHE_OVERHEAD</name></cpp:macro> \
	<cpp:value>MAXALIGN(sizeof(bool) + sizeof(int) + sizeof(NUMDesc))</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_CACHE_SIZE</name></cpp:macro> \
	<cpp:value>((2048 - DCH_CACHE_OVERHEAD) / (sizeof(FormatNode) + sizeof(char)) - 1)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CACHE_SIZE</name></cpp:macro> \
	<cpp:value>((1024 - NUM_CACHE_OVERHEAD) / (sizeof(FormatNode) + sizeof(char)) - 1)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_CACHE_ENTRIES</name></cpp:macro>	<cpp:value>20</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_CACHE_ENTRIES</name></cpp:macro>	<cpp:value>20</cpp:value></cpp:define>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>FormatNode</name></type>	<name><name>format</name><index>[<expr><name>DCH_CACHE_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>str</name><index>[<expr><name>DCH_CACHE_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>age</name></decl>;</decl_stmt>
}</block></struct></type> <name>DCHCacheEntry</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>FormatNode</name></type>	<name><name>format</name><index>[<expr><name>NUM_CACHE_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>str</name><index>[<expr><name>NUM_CACHE_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>valid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>age</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NUMDesc</name></type>		<name>Num</name></decl>;</decl_stmt>
}</block></struct></type> <name>NUMCacheEntry</name>;</typedef>

<comment type="block">/* global cache for date/time format pictures */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>DCHCacheEntry</name> <modifier>*</modifier></type><name><name>DCHCache</name><index>[<expr><name>DCH_CACHE_ENTRIES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>n_DCHCache</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* current number of entries */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>DCHCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* aging-event counter */</comment>

<comment type="block">/* global cache for number format pictures */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>NUMCacheEntry</name> <modifier>*</modifier></type><name><name>NUMCache</name><index>[<expr><name>NUM_CACHE_ENTRIES</name></expr>]</index></name></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>n_NUMCache</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* current number of entries */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>NUMCounter</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>		<comment type="block">/* aging-event counter */</comment>

<comment type="block">/* ----------
 * For char-&gt;date/time conversion
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>FromCharDateMode</name></type> <name>mode</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>hh</name></decl>,
				<name>pm</name>,
				<name>mi</name>,
				<name>ss</name>,
				<name>ssss</name>,
				<name>d</name>,				<comment type="block">/* stored as 1-7, Sunday = 1, 0 means missing */</comment>
				<name>dd</name>,
				<name>ddd</name>,
				<name>mm</name>,
				<name>ms</name>,
				<name>year</name>,
				<name>bc</name>,
				<name>ww</name>,
				<name>w</name>,
				<name>cc</name>,
				<name>j</name>,
				<name>us</name>,
				<name>yysz</name>,			<comment type="block">/* is it YY or YYYY ? */</comment>
				<name>clock</name>,			<comment type="block">/* 12 or 24 hour clock? */</comment>
				<name>tzsign</name>,			<comment type="block">/* +1, -1 or 0 if timezone info is absent */</comment>
				<name>tzh</name>,
				<name>tzm</name>;</decl_stmt>
}</block></struct></type> <name>TmFromChar</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZERO_tmfc</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>memset(_X, 0, sizeof(TmFromChar))</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Debug
 * ----------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_TMFC</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>elog(DEBUG_elog_output, "TMFC:\nmode %d\nhh %d\npm %d\nmi %d\nss %d\nssss %d\nd %d\ndd %d\nddd %d\nmm %d\nms: %d\nyear %d\nbc %d\nww %d\nw %d\ncc %d\nj %d\nus: %d\nyysz: %d\nclock: %d", \
			(_X)-&gt;mode, (_X)-&gt;hh, (_X)-&gt;pm, (_X)-&gt;mi, (_X)-&gt;ss, (_X)-&gt;ssss, \
			(_X)-&gt;d, (_X)-&gt;dd, (_X)-&gt;ddd, (_X)-&gt;mm, (_X)-&gt;ms, (_X)-&gt;year, \
			(_X)-&gt;bc, (_X)-&gt;ww, (_X)-&gt;w, (_X)-&gt;cc, (_X)-&gt;j, (_X)-&gt;us, \
			(_X)-&gt;yysz, (_X)-&gt;clock);</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_TM</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>elog(DEBUG_elog_output, "TM:\nsec %d\nyear %d\nmin %d\nwday %d\nhour %d\nyday %d\nmday %d\nnisdst %d\nmon %d\n",\
			(_X)-&gt;tm_sec, (_X)-&gt;tm_year,\
			(_X)-&gt;tm_min, (_X)-&gt;tm_wday, (_X)-&gt;tm_hour, (_X)-&gt;tm_yday,\
			(_X)-&gt;tm_mday, (_X)-&gt;tm_isdst, (_X)-&gt;tm_mon)</cpp:value></cpp:define>
<cpp:else>#<cpp:directive>else</cpp:directive></cpp:else>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_TMFC</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEBUG_TM</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro></cpp:define>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<comment type="block">/* ----------
 * Datetime to char conversion
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct <name>TmToChar</name>
<block>{
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>			<comment type="block">/* classic 'tm' struct */</comment>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>			<comment type="block">/* fractional seconds */</comment>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>tzn</name></decl>;</decl_stmt>			<comment type="block">/* timezone */</comment>
}</block></struct></type> <name>TmToChar</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tmtcTm</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(&amp;(_X)-&gt;tm)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tmtcTzn</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>((_X)-&gt;tzn)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>tmtcFsec</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((_X)-&gt;fsec)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZERO_tm</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do {	\
	(_X)-&gt;tm_sec  = (_X)-&gt;tm_year = (_X)-&gt;tm_min = (_X)-&gt;tm_wday = \
	(_X)-&gt;tm_hour = (_X)-&gt;tm_yday = (_X)-&gt;tm_isdst = 0; \
	(_X)-&gt;tm_mday = (_X)-&gt;tm_mon  = 1; \
	(_X)-&gt;tm_zone = NULL; \
} while(0)</cpp:value></cpp:define>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>ZERO_tmtc</name><parameter_list>(<parameter><type><name>_X</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	ZERO_tm( tmtcTm(_X) ); \
	tmtcFsec(_X) = 0; \
	tmtcTzn(_X) = NULL; \
} while(0)</cpp:value></cpp:define>

<comment type="block">/*
 *	to_char(time) appears to to_char() as an interval, so this check
 *	is really for interval and time data types.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>INVALID_FOR_INTERVAL</name></cpp:macro>  \
<cpp:value>do { \
	if (is_interval) \
		ereport(ERROR, \
				(errcode(ERRCODE_INVALID_DATETIME_FORMAT), \
				 errmsg("invalid format specification for an interval value"), \
				 errhint("Intervals are not tied to specific calendar dates."))); \
} while(0)</cpp:value></cpp:define>

<comment type="block" format="doxygen">/*****************************************************************************
 *			KeyWord definitions
 *****************************************************************************/</comment>

<comment type="block">/* ----------
 * Suffixes (FormatNode.suffix is an OR of these codes)
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_S_FM</name></cpp:macro>	<cpp:value>0x01</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_S_TH</name></cpp:macro>	<cpp:value>0x02</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_S_th</name></cpp:macro>	<cpp:value>0x04</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_S_SP</name></cpp:macro>	<cpp:value>0x08</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DCH_S_TM</name></cpp:macro>	<cpp:value>0x10</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Suffix tests
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_THth</name><parameter_list>(<parameter><type><name>_s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>((((_s) &amp; DCH_S_TH) || ((_s) &amp; DCH_S_th)) ? 1 : 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_TH</name><parameter_list>(<parameter><type><name>_s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((_s) &amp; DCH_S_TH) ? 1 : 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_th</name><parameter_list>(<parameter><type><name>_s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((_s) &amp; DCH_S_th) ? 1 : 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_TH_TYPE</name><parameter_list>(<parameter><type><name>_s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((_s) &amp; DCH_S_TH) ? TH_UPPER : TH_LOWER)</cpp:value></cpp:define>

<comment type="block">/* Oracle toggles FM behavior, we don't; see docs. */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_FM</name><parameter_list>(<parameter><type><name>_s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((_s) &amp; DCH_S_FM) ? 1 : 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_SP</name><parameter_list>(<parameter><type><name>_s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((_s) &amp; DCH_S_SP) ? 1 : 0)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>S_TM</name><parameter_list>(<parameter><type><name>_s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(((_s) &amp; DCH_S_TM) ? 1 : 0)</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Suffixes definition for DATE-TIME TO/FROM CHAR
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TM_SUFFIX_LEN</name></cpp:macro>	<cpp:value>2</cpp:value></cpp:define>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>KeySuffix</name></type> <name><name>DCH_suff</name><index>[]</index></name> <init>= <expr><block>{
	<expr><block>{<expr><literal type="string">"FM"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_S_FM</name></expr>, <expr><name>SUFFTYPE_PREFIX</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"fm"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_S_FM</name></expr>, <expr><name>SUFFTYPE_PREFIX</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TM"</literal></expr>, <expr><name>TM_SUFFIX_LEN</name></expr>, <expr><name>DCH_S_TM</name></expr>, <expr><name>SUFFTYPE_PREFIX</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"tm"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_S_TM</name></expr>, <expr><name>SUFFTYPE_PREFIX</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TH"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_S_TH</name></expr>, <expr><name>SUFFTYPE_POSTFIX</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"th"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_S_th</name></expr>, <expr><name>SUFFTYPE_POSTFIX</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"SP"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_S_SP</name></expr>, <expr><name>SUFFTYPE_POSTFIX</name></expr>}</block></expr>,
	<comment type="block">/* last */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ----------
 * Format-pictures (KeyWord).
 *
 * The KeyWord field; alphabetic sorted, *BUT* strings alike is sorted
 *		  complicated -to-&gt; easy:
 *
 *	(example: "DDD","DD","Day","D" )
 *
 * (this specific sort needs the algorithm for sequential search for strings,
 * which not has exact end; -&gt; How keyword is in "HH12blabla" ? - "HH"
 * or "HH12"? You must first try "HH12", because "HH" is in string, but
 * it is not good.
 *
 * (!)
 *	 - Position for the keyword is similar as position in the enum DCH/NUM_poz.
 * (!)
 *
 * For fast search is used the 'int index[]', index is ascii table from position
 * 32 (' ') to 126 (~), in this index is DCH_ / NUM_ enums for each ASCII
 * position or -1 if char is not used in the KeyWord. Search example for
 * string "MM":
 *	1)	see in index to index['M' - 32],
 *	2)	take keywords position (enum DCH_MI) from index
 *	3)	run sequential search in keywords[] from this position
 *
 * ----------
 */</comment>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>DCH_A_D</name></decl>,
	<decl><name>DCH_A_M</name></decl>,
	<decl><name>DCH_AD</name></decl>,
	<decl><name>DCH_AM</name></decl>,
	<decl><name>DCH_B_C</name></decl>,
	<decl><name>DCH_BC</name></decl>,
	<decl><name>DCH_CC</name></decl>,
	<decl><name>DCH_DAY</name></decl>,
	<decl><name>DCH_DDD</name></decl>,
	<decl><name>DCH_DD</name></decl>,
	<decl><name>DCH_DY</name></decl>,
	<decl><name>DCH_Day</name></decl>,
	<decl><name>DCH_Dy</name></decl>,
	<decl><name>DCH_D</name></decl>,
	<decl><name>DCH_FX</name></decl>,						<comment type="block">/* global suffix */</comment>
	<decl><name>DCH_HH24</name></decl>,
	<decl><name>DCH_HH12</name></decl>,
	<decl><name>DCH_HH</name></decl>,
	<decl><name>DCH_IDDD</name></decl>,
	<decl><name>DCH_ID</name></decl>,
	<decl><name>DCH_IW</name></decl>,
	<decl><name>DCH_IYYY</name></decl>,
	<decl><name>DCH_IYY</name></decl>,
	<decl><name>DCH_IY</name></decl>,
	<decl><name>DCH_I</name></decl>,
	<decl><name>DCH_J</name></decl>,
	<decl><name>DCH_MI</name></decl>,
	<decl><name>DCH_MM</name></decl>,
	<decl><name>DCH_MONTH</name></decl>,
	<decl><name>DCH_MON</name></decl>,
	<decl><name>DCH_MS</name></decl>,
	<decl><name>DCH_Month</name></decl>,
	<decl><name>DCH_Mon</name></decl>,
	<decl><name>DCH_OF</name></decl>,
	<decl><name>DCH_P_M</name></decl>,
	<decl><name>DCH_PM</name></decl>,
	<decl><name>DCH_Q</name></decl>,
	<decl><name>DCH_RM</name></decl>,
	<decl><name>DCH_SSSS</name></decl>,
	<decl><name>DCH_SS</name></decl>,
	<decl><name>DCH_TZH</name></decl>,
	<decl><name>DCH_TZM</name></decl>,
	<decl><name>DCH_TZ</name></decl>,
	<decl><name>DCH_US</name></decl>,
	<decl><name>DCH_WW</name></decl>,
	<decl><name>DCH_W</name></decl>,
	<decl><name>DCH_Y_YYY</name></decl>,
	<decl><name>DCH_YYYY</name></decl>,
	<decl><name>DCH_YYY</name></decl>,
	<decl><name>DCH_YY</name></decl>,
	<decl><name>DCH_Y</name></decl>,
	<decl><name>DCH_a_d</name></decl>,
	<decl><name>DCH_a_m</name></decl>,
	<decl><name>DCH_ad</name></decl>,
	<decl><name>DCH_am</name></decl>,
	<decl><name>DCH_b_c</name></decl>,
	<decl><name>DCH_bc</name></decl>,
	<decl><name>DCH_cc</name></decl>,
	<decl><name>DCH_day</name></decl>,
	<decl><name>DCH_ddd</name></decl>,
	<decl><name>DCH_dd</name></decl>,
	<decl><name>DCH_dy</name></decl>,
	<decl><name>DCH_d</name></decl>,
	<decl><name>DCH_fx</name></decl>,
	<decl><name>DCH_hh24</name></decl>,
	<decl><name>DCH_hh12</name></decl>,
	<decl><name>DCH_hh</name></decl>,
	<decl><name>DCH_iddd</name></decl>,
	<decl><name>DCH_id</name></decl>,
	<decl><name>DCH_iw</name></decl>,
	<decl><name>DCH_iyyy</name></decl>,
	<decl><name>DCH_iyy</name></decl>,
	<decl><name>DCH_iy</name></decl>,
	<decl><name>DCH_i</name></decl>,
	<decl><name>DCH_j</name></decl>,
	<decl><name>DCH_mi</name></decl>,
	<decl><name>DCH_mm</name></decl>,
	<decl><name>DCH_month</name></decl>,
	<decl><name>DCH_mon</name></decl>,
	<decl><name>DCH_ms</name></decl>,
	<decl><name>DCH_p_m</name></decl>,
	<decl><name>DCH_pm</name></decl>,
	<decl><name>DCH_q</name></decl>,
	<decl><name>DCH_rm</name></decl>,
	<decl><name>DCH_ssss</name></decl>,
	<decl><name>DCH_ss</name></decl>,
	<decl><name>DCH_tz</name></decl>,
	<decl><name>DCH_us</name></decl>,
	<decl><name>DCH_ww</name></decl>,
	<decl><name>DCH_w</name></decl>,
	<decl><name>DCH_y_yyy</name></decl>,
	<decl><name>DCH_yyyy</name></decl>,
	<decl><name>DCH_yyy</name></decl>,
	<decl><name>DCH_yy</name></decl>,
	<decl><name>DCH_y</name></decl>,

	<comment type="block">/* last */</comment>
	<decl><name>_DCH_last_</name></decl>
}</block></enum></type>			<name>DCH_poz</name>;</typedef>

<typedef>typedef <type><enum>enum
<block>{
	<decl><name>NUM_COMMA</name></decl>,
	<decl><name>NUM_DEC</name></decl>,
	<decl><name>NUM_0</name></decl>,
	<decl><name>NUM_9</name></decl>,
	<decl><name>NUM_B</name></decl>,
	<decl><name>NUM_C</name></decl>,
	<decl><name>NUM_D</name></decl>,
	<decl><name>NUM_E</name></decl>,
	<decl><name>NUM_FM</name></decl>,
	<decl><name>NUM_G</name></decl>,
	<decl><name>NUM_L</name></decl>,
	<decl><name>NUM_MI</name></decl>,
	<decl><name>NUM_PL</name></decl>,
	<decl><name>NUM_PR</name></decl>,
	<decl><name>NUM_RN</name></decl>,
	<decl><name>NUM_SG</name></decl>,
	<decl><name>NUM_SP</name></decl>,
	<decl><name>NUM_S</name></decl>,
	<decl><name>NUM_TH</name></decl>,
	<decl><name>NUM_V</name></decl>,
	<decl><name>NUM_b</name></decl>,
	<decl><name>NUM_c</name></decl>,
	<decl><name>NUM_d</name></decl>,
	<decl><name>NUM_e</name></decl>,
	<decl><name>NUM_fm</name></decl>,
	<decl><name>NUM_g</name></decl>,
	<decl><name>NUM_l</name></decl>,
	<decl><name>NUM_mi</name></decl>,
	<decl><name>NUM_pl</name></decl>,
	<decl><name>NUM_pr</name></decl>,
	<decl><name>NUM_rn</name></decl>,
	<decl><name>NUM_sg</name></decl>,
	<decl><name>NUM_sp</name></decl>,
	<decl><name>NUM_s</name></decl>,
	<decl><name>NUM_th</name></decl>,
	<decl><name>NUM_v</name></decl>,

	<comment type="block">/* last */</comment>
	<decl><name>_NUM_last_</name></decl>
}</block></enum></type>			<name>NUM_poz</name>;</typedef>

<comment type="block">/* ----------
 * KeyWords for DATE-TIME version
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>KeyWord</name></type> <name><name>DCH_keywords</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/*	name, len, id, is_digit, date_mode */</comment>
	<expr><block>{<expr><literal type="string">"A.D."</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_A_D</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* A */</comment>
	<expr><block>{<expr><literal type="string">"A.M."</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_A_M</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"AD"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_AD</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"AM"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_AM</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"B.C."</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_B_C</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* B */</comment>
	<expr><block>{<expr><literal type="string">"BC"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_BC</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"CC"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_CC</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* C */</comment>
	<expr><block>{<expr><literal type="string">"DAY"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_DAY</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* D */</comment>
	<expr><block>{<expr><literal type="string">"DDD"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_DDD</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"DD"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_DD</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"DY"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_DY</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"Day"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_Day</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"Dy"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_Dy</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"D"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_D</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"FX"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_FX</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* F */</comment>
	<expr><block>{<expr><literal type="string">"HH24"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_HH24</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* H */</comment>
	<expr><block>{<expr><literal type="string">"HH12"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_HH12</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"HH"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_HH</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"IDDD"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_IDDD</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,	<comment type="block">/* I */</comment>
	<expr><block>{<expr><literal type="string">"ID"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_ID</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"IW"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_IW</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"IYYY"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_IYYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"IYY"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_IYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"IY"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_IY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"I"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_I</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"J"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_J</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>, <comment type="block">/* J */</comment>
	<expr><block>{<expr><literal type="string">"MI"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_MI</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* M */</comment>
	<expr><block>{<expr><literal type="string">"MM"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_MM</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MONTH"</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>DCH_MONTH</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MON"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_MON</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"MS"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_MS</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"Month"</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>DCH_Month</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"Mon"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_Mon</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"OF"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_OF</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* O */</comment>
	<expr><block>{<expr><literal type="string">"P.M."</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_P_M</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* P */</comment>
	<expr><block>{<expr><literal type="string">"PM"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_PM</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"Q"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_Q</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>, <comment type="block">/* Q */</comment>
	<expr><block>{<expr><literal type="string">"RM"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_RM</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>, <comment type="block">/* R */</comment>
	<expr><block>{<expr><literal type="string">"SSSS"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_SSSS</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* S */</comment>
	<expr><block>{<expr><literal type="string">"SS"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_SS</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TZH"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_TZH</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* T */</comment>
	<expr><block>{<expr><literal type="string">"TZM"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_TZM</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TZ"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_TZ</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"US"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_US</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* U */</comment>
	<expr><block>{<expr><literal type="string">"WW"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_WW</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,	<comment type="block">/* W */</comment>
	<expr><block>{<expr><literal type="string">"W"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_W</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"Y,YYY"</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>DCH_Y_YYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,	<comment type="block">/* Y */</comment>
	<expr><block>{<expr><literal type="string">"YYYY"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_YYYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"YYY"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_YYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"YY"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_YY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"Y"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_Y</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"a.d."</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_a_d</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* a */</comment>
	<expr><block>{<expr><literal type="string">"a.m."</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_a_m</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ad"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_ad</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"am"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_am</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"b.c."</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_b_c</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* b */</comment>
	<expr><block>{<expr><literal type="string">"bc"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_bc</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"cc"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_CC</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* c */</comment>
	<expr><block>{<expr><literal type="string">"day"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_day</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* d */</comment>
	<expr><block>{<expr><literal type="string">"ddd"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_DDD</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"dd"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_DD</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"dy"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_dy</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_D</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"fx"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_FX</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* f */</comment>
	<expr><block>{<expr><literal type="string">"hh24"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_HH24</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* h */</comment>
	<expr><block>{<expr><literal type="string">"hh12"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_HH12</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"hh"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_HH</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"iddd"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_IDDD</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,	<comment type="block">/* i */</comment>
	<expr><block>{<expr><literal type="string">"id"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_ID</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"iw"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_IW</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"iyyy"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_IYYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"iyy"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_IYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"iy"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_IY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"i"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_I</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_ISOWEEK</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"j"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_J</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>, <comment type="block">/* j */</comment>
	<expr><block>{<expr><literal type="string">"mi"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_MI</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* m */</comment>
	<expr><block>{<expr><literal type="string">"mm"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_MM</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"month"</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>DCH_month</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"mon"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_mon</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"ms"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_MS</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"p.m."</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_p_m</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* p */</comment>
	<expr><block>{<expr><literal type="string">"pm"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_pm</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"q"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_Q</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>, <comment type="block">/* q */</comment>
	<expr><block>{<expr><literal type="string">"rm"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_rm</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>, <comment type="block">/* r */</comment>
	<expr><block>{<expr><literal type="string">"ssss"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_SSSS</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* s */</comment>
	<expr><block>{<expr><literal type="string">"ss"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_SS</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"tz"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_tz</name></expr>, <expr><name>false</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* t */</comment>
	<expr><block>{<expr><literal type="string">"us"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_US</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_NONE</name></expr>}</block></expr>,	<comment type="block">/* u */</comment>
	<expr><block>{<expr><literal type="string">"ww"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_WW</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,	<comment type="block">/* w */</comment>
	<expr><block>{<expr><literal type="string">"w"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_W</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"y,yyy"</literal></expr>, <expr><literal type="number">5</literal></expr>, <expr><name>DCH_Y_YYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,	<comment type="block">/* y */</comment>
	<expr><block>{<expr><literal type="string">"yyyy"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>DCH_YYYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yyy"</literal></expr>, <expr><literal type="number">3</literal></expr>, <expr><name>DCH_YYY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"yy"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>DCH_YY</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"y"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>DCH_Y</name></expr>, <expr><name>true</name></expr>, <expr><name>FROM_CHAR_DATE_GREGORIAN</name></expr>}</block></expr>,

	<comment type="block">/* last */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * KeyWords for NUMBER version
 *
 * The is_digit and date_mode fields are not relevant here.
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>KeyWord</name></type> <name><name>NUM_keywords</name><index>[]</index></name> <init>= <expr><block>{
<comment type="block">/*	name, len, id			is in Index */</comment>
	<expr><block>{<expr><literal type="string">","</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_COMMA</name></expr>}</block></expr>,		<comment type="block">/* , */</comment>
	<expr><block>{<expr><literal type="string">"."</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_DEC</name></expr>}</block></expr>,			<comment type="block">/* . */</comment>
	<expr><block>{<expr><literal type="string">"0"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_0</name></expr>}</block></expr>,			<comment type="block">/* 0 */</comment>
	<expr><block>{<expr><literal type="string">"9"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_9</name></expr>}</block></expr>,			<comment type="block">/* 9 */</comment>
	<expr><block>{<expr><literal type="string">"B"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_B</name></expr>}</block></expr>,			<comment type="block">/* B */</comment>
	<expr><block>{<expr><literal type="string">"C"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_C</name></expr>}</block></expr>,			<comment type="block">/* C */</comment>
	<expr><block>{<expr><literal type="string">"D"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_D</name></expr>}</block></expr>,			<comment type="block">/* D */</comment>
	<expr><block>{<expr><literal type="string">"EEEE"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>NUM_E</name></expr>}</block></expr>,			<comment type="block">/* E */</comment>
	<expr><block>{<expr><literal type="string">"FM"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_FM</name></expr>}</block></expr>,			<comment type="block">/* F */</comment>
	<expr><block>{<expr><literal type="string">"G"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_G</name></expr>}</block></expr>,			<comment type="block">/* G */</comment>
	<expr><block>{<expr><literal type="string">"L"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_L</name></expr>}</block></expr>,			<comment type="block">/* L */</comment>
	<expr><block>{<expr><literal type="string">"MI"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_MI</name></expr>}</block></expr>,			<comment type="block">/* M */</comment>
	<expr><block>{<expr><literal type="string">"PL"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_PL</name></expr>}</block></expr>,			<comment type="block">/* P */</comment>
	<expr><block>{<expr><literal type="string">"PR"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_PR</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"RN"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_RN</name></expr>}</block></expr>,			<comment type="block">/* R */</comment>
	<expr><block>{<expr><literal type="string">"SG"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_SG</name></expr>}</block></expr>,			<comment type="block">/* S */</comment>
	<expr><block>{<expr><literal type="string">"SP"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_SP</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"S"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_S</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"TH"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_TH</name></expr>}</block></expr>,			<comment type="block">/* T */</comment>
	<expr><block>{<expr><literal type="string">"V"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_V</name></expr>}</block></expr>,			<comment type="block">/* V */</comment>
	<expr><block>{<expr><literal type="string">"b"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_B</name></expr>}</block></expr>,			<comment type="block">/* b */</comment>
	<expr><block>{<expr><literal type="string">"c"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_C</name></expr>}</block></expr>,			<comment type="block">/* c */</comment>
	<expr><block>{<expr><literal type="string">"d"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_D</name></expr>}</block></expr>,			<comment type="block">/* d */</comment>
	<expr><block>{<expr><literal type="string">"eeee"</literal></expr>, <expr><literal type="number">4</literal></expr>, <expr><name>NUM_E</name></expr>}</block></expr>,			<comment type="block">/* e */</comment>
	<expr><block>{<expr><literal type="string">"fm"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_FM</name></expr>}</block></expr>,			<comment type="block">/* f */</comment>
	<expr><block>{<expr><literal type="string">"g"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_G</name></expr>}</block></expr>,			<comment type="block">/* g */</comment>
	<expr><block>{<expr><literal type="string">"l"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_L</name></expr>}</block></expr>,			<comment type="block">/* l */</comment>
	<expr><block>{<expr><literal type="string">"mi"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_MI</name></expr>}</block></expr>,			<comment type="block">/* m */</comment>
	<expr><block>{<expr><literal type="string">"pl"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_PL</name></expr>}</block></expr>,			<comment type="block">/* p */</comment>
	<expr><block>{<expr><literal type="string">"pr"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_PR</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"rn"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_rn</name></expr>}</block></expr>,			<comment type="block">/* r */</comment>
	<expr><block>{<expr><literal type="string">"sg"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_SG</name></expr>}</block></expr>,			<comment type="block">/* s */</comment>
	<expr><block>{<expr><literal type="string">"sp"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_SP</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"s"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_S</name></expr>}</block></expr>,
	<expr><block>{<expr><literal type="string">"th"</literal></expr>, <expr><literal type="number">2</literal></expr>, <expr><name>NUM_th</name></expr>}</block></expr>,			<comment type="block">/* t */</comment>
	<expr><block>{<expr><literal type="string">"v"</literal></expr>, <expr><literal type="number">1</literal></expr>, <expr><name>NUM_V</name></expr>}</block></expr>,			<comment type="block">/* v */</comment>

	<comment type="block">/* last */</comment>
	<expr><block>{<expr><name>NULL</name></expr>, <expr><literal type="number">0</literal></expr>, <expr><literal type="number">0</literal></expr>}</block></expr>
}</block></expr></init></decl>;</decl_stmt>


<comment type="block">/* ----------
 * KeyWords index for DATE-TIME version
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>DCH_index</name><index>[<expr><name>KeyWord_INDEX_SIZE</name></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*
0	1	2	3	4	5	6	7	8	9
*/</comment>
	<comment type="block">/*---- first 0..31 chars are skipped ----*/</comment>

	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_A_D</name></expr>, <expr><name>DCH_B_C</name></expr>, <expr><name>DCH_CC</name></expr>, <expr><name>DCH_DAY</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><name>DCH_FX</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_HH24</name></expr>, <expr><name>DCH_IDDD</name></expr>, <expr><name>DCH_J</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_MI</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_OF</name></expr>,
	<expr><name>DCH_P_M</name></expr>, <expr><name>DCH_Q</name></expr>, <expr><name>DCH_RM</name></expr>, <expr><name>DCH_SSSS</name></expr>, <expr><name>DCH_TZH</name></expr>, <expr><name>DCH_US</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_WW</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_Y_YYY</name></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_a_d</name></expr>, <expr><name>DCH_b_c</name></expr>, <expr><name>DCH_cc</name></expr>,
	<expr><name>DCH_day</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_fx</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_hh24</name></expr>, <expr><name>DCH_iddd</name></expr>, <expr><name>DCH_j</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_mi</name></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_p_m</name></expr>, <expr><name>DCH_q</name></expr>, <expr><name>DCH_rm</name></expr>, <expr><name>DCH_ssss</name></expr>, <expr><name>DCH_tz</name></expr>, <expr><name>DCH_us</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_ww</name></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>DCH_y_yyy</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>

	<comment type="block">/*---- chars over 126 are skipped ----*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * KeyWords index for NUMBER version
 * ----------
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>NUM_index</name><index>[<expr><name>KeyWord_INDEX_SIZE</name></expr>]</index></name> <init>= <expr><block>{
<comment type="block">/*
0	1	2	3	4	5	6	7	8	9
*/</comment>
	<comment type="block">/*---- first 0..31 chars are skipped ----*/</comment>

	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_COMMA</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_DEC</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_0</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_9</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_B</name></expr>, <expr><name>NUM_C</name></expr>, <expr><name>NUM_D</name></expr>, <expr><name>NUM_E</name></expr>,
	<expr><name>NUM_FM</name></expr>, <expr><name>NUM_G</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_L</name></expr>, <expr><name>NUM_MI</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><name>NUM_PL</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_RN</name></expr>, <expr><name>NUM_SG</name></expr>, <expr><name>NUM_TH</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_V</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_b</name></expr>, <expr><name>NUM_c</name></expr>,
	<expr><name>NUM_d</name></expr>, <expr><name>NUM_e</name></expr>, <expr><name>NUM_fm</name></expr>, <expr><name>NUM_g</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_l</name></expr>, <expr><name>NUM_mi</name></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_pl</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_rn</name></expr>, <expr><name>NUM_sg</name></expr>, <expr><name>NUM_th</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><name>NUM_v</name></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>,
	<expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>, <expr><operator>-</operator><literal type="number">1</literal></expr>

	<comment type="block">/*---- chars over 126 are skipped ----*/</comment>
}</block></expr></init></decl>;</decl_stmt>

<comment type="block">/* ----------
 * Number processor struct
 * ----------
 */</comment>
<typedef>typedef <type><struct>struct <name>NUMProc</name>
<block>{
	<decl_stmt><decl><type><name>bool</name></type>		<name>is_to_char</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NUMDesc</name>    <modifier>*</modifier></type><name>Num</name></decl>;</decl_stmt>			<comment type="block">/* number description		*/</comment>

	<decl_stmt><decl><type><name>int</name></type>			<name>sign</name></decl>,			<comment type="block">/* '-' or '+'			*/</comment>
				<name>sign_wrote</name>,		<comment type="block">/* was sign write		*/</comment>
				<name>num_count</name>,		<comment type="block">/* number of write digits	*/</comment>
				<name>num_in</name>,			<comment type="block">/* is inside number		*/</comment>
				<name>num_curr</name>,		<comment type="block">/* current position in number	*/</comment>
				<name>out_pre_spaces</name>, <comment type="block">/* spaces before first digit	*/</comment>

				<name>read_dec</name>,		<comment type="block">/* to_number - was read dec. point	*/</comment>
				<name>read_post</name>,		<comment type="block">/* to_number - number of dec. digit */</comment>
				<name>read_pre</name>;</decl_stmt>		<comment type="block">/* to_number - number non-dec. digit */</comment>

	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>number</name></decl>,			<comment type="block">/* string with number	*/</comment>
			   <modifier>*</modifier><name>number_p</name>,		<comment type="block">/* pointer to current number position */</comment>
			   <modifier>*</modifier><name>inout</name>,			<comment type="block">/* in / out buffer	*/</comment>
			   <modifier>*</modifier><name>inout_p</name>,		<comment type="block">/* pointer to current inout position */</comment>
			   <modifier>*</modifier><name>last_relevant</name>,	<comment type="block">/* last relevant number after decimal point */</comment>

			   <modifier>*</modifier><name>L_negative_sign</name>,	<comment type="block">/* Locale */</comment>
			   <modifier>*</modifier><name>L_positive_sign</name>,
			   <modifier>*</modifier><name>decimal</name>,
			   <modifier>*</modifier><name>L_thousands_sep</name>,
			   <modifier>*</modifier><name>L_currency_symbol</name>;</decl_stmt>
}</block></struct></type> <name>NUMProc</name>;</typedef>


<comment type="block">/* ----------
 * Functions
 * ----------
 */</comment>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type><name>index_seq_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type><name>kw</name></decl></parameter>,
									   <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>KeySuffix</name> <modifier>*</modifier></type><name>suff_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>KeySuffix</name> <modifier>*</modifier></type><name>suf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>bool</name></type> <name>is_separator_char</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NUMDesc_prepare</name><parameter_list>(<parameter><decl><type><name>NUMDesc</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>parse_format</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type><name>kw</name></decl></parameter>,
						 <parameter><decl><type><specifier>const</specifier> <name>KeySuffix</name> <modifier>*</modifier></type><name>suf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ver</name></decl></parameter>, <parameter><decl><type><name>NUMDesc</name> <modifier>*</modifier></type><name>Num</name></decl></parameter>)</parameter_list>;</function_decl>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DCH_to_char</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_interval</name></decl></parameter>,
						<parameter><decl><type><name>TmToChar</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>DCH_from_char</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>TmFromChar</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>;</function_decl>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dump_node</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>;</function_decl>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

<function_decl><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>get_th</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>str_numth</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>adjust_partial_year_to_2020</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>year</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>strspace_len</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>from_char_set_mode</name><parameter_list>(<parameter><decl><type><name>TmFromChar</name> <modifier>*</modifier></type><name>tmfc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FromCharDateMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>from_char_set_int</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>from_char_parse_int_len</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>from_char_parse_int</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>seq_search</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>from_char_seq_search</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>do_to_timestamp</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>date_txt</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,
							<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>fill_str</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>FormatNode</name> <modifier>*</modifier></type><name>NUM_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>NUMDesc</name> <modifier>*</modifier></type><name>Num</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>pars_str</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>shouldFree</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>int_to_roman</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NUM_prepare_locale</name><parameter_list>(<parameter><decl><type><name>NUMProc</name> <modifier>*</modifier></type><name>Np</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>get_last_relevant_decnum</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NUM_numpart_from_char</name><parameter_list>(<parameter><decl><type><name>NUMProc</name> <modifier>*</modifier></type><name>Np</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>input_len</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>NUM_numpart_to_char</name><parameter_list>(<parameter><decl><type><name>NUMProc</name> <modifier>*</modifier></type><name>Np</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type><name>NUM_processor</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>NUMDesc</name> <modifier>*</modifier></type><name>Num</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>inout</name></decl></parameter>,
						   <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>number</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>input_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to_char_out_pre_spaces</name></decl></parameter>,
						   <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_to_char</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DCHCacheEntry</name> <modifier>*</modifier></type><name>DCH_cache_getnew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DCHCacheEntry</name> <modifier>*</modifier></type><name>DCH_cache_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>DCHCacheEntry</name> <modifier>*</modifier></type><name>DCH_cache_fetch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NUMCacheEntry</name> <modifier>*</modifier></type><name>NUM_cache_getnew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NUMCacheEntry</name> <modifier>*</modifier></type><name>NUM_cache_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>NUMCacheEntry</name> <modifier>*</modifier></type><name>NUM_cache_fetch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>;</function_decl>


<comment type="block">/* ----------
 * Fast sequential search, use index for data selection which
 * go to seq. cycle (it is very fast for unwanted strings)
 * (can't be used binary search in format parsing)
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type>
<name>index_seq_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type><name>kw</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>poz</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>KeyWord_INDEX_FILTER</name><argument_list>(<argument><expr><operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>poz</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>index</name> <operator>+</operator> <operator>(</operator><operator>*</operator><name>str</name> <operator>-</operator> <literal type="char">' '</literal><operator>)</operator><operator>)</operator><operator>)</operator> <operator>&gt;</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type><name>k</name> <init>= <expr><name>kw</name> <operator>+</operator> <name>poz</name></expr></init></decl>;</decl_stmt>

		<do>do
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>k</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>k</name></expr>;</return></block_content></block></if></if_stmt>
			<expr_stmt><expr><name>k</name><operator>++</operator></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>k</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block> while <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <operator>*</operator><name><name>k</name><operator>-&gt;</operator><name>name</name></name></expr>)</condition>;</do>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <specifier>const</specifier> <name>KeySuffix</name> <modifier>*</modifier></type>
<name>suff_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>KeySuffix</name> <modifier>*</modifier></type><name>suf</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>KeySuffix</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>s</name> <operator>=</operator> <name>suf</name></expr>;</init> <condition><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>type</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>strncmp</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>s</name></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_separator_char</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* ASCII printable character, but not letter or digit */</comment>
	<return>return <expr><operator>(</operator><operator>*</operator><name>str</name> <operator>&gt;</operator> <literal type="number">0x20</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>&lt;</operator> <literal type="number">0x7F</literal> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><operator>*</operator><name>str</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><operator>*</operator><name>str</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>!</operator><operator>(</operator><operator>*</operator><name>str</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator><operator>)</operator></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Prepare NUMDesc (number description struct) via FormatNode struct
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NUMDesc_prepare</name><parameter_list>(<parameter><decl><type><name>NUMDesc</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>NODE_TYPE_ACTION</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_EEEE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>NUM_E</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"EEEE\" must be the last pattern used"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>NUM_9</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_BRACKET</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"9\" must be ahead of \"PR\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_MULTI</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>++</operator><name><name>num</name><operator>-&gt;</operator><name>multi</name></name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name><name>num</name><operator>-&gt;</operator><name>post</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name><name>num</name><operator>-&gt;</operator><name>pre</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_0</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_BRACKET</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"0\" must be ahead of \"PR\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_ZERO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <operator>!</operator><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_ZERO</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>zero_start</name></name> <operator>=</operator> <name><name>num</name><operator>-&gt;</operator><name>pre</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name><name>num</name><operator>-&gt;</operator><name>pre</name></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name><name>num</name><operator>-&gt;</operator><name>post</name></name></expr>;</expr_stmt></block_content></block></else></if_stmt>

			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>zero_end</name></name> <operator>=</operator> <name><name>num</name><operator>-&gt;</operator><name>pre</name></name> <operator>+</operator> <name><name>num</name><operator>-&gt;</operator><name>post</name></name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_B</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name><name>num</name><operator>-&gt;</operator><name>pre</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name><name>num</name><operator>-&gt;</operator><name>post</name></name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>(</operator><operator>!</operator><call><name>IS_ZERO</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_BLANK</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_D</name></expr>:</case>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_LDECIMAL</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>need_locale</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<comment type="block">/* FALLTHROUGH */</comment>
		<case>case <expr><name>NUM_DEC</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"multiple decimal points"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_MULTI</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"V\" and decimal point together"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_DECIMAL</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_FM</name></expr>:</case>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_FILLMODE</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_S</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_LSIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"S\" twice"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_PLUS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_MINUS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_BRACKET</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"S\" and \"PL\"/\"MI\"/\"SG\"/\"PR\" together"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>=</operator> <name>NUM_LSIGN_PRE</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>pre_lsign_num</name></name> <operator>=</operator> <name><name>num</name><operator>-&gt;</operator><name>pre</name></name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>need_locale</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_LSIGN</name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>==</operator> <name>NUM_LSIGN_NONE</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>=</operator> <name>NUM_LSIGN_POST</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>need_locale</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_LSIGN</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_MI</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_LSIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"S\" and \"MI\" together"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_MINUS</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_MINUS_POST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_PL</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_LSIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"S\" and \"PL\" together"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_PLUS</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_PLUS_POST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_SG</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_LSIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"S\" and \"SG\" together"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_MINUS</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_PLUS</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_PR</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_LSIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_PLUS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_MINUS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"PR\" and \"S\"/\"PL\"/\"MI\"/\"SG\" together"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_BRACKET</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_rn</name></expr>:</case>
		<case>case <expr><name>NUM_RN</name></expr>:</case>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_ROMAN</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_L</name></expr>:</case>
		<case>case <expr><name>NUM_G</name></expr>:</case>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>need_locale</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_V</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"V\" and decimal point together"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_MULTI</name></expr>;</expr_stmt>
			<break>break;</break>

		<case>case <expr><name>NUM_E</name></expr>:</case>
			<if_stmt><if>if <condition>(<expr><call><name>IS_EEEE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot use \"EEEE\" twice"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><call><name>IS_BLANK</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_LSIGN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>IS_BRACKET</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_MINUS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_PLUS</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator>
				<call><name>IS_ROMAN</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_MULTI</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_SYNTAX_ERROR</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"EEEE\" is incompatible with other formats"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"\"EEEE\" may only be used together with digit and decimal point patterns."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_EEEE</name></expr>;</expr_stmt>
			<break>break;</break>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Format parser, search small keywords and keyword's suffixes, and make
 * format-node tree.
 *
 * for DATE-TIME &amp; NUMBER version
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>parse_format</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type><name>kw</name></decl></parameter>,
			 <parameter><decl><type><specifier>const</specifier> <name>KeySuffix</name> <modifier>*</modifier></type><name>suf</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>ver</name></decl></parameter>, <parameter><decl><type><name>NUMDesc</name> <modifier>*</modifier></type><name>Num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"to_char/number(): run parser"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <name>node</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>suffix</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><specifier>const</specifier> <name>KeySuffix</name> <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Prefix
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>ver</name> <operator>==</operator> <name>DCH_TYPE</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name>s</name> <operator>=</operator> <call><name>suff_search</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suf</name></expr></argument>, <argument><expr><name>SUFFTYPE_PREFIX</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>suffix</name> <operator>|=</operator> <name><name>s</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>str</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Keyword
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <call><name>index_seq_search</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>kw</name></expr></argument>, <argument><expr><name>index</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NODE_TYPE_ACTION</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name> <operator>=</operator> <name>suffix</name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>str</name> <operator>+=</operator> <name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * NUM version: Prepare global NUMDesc struct
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ver</name> <operator>==</operator> <name>NUM_TYPE</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>NUMDesc_prepare</name><argument_list>(<argument><expr><name>Num</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Postfix
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>ver</name> <operator>==</operator> <name>DCH_TYPE</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>str</name> <operator>&amp;&amp;</operator>
				<operator>(</operator><name>s</name> <operator>=</operator> <call><name>suff_search</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>suf</name></expr></argument>, <argument><expr><name>SUFFTYPE_POSTFIX</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>!=</operator> <name>NULL</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name> <operator>|=</operator> <name><name>s</name><operator>-&gt;</operator><name>id</name></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>s</name><operator>-&gt;</operator><name>len</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>str</name> <operator>+=</operator> <name><name>s</name><operator>-&gt;</operator><name>len</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>chlen</name></decl>;</decl_stmt>

			<comment type="block">/*
			 * Process double-quoted literal string, if any
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
				<while>while <condition>(<expr><operator>*</operator><name>str</name></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
						<break>break;</break>
					</block_content>}</block></if></if_stmt>
					<comment type="block">/* backslash quotes the next character, if any */</comment>
					<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>chlen</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NODE_TYPE_CHAR</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>character</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>chlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>character</name><index>[<expr><name>chlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>str</name> <operator>+=</operator> <name>chlen</name></expr>;</expr_stmt>
				</block_content>}</block></while>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Outside double-quoted strings, backslash is only special if
				 * it immediately precedes a double quote.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">'\\'</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'"'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>chlen</name> <operator>=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<if_stmt><if>if <condition>(<expr><name>ver</name> <operator>==</operator> <name>DCH_TYPE</name> <operator>&amp;&amp;</operator> <call><name>is_separator_char</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NODE_TYPE_SEPARATOR</name></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NODE_TYPE_SPACE</name></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NODE_TYPE_CHAR</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

				<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>character</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>chlen</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>character</name><index>[<expr><name>chlen</name></expr>]</index></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>key</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>str</name> <operator>+=</operator> <name>chlen</name></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></while>

	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>=</operator> <name>NODE_TYPE_END</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * DEBUG: Dump the FormatNode Tree (debug)
 * ----------
 */</comment>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_THth</name><parameter_list>(<parameter><type><name>_suf</name></type></parameter>)</parameter_list></cpp:macro> <cpp:value>(S_TH(_suf) ? "TH" : (S_th(_suf) ? "th" : " "))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_FM</name><parameter_list>(<parameter><type><name>_suf</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(S_FM(_suf) ? "FM" : " ")</cpp:value></cpp:define>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_node</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>a</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"to_from-char(): DUMP FORMAT"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>a</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>n</name> <operator>=</operator> <name>node</name></expr>;</init> <condition><expr><name>a</name> <operator>&lt;=</operator> <name>max</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr><operator>,</operator> <expr><name>a</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_ACTION</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"%d:\t NODE_TYPE_ACTION '%s'\t(%s,%s)"</literal></expr></argument>,
				 <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>name</name></name></expr></argument>, <argument><expr><call><name>DUMP_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>DUMP_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_CHAR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"%d:\t NODE_TYPE_CHAR '%s'"</literal></expr></argument>,
				 <argument><expr><name>a</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>character</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_END</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"%d:\t NODE_TYPE_END"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<return>return;</return>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"%d:\t unknown NODE!"</literal></expr></argument>, <argument><expr><name>a</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* DEBUG */</comment>

<comment type="block" format="doxygen">/*****************************************************************************
 *			Private utils
 *****************************************************************************/</comment>

<comment type="block">/* ----------
 * Return ST/ND/RD/TH for simple (1..9) numbers
 * type --&gt; 0 upper, 1 lower
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <specifier>const</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_th</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name>num</name></expr></argument>)</argument_list></call></expr></init></decl>,
				<decl><type ref="prev"/><name>last</name></decl>,
				<decl><type ref="prev"/><name>seclast</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>last</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>num</name> <operator>+</operator> <operator>(</operator><name>len</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name>last</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"%s\" is not a number"</literal></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * All "teens" (&lt;x&gt;1[0-9]) get 'TH/th', while &lt;x&gt;[02-9][123] still get
	 * 'ST/st', 'ND/nd', 'RD/rd', respectively
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>len</name> <operator>&gt;</operator> <literal type="number">1</literal><operator>)</operator> <operator>&amp;&amp;</operator> <operator>(</operator><operator>(</operator><name>seclast</name> <operator>=</operator> <name><name>num</name><index>[<expr><name>len</name> <operator>-</operator> <literal type="number">2</literal></expr>]</index></name><operator>)</operator> <operator>==</operator> <literal type="char">'1'</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<switch>switch <condition>(<expr><name>last</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><literal type="char">'1'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TH_UPPER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>numTH</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name><name>numth</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><literal type="char">'2'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TH_UPPER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>numTH</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name><name>numth</name><index>[<expr><literal type="number">1</literal></expr>]</index></name></expr>;</return>
		<case>case <expr><literal type="char">'3'</literal></expr>:</case>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TH_UPPER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>numTH</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name><name>numth</name><index>[<expr><literal type="number">2</literal></expr>]</index></name></expr>;</return>
		<default>default:</default>
			<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>TH_UPPER</name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name><name>numTH</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</return></block_content></block></if></if_stmt>
			<return>return <expr><name><name>numth</name><index>[<expr><literal type="number">3</literal></expr>]</index></name></expr>;</return>
	</block_content>}</block></switch>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Convert string-number to ordinal string-number
 * type --&gt; 0 upper, 1 lower
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>str_numth</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>!=</operator> <name>num</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><call><name>get_th</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><name>type</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>dest</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/*****************************************************************************
 *			upper/lower/initcap functions
 *****************************************************************************/</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>

<typedef>typedef <function_decl><type><name>int32_t</name></type> (<modifier>*</modifier><name>ICU_Convert_Func</name>) <parameter_list>(<parameter><decl><type><name>UChar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>destCapacity</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>srcLength</name></decl></parameter>,
									 <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>,
									 <parameter><decl><type><name>UErrorCode</name> <modifier>*</modifier></type><name>pErrorCode</name></decl></parameter>)</parameter_list>;</function_decl></typedef>

<function><type><specifier>static</specifier> <name>int32_t</name></type>
<name>icu_convert_case</name><parameter_list>(<parameter><decl><type><name>ICU_Convert_Func</name></type> <name>func</name></decl></parameter>, <parameter><decl><type><name>pg_locale_t</name></type> <name>mylocale</name></decl></parameter>,
				 <parameter><decl><type><name>UChar</name> <modifier>*</modifier><modifier>*</modifier></type><name>buff_dest</name></decl></parameter>, <parameter><decl><type><name>UChar</name> <modifier>*</modifier></type><name>buff_source</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>len_source</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>UErrorCode</name></type>	<name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int32_t</name></type>		<name>len_dest</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len_dest</name> <operator>=</operator> <name>len_source</name></expr>;</expr_stmt>		<comment type="block">/* try first with same length */</comment>
	<expr_stmt><expr><operator>*</operator><name>buff_dest</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len_dest</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>buff_dest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>len_dest</name> <operator>=</operator> <call><name>func</name><argument_list>(<argument><expr><operator>*</operator><name>buff_dest</name></expr></argument>, <argument><expr><name>len_dest</name></expr></argument>, <argument><expr><name>buff_source</name></expr></argument>, <argument><expr><name>len_source</name></expr></argument>,
					<argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>locale</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>U_BUFFER_OVERFLOW_ERROR</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* try again with adjusted length */</comment>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><operator>*</operator><name>buff_dest</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>buff_dest</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>len_dest</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><operator>*</operator><operator>*</operator><name>buff_dest</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>U_ZERO_ERROR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>len_dest</name> <operator>=</operator> <call><name>func</name><argument_list>(<argument><expr><operator>*</operator><name>buff_dest</name></expr></argument>, <argument><expr><name>len_dest</name></expr></argument>, <argument><expr><name>buff_source</name></expr></argument>, <argument><expr><name>len_source</name></expr></argument>,
						<argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>icu</name><operator>.</operator><name>locale</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>status</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>U_FAILURE</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"case conversion failed: %s"</literal></expr></argument>, <argument><expr><call><name>u_errorName</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>len_dest</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>int32_t</name></type>
<name>u_strToTitle_default_BI</name><parameter_list>(<parameter><decl><type><name>UChar</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>destCapacity</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>UChar</name> <modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>int32_t</name></type> <name>srcLength</name></decl></parameter>,
						<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>locale</name></decl></parameter>,
						<parameter><decl><type><name>UErrorCode</name> <modifier>*</modifier></type><name>pErrorCode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>u_strToTitle</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>destCapacity</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name>srcLength</name></expr></argument>,
						<argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>locale</name></expr></argument>, <argument><expr><name>pErrorCode</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* USE_ICU */</comment>

<comment type="block">/*
 * If the system provides the needed functions for wide-character manipulation
 * (which are all standardized by C99), then we implement upper/lower/initcap
 * using wide-character functions, if necessary.  Otherwise we use the
 * traditional &lt;ctype.h&gt; functions, which of course will not work as desired
 * in multibyte character sets.  Note that in either case we are effectively
 * assuming that the database character encoding matches the encoding implied
 * by LC_CTYPE.
 *
 * If the system provides locale_t and associated functions (which are
 * standardized by Open Group's XBD), we can support collations that are
 * neither default nor C.  The code is written to handle both combinations
 * of have-wide-characters and have-locale_t, though it's rather unlikely
 * a platform would have the latter without the former.
 */</comment>

<comment type="block">/*
 * collation-aware, wide-character-aware lower function
 *
 * We pass the number of bytes so we can pass varlena and char*
 * to this function.  The result is a palloc'd, null-terminated string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>str_tolower</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* C/POSIX collations use this path regardless of database encoding */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lc_ctype_is_c</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>asc_tolower</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>mylocale</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>collid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This typically means that the parser could not resolve a
				 * conflict of implicit collations, so report it that way.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for %s function"</literal></expr></argument>,
								<argument><expr><literal type="string">"lower()"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>mylocale</name> <operator>=</operator> <call><name>pg_newlocale_from_collation</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>mylocale</name> <operator>&amp;&amp;</operator> <name><name>mylocale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32_t</name></type>		<name>len_uchar</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int32_t</name></type>		<name>len_conv</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>buff_uchar</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>buff_conv</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>len_uchar</name> <operator>=</operator> <call><name>icu_to_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff_uchar</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len_conv</name> <operator>=</operator> <call><name>icu_convert_case</name><argument_list>(<argument><expr><name>u_strToLower</name></expr></argument>, <argument><expr><name>mylocale</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>buff_conv</name></expr></argument>, <argument><expr><name>buff_uchar</name></expr></argument>, <argument><expr><name>len_uchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>icu_from_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>buff_conv</name></expr></argument>, <argument><expr><name>len_conv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buff_uchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buff_conv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>wchar_t</name>    <modifier>*</modifier></type><name>workspace</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>curr_char</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>result_size</name></decl>;</decl_stmt>

				<comment type="block">/* Overflow paranoia */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>INT_MAX</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Output workspace cannot have more codes than input bytes */</comment>
				<expr_stmt><expr><name>workspace</name> <operator>=</operator> <operator>(</operator><name>wchar_t</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>char2wchar</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>mylocale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>curr_char</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>curr_char</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>mylocale</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>=</operator> <call><name>towlower_l</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>=</operator> <call><name>towlower</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * Make result large enough; case change might change number
				 * of bytes
				 */</comment>
				<expr_stmt><expr><name>result_size</name> <operator>=</operator> <name>curr_char</name> <operator>*</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>result_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>wchar2char</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>result_size</name></expr></argument>, <argument><expr><name>mylocale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Note: we assume that tolower_l() will not be so broken as
				 * to need an isupper_l() guard test.  When using the default
				 * collation, we apply the traditional Postgres behavior that
				 * forces ASCII-style treatment of I/i, but in non-default
				 * collations you get exactly what the collation says.
				 */</comment>
				<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>result</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>mylocale</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>tolower_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * collation-aware, wide-character-aware upper function
 *
 * We pass the number of bytes so we can pass varlena and char*
 * to this function.  The result is a palloc'd, null-terminated string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>str_toupper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* C/POSIX collations use this path regardless of database encoding */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lc_ctype_is_c</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>asc_toupper</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>mylocale</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>collid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This typically means that the parser could not resolve a
				 * conflict of implicit collations, so report it that way.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for %s function"</literal></expr></argument>,
								<argument><expr><literal type="string">"upper()"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>mylocale</name> <operator>=</operator> <call><name>pg_newlocale_from_collation</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>mylocale</name> <operator>&amp;&amp;</operator> <name><name>mylocale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32_t</name></type>		<name>len_uchar</name></decl>,
						<decl><type ref="prev"/><name>len_conv</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>buff_uchar</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>buff_conv</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>len_uchar</name> <operator>=</operator> <call><name>icu_to_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff_uchar</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len_conv</name> <operator>=</operator> <call><name>icu_convert_case</name><argument_list>(<argument><expr><name>u_strToUpper</name></expr></argument>, <argument><expr><name>mylocale</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>buff_conv</name></expr></argument>, <argument><expr><name>buff_uchar</name></expr></argument>, <argument><expr><name>len_uchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>icu_from_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>buff_conv</name></expr></argument>, <argument><expr><name>len_conv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buff_uchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buff_conv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>wchar_t</name>    <modifier>*</modifier></type><name>workspace</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>curr_char</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>result_size</name></decl>;</decl_stmt>

				<comment type="block">/* Overflow paranoia */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>INT_MAX</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Output workspace cannot have more codes than input bytes */</comment>
				<expr_stmt><expr><name>workspace</name> <operator>=</operator> <operator>(</operator><name>wchar_t</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>char2wchar</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>mylocale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>curr_char</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>curr_char</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>mylocale</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>=</operator> <call><name>towupper_l</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>=</operator> <call><name>towupper</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * Make result large enough; case change might change number
				 * of bytes
				 */</comment>
				<expr_stmt><expr><name>result_size</name> <operator>=</operator> <name>curr_char</name> <operator>*</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>result_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>wchar2char</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>result_size</name></expr></argument>, <argument><expr><name>mylocale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Note: we assume that toupper_l() will not be so broken as
				 * to need an islower_l() guard test.  When using the default
				 * collation, we apply the traditional Postgres behavior that
				 * forces ASCII-style treatment of I/i, but in non-default
				 * collations you get exactly what the collation says.
				 */</comment>
				<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>result</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>mylocale</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>toupper_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
						<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>pg_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * collation-aware, wide-character-aware initcap function
 *
 * We pass the number of bytes so we can pass varlena and char*
 * to this function.  The result is a palloc'd, null-terminated string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>str_initcap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wasalnum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* C/POSIX collations use this path regardless of database encoding */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>lc_ctype_is_c</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>asc_initcap</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>pg_locale_t</name></type> <name>mylocale</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>collid</name> <operator>!=</operator> <name>DEFAULT_COLLATION_OID</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>OidIsValid</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * This typically means that the parser could not resolve a
				 * conflict of implicit collations, so report it that way.
				 */</comment>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INDETERMINATE_COLLATION</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not determine which collation to use for %s function"</literal></expr></argument>,
								<argument><expr><literal type="string">"initcap()"</literal></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the COLLATE clause to set the collation explicitly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name>mylocale</name> <operator>=</operator> <call><name>pg_newlocale_from_collation</name><argument_list>(<argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_ICU</name></cpp:ifdef>
		<if_stmt><if>if <condition>(<expr><name>mylocale</name> <operator>&amp;&amp;</operator> <name><name>mylocale</name><operator>-&gt;</operator><name>provider</name></name> <operator>==</operator> <name>COLLPROVIDER_ICU</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int32_t</name></type>		<name>len_uchar</name></decl>,
						<decl><type ref="prev"/><name>len_conv</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>buff_uchar</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>UChar</name>	   <modifier>*</modifier></type><name>buff_conv</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>len_uchar</name> <operator>=</operator> <call><name>icu_to_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buff_uchar</name></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>len_conv</name> <operator>=</operator> <call><name>icu_convert_case</name><argument_list>(<argument><expr><name>u_strToTitle_default_BI</name></expr></argument>, <argument><expr><name>mylocale</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>buff_conv</name></expr></argument>, <argument><expr><name>buff_uchar</name></expr></argument>, <argument><expr><name>len_uchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>icu_from_uchar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>result</name></expr></argument>, <argument><expr><name>buff_conv</name></expr></argument>, <argument><expr><name>len_conv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buff_uchar</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buff_conv</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>wchar_t</name>    <modifier>*</modifier></type><name>workspace</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>curr_char</name></decl>;</decl_stmt>
				<decl_stmt><decl><type><name>size_t</name></type>		<name>result_size</name></decl>;</decl_stmt>

				<comment type="block">/* Overflow paranoia */</comment>
				<if_stmt><if>if <condition>(<expr><operator>(</operator><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&gt;</operator> <operator>(</operator><name>INT_MAX</name> <operator>/</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
							<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
							 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"out of memory"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

				<comment type="block">/* Output workspace cannot have more codes than input bytes */</comment>
				<expr_stmt><expr><name>workspace</name> <operator>=</operator> <operator>(</operator><name>wchar_t</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>wchar_t</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>char2wchar</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>nbytes</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>, <argument><expr><name>mylocale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<for>for <control>(<init><expr><name>curr_char</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>!=</operator> <literal type="number">0</literal></expr>;</condition> <incr><expr><name>curr_char</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>mylocale</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>wasalnum</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>=</operator> <call><name>towlower_l</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>=</operator> <call><name>towupper_l</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><name>wasalnum</name> <operator>=</operator> <call><name>iswalnum_l</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>wasalnum</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>=</operator> <call><name>towlower</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name> <operator>=</operator> <call><name>towupper</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><name>wasalnum</name> <operator>=</operator> <call><name>iswalnum</name><argument_list>(<argument><expr><name><name>workspace</name><index>[<expr><name>curr_char</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>

				<comment type="block">/*
				 * Make result large enough; case change might change number
				 * of bytes
				 */</comment>
				<expr_stmt><expr><name>result_size</name> <operator>=</operator> <name>curr_char</name> <operator>*</operator> <call><name>pg_database_encoding_max_length</name><argument_list>()</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>result_size</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>wchar2char</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name>workspace</name></expr></argument>, <argument><expr><name>result_size</name></expr></argument>, <argument><expr><name>mylocale</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>workspace</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * Note: we assume that toupper_l()/tolower_l() will not be so
				 * broken as to need guard tests.  When using the default
				 * collation, we apply the traditional Postgres behavior that
				 * forces ASCII-style treatment of I/i, but in non-default
				 * collations you get exactly what the collation says.
				 */</comment>
				<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>result</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
				<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>HAVE_LOCALE_T</name></cpp:ifdef>
					<if_stmt><if>if <condition>(<expr><name>mylocale</name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>wasalnum</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>tolower_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>toupper_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><name>wasalnum</name> <operator>=</operator> <call><name>isalnum_l</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>, <argument><expr><name><name>mylocale</name><operator>-&gt;</operator><name>info</name><operator>.</operator><name>lt</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name>wasalnum</name></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>pg_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
						<expr_stmt><expr><name>wasalnum</name> <operator>=</operator> <call><name>isalnum</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
				</block_content>}</block></for>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></else></if_stmt>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ASCII-only lower function
 *
 * We pass the number of bytes so we can pass varlena and char*
 * to this function.  The result is a palloc'd, null-terminated string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>asc_tolower</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>result</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>pg_ascii_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ASCII-only upper function
 *
 * We pass the number of bytes so we can pass varlena and char*
 * to this function.  The result is a palloc'd, null-terminated string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>asc_toupper</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>result</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <call><name>pg_ascii_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * ASCII-only initcap function
 *
 * We pass the number of bytes so we can pass varlena and char*
 * to this function.  The result is a palloc'd, null-terminated string.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>asc_initcap</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>size_t</name></type> <name>nbytes</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>wasalnum</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>buff</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>pnstrdup</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><name>nbytes</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>result</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name>c</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>wasalnum</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>c</name> <operator>=</operator> <call><name>pg_ascii_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>p</name> <operator>=</operator> <name>c</name> <operator>=</operator> <call><name>pg_ascii_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<comment type="block">/* we don't trust isalnum() here */</comment>
		<expr_stmt><expr><name>wasalnum</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'A'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'Z'</literal><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'a'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'z'</literal><operator>)</operator> <operator>||</operator>
					<operator>(</operator><name>c</name> <operator>&gt;=</operator> <literal type="char">'0'</literal> <operator>&amp;&amp;</operator> <name>c</name> <operator>&lt;=</operator> <literal type="char">'9'</literal><operator>)</operator><operator>)</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* convenience routines for when the input is null-terminated */</comment>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>str_tolower_z</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>str_tolower</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>str_toupper_z</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>str_toupper</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>str_initcap_z</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>str_initcap</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>asc_tolower_z</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>asc_tolower</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>asc_toupper_z</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>buff</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>asc_toupper</name><argument_list>(<argument><expr><name>buff</name></expr></argument>, <argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>buff</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* asc_initcap_z is not currently needed */</comment>


<comment type="block">/* ----------
 * Skip TM / th in FROM_CHAR
 *
 * If S_THth is on, skip two chars, assuming there are two available
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>SKIP_THth</name><parameter_list>(<parameter><type><name>ptr</name></type></parameter>, <parameter><type><name>_suf</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>do { \
		if (S_THth(_suf)) \
		{ \
			if (*(ptr)) (ptr) += pg_mblen(ptr); \
			if (*(ptr)) (ptr) += pg_mblen(ptr); \
		} \
	} while (0)</cpp:value></cpp:define>


<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
<comment type="block">/* -----------
 * DEBUG: Call for debug and for index checking; (Show ASCII char
 * and defined keyword for each used position
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>dump_index</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>KeyWord</name> <modifier>*</modifier></type><name>k</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name> <modifier>*</modifier></type><name>index</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>count</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>free_i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"TO-FROM_CHAR: Dump KeyWord Index:"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>KeyWord_INDEX_SIZE</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>index</name><index>[<expr><name>i</name></expr>]</index></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"\t%c: %s, "</literal></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name><name>k</name><index>[<expr><name><name>index</name><index>[<expr><name>i</name></expr>]</index></name></expr>]</index></name><operator>.</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>count</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>free_i</name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"\t(%d) %c %d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>, <argument><expr><name>i</name> <operator>+</operator> <literal type="number">32</literal></expr></argument>, <argument><expr><name><name>index</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"\n\t\tUsed positions: %d,\n\t\tFree positions: %d"</literal></expr></argument>,
		 <argument><expr><name>count</name></expr></argument>, <argument><expr><name>free_i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>							<comment type="block">/* DEBUG */</comment>

<comment type="block">/* ----------
 * Return true if next format picture is not digit value
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_next_separator</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>n</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_END</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_ACTION</name> <operator>&amp;&amp;</operator> <call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Next node
	 */</comment>
	<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* end of format string is treated like a non-digit separator */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_END</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_ACTION</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>is_digit</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>character</name><index>[<expr><literal type="number">1</literal></expr>]</index></name> <operator>==</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator>
			 <call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <name><name>n</name><operator>-&gt;</operator><name>character</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>				<comment type="block">/* some non-digit input (separator) */</comment>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>adjust_partial_year_to_2020</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>year</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Adjust all dates toward 2020; this is effectively what happens when we
	 * assume '70' is 1970 and '69' is 2069.
	 */</comment>
	<comment type="block">/* Force 0-69 into the 2000's */</comment>
	<if_stmt><if>if <condition>(<expr><name>year</name> <operator>&lt;</operator> <literal type="number">70</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>year</name> <operator>+</operator> <literal type="number">2000</literal></expr>;</return></block_content></block></if>
	<comment type="block">/* Force 70-99 into the 1900's */</comment>
	<if type="elseif">else if <condition>(<expr><name>year</name> <operator>&lt;</operator> <literal type="number">100</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>year</name> <operator>+</operator> <literal type="number">1900</literal></expr>;</return></block_content></block></if>
	<comment type="block">/* Force 100-519 into the 2000's */</comment>
	<if type="elseif">else if <condition>(<expr><name>year</name> <operator>&lt;</operator> <literal type="number">520</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>year</name> <operator>+</operator> <literal type="number">2000</literal></expr>;</return></block_content></block></if>
	<comment type="block">/* Force 520-999 into the 1000's */</comment>
	<if type="elseif">else if <condition>(<expr><name>year</name> <operator>&lt;</operator> <literal type="number">1000</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>year</name> <operator>+</operator> <literal type="number">1000</literal></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>year</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>int</name></type>
<name>strspace_len</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>str</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt>
		<expr_stmt><expr><name>len</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></while>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Set the date mode of a from-char conversion.
 *
 * Puke if the date mode has already been set, and the caller attempts to set
 * it to a conflicting mode.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>from_char_set_mode</name><parameter_list>(<parameter><decl><type><name>TmFromChar</name> <modifier>*</modifier></type><name>tmfc</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FromCharDateMode</name></type> <name>mode</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>mode</name> <operator>!=</operator> <name>FROM_CHAR_DATE_NONE</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>-&gt;</operator><name>mode</name></name> <operator>==</operator> <name>FROM_CHAR_DATE_NONE</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tmfc</name><operator>-&gt;</operator><name>mode</name></name> <operator>=</operator> <name>mode</name></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name><name>tmfc</name><operator>-&gt;</operator><name>mode</name></name> <operator>!=</operator> <name>mode</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid combination of date conventions"</literal></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Do not mix Gregorian and ISO week date "</literal>
							 <literal type="string">"conventions in a formatting template."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Set the integer pointed to by 'dest' to the given value.
 *
 * Puke if the destination integer has previously been set to some other
 * non-zero value.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>from_char_set_int</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>dest</name> <operator>!=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><name>dest</name> <operator>!=</operator> <name>value</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"conflicting values for \"%s\" field in formatting string"</literal></expr></argument>,
						<argument><expr><name><name>node</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"This value contradicts a previous setting for "</literal>
						   <literal type="string">"the same field type."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <name>value</name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read a single integer from the source string, into the int pointed to by
 * 'dest'. If 'dest' is NULL, the result is discarded.
 *
 * In fixed-width mode (the node does not have the FM suffix), consume at most
 * 'len' characters.  However, any leading whitespace isn't counted in 'len'.
 *
 * We use strtol() to recover the integer value from the source string, in
 * accordance with the given FormatNode.
 *
 * If the conversion completes successfully, src will have been advanced to
 * point at the character immediately following the last character used in the
 * conversion.
 *
 * Return the number of characters consumed.
 *
 * Note that from_char_parse_int() provides a more convenient wrapper where
 * the length of the field is the same as the length of the format keyword (as
 * with DD and MI).
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>from_char_parse_int_len</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>long</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name></type>		<name><name>copy</name><index>[<expr><name>DCH_MAX_ITEM_SIZ</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>init</name> <init>= <expr><operator>*</operator><name>src</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>used</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Skip any whitespace before parsing the integer.
	 */</comment>
	<expr_stmt><expr><operator>*</operator><name>src</name> <operator>+=</operator> <call><name>strspace_len</name><argument_list>(<argument><expr><operator>*</operator><name>src</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>len</name> <operator>&lt;=</operator> <name>DCH_MAX_ITEM_SIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>used</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>strlcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><operator>*</operator><name>src</name></expr></argument>, <argument><expr><name>len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>node</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_next_separator</name><argument_list>(<argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * This node is in Fill Mode, or the next node is known to be a
		 * non-digit value, so we just slurp as many characters as we can get.
		 */</comment>
		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>init</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * We need to pull exactly the number of characters given in 'len' out
		 * of the string, and convert those.
		 */</comment>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>last</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>used</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"source string too short for \"%s\" formatting field"</literal></expr></argument>,
							<argument><expr><name><name>node</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Field requires %d characters, but only %d "</literal>
							   <literal type="string">"remain."</literal></expr></argument>,
							   <argument><expr><name>len</name></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If your source string is not fixed-width, try "</literal>
							 <literal type="string">"using the \"FM\" modifier."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>errno</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>strtol</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>last</name></expr></argument>, <argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>used</name> <operator>=</operator> <name>last</name> <operator>-</operator> <name>copy</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>used</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>used</name> <operator>&lt;</operator> <name>len</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value \"%s\" for \"%s\""</literal></expr></argument>,
							<argument><expr><name>copy</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Field requires %d characters, but only %d "</literal>
							   <literal type="string">"could be parsed."</literal></expr></argument>, <argument><expr><name>len</name></expr></argument>, <argument><expr><name>used</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"If your source string is not fixed-width, try "</literal>
							 <literal type="string">"using the \"FM\" modifier."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name>src</name> <operator>+=</operator> <name>used</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>src</name> <operator>==</operator> <name>init</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value \"%s\" for \"%s\""</literal></expr></argument>,
						<argument><expr><name>copy</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Value must be an integer."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>errno</name> <operator>==</operator> <name>ERANGE</name> <operator>||</operator> <name><name>result</name> <argument_list type="generic">&lt; <argument><expr><name>INT_MIN</name> <operator>||</operator> <name>result</name></expr></argument> &gt;</argument_list></name> <name>INT_MAX</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"value for \"%s\" in source string is out of range"</literal></expr></argument>,
						<argument><expr><name><name>node</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Value must be in the range %d to %d."</literal></expr></argument>,
						   <argument><expr><name>INT_MIN</name></expr></argument>, <argument><expr><name>INT_MAX</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>dest</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name>result</name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><operator>*</operator><name>src</name> <operator>-</operator> <name>init</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Call from_char_parse_int_len(), using the length of the format keyword as
 * the expected length of the field.
 *
 * Don't call this function if the field differs in length from the format
 * keyword (as with HH24; the keyword length is 4, but the field length is 2).
 * In such cases, call from_char_parse_int_len() instead to specify the
 * required length explicitly.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>from_char_parse_int</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<return>return <expr><call><name>from_char_parse_int_len</name><argument_list>(<argument><expr><name>dest</name></expr></argument>, <argument><expr><name>src</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>node</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Sequential search with to upper/lower conversion
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>seq_search</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>name</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>a</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>last</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>*</operator><name>name</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* set first char */</comment>
	<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ONE_UPPER</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>ALL_UPPER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>pg_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>ALL_LOWER</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>name</name> <operator>=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<for>for <control>(<init><expr><name>last</name> <operator>=</operator> <literal type="number">0</literal></expr><operator>,</operator> <expr><name>a</name> <operator>=</operator> <name>array</name></expr>;</init> <condition><expr><operator>*</operator><name>a</name> <operator>!=</operator> <name>NULL</name></expr>;</condition> <incr><expr><name>a</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* compare first chars */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>name</name> <operator>!=</operator> <operator>*</operator><operator>*</operator><name>a</name></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>p</name> <operator>=</operator> <operator>*</operator><name>a</name> <operator>+</operator> <literal type="number">1</literal></expr><operator>,</operator> <expr><name>n</name> <operator>=</operator> <name>name</name> <operator>+</operator> <literal type="number">1</literal></expr>;</init><condition>;</condition> <incr><expr><name>n</name><operator>++</operator></expr><operator>,</operator> <expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<comment type="block">/* search fragment (max) only */</comment>
			<if_stmt><if>if <condition>(<expr><name>max</name> <operator>&amp;&amp;</operator> <name>i</name> <operator>==</operator> <name>max</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<return>return <expr><name>a</name> <operator>-</operator> <name>array</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* full size */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name>len</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
				<return>return <expr><name>a</name> <operator>-</operator> <name>array</name></expr>;</return>
			</block_content>}</block></if></if_stmt>
			<comment type="block">/* Not found in array 'a' */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>n</name> <operator>==</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>

			<comment type="block">/*
			 * Convert (but convert new chars only)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <name>last</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name>type</name> <operator>==</operator> <name>ONE_UPPER</name> <operator>||</operator> <name>type</name> <operator>==</operator> <name>ALL_LOWER</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>pg_tolower</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<if type="elseif">else if <condition>(<expr><name>type</name> <operator>==</operator> <name>ALL_UPPER</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><operator>*</operator><name>n</name> <operator>=</operator> <call><name>pg_toupper</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>last</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"N: %c, P: %c, A: %s (%s)"</literal></expr></argument>,
				 <argument><expr><operator>*</operator><name>n</name></expr></argument>, <argument><expr><operator>*</operator><name>p</name></expr></argument>, <argument><expr><operator>*</operator><name>a</name></expr></argument>, <argument><expr><name>name</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>n</name> <operator>!=</operator> <operator>*</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></for>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Perform a sequential search in 'array' for text matching the first 'max'
 * characters of the source string.
 *
 * If a match is found, copy the array index of the match into the integer
 * pointed to by 'dest', advance 'src' to the end of the part of the string
 * which matched, and return the number of characters consumed.
 *
 * If the string doesn't match, throw an error.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>from_char_seq_search</name><parameter_list>(<parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>dest</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>src</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><specifier>const</specifier> <modifier>*</modifier></type><name>array</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>type</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>,
					 <parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>;</decl_stmt>

	<expr_stmt><expr><operator>*</operator><name>dest</name> <operator>=</operator> <call><name>seq_search</name><argument_list>(<argument><expr><operator>*</operator><name>src</name></expr></argument>, <argument><expr><name>array</name></expr></argument>, <argument><expr><name>type</name></expr></argument>, <argument><expr><name>max</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name></type>		<name><name>copy</name><index>[<expr><name>DCH_MAX_ITEM_SIZ</name> <operator>+</operator> <literal type="number">1</literal></expr>]</index></name></decl>;</decl_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>max</name> <operator>&lt;=</operator> <name>DCH_MAX_ITEM_SIZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>strlcpy</name><argument_list>(<argument><expr><name>copy</name></expr></argument>, <argument><expr><operator>*</operator><name>src</name></expr></argument>, <argument><expr><name>max</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid value \"%s\" for \"%s\""</literal></expr></argument>,
						<argument><expr><name>copy</name></expr></argument>, <argument><expr><name><name>node</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"The given value did not match any of the allowed "</literal>
						   <literal type="string">"values for this field."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><operator>*</operator><name>src</name> <operator>+=</operator> <name>len</name></expr>;</expr_stmt>
	<return>return <expr><name>len</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Process a TmToChar struct as denoted by a list of FormatNodes.
 * The formatted data is written to the string pointed to by 'out'.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DCH_to_char</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_interval</name></decl></parameter>, <parameter><decl><type><name>TmToChar</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>out</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name> <init>= <expr><operator>&amp;</operator><name><name>in</name><operator>-&gt;</operator><name>tm</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/* cache localized days and months */</comment>
	<expr_stmt><expr><call><name>cache_locale_time</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>s</name> <operator>=</operator> <name>out</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>node</name></expr>;</init> <condition><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>NODE_TYPE_END</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>NODE_TYPE_ACTION</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>character</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<switch>switch <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DCH_A_M</name></expr>:</case>
			<case>case <expr><name>DCH_P_M</name></expr>:</case>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>%</operator> <name>HOURS_PER_DAY</name> <operator>&gt;=</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>
					   ?</condition><then> <expr><name>P_M_STR</name></expr> </then><else>: <expr><name>A_M_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_AM</name></expr>:</case>
			<case>case <expr><name>DCH_PM</name></expr>:</case>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>%</operator> <name>HOURS_PER_DAY</name> <operator>&gt;=</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>
					   ?</condition><then> <expr><name>PM_STR</name></expr> </then><else>: <expr><name>AM_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_a_m</name></expr>:</case>
			<case>case <expr><name>DCH_p_m</name></expr>:</case>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>%</operator> <name>HOURS_PER_DAY</name> <operator>&gt;=</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>
					   ?</condition><then> <expr><name>p_m_STR</name></expr> </then><else>: <expr><name>a_m_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_am</name></expr>:</case>
			<case>case <expr><name>DCH_pm</name></expr>:</case>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>%</operator> <name>HOURS_PER_DAY</name> <operator>&gt;=</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr>
					   ?</condition><then> <expr><name>pm_STR</name></expr> </then><else>: <expr><name>am_STR</name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_HH</name></expr>:</case>
			<case>case <expr><name>DCH_HH12</name></expr>:</case>

				<comment type="block">/*
				 * display time as shown on a 12-hour clock, even for
				 * intervals
				 */</comment>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
						<argument><expr><ternary><condition><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>%</operator> <operator>(</operator><name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr> </then><else>:
						<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>%</operator> <operator>(</operator><name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal><operator>)</operator></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_HH24</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
						<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MI</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
						<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_SS</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
						<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MS</name></expr>:</case>		<comment type="block">/* millisecond */</comment>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%03d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <operator>(</operator><name><name>in</name><operator>-&gt;</operator><name>fsec</name></name> <operator>/</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">1000</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_US</name></expr>:</case>		<comment type="block">/* microsecond */</comment>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%06d"</literal></expr></argument>, <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>in</name><operator>-&gt;</operator><name>fsec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_SSSS</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>*</operator> <name>SECS_PER_HOUR</name> <operator>+</operator>
						<name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>*</operator> <name>SECS_PER_MINUTE</name> <operator>+</operator>
						<name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_tz</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>tmtcTzn</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<comment type="block">/* We assume here that timezone names aren't localized */</comment>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>asc_tolower_z</name><argument_list>(<argument><expr><call><name>tmtcTzn</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>p</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_TZ</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>tmtcTzn</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>tmtcTzn</name><argument_list>(<argument><expr><name>in</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_TZH</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%c%02d"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></argument>,
						<argument><expr><call><name>abs</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_TZM</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%02d"</literal></expr></argument>,
						<argument><expr><operator>(</operator><call><name>abs</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr></argument>)</argument_list></call> <operator>%</operator> <name>SECS_PER_HOUR</name><operator>)</operator> <operator>/</operator> <name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_OF</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%c%0*d"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></argument>,
						<argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>,
						<argument><expr><call><name>abs</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr></argument>)</argument_list></call> <operator>/</operator> <name>SECS_PER_HOUR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>abs</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr></argument>)</argument_list></call> <operator>%</operator> <name>SECS_PER_HOUR</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">":%02d"</literal></expr></argument>,
							<argument><expr><operator>(</operator><call><name>abs</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_gmtoff</name></name></expr></argument>)</argument_list></call> <operator>%</operator> <name>SECS_PER_HOUR</name><operator>)</operator> <operator>/</operator> <name>SECS_PER_MINUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_A_D</name></expr>:</case>
			<case>case <expr><name>DCH_B_C</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>B_C_STR</name></expr> </then><else>: <expr><name>A_D_STR</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_AD</name></expr>:</case>
			<case>case <expr><name>DCH_BC</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>BC_STR</name></expr> </then><else>: <expr><name>AD_STR</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_a_d</name></expr>:</case>
			<case>case <expr><name>DCH_b_c</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>b_c_STR</name></expr> </then><else>: <expr><name>a_d_STR</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_ad</name></expr>:</case>
			<case>case <expr><name>DCH_bc</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><operator>(</operator><ternary><condition><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&lt;=</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><name>bc_STR</name></expr> </then><else>: <expr><name>ad_STR</name></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MONTH</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_toupper_z</name><argument_list>(<argument><expr><name><name>localized_full_months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">9</literal></expr></else></ternary></expr></argument>,
							<argument><expr><call><name>asc_toupper_z</name><argument_list>(<argument><expr><name><name>months_full</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Month</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_initcap_z</name><argument_list>(<argument><expr><name><name>localized_full_months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">9</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name><name>months_full</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_month</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_tolower_z</name><argument_list>(<argument><expr><name><name>localized_full_months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">9</literal></expr></else></ternary></expr></argument>,
							<argument><expr><call><name>asc_tolower_z</name><argument_list>(<argument><expr><name><name>months_full</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MON</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_toupper_z</name><argument_list>(<argument><expr><name><name>localized_abbrev_months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>asc_toupper_z</name><argument_list>(<argument><expr><name><name>months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Mon</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_initcap_z</name><argument_list>(<argument><expr><name><name>localized_abbrev_months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_mon</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_tolower_z</name><argument_list>(<argument><expr><name><name>localized_abbrev_months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>asc_tolower_z</name><argument_list>(<argument><expr><name><name>months</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MM</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
						<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_DAY</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_toupper_z</name><argument_list>(<argument><expr><name><name>localized_full_days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">9</literal></expr></else></ternary></expr></argument>,
							<argument><expr><call><name>asc_toupper_z</name><argument_list>(<argument><expr><name><name>days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Day</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_initcap_z</name><argument_list>(<argument><expr><name><name>localized_full_days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">9</literal></expr></else></ternary></expr></argument>,
							<argument><expr><name><name>days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_day</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_tolower_z</name><argument_list>(<argument><expr><name><name>localized_full_days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">9</literal></expr></else></ternary></expr></argument>,
							<argument><expr><call><name>asc_tolower_z</name><argument_list>(<argument><expr><name><name>days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_DY</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_toupper_z</name><argument_list>(<argument><expr><name><name>localized_abbrev_days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>asc_toupper_z</name><argument_list>(<argument><expr><name><name>days_short</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Dy</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_initcap_z</name><argument_list>(<argument><expr><name><name>localized_abbrev_days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>days_short</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_dy</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_TM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>str_tolower_z</name><argument_list>(<argument><expr><name><name>localized_abbrev_days</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

					<if_stmt><if>if <condition>(<expr><call><name>strlen</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name> <operator>+</operator> <name>TM_SUFFIX_LEN</name><operator>)</operator> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"localized string format value too long"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>asc_tolower_z</name><argument_list>(<argument><expr><name><name>days_short</name><index>[<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_DDD</name></expr>:</case>
			<case>case <expr><name>DCH_IDDD</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></argument>,
						<argument><expr><ternary><condition><expr><operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>DCH_DDD</name><operator>)</operator></expr> ?</condition><then>
						<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_yday</name></name></expr> </then><else>:
						<expr><call><name>date2isoyearday</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_DD</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_D</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_ID</name></expr>:</case>
				<expr_stmt><expr><name>INVALID_FOR_INTERVAL</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>==</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">7</literal></expr> </then><else>: <expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_WW</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>,
						<argument><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_yday</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_IW</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">2</literal></expr></else></ternary></expr></argument>,
						<argument><expr><call><name>date2isoweek</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Q</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">3</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_CC</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><name>is_interval</name></expr>)</condition><block type="pseudo"><block_content>	<comment type="block">/* straight calculation */</comment>
					<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
						<comment type="block">/* Century 20 == 1901 - 2000 */</comment>
						<expr_stmt><expr><name>i</name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">100</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<comment type="block">/* Century 6BC == 600BC - 501BC */</comment>
						<expr_stmt><expr><name>i</name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>/</operator> <literal type="number">100</literal> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&lt;=</operator> <literal type="number">99</literal> <operator>&amp;&amp;</operator> <name>i</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">99</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><ternary><condition><expr><operator>(</operator><name>i</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></else></ternary></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Y_YYY</name></expr>:</case>
				<expr_stmt><expr><name>i</name> <operator>=</operator> <call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call> <operator>/</operator> <literal type="number">1000</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d,%03d"</literal></expr></argument>, <argument><expr><name>i</name></expr></argument>,
						<argument><expr><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>i</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_YYYY</name></expr>:</case>
			<case>case <expr><name>DCH_IYYY</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
						<expr><ternary><condition><expr><operator>(</operator><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">4</literal></expr> </then><else>: <expr><literal type="number">5</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>DCH_YYYY</name></expr> ?</condition><then>
						 <expr><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call></expr> </then><else>:
						 <expr><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><call><name>date2isoyear</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>,
												  <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>,
												  <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_YYY</name></expr>:</case>
			<case>case <expr><name>DCH_IYY</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
						<expr><ternary><condition><expr><operator>(</operator><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">3</literal></expr> </then><else>: <expr><literal type="number">4</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>DCH_YYY</name></expr> ?</condition><then>
						 <expr><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call></expr> </then><else>:
						 <expr><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><call><name>date2isoyear</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>,
												  <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>,
												  <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>%</operator> <literal type="number">1000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_YY</name></expr>:</case>
			<case>case <expr><name>DCH_IY</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%0*d"</literal></expr></argument>,
						<argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>:
						<expr><ternary><condition><expr><operator>(</operator><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">2</literal></expr> </then><else>: <expr><literal type="number">3</literal></expr></else></ternary></expr></else></ternary></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>DCH_YY</name></expr> ?</condition><then>
						 <expr><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call></expr> </then><else>:
						 <expr><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><call><name>date2isoyear</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>,
												  <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>,
												  <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>%</operator> <literal type="number">100</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Y</name></expr>:</case>
			<case>case <expr><name>DCH_I</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%1d"</literal></expr></argument>,
						<argument><expr><operator>(</operator><ternary><condition><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name> <operator>==</operator> <name>DCH_Y</name></expr> ?</condition><then>
						 <expr><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call></expr> </then><else>:
						 <expr><call><name>ADJUST_YEAR</name><argument_list>(<argument><expr><call><name>date2isoyear</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>,
												  <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>,
												  <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr></argument>,
									 <argument><expr><name>is_interval</name></expr></argument>)</argument_list></call></expr></else></ternary><operator>)</operator> <operator>%</operator> <literal type="number">10</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_RM</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">4</literal></expr></else></ternary></expr></argument>,
						<argument><expr><name><name>rm_months_upper</name><index>[<expr><name>MONTHS_PER_YEAR</name> <operator>-</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_rm</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%*s"</literal></expr></argument>, <argument><expr><ternary><condition><expr><call><name>S_FM</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><operator>-</operator><literal type="number">4</literal></expr></else></ternary></expr></argument>,
						<argument><expr><name><name>rm_months_lower</name><index>[<expr><name>MONTHS_PER_YEAR</name> <operator>-</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_W</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>/</operator> <literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_J</name></expr>:</case>
				<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>S_THth</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>str_numth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name>s</name></expr></argument>, <argument><expr><call><name>S_TH_TYPE</name><argument_list>(<argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>
	</block_content>}</block></for>

	<expr_stmt><expr><operator>*</operator><name>s</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Process a string as denoted by a list of FormatNodes.
 * The TmFromChar struct pointed to by 'out' is populated with the results.
 *
 * Note: we currently don't have any to_interval() function, so there
 * is no need here for INVALID_FOR_INTERVAL checks.
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>DCH_from_char</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>in</name></decl></parameter>, <parameter><decl><type><name>TmFromChar</name> <modifier>*</modifier></type><name>out</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>s</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name></decl>,
				<decl><type ref="prev"/><name>value</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>fx_mode</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* number of extra skipped characters (more than given in format string) */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>extra_skip</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>node</name></expr><operator>,</operator> <expr><name>s</name> <operator>=</operator> <name>in</name></expr>;</init> <condition><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>NODE_TYPE_END</name> <operator>&amp;&amp;</operator> <operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/*
		 * Ignore spaces at the beginning of the string and before fields when
		 * not in FX (fixed width) mode.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fx_mode</name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>NODE_TYPE_ACTION</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name> <operator>!=</operator> <name>DCH_FX</name><operator>)</operator> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_ACTION</name> <operator>||</operator> <name>n</name> <operator>==</operator> <name>node</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>extra_skip</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_SPACE</name> <operator>||</operator> <name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_SEPARATOR</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fx_mode</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In non FX (fixed format) mode one format string space or
				 * separator match to one space or separator in input string.
				 * Or match nothing if there is no space or separator in the
				 * current position of input string.
				 */</comment>
				<expr_stmt><expr><name>extra_skip</name><operator>--</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>is_separator_char</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
					<expr_stmt><expr><name>extra_skip</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * In FX mode, on format string space or separator we consume
				 * exactly one character from input string.  Notice we don't
				 * insist that the consumed character match the format's
				 * character.
				 */</comment>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>NODE_TYPE_ACTION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Text character, so consume one character from input string.
			 * Notice we don't insist that the consumed character match the
			 * format's character.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fx_mode</name></expr>)</condition>
			<block>{<block_content>
				<comment type="block">/*
				 * In non FX mode we might have skipped some extra characters
				 * (more than specified in format string) before.  In this
				 * case we don't skip input string character, because it might
				 * be part of field.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name>extra_skip</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>extra_skip</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name>s</name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name>s</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>from_char_set_mode</name><argument_list>(<argument><expr><name>out</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>date_mode</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<switch>switch <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition>
		<block>{<block_content>
			<case>case <expr><name>DCH_FX</name></expr>:</case>
				<expr_stmt><expr><name>fx_mode</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_A_M</name></expr>:</case>
			<case>case <expr><name>DCH_P_M</name></expr>:</case>
			<case>case <expr><name>DCH_a_m</name></expr>:</case>
			<case>case <expr><name>DCH_p_m</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>ampm_strings_long</name></expr></argument>,
									 <argument><expr><name>ALL_UPPER</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>pm</name></name></expr></argument>, <argument><expr><name>value</name> <operator>%</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>clock</name></name> <operator>=</operator> <name>CLOCK_12_HOUR</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_AM</name></expr>:</case>
			<case>case <expr><name>DCH_PM</name></expr>:</case>
			<case>case <expr><name>DCH_am</name></expr>:</case>
			<case>case <expr><name>DCH_pm</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>ampm_strings</name></expr></argument>,
									 <argument><expr><name>ALL_UPPER</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>pm</name></name></expr></argument>, <argument><expr><name>value</name> <operator>%</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>clock</name></name> <operator>=</operator> <name>CLOCK_12_HOUR</name></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_HH</name></expr>:</case>
			<case>case <expr><name>DCH_HH12</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>hh</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>clock</name></name> <operator>=</operator> <name>CLOCK_12_HOUR</name></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_HH24</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>hh</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MI</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>mi</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_SS</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>ss</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MS</name></expr>:</case>		<comment type="block">/* millisecond */</comment>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>from_char_parse_int_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>ms</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<comment type="block">/*
				 * 25 is 0.25 and 250 is 0.25 too; 025 is 0.025 and not 0.25
				 */</comment>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>ms</name></name> <operator>*=</operator> <ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">100</literal></expr> </then><else>:
					<expr><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">10</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_US</name></expr>:</case>		<comment type="block">/* microsecond */</comment>
				<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>from_char_parse_int_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>us</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">6</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>us</name></name> <operator>*=</operator> <ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr> ?</condition><then> <expr><literal type="number">100000</literal></expr> </then><else>:
					<expr><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">2</literal></expr> ?</condition><then> <expr><literal type="number">10000</literal></expr> </then><else>:
					<expr><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">3</literal></expr> ?</condition><then> <expr><literal type="number">1000</literal></expr> </then><else>:
					<expr><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">4</literal></expr> ?</condition><then> <expr><literal type="number">100</literal></expr> </then><else>:
					<expr><ternary><condition><expr><name>len</name> <operator>==</operator> <literal type="number">5</literal></expr> ?</condition><then> <expr><literal type="number">10</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr></else></ternary></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_SSSS</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>ssss</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_tz</name></expr>:</case>
			<case>case <expr><name>DCH_TZ</name></expr>:</case>
			<case>case <expr><name>DCH_OF</name></expr>:</case>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"formatting field \"%s\" is only supported in to_char"</literal></expr></argument>,
								<argument><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>name</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_TZH</name></expr>:</case>

				<comment type="block">/*
				 * Value of TZH might be negative.  And the issue is that we
				 * might swallow minus sign as the separator.  So, if we have
				 * skipped more characters than specified in the format
				 * string, then we consider prepending last skipped minus to
				 * TZH.
				 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'+'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>tzsign</name></name> <operator>=</operator> <ternary><condition><expr><operator>*</operator><name>s</name> <operator>==</operator> <literal type="char">'-'</literal></expr> ?</condition><then> <expr><operator>-</operator><literal type="number">1</literal></expr> </then><else>: <expr><operator>+</operator><literal type="number">1</literal></expr></else></ternary></expr>;</expr_stmt>
					<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><name>extra_skip</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <operator>*</operator><operator>(</operator><name>s</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>tzsign</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
					<else>else<block type="pseudo"><block_content>
						<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>tzsign</name></name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
				</block_content>}</block></else></if_stmt>

				<expr_stmt><expr><call><name>from_char_parse_int_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>tzh</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_TZM</name></expr>:</case>
				<comment type="block">/* assign positive timezone sign if TZH was not seen before */</comment>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>out</name><operator>-&gt;</operator><name>tzsign</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>tzsign</name></name> <operator>=</operator> <operator>+</operator><literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>from_char_parse_int_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>tzm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_A_D</name></expr>:</case>
			<case>case <expr><name>DCH_B_C</name></expr>:</case>
			<case>case <expr><name>DCH_a_d</name></expr>:</case>
			<case>case <expr><name>DCH_b_c</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>adbc_strings_long</name></expr></argument>,
									 <argument><expr><name>ALL_UPPER</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>bc</name></name></expr></argument>, <argument><expr><name>value</name> <operator>%</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_AD</name></expr>:</case>
			<case>case <expr><name>DCH_BC</name></expr>:</case>
			<case>case <expr><name>DCH_ad</name></expr>:</case>
			<case>case <expr><name>DCH_bc</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>adbc_strings</name></expr></argument>,
									 <argument><expr><name>ALL_UPPER</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>len</name></name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>bc</name></name></expr></argument>, <argument><expr><name>value</name> <operator>%</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MONTH</name></expr>:</case>
			<case>case <expr><name>DCH_Month</name></expr>:</case>
			<case>case <expr><name>DCH_month</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>months_full</name></expr></argument>, <argument><expr><name>ONE_UPPER</name></expr></argument>,
									 <argument><expr><name>MAX_MONTH_LEN</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>mm</name></name></expr></argument>, <argument><expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MON</name></expr>:</case>
			<case>case <expr><name>DCH_Mon</name></expr>:</case>
			<case>case <expr><name>DCH_mon</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>months</name></expr></argument>, <argument><expr><name>ONE_UPPER</name></expr></argument>,
									 <argument><expr><name>MAX_MON_LEN</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>mm</name></name></expr></argument>, <argument><expr><name>value</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_MM</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>mm</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_DAY</name></expr>:</case>
			<case>case <expr><name>DCH_Day</name></expr>:</case>
			<case>case <expr><name>DCH_day</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>days</name></expr></argument>, <argument><expr><name>ONE_UPPER</name></expr></argument>,
									 <argument><expr><name>MAX_DAY_LEN</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>d</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>d</name></name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_DY</name></expr>:</case>
			<case>case <expr><name>DCH_Dy</name></expr>:</case>
			<case>case <expr><name>DCH_dy</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>days</name></expr></argument>, <argument><expr><name>ONE_UPPER</name></expr></argument>,
									 <argument><expr><name>MAX_DY_LEN</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>d</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>d</name></name><operator>++</operator></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_DDD</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>ddd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_IDDD</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>ddd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">3</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_DD</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>dd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_D</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>d</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_ID</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int_len</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>d</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<comment type="block">/* Shift numbering to match Gregorian where Sunday = 1 */</comment>
				<if_stmt><if>if <condition>(<expr><operator>++</operator><name><name>out</name><operator>-&gt;</operator><name>d</name></name> <operator>&gt;</operator> <literal type="number">7</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>d</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_WW</name></expr>:</case>
			<case>case <expr><name>DCH_IW</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>ww</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Q</name></expr>:</case>

				<comment type="block">/*
				 * We ignore 'Q' when converting to date because it is unclear
				 * which date in the quarter to use, and some people specify
				 * both quarter and month, so if it was honored it might
				 * conflict with the supplied month. That is also why we don't
				 * throw an error.
				 *
				 * We still parse the source string for an integer, but it
				 * isn't stored anywhere in 'out'.
				 */</comment>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>NULL</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_CC</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>cc</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Y_YYY</name></expr>:</case>
				<block>{<block_content>
					<decl_stmt><decl><type><name>int</name></type>			<name>matched</name></decl>,
								<decl><type ref="prev"/><name>years</name></decl>,
								<decl><type ref="prev"/><name>millennia</name></decl>,
								<decl><type ref="prev"/><name>nch</name></decl>;</decl_stmt>

					<expr_stmt><expr><name>matched</name> <operator>=</operator> <call><name>sscanf</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><literal type="string">"%d,%03d%n"</literal></expr></argument>, <argument><expr><operator>&amp;</operator><name>millennia</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>years</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>nch</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name>matched</name> <operator>&lt;</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
								<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
								 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input string for \"Y,YYY\""</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
					<expr_stmt><expr><name>years</name> <operator>+=</operator> <operator>(</operator><name>millennia</name> <operator>*</operator> <literal type="number">1000</literal><operator>)</operator></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>year</name></name></expr></argument>, <argument><expr><name>years</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>yysz</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
					<expr_stmt><expr><name>s</name> <operator>+=</operator> <name>nch</name></expr>;</expr_stmt>
					<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block>
				<break>break;</break>
			<case>case <expr><name>DCH_YYYY</name></expr>:</case>
			<case>case <expr><name>DCH_IYYY</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>yysz</name></name> <operator>=</operator> <literal type="number">4</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_YYY</name></expr>:</case>
			<case>case <expr><name>DCH_IYY</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>year</name></name> <operator>=</operator> <call><name>adjust_partial_year_to_2020</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>year</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>yysz</name></name> <operator>=</operator> <literal type="number">3</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_YY</name></expr>:</case>
			<case>case <expr><name>DCH_IY</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>year</name></name> <operator>=</operator> <call><name>adjust_partial_year_to_2020</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>year</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>yysz</name></name> <operator>=</operator> <literal type="number">2</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_Y</name></expr>:</case>
			<case>case <expr><name>DCH_I</name></expr>:</case>
				<if_stmt><if>if <condition>(<expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call> <operator>&lt;</operator> <literal type="number">4</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>year</name></name> <operator>=</operator> <call><name>adjust_partial_year_to_2020</name><argument_list>(<argument><expr><name><name>out</name><operator>-&gt;</operator><name>year</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<expr_stmt><expr><name><name>out</name><operator>-&gt;</operator><name>yysz</name></name> <operator>=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_RM</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>rm_months_upper</name></expr></argument>,
									 <argument><expr><name>ALL_UPPER</name></expr></argument>, <argument><expr><name>MAX_RM_LEN</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>mm</name></name></expr></argument>, <argument><expr><name>MONTHS_PER_YEAR</name> <operator>-</operator> <name>value</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_rm</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_seq_search</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>rm_months_lower</name></expr></argument>,
									 <argument><expr><name>ALL_LOWER</name></expr></argument>, <argument><expr><name>MAX_RM_LEN</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>from_char_set_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>mm</name></name></expr></argument>, <argument><expr><name>MONTHS_PER_YEAR</name> <operator>-</operator> <name>value</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_W</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>w</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
			<case>case <expr><name>DCH_J</name></expr>:</case>
				<expr_stmt><expr><call><name>from_char_parse_int</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>out</name><operator>-&gt;</operator><name>j</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>s</name></expr></argument>, <argument><expr><name>n</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><call><name>SKIP_THth</name><argument_list>(<argument><expr><name>s</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>suffix</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<break>break;</break>
		</block_content>}</block></switch>

		<comment type="block">/* Ignore all spaces after fields */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>fx_mode</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>extra_skip</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<while>while <condition>(<expr><operator>*</operator><name>s</name> <operator>!=</operator> <literal type="char">'\0'</literal> <operator>&amp;&amp;</operator> <call><name>isspace</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name>s</name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>s</name><operator>++</operator></expr>;</expr_stmt>
				<expr_stmt><expr><name>extra_skip</name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></while>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * The invariant for DCH cache entry management is that DCHCounter is equal
 * to the maximum age value among the existing entries, and we increment it
 * whenever an access occurs.  If we approach overflow, deal with that by
 * halving all the age values, so that we retain a fairly accurate idea of
 * which entries are oldest.
 */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>DCH_prevent_counter_overflow</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>DCHCounter</name> <operator>&gt;=</operator> <operator>(</operator><name>INT_MAX</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_DCHCache</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>DCHCache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>age</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name>DCHCounter</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* select a DCHCacheEntry to hold the given format picture */</comment>
<function><type><specifier>static</specifier> <name>DCHCacheEntry</name> <modifier>*</modifier></type>
<name>DCH_cache_getnew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DCHCacheEntry</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure we can advance DCHCounter below */</comment>
	<expr_stmt><expr><call><name>DCH_prevent_counter_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If cache is full, remove oldest entry (or recycle first not-valid one)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n_DCHCache</name> <operator>&gt;=</operator> <name>DCH_CACHE_ENTRIES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DCHCacheEntry</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><name><name>DCHCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"cache is full (%d)"</literal></expr></argument>, <argument><expr><name>n_DCHCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name><name>old</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>DCH_CACHE_ENTRIES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>ent</name> <operator>=</operator> <name><name>DCHCache</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ent</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>old</name> <operator>=</operator> <name>ent</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>age</name></name> <operator>&lt;</operator> <name><name>old</name><operator>-&gt;</operator><name>age</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>old</name> <operator>=</operator> <name>ent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"OLD: '%s' AGE: %d"</literal></expr></argument>, <argument><expr><name><name>old</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>old</name><operator>-&gt;</operator><name>age</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>old</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>old</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>DCH_CACHE_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>old</name><operator>-&gt;</operator><name>age</name></name> <operator>=</operator> <operator>(</operator><operator>++</operator><name>DCHCounter</name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* caller is expected to fill format, then set valid */</comment>
		<return>return <expr><name>old</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"NEW (%d)"</literal></expr></argument>, <argument><expr><name>n_DCHCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>DCHCache</name><index>[<expr><name>n_DCHCache</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>DCHCache</name><index>[<expr><name>n_DCHCache</name></expr>]</index></name> <operator>=</operator> <name>ent</name> <operator>=</operator> <operator>(</operator><name>DCHCacheEntry</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>DCHCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>DCH_CACHE_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>age</name></name> <operator>=</operator> <operator>(</operator><operator>++</operator><name>DCHCounter</name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* caller is expected to fill format, then set valid */</comment>
		<expr_stmt><expr><operator>++</operator><name>n_DCHCache</name></expr>;</expr_stmt>
		<return>return <expr><name>ent</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* look for an existing DCHCacheEntry matching the given format picture */</comment>
<function><type><specifier>static</specifier> <name>DCHCacheEntry</name> <modifier>*</modifier></type>
<name>DCH_cache_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Ensure we can advance DCHCounter below */</comment>
	<expr_stmt><expr><call><name>DCH_prevent_counter_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_DCHCache</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>DCHCacheEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name><name>DCHCache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>valid</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>age</name></name> <operator>=</operator> <operator>(</operator><operator>++</operator><name>DCHCounter</name><operator>)</operator></expr>;</expr_stmt>
			<return>return <expr><name>ent</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find or create a DCHCacheEntry for the given format picture */</comment>
<function><type><specifier>static</specifier> <name>DCHCacheEntry</name> <modifier>*</modifier></type>
<name>DCH_cache_fetch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>DCHCacheEntry</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ent</name> <operator>=</operator> <call><name>DCH_cache_search</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Not in the cache, must run parser and save a new format-picture to
		 * the cache.  Do not mark the cache entry valid until parsing
		 * succeeds.
		 */</comment>
		<expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>DCH_cache_getnew</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>parse_format</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>format</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>DCH_keywords</name></expr></argument>,
					 <argument><expr><name>DCH_suff</name></expr></argument>, <argument><expr><name>DCH_index</name></expr></argument>, <argument><expr><name>DCH_TYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ent</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Format a date/time or interval into a string according to fmt.
 * We parse fmt into a list of FormatNodes.  This is then passed to DCH_to_char
 * for formatting.
 */</comment>
<function><type><specifier>static</specifier> <name>text</name> <modifier>*</modifier></type>
<name>datetime_to_char_body</name><parameter_list>(<parameter><decl><type><name>TmToChar</name> <modifier>*</modifier></type><name>tmtc</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_interval</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fmt_str</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>incache</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmt_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Convert fmt to C string
	 */</comment>
	<expr_stmt><expr><name>fmt_str</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>fmt_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>fmt_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate workspace for result as C string
	 */</comment>
	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>fmt_len</name> <operator>*</operator> <name>DCH_MAX_ITEM_SIZ</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fmt_len</name> <operator>&gt;</operator> <name>DCH_CACHE_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Allocate new memory if format picture is bigger than static cache
		 * and do not use cache (call parser always)
		 */</comment>
		<expr_stmt><expr><name>incache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>format</name> <operator>=</operator> <operator>(</operator><name>FormatNode</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>fmt_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FormatNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>parse_format</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>fmt_str</name></expr></argument>, <argument><expr><name>DCH_keywords</name></expr></argument>,
					 <argument><expr><name>DCH_suff</name></expr></argument>, <argument><expr><name>DCH_index</name></expr></argument>, <argument><expr><name>DCH_TYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Use cache buffers
		 */</comment>
		<decl_stmt><decl><type><name>DCHCacheEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><call><name>DCH_cache_fetch</name><argument_list>(<argument><expr><name>fmt_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>incache</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>format</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>format</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<comment type="block">/* The real work is here */</comment>
	<expr_stmt><expr><call><name>DCH_to_char</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>is_interval</name></expr></argument>, <argument><expr><name>tmtc</name></expr></argument>, <argument><expr><name>result</name></expr></argument>, <argument><expr><name>collid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>incache</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fmt_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* convert C-string result to TEXT format */</comment>
	<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>cstring_to_text</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>res</name></expr>;</return>
</block_content>}</block></function>

<comment type="block" format="doxygen">/****************************************************************************
 *				Public routines
 ***************************************************************************/</comment>

<comment type="block">/* -------------------
 * TIMESTAMP to_char()
 * -------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>timestamp_to_char</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>dt</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TmToChar</name></type>	<name>tmtc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>thisdate</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ZERO_tmtc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>tmtcTm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>tmtcFsec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>thisdate</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>=</operator> <operator>(</operator><name>thisdate</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">7</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_yday</name></name> <operator>=</operator> <name>thisdate</name> <operator>-</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>res</name> <operator>=</operator> <call><name>datetime_to_char_body</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>Datum</name></type>
<name>timestamptz_to_char</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TimestampTz</name></type> <name>dt</name> <init>= <expr><call><name>PG_GETARG_TIMESTAMP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TmToChar</name></type>	<name>tmtc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>thisdate</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <call><name>TIMESTAMP_NOT_FINITE</name><argument_list>(<argument><expr><name>dt</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ZERO_tmtc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>tmtcTm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>timestamp2tm</name><argument_list>(<argument><expr><name>dt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>tmtcFsec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>tmtcTzn</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>thisdate</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_wday</name></name> <operator>=</operator> <operator>(</operator><name>thisdate</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <literal type="number">7</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_yday</name></name> <operator>=</operator> <name>thisdate</name> <operator>-</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>res</name> <operator>=</operator> <call><name>datetime_to_char_body</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block">/* -------------------
 * INTERVAL to_char()
 * -------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>interval_to_char</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Interval</name>   <modifier>*</modifier></type><name>it</name> <init>= <expr><call><name>PG_GETARG_INTERVAL_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TmToChar</name></type>	<name>tmtc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call> <operator>&lt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>ZERO_tmtc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>tm</name> <operator>=</operator> <call><name>tmtcTm</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>interval2tm</name><argument_list>(<argument><expr><operator>*</operator><name>it</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><call><name>tmtcFsec</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* wday is meaningless, yday approximates the total span in days */</comment>
	<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_yday</name></name> <operator>=</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>*</operator> <name>MONTHS_PER_YEAR</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name><operator>)</operator> <operator>*</operator> <name>DAYS_PER_MONTH</name> <operator>+</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><operator>(</operator><name>res</name> <operator>=</operator> <call><name>datetime_to_char_body</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmtc</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>res</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ---------------------
 * TO_TIMESTAMP()
 *
 * Make Timestamp from date_str which is formatted at argument 'fmt'
 * ( to_timestamp is reverse to_char() )
 * ---------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>to_timestamp</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>date_txt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Timestamp</name></type>	<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>tz</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>do_to_timestamp</name><argument_list>(<argument><expr><name>date_txt</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Use the specified time zone, if any. */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>.</operator><name>tm_zone</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name> <init>= <expr><call><name>DecodeTimezone</name><argument_list>(<argument><expr><call><name>unconstify</name><argument_list>(<argument><expr><name>char</name> <operator>*</operator></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_zone</name></name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>dterr</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>dterr</name></expr></argument>, <argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>date_txt</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="string">"timestamptz"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>DetermineTimeZoneOffset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>session_timezone</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>tm2timestamp</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><name>fsec</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tz</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>result</name></expr></argument>)</argument_list></call> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"timestamp out of range"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_TIMESTAMP</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * TO_DATE
 *	Make Date from date_str which is formatted at argument 'fmt'
 * ----------
 */</comment>
<function><type><name>Datum</name></type>
<name>to_date</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>date_txt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>DateADT</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name><name>struct</name> <name>pg_tm</name></name></type> <name>tm</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>fsec_t</name></type>		<name>fsec</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>do_to_timestamp</name><argument_list>(<argument><expr><name>date_txt</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tm</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>fsec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Prevent overflow in Julian-day routines */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_JULIAN</name><argument_list>(<argument><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range: \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>date_txt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>date2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>.</operator><name>tm_year</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><name><name>tm</name><operator>.</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <name>POSTGRES_EPOCH_JDATE</name></expr>;</expr_stmt>

	<comment type="block">/* Now check for just-out-of-range dates */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_VALID_DATE</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_DATETIME_VALUE_OUT_OF_RANGE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"date out of range: \"%s\""</literal></expr></argument>,
						<argument><expr><call><name>text_to_cstring</name><argument_list>(<argument><expr><name>date_txt</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_DATEADT</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * do_to_timestamp: shared code for to_timestamp and to_date
 *
 * Parse the 'date_txt' according to 'fmt', return results as a struct pg_tm
 * and fractional seconds.
 *
 * We parse 'fmt' into a list of FormatNodes, which is then passed to
 * DCH_from_char to populate a TmFromChar with the parsed contents of
 * 'date_txt'.
 *
 * The TmFromChar is then analysed and converted into the final results in
 * struct 'tm' and 'fsec'.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>do_to_timestamp</name><parameter_list>(<parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>date_txt</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>fmt</name></decl></parameter>,
				<parameter><decl><type><name><name>struct</name> <name>pg_tm</name></name> <modifier>*</modifier></type><name>tm</name></decl></parameter>, <parameter><decl><type><name>fsec_t</name> <modifier>*</modifier></type><name>fsec</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TmFromChar</name></type>	<name>tmfc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmt_len</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>date_str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>fmask</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>date_str</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>date_txt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ZERO_tmfc</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmfc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ZERO_tm</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>fmask</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>					<comment type="block">/* bit mask for ValidateDate() */</comment>

	<expr_stmt><expr><name>fmt_len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>fmt_len</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>fmt_str</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>bool</name></type>		<name>incache</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>fmt_str</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>fmt_len</name> <operator>&gt;</operator> <name>DCH_CACHE_SIZE</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Allocate new memory if format picture is bigger than static
			 * cache and do not use cache (call parser always)
			 */</comment>
			<expr_stmt><expr><name>incache</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

			<expr_stmt><expr><name>format</name> <operator>=</operator> <operator>(</operator><name>FormatNode</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>fmt_len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FormatNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>parse_format</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>fmt_str</name></expr></argument>, <argument><expr><name>DCH_keywords</name></expr></argument>,
						 <argument><expr><name>DCH_suff</name></expr></argument>, <argument><expr><name>DCH_index</name></expr></argument>, <argument><expr><name>DCH_TYPE</name></expr></argument>, <argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Use cache buffers
			 */</comment>
			<decl_stmt><decl><type><name>DCHCacheEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><call><name>DCH_cache_fetch</name><argument_list>(<argument><expr><name>fmt_str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>incache</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>format</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>format</name></name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<comment type="block">/* dump_node(format, fmt_len); */</comment>
		<comment type="block">/* dump_index(DCH_keywords, DCH_index); */</comment>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<expr_stmt><expr><call><name>DCH_from_char</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>date_str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>tmfc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>fmt_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>incache</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DEBUG_TMFC</name><argument_list>(<argument><expr><operator>&amp;</operator><name>tmfc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Convert to_date/to_timestamp input fields to standard 'tm'
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>ssss</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>x</name> <init>= <expr><name><name>tmfc</name><operator>.</operator><name>ssss</name></name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name>x</name> <operator>/</operator> <name>SECS_PER_HOUR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> <operator>%=</operator> <name>SECS_PER_HOUR</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name>x</name> <operator>/</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>x</name> <operator>%=</operator> <name>SECS_PER_MINUTE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name>x</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>ss</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>ss</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>mi</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>mi</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>hh</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>hh</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>clock</name></name> <operator>==</operator> <name>CLOCK_12_HOUR</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&lt;</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tmfc</name><operator>.</operator><name>pm</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>WARNING</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hour \"%d\" is invalid for the 12-hour clock"</literal></expr></argument>,
								<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the 24-hour clock, or give an hour between 1 and 12."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tmfc</name><operator>.</operator><name>pm</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>-</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
						<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"hour \"%d\" is invalid for the 12-hour clock"</literal></expr></argument>,
								<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name></expr></argument>)</argument_list></call><operator>,</operator>
						 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Use the 24-hour clock, or give an hour between 1 and 12."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>pm</name></name> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&lt;</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>+=</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>!</operator><name><name>tmfc</name><operator>.</operator><name>pm</name></name> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>==</operator> <name>HOURS_PER_DAY</name> <operator>/</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>year</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * If CC and YY (or Y) are provided, use YY as 2 low-order digits for
		 * the year in the given century.  Keep in mind that the 21st century
		 * AD runs from 2001-2100, not 2000-2099; 6th century BC runs from
		 * 600BC to 501BC.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>&amp;&amp;</operator> <name><name>tmfc</name><operator>.</operator><name>yysz</name></name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>bc</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <operator>-</operator><name><name>tmfc</name><operator>.</operator><name>cc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>year</name></name> <operator>%</operator> <literal type="number">100</literal></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+=</operator> <operator>(</operator><name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>-</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/* find century year for dates ending in "00" */</comment>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <operator>(</operator><ternary><condition><expr><operator>(</operator><name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator></expr> ?</condition><then> <expr><literal type="number">0</literal></expr> </then><else>: <expr><literal type="number">1</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/* If a 4-digit year is provided, we use that and ignore CC. */</comment>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>year</name></name></expr>;</expr_stmt>
			<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>bc</name></name> <operator>&amp;&amp;</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>-</operator><operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>cc</name></name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* use first year of century */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>bc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>=</operator> <operator>-</operator><name><name>tmfc</name><operator>.</operator><name>cc</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<comment type="block">/* +1 because 21st century started in 2001 */</comment>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <operator>(</operator><name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<comment type="block">/* +1 because year == 599 is 600 BC */</comment>
			<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>cc</name></name> <operator>*</operator> <literal type="number">100</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>YEAR</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>j</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name><name>tmfc</name><operator>.</operator><name>j</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <name>DTK_DATE_M</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>ww</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>mode</name></name> <operator>==</operator> <name>FROM_CHAR_DATE_ISOWEEK</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * If tmfc.d is not set, then the date is left at the beginning of
			 * the ISO week (Monday).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>d</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>isoweekdate2date</name><argument_list>(<argument><expr><name><name>tmfc</name><operator>.</operator><name>ww</name></name></expr></argument>, <argument><expr><name><name>tmfc</name><operator>.</operator><name>d</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>isoweek2date</name><argument_list>(<argument><expr><name><name>tmfc</name><operator>.</operator><name>ww</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <name>DTK_DATE_M</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>tmfc</name><operator>.</operator><name>ddd</name></name> <operator>=</operator> <operator>(</operator><name><name>tmfc</name><operator>.</operator><name>ww</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>w</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>tmfc</name><operator>.</operator><name>dd</name></name> <operator>=</operator> <operator>(</operator><name><name>tmfc</name><operator>.</operator><name>w</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <literal type="number">7</literal> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>dd</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>dd</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>mm</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>mm</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>ddd</name></name> <operator>&amp;&amp;</operator> <operator>(</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;=</operator> <literal type="number">1</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * The month and day field have not been set, so we use the
		 * day-of-year field to populate them.  Depending on the date mode,
		 * this field may be interpreted as a Gregorian day-of-year, or an ISO
		 * week date day-of-year.
		 */</comment>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name> <operator>&amp;&amp;</operator> <operator>!</operator><name><name>tmfc</name><operator>.</operator><name>bc</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_DATETIME_FORMAT</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"cannot calculate day of year without year information"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>mode</name></name> <operator>==</operator> <name>FROM_CHAR_DATE_ISOWEEK</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>j0</name></decl>;</decl_stmt>		<comment type="block">/* zeroth day of the ISO year, in Julian */</comment>

			<expr_stmt><expr><name>j0</name> <operator>=</operator> <call><name>isoweek2j</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>j2date</name><argument_list>(<argument><expr><name>j0</name> <operator>+</operator> <name><name>tmfc</name><operator>.</operator><name>ddd</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <name>DTK_DATE_M</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><specifier>const</specifier> <name>int</name>  <modifier>*</modifier></type><name>y</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

			<decl_stmt><decl><type><specifier>static</specifier> <specifier>const</specifier> <name>int</name></type> <name><name>ysum</name><index>[<expr><literal type="number">2</literal></expr>]</index><index>[<expr><literal type="number">13</literal></expr>]</index></name> <init>= <expr><block>{
				<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">59</literal></expr>, <expr><literal type="number">90</literal></expr>, <expr><literal type="number">120</literal></expr>, <expr><literal type="number">151</literal></expr>, <expr><literal type="number">181</literal></expr>, <expr><literal type="number">212</literal></expr>, <expr><literal type="number">243</literal></expr>, <expr><literal type="number">273</literal></expr>, <expr><literal type="number">304</literal></expr>, <expr><literal type="number">334</literal></expr>, <expr><literal type="number">365</literal></expr>}</block></expr>,
			<expr><block>{<expr><literal type="number">0</literal></expr>, <expr><literal type="number">31</literal></expr>, <expr><literal type="number">60</literal></expr>, <expr><literal type="number">91</literal></expr>, <expr><literal type="number">121</literal></expr>, <expr><literal type="number">152</literal></expr>, <expr><literal type="number">182</literal></expr>, <expr><literal type="number">213</literal></expr>, <expr><literal type="number">244</literal></expr>, <expr><literal type="number">274</literal></expr>, <expr><literal type="number">305</literal></expr>, <expr><literal type="number">335</literal></expr>, <expr><literal type="number">366</literal></expr>}</block></expr>}</block></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>y</name> <operator>=</operator> <name><name>ysum</name><index>[<expr><call><name>isleap</name><argument_list>(<argument><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_year</name></name></expr></argument>)</argument_list></call></expr>]</index></name></expr>;</expr_stmt>

			<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;=</operator> <name>MONTHS_PER_YEAR</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>ddd</name></name> <operator>&lt;=</operator> <name><name>y</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
					<break>break;</break></block_content></block></if></if_stmt>
			</block_content>}</block></for>
			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mon</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_mday</name></name> <operator>=</operator> <name><name>tmfc</name><operator>.</operator><name>ddd</name></name> <operator>-</operator> <name><name>y</name><index>[<expr><name>i</name> <operator>-</operator> <literal type="number">1</literal></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>fmask</name> <operator>|=</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>MONTH</name></expr></argument>)</argument_list></call> <operator>|</operator> <call><name>DTK_M</name><argument_list>(<argument><expr><name>DAY</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>ms</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <name><name>tmfc</name><operator>.</operator><name>ms</name></name> <operator>*</operator> <literal type="number">1000</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>us</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>fsec</name> <operator>+=</operator> <name><name>tmfc</name><operator>.</operator><name>us</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Range-check date fields according to bit mask computed above */</comment>
	<if_stmt><if>if <condition>(<expr><name>fmask</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* We already dealt with AD/BC, so pass isjulian = true */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>dterr</name> <init>= <expr><call><name>ValidateDate</name><argument_list>(<argument><expr><name>fmask</name></expr></argument>, <argument><expr><name>true</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>dterr</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Force the error to be DTERR_FIELD_OVERFLOW even if ValidateDate
			 * said DTERR_MD_FIELD_OVERFLOW, because we don't want to print an
			 * irrelevant hint about datestyle.
			 */</comment>
			<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>DTERR_FIELD_OVERFLOW</name></expr></argument>, <argument><expr><name>date_str</name></expr></argument>, <argument><expr><literal type="string">"timestamp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Range-check time fields too */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_hour</name></name> <operator>&gt;=</operator> <name>HOURS_PER_DAY</name> <operator>||</operator>
		<name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_min</name></name> <operator>&gt;=</operator> <name>MINS_PER_HOUR</name> <operator>||</operator>
		<name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tm</name><operator>-&gt;</operator><name>tm_sec</name></name> <operator>&gt;=</operator> <name>SECS_PER_MINUTE</name> <operator>||</operator>
		<operator>*</operator><name>fsec</name> <operator>&lt;</operator> <call><name>INT64CONST</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name>fsec</name> <operator>&gt;=</operator> <name>USECS_PER_SEC</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>DTERR_FIELD_OVERFLOW</name></expr></argument>, <argument><expr><name>date_str</name></expr></argument>, <argument><expr><literal type="string">"timestamp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Save parsed time-zone into tm-&gt;tm_zone if it was specified */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>tzsign</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tz</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tmfc</name><operator>.</operator><name>tzh</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tmfc</name><operator>.</operator><name>tzh</name></name> <operator>&gt;</operator> <name>MAX_TZDISP_HOUR</name> <operator>||</operator>
			<name><name>tmfc</name><operator>.</operator><name>tzm</name></name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>||</operator> <name><name>tmfc</name><operator>.</operator><name>tzm</name></name> <operator>&gt;=</operator> <name>MINS_PER_HOUR</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>DateTimeParseError</name><argument_list>(<argument><expr><name>DTERR_TZDISP_OVERFLOW</name></expr></argument>, <argument><expr><name>date_str</name></expr></argument>, <argument><expr><literal type="string">"timestamp"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>tz</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%c%02d:%02d"</literal></expr></argument>,
					  <argument><expr><ternary><condition><expr><name><name>tmfc</name><operator>.</operator><name>tzsign</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr> ?</condition><then> <expr><literal type="char">'+'</literal></expr> </then><else>: <expr><literal type="char">'-'</literal></expr></else></ternary></expr></argument>, <argument><expr><name><name>tmfc</name><operator>.</operator><name>tzh</name></name></expr></argument>, <argument><expr><name><name>tmfc</name><operator>.</operator><name>tzm</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>tm</name><operator>-&gt;</operator><name>tm_zone</name></name> <operator>=</operator> <name>tz</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>DEBUG_TM</name><argument_list>(<argument><expr><name>tm</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>date_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**********************************************************************
 *	the NUMBER version part
 *********************************************************************/</comment>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>fill_str</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>c</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>max</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><name>c</name></expr></argument>, <argument><expr><name>max</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>str</name> <operator>+</operator> <name>max</name><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	<return>return <expr><name>str</name></expr>;</return>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>zeroize_NUM</name><parameter_list>(<parameter><type><name>_n</name></type></parameter>)</parameter_list></cpp:macro> \
<cpp:value>do { \
	(_n)-&gt;flag		= 0;	\
	(_n)-&gt;lsign		= 0;	\
	(_n)-&gt;pre		= 0;	\
	(_n)-&gt;post		= 0;	\
	(_n)-&gt;pre_lsign_num = 0;	\
	(_n)-&gt;need_locale	= 0;	\
	(_n)-&gt;multi		= 0;	\
	(_n)-&gt;zero_start	= 0;	\
	(_n)-&gt;zero_end		= 0;	\
} while(0)</cpp:value></cpp:define>

<comment type="block">/* This works the same as DCH_prevent_counter_overflow */</comment>
<function><type><specifier>static</specifier> <specifier>inline</specifier> <name>void</name></type>
<name>NUM_prevent_counter_overflow</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>NUMCounter</name> <operator>&gt;=</operator> <operator>(</operator><name>INT_MAX</name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_NUMCache</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>NUMCache</name><index>[<expr><name>i</name></expr>]</index></name><operator>-&gt;</operator><name>age</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></for>
		<expr_stmt><expr><name>NUMCounter</name> <operator>&gt;&gt;=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/* select a NUMCacheEntry to hold the given format picture */</comment>
<function><type><specifier>static</specifier> <name>NUMCacheEntry</name> <modifier>*</modifier></type>
<name>NUM_cache_getnew</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NUMCacheEntry</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

	<comment type="block">/* Ensure we can advance NUMCounter below */</comment>
	<expr_stmt><expr><call><name>NUM_prevent_counter_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If cache is full, remove oldest entry (or recycle first not-valid one)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>n_NUMCache</name> <operator>&gt;=</operator> <name>NUM_CACHE_ENTRIES</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NUMCacheEntry</name> <modifier>*</modifier></type><name>old</name> <init>= <expr><name><name>NUMCache</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"Cache is full (%d)"</literal></expr></argument>, <argument><expr><name>n_NUMCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name><name>old</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition>
		<block>{<block_content>
			<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">1</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>NUM_CACHE_ENTRIES</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
			<block>{<block_content>
				<expr_stmt><expr><name>ent</name> <operator>=</operator> <name><name>NUMCache</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>ent</name><operator>-&gt;</operator><name>valid</name></name></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><name>old</name> <operator>=</operator> <name>ent</name></expr>;</expr_stmt>
					<break>break;</break>
				</block_content>}</block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>age</name></name> <operator>&lt;</operator> <name><name>old</name><operator>-&gt;</operator><name>age</name></name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name>old</name> <operator>=</operator> <name>ent</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></for>
		</block_content>}</block></if></if_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"OLD: \"%s\" AGE: %d"</literal></expr></argument>, <argument><expr><name><name>old</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name><name>old</name><operator>-&gt;</operator><name>age</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><name><name>old</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>old</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>NUM_CACHE_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>old</name><operator>-&gt;</operator><name>age</name></name> <operator>=</operator> <operator>(</operator><operator>++</operator><name>NUMCounter</name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* caller is expected to fill format and Num, then set valid */</comment>
		<return>return <expr><name>old</name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"NEW (%d)"</literal></expr></argument>, <argument><expr><name>n_NUMCache</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>NUMCache</name><index>[<expr><name>n_NUMCache</name></expr>]</index></name> <operator>==</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>NUMCache</name><index>[<expr><name>n_NUMCache</name></expr>]</index></name> <operator>=</operator> <name>ent</name> <operator>=</operator> <operator>(</operator><name>NUMCacheEntry</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAllocZero</name><argument_list>(<argument><expr><name>TopMemoryContext</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NUMCacheEntry</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>StrNCpy</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>NUM_CACHE_SIZE</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>age</name></name> <operator>=</operator> <operator>(</operator><operator>++</operator><name>NUMCounter</name><operator>)</operator></expr>;</expr_stmt>
		<comment type="block">/* caller is expected to fill format and Num, then set valid */</comment>
		<expr_stmt><expr><operator>++</operator><name>n_NUMCache</name></expr>;</expr_stmt>
		<return>return <expr><name>ent</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* look for an existing NUMCacheEntry matching the given format picture */</comment>
<function><type><specifier>static</specifier> <name>NUMCacheEntry</name> <modifier>*</modifier></type>
<name>NUM_cache_search</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/* Ensure we can advance NUMCounter below */</comment>
	<expr_stmt><expr><call><name>NUM_prevent_counter_overflow</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>n_NUMCache</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>NUMCacheEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><name><name>NUMCache</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>ent</name><operator>-&gt;</operator><name>valid</name></name> <operator>&amp;&amp;</operator> <call><name>strcmp</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>str</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>age</name></name> <operator>=</operator> <operator>(</operator><operator>++</operator><name>NUMCounter</name><operator>)</operator></expr>;</expr_stmt>
			<return>return <expr><name>ent</name></expr>;</return>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>NULL</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Find or create a NUMCacheEntry for the given format picture */</comment>
<function><type><specifier>static</specifier> <name>NUMCacheEntry</name> <modifier>*</modifier></type>
<name>NUM_cache_fetch</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>NUMCacheEntry</name> <modifier>*</modifier></type><name>ent</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>ent</name> <operator>=</operator> <call><name>NUM_cache_search</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call><operator>)</operator> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Not in the cache, must run parser and save a new format-picture to
		 * the cache.  Do not mark the cache entry valid until parsing
		 * succeeds.
		 */</comment>
		<expr_stmt><expr><name>ent</name> <operator>=</operator> <call><name>NUM_cache_getnew</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>zeroize_NUM</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>parse_format</name><argument_list>(<argument><expr><name><name>ent</name><operator>-&gt;</operator><name>format</name></name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>NUM_keywords</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NUM_index</name></expr></argument>, <argument><expr><name>NUM_TYPE</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>ent</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>ent</name><operator>-&gt;</operator><name>valid</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<return>return <expr><name>ent</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Cache routine for NUM to_char version
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>FormatNode</name> <modifier>*</modifier></type>
<name>NUM_cache</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>len</name></decl></parameter>, <parameter><decl><type><name>NUMDesc</name> <modifier>*</modifier></type><name>Num</name></decl></parameter>, <parameter><decl><type><name>text</name> <modifier>*</modifier></type><name>pars_str</name></decl></parameter>, <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>shouldFree</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>format</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>str</name> <operator>=</operator> <call><name>text_to_cstring</name><argument_list>(<argument><expr><name>pars_str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <name>NUM_CACHE_SIZE</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Allocate new memory if format picture is bigger than static cache
		 * and do not use cache (call parser always)
		 */</comment>
		<expr_stmt><expr><name>format</name> <operator>=</operator> <operator>(</operator><name>FormatNode</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>FormatNode</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><operator>*</operator><name>shouldFree</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>zeroize_NUM</name><argument_list>(<argument><expr><name>Num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>parse_format</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><name>str</name></expr></argument>, <argument><expr><name>NUM_keywords</name></expr></argument>,
					 <argument><expr><name>NULL</name></expr></argument>, <argument><expr><name>NUM_index</name></expr></argument>, <argument><expr><name>NUM_TYPE</name></expr></argument>, <argument><expr><name>Num</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Use cache buffers
		 */</comment>
		<decl_stmt><decl><type><name>NUMCacheEntry</name> <modifier>*</modifier></type><name>ent</name> <init>= <expr><call><name>NUM_cache_fetch</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>shouldFree</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>format</name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>format</name></name></expr>;</expr_stmt>

		<comment type="block">/*
		 * Copy cache to used struct
		 */</comment>
		<expr_stmt><expr><name><name>Num</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>Num</name><operator>.</operator><name>flag</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>Num</name><operator>.</operator><name>lsign</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Num</name><operator>-&gt;</operator><name>pre</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>Num</name><operator>.</operator><name>pre</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Num</name><operator>-&gt;</operator><name>post</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>Num</name><operator>.</operator><name>post</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Num</name><operator>-&gt;</operator><name>pre_lsign_num</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>Num</name><operator>.</operator><name>pre_lsign_num</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Num</name><operator>-&gt;</operator><name>need_locale</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>Num</name><operator>.</operator><name>need_locale</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Num</name><operator>-&gt;</operator><name>multi</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>Num</name><operator>.</operator><name>multi</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Num</name><operator>-&gt;</operator><name>zero_start</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>Num</name><operator>.</operator><name>zero_start</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Num</name><operator>-&gt;</operator><name>zero_end</name></name> <operator>=</operator> <name><name>ent</name><operator>-&gt;</operator><name>Num</name><operator>.</operator><name>zero_end</name></name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
	<comment type="block">/* dump_node(format, len); */</comment>
	<expr_stmt><expr><call><name>dump_index</name><argument_list>(<argument><expr><name>NUM_keywords</name></expr></argument>, <argument><expr><name>NUM_index</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>format</name></expr>;</return>
</block_content>}</block></function>


<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>int_to_roman</name><parameter_list>(<parameter><decl><type><name>int</name></type> <name>number</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>num</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>p</name> <init>= <expr><name>NULL</name></expr></init></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>result</name></decl>,
				<decl><type ref="prev"/><name><name>numstr</name><index>[<expr><literal type="number">12</literal></expr>]</index></name></decl>;</decl_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><literal type="number">16</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>result</name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>number</name> <operator>&gt;</operator> <literal type="number">3999</literal> <operator>||</operator> <name>number</name> <operator>&lt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>fill_str</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><literal type="number">15</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<return>return <expr><name>result</name></expr>;</return>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>snprintf</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>numstr</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><literal type="string">"%d"</literal></expr></argument>, <argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>p</name> <operator>=</operator> <name>numstr</name></expr>;</init> <condition><expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>;</condition> <incr><expr><name>p</name><operator>++</operator></expr><operator>,</operator> <expr><operator>--</operator><name>len</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>num</name> <operator>=</operator> <operator>*</operator><name>p</name> <operator>-</operator> <literal type="number">49</literal></expr>;</expr_stmt>			<comment type="block">/* 48 ascii + 1 */</comment>
		<if_stmt><if>if <condition>(<expr><name>num</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<continue>continue;</continue></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&gt;</operator> <literal type="number">3</literal></expr>)</condition>
		<block>{<block_content>
			<while>while <condition>(<expr><name>num</name><operator>--</operator> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><literal type="string">"M"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></while>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">3</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>rm100</name><index>[<expr><name>num</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>rm10</name><index>[<expr><name>num</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<if type="elseif">else if <condition>(<expr><name>len</name> <operator>==</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>strcat</name><argument_list>(<argument><expr><name>result</name></expr></argument>, <argument><expr><name><name>rm1</name><index>[<expr><name>num</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>



<comment type="block">/* ----------
 * Locale
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NUM_prepare_locale</name><parameter_list>(<parameter><decl><type><name>NUMProc</name> <modifier>*</modifier></type><name>Np</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>need_locale</name></name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name><name>struct</name> <name>lconv</name></name> <modifier>*</modifier></type><name>lconv</name></decl>;</decl_stmt>

		<comment type="block">/*
		 * Get locales
		 */</comment>
		<expr_stmt><expr><name>lconv</name> <operator>=</operator> <call><name>PGLC_localeconv</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Positive / Negative number sign
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lconv</name><operator>-&gt;</operator><name>negative_sign</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>lconv</name><operator>-&gt;</operator><name>negative_sign</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name> <operator>=</operator> <name><name>lconv</name><operator>-&gt;</operator><name>negative_sign</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name> <operator>=</operator> <literal type="string">"-"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>lconv</name><operator>-&gt;</operator><name>positive_sign</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>lconv</name><operator>-&gt;</operator><name>positive_sign</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name> <operator>=</operator> <name><name>lconv</name><operator>-&gt;</operator><name>positive_sign</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name> <operator>=</operator> <literal type="string">"+"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Number decimal point
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lconv</name><operator>-&gt;</operator><name>decimal_point</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>lconv</name><operator>-&gt;</operator><name>decimal_point</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>decimal</name></name> <operator>=</operator> <name><name>lconv</name><operator>-&gt;</operator><name>decimal_point</name></name></expr>;</expr_stmt></block_content></block></if>

		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>decimal</name></name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_LDECIMAL</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>decimal</name></name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<comment type="block">/*
		 * Number thousands separator
		 *
		 * Some locales (e.g. broken glibc pt_BR), have a comma for decimal,
		 * but "" for thousands_sep, so we set the thousands_sep too.
		 * http://archives.postgresql.org/pgsql-hackers/2007-11/msg00772.php
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lconv</name><operator>-&gt;</operator><name>thousands_sep</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>lconv</name><operator>-&gt;</operator><name>thousands_sep</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_thousands_sep</name></name> <operator>=</operator> <name><name>lconv</name><operator>-&gt;</operator><name>thousands_sep</name></name></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* Make sure thousands separator doesn't match decimal point symbol. */</comment>
		<if type="elseif">else if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>decimal</name></name></expr></argument>, <argument><expr><literal type="string">","</literal></expr></argument>)</argument_list></call> <operator>!=</operator><literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_thousands_sep</name></name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_thousands_sep</name></name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Currency symbol
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>lconv</name><operator>-&gt;</operator><name>currency_symbol</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>lconv</name><operator>-&gt;</operator><name>currency_symbol</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_currency_symbol</name></name> <operator>=</operator> <name><name>lconv</name><operator>-&gt;</operator><name>currency_symbol</name></name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_currency_symbol</name></name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<comment type="block">/*
		 * Default values
		 */</comment>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name> <operator>=</operator> <literal type="string">"-"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name> <operator>=</operator> <literal type="string">"+"</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>decimal</name></name> <operator>=</operator> <literal type="string">"."</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_thousands_sep</name></name> <operator>=</operator> <literal type="string">","</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>L_currency_symbol</name></name> <operator>=</operator> <literal type="string">" "</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * Return pointer of last relevant number after decimal point
 *	12.0500 --&gt; last relevant is '5'
 *	12.0000 --&gt; last relevant is '.'
 * If there is no decimal point, return NULL (which will result in same
 * behavior as if FM hadn't been specified).
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>get_last_relevant_decnum</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>num</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>result</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name> <init>= <expr><call><name>strchr</name><argument_list>(<argument><expr><name>num</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"get_last_relevant_decnum()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>p</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>NULL</name></expr>;</return></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt>

	<while>while <condition>(<expr><operator>*</operator><operator>(</operator><operator>++</operator><name>p</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>p</name> <operator>!=</operator> <literal type="char">'0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>result</name> <operator>=</operator> <name>p</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * These macros are used in NUM_processor() and its subsidiary routines.
 * OVERLOAD_TEST: true if we've reached end of input string
 * AMOUNT_TEST(s): true if at least s bytes remain in string
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>OVERLOAD_TEST</name></cpp:macro>	<cpp:value>(Np-&gt;inout_p &gt;= Np-&gt;inout + input_len)</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>AMOUNT_TEST</name><parameter_list>(<parameter><type><name>s</name></type></parameter>)</parameter_list></cpp:macro>	<cpp:value>(Np-&gt;inout_p &lt;= Np-&gt;inout + (input_len - (s)))</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Number extraction for TO_NUMBER()
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NUM_numpart_from_char</name><parameter_list>(<parameter><decl><type><name>NUMProc</name> <modifier>*</modifier></type><name>Np</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>input_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>		<name>isread</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">" --- scan start --- id=%s"</literal></expr></argument>,
		 <argument><expr><ternary><condition><expr><operator>(</operator><name>id</name> <operator>==</operator> <name>NUM_0</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>NUM_9</name><operator>)</operator></expr> ?</condition><then> <expr><literal type="string">"NUM_0/9"</literal></expr> </then><else>: <expr><ternary><condition><expr><name>id</name> <operator>==</operator> <name>NUM_DEC</name></expr> ?</condition><then> <expr><literal type="string">"NUM_DEC"</literal></expr> </then><else>: <expr><literal type="string">"???"</literal></expr></else></ternary></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<if_stmt><if>if <condition>(<expr><name>OVERLOAD_TEST</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>OVERLOAD_TEST</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * read sign before number
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>id</name> <operator>==</operator> <name>NUM_0</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>NUM_9</name><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>read_pre</name></name> <operator>+</operator> <name><name>Np</name><operator>-&gt;</operator><name>read_post</name></name><operator>)</operator> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"Try read sign (%c), locale positive: %s, negative: %s"</literal></expr></argument>,
			 <argument><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

		<comment type="block">/*
		 * locale sign
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_LSIGN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>==</operator> <name>NUM_LSIGN_PRE</name></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>x</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"Try read locale pre-sign (%c)"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>AMOUNT_TEST</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>strncmp</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <name>x</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
					 <call><name>AMOUNT_TEST</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <name>x</name></expr>;</expr_stmt>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"Try read simple sign (%c)"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/*
			 * simple + - &lt; &gt;
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>(</operator><call><name>IS_BRACKET</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
										<operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">'&lt;'</literal><operator>)</operator></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>	<comment type="block">/* set - */</comment>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>	<comment type="block">/* set + */</comment>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name><operator>++</operator></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>OVERLOAD_TEST</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"Scan for numbers (%c), current number: '%s'"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * read digit or decimal point
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>read_dec</name></name> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>read_post</name></name> <operator>==</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>post</name></name></expr>)</condition><block type="pseudo"><block_content>
			<return>return;</return></block_content></block></if></if_stmt>

		<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name> <operator>=</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name><operator>++</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>read_dec</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>read_post</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>read_pre</name></name><operator>++</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>isread</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"Read digit (%c)"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>read_dec</name></name> <operator>==</operator> <name>false</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We need not test IS_LDECIMAL(Np-&gt;Num) explicitly here, because
		 * Np-&gt;decimal is always just "." if we don't have a D format token.
		 * So we just unconditionally match to Np-&gt;decimal.
		 */</comment>
		<decl_stmt><decl><type><name>int</name></type>			<name>x</name> <init>= <expr><call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>decimal</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"Try read decimal point (%c)"</literal></expr></argument>,
			 <argument><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<if_stmt><if>if <condition>(<expr><name>x</name> <operator>&amp;&amp;</operator> <call><name>AMOUNT_TEST</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>strncmp</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>decimal</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <name>x</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name><operator>++</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>read_dec</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			<expr_stmt><expr><name>isread</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>OVERLOAD_TEST</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Read sign behind "last" number
	 *
	 * We need sign detection because determine exact position of post-sign is
	 * difficult:
	 *
	 * FM9999.9999999S	   -&gt; 123.001- 9.9S			   -&gt; .5- FM9.999999MI -&gt;
	 * 5.01-
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <literal type="char">' '</literal> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>read_pre</name></name> <operator>+</operator> <name><name>Np</name><operator>-&gt;</operator><name>read_post</name></name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * locale sign (NUM_S) is always anchored behind a last number, if: -
		 * locale sign expected - last read char was NUM_0/9 or NUM_DEC - and
		 * next char is not digit
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_LSIGN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name>isread</name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>&lt;</operator> <name><name>Np</name><operator>-&gt;</operator><name>inout</name></name> <operator>+</operator> <name>input_len</name> <operator>&amp;&amp;</operator>
			<operator>!</operator><call><name>isdigit</name><argument_list>(<argument><expr><operator>(</operator><name>unsigned</name> <name>char</name><operator>)</operator> <operator>*</operator><operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>int</name></type>			<name>x</name></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>tmp</name> <init>= <expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name><operator>++</operator></expr></init></decl>;</decl_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"Try read locale post-sign (%c)"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
			<if_stmt><if>if <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
				<call><name>AMOUNT_TEST</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				<call><name>strncmp</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <name>x</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* -1 .. NUM_processor() do inout_p++ */</comment>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><operator>(</operator><name>x</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name></expr></argument>)</argument_list></call><operator>)</operator> <operator>&amp;&amp;</operator>
					 <call><name>AMOUNT_TEST</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
					 <call><name>strncmp</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name></expr></argument>, <argument><expr><name>x</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <name>x</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>	<comment type="block">/* -1 .. NUM_processor() do inout_p++ */</comment>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <literal type="char">' '</literal></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* no sign read */</comment>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <name>tmp</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if>

		<comment type="block">/*
		 * try read non-locale sign, it's happen only if format is not exact
		 * and we cannot determine sign position of MI/PL/SG, an example:
		 *
		 * FM9.999999MI			   -&gt; 5.01-
		 *
		 * if (.... &amp;&amp; IS_LSIGN(Np-&gt;Num)==false) prevents read wrong formats
		 * like to_number('1 -', '9S') where sign is not anchored to last
		 * number.
		 */</comment>
		<if type="elseif">else if <condition>(<expr><name>isread</name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <call><name>IS_LSIGN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator>
				 <operator>(</operator><call><name>IS_PLUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_MINUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"Try read simple post-sign (%c)"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

			<comment type="block">/*
			 * simple + -
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
				<comment type="block">/* NUM_processor() do inout_p++ */</comment>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>IS_PREDEC_SPACE</name><parameter_list>(<parameter><type><name>_n</name></type></parameter>)</parameter_list></cpp:macro> \
		<cpp:value>(IS_ZERO((_n)-&gt;Num)==false &amp;&amp; \
		 (_n)-&gt;number == (_n)-&gt;number_p &amp;&amp; \
		 *(_n)-&gt;number == '0' &amp;&amp; \
				 (_n)-&gt;Num-&gt;post != 0)</cpp:value></cpp:define>

<comment type="block">/* ----------
 * Add digit or sign to number-string
 * ----------
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NUM_numpart_to_char</name><parameter_list>(<parameter><decl><type><name>NUMProc</name> <modifier>*</modifier></type><name>Np</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>end</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<comment type="block">/* Note: in this elog() output not set '\0' in 'inout' */</comment>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>

	<comment type="block">/*
	 * Np-&gt;num_curr is number of current item in format-picture, it is not
	 * current position in inout!
	 */</comment>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>,
		 <argument><expr><literal type="string">"SIGN_WROTE: %d, CURRENT: %d, NUMBER_P: \"%s\", INOUT: \"%s\""</literal></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>num_in</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * Write sign if real number will write to output Note: IS_PREDEC_SPACE()
	 * handle "9.9" --&gt; " .1"
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator>
		<operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name> <operator>&gt;=</operator> <name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name> <operator>||</operator> <operator>(</operator><call><name>IS_ZERO</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>zero_start</name></name> <operator>==</operator> <name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name><operator>)</operator><operator>)</operator> <operator>&amp;&amp;</operator>
		<operator>(</operator><call><name>IS_PREDEC_SPACE</name><argument_list>(<argument><expr><name>Np</name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name> <operator>||</operator> <operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>==</operator> <literal type="char">'.'</literal><operator>)</operator><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_LSIGN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>==</operator> <name>NUM_LSIGN_PRE</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_BRACKET</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <ternary><condition><expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'+'</literal></expr> ?</condition><then> <expr><literal type="char">' '</literal></expr> </then><else>: <expr><literal type="char">'&lt;'</literal></expr></else></ternary></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt> <comment type="block">/* Write + */</comment>
				<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>						<comment type="block">/* Write - */</comment>
			<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>


	<comment type="block">/*
	 * digits / FM / Zero / Dec. point
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>id</name> <operator>==</operator> <name>NUM_9</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>NUM_0</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>NUM_D</name> <operator>||</operator> <name>id</name> <operator>==</operator> <name>NUM_DEC</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name> <operator>&lt;</operator> <name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name> <operator>&amp;&amp;</operator>
			<operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>zero_start</name></name> <operator>&gt;</operator> <name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name> <operator>||</operator> <operator>!</operator><call><name>IS_ZERO</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Write blank space
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt> <comment type="block">/* Write ' ' */</comment>
				<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><call><name>IS_ZERO</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
				 <name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name> <operator>&lt;</operator> <name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name> <operator>&amp;&amp;</operator>
				 <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>zero_start</name></name> <operator>&lt;=</operator> <name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Write ZERO
			 */</comment>
			<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt> <comment type="block">/* Write '0' */</comment>
			<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>num_in</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * Write Decimal point
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>||</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>!=</operator> <literal type="char">'.'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>decimal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Write DEC/D */</comment>
					<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if>

				<comment type="block">/*
				 * Ora 'n' -- FM9.9 --&gt; 'n.'
				 */</comment>
				<if type="elseif">else if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
						 <name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
				<block>{<block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>decimal</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* Write DEC/D */</comment>
					<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				</block_content>}</block></if></if_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<comment type="block">/*
				 * Write Digits
				 */</comment>
				<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name> <operator>&gt;</operator> <name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>&amp;&amp;</operator>
					<name>id</name> <operator>!=</operator> <name>NUM_0</name></expr>)</condition><block type="pseudo"><block_content>
					<empty_stmt>;</empty_stmt></block_content></block></if>

				<comment type="block">/*
				 * '0.1' -- 9.9 --&gt; '  .1'
				 */</comment>
				<if type="elseif">else if <condition>(<expr><call><name>IS_PREDEC_SPACE</name><argument_list>(<argument><expr><name>Np</name></expr></argument>)</argument_list></call></expr>)</condition>
				<block>{<block_content>
					<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
						<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
					</block_content>}</block></if>

					<comment type="block">/*
					 * '0' -- FM9.9 --&gt; '0.'
					 */</comment>
					<if type="elseif">else if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>&amp;&amp;</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>
						<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
					</block_content>}</block></if></if_stmt>
				</block_content>}</block></if>
				<else>else
				<block>{<block_content>
					<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name></expr>;</expr_stmt>	<comment type="block">/* Write DIGIT */</comment>
					<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>num_in</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				</block_content>}</block></else></if_stmt>
			</block_content>}</block></else></if_stmt>
			<comment type="block">/* do no exceed string length */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>

		<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>num_count</name></name> <operator>+</operator> <operator>(</operator><ternary><condition><expr><name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator> <operator>+</operator> <operator>(</operator><ternary><condition><expr><call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="number">1</literal></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary><operator>)</operator></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>==</operator> <name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>end</name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>end</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>==</operator> <name>true</name> <operator>&amp;&amp;</operator> <call><name>IS_BRACKET</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <ternary><condition><expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'+'</literal></expr> ?</condition><then> <expr><literal type="char">' '</literal></expr> </then><else>: <expr><literal type="char">'&gt;'</literal></expr></else></ternary></expr>;</expr_stmt>
				<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr>;</expr_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><call><name>IS_LSIGN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>==</operator> <name>NUM_LSIGN_POST</name></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_negative_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
				<else>else<block type="pseudo"><block_content>
					<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>L_positive_sign</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Skip over "n" input characters, but only if they aren't numeric data
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>NUM_eat_non_data_chars</name><parameter_list>(<parameter><decl><type><name>NUMProc</name> <modifier>*</modifier></type><name>Np</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>n</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>input_len</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<while>while <condition>(<expr><name>n</name><operator>--</operator> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>OVERLOAD_TEST</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* end of input */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strchr</name><argument_list>(<argument><expr><literal type="string">"0123456789.,+-"</literal></expr></argument>, <argument><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>				<comment type="block">/* it's a data character */</comment>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></while>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>char</name> <modifier>*</modifier></type>
<name>NUM_processor</name><parameter_list>(<parameter><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>node</name></decl></parameter>, <parameter><decl><type><name>NUMDesc</name> <modifier>*</modifier></type><name>Num</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>inout</name></decl></parameter>,
			  <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>number</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>input_len</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>to_char_out_pre_spaces</name></decl></parameter>,
			  <parameter><decl><type><name>int</name></type> <name>sign</name></decl></parameter>, <parameter><decl><type><name>bool</name></type> <name>is_to_char</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>collid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NUMProc</name></type>		<name>_Np</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>Np</name> <init>= <expr><operator>&amp;</operator><name>_Np</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>pattern</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>pattern_len</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name>Np</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>NUMProc</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name> <operator>=</operator> <name>Num</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name> <operator>=</operator> <name>is_to_char</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <name>number</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout</name></name> <operator>=</operator> <name>inout</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>read_post</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>read_pre</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>read_dec</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>zero_start</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>--</operator><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>zero_start</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_EEEE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"EEEE\" not supported for input"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<return>return <expr><call><name>strcpy</name><argument_list>(<argument><expr><name>inout</name></expr></argument>, <argument><expr><name>number</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Roman correction
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_FEATURE_NOT_SUPPORTED</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"\"RN\" not supported for input"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>pre_lsign_num</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>post</name></name> <operator>=</operator>
			<name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>pre</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_FILLMODE</name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>flag</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>flag</name></name> <operator>|=</operator> <name>NUM_F_ROMAN</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Sign
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>is_to_char</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>sign</name></expr>;</expr_stmt>

		<comment type="block">/* MI/PL/SG - write sign itself and not in number */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>IS_PLUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>IS_MINUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>IS_PLUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_MINUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></if> <comment type="block">/* need sign */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* needn't sign */</comment>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition>
			<block>{<block_content>
				<if_stmt><if>if <condition>(<expr><call><name>IS_BRACKET</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NUM_F_BRACKET</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
				<if_stmt><if>if <condition>(<expr><call><name>IS_MINUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NUM_F_MINUS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if>
			<if type="elseif">else if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>!=</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <call><name>IS_PLUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>flag</name></name> <operator>&amp;=</operator> <operator>~</operator><name>NUM_F_PLUS</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'+'</literal> <operator>&amp;&amp;</operator> <call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_LSIGN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>==</operator> <name>false</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>=</operator> <name>true</name></expr>;</expr_stmt></block_content></block></if>	<comment type="block">/* needn't sign */</comment>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt> <comment type="block">/* need sign */</comment>

			<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>==</operator> <name>NUM_LSIGN_PRE</name> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>pre</name></name> <operator>==</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>pre_lsign_num</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>lsign</name></name> <operator>=</operator> <name>NUM_LSIGN_POST</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>=</operator> <name>false</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/*
	 * Count
	 */</comment>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>num_count</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>post</name></name> <operator>+</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>pre</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>is_to_char</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name> <operator>=</operator> <name>to_char_out_pre_spaces</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator> <call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>=</operator> <call><name>get_last_relevant_decnum</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * If any '0' specifiers are present, make sure we don't strip
			 * those digits.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>zero_end</name></name> <operator>&gt;</operator> <name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name></expr>)</condition>
			<block>{<block_content>
				<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>last_zero</name></decl>;</decl_stmt>

				<expr_stmt><expr><name>last_zero</name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>+</operator> <operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>zero_end</name></name> <operator>-</operator> <name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name><operator>)</operator></expr>;</expr_stmt>
				<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>&lt;</operator> <name>last_zero</name></expr>)</condition><block type="pseudo"><block_content>
					<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name> <operator>=</operator> <name>last_zero</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name> <operator>==</operator> <name>false</name> <operator>&amp;&amp;</operator> <name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>++</operator><name><name>Np</name><operator>-&gt;</operator><name>num_count</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>		<comment type="block">/* sign space */</comment>
		<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>num_in</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>num_curr</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>,
		 <argument><expr><literal type="string">"\n\tSIGN: '%c'\n\tNUM: '%s'\n\tPRE: %d\n\tPOST: %d\n\tNUM_COUNT: %d\n\tNUM_PRE: %d\n\tSIGN_WROTE: %s\n\tZERO: %s\n\tZERO_START: %d\n\tZERO_END: %d\n\tLAST_RELEVANT: %s\n\tBRACKET: %s\n\tPLUS: %s\n\tMINUS: %s\n\tFILLMODE: %s\n\tROMAN: %s\n\tEEEE: %s"</literal></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number</name></name></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>pre</name></name></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>post</name></name></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>num_count</name></name></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>out_pre_spaces</name></name></expr></argument>,
		 <argument><expr><ternary><condition><expr><name><name>Np</name><operator>-&gt;</operator><name>sign_wrote</name></name></expr> ?</condition><then> <expr><literal type="string">"Yes"</literal></expr> </then><else>: <expr><literal type="string">"No"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><call><name>IS_ZERO</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Yes"</literal></expr> </then><else>: <expr><literal type="string">"No"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>zero_start</name></name></expr></argument>,
		 <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>zero_end</name></name></expr></argument>,
		 <argument><expr><ternary><condition><expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name></expr> ?</condition><then> <expr><name><name>Np</name><operator>-&gt;</operator><name>last_relevant</name></name></expr> </then><else>: <expr><literal type="string">"&lt;not set&gt;"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><call><name>IS_BRACKET</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Yes"</literal></expr> </then><else>: <expr><literal type="string">"No"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><call><name>IS_PLUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Yes"</literal></expr> </then><else>: <expr><literal type="string">"No"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><call><name>IS_MINUS</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Yes"</literal></expr> </then><else>: <expr><literal type="string">"No"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Yes"</literal></expr> </then><else>: <expr><literal type="string">"No"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Yes"</literal></expr> </then><else>: <expr><literal type="string">"No"</literal></expr></else></ternary></expr></argument>,
		 <argument><expr><ternary><condition><expr><call><name>IS_EEEE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr> ?</condition><then> <expr><literal type="string">"Yes"</literal></expr> </then><else>: <expr><literal type="string">"No"</literal></expr></else></ternary></expr></argument>
		)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>

	<comment type="block">/*
	 * Locale
	 */</comment>
	<expr_stmt><expr><call><name>NUM_prepare_locale</name><argument_list>(<argument><expr><name>Np</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Processor direct cycle
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>number</name></name></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>	<comment type="block">/* first char is space for sign */</comment>

	<for>for <control>(<init><expr><name>n</name> <operator>=</operator> <name>node</name></expr><operator>,</operator> <expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>inout</name></name></expr>;</init> <condition><expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>!=</operator> <name>NODE_TYPE_END</name></expr>;</condition> <incr><expr><name>n</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Check at least one byte remains to be scanned.  (In actions
			 * below, must use AMOUNT_TEST if we want to read more bytes than
			 * that.)
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name>OVERLOAD_TEST</name></expr>)</condition><block type="pseudo"><block_content>
				<break>break;</break></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/*
		 * Format pictures actions
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>type</name></name> <operator>==</operator> <name>NODE_TYPE_ACTION</name></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Create/read digit/zero/blank/sign/special-case
			 *
			 * 'NUM_S' note: The locale sign is anchored to number and we
			 * read/write it when we work with first or last number
			 * (NUM_0/NUM_9).  This is why NUM_S is missing in switch().
			 *
			 * Notice the "Np-&gt;inout_p++" at the bottom of the loop.  This is
			 * why most of the actions advance inout_p one less than you might
			 * expect.  In cases where we don't want that increment to happen,
			 * a switch case ends with "continue" not "break".
			 */</comment>
			<switch>switch <condition>(<expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name></expr>)</condition>
			<block>{<block_content>
				<case>case <expr><name>NUM_9</name></expr>:</case>
				<case>case <expr><name>NUM_0</name></expr>:</case>
				<case>case <expr><name>NUM_DEC</name></expr>:</case>
				<case>case <expr><name>NUM_D</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>NUM_numpart_to_char</name><argument_list>(<argument><expr><name>Np</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>	<comment type="block">/* for() */</comment>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>NUM_numpart_from_char</name><argument_list>(<argument><expr><name>Np</name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>key</name><operator>-&gt;</operator><name>id</name></name></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<break>break;</break>	<comment type="block">/* switch() case: */</comment>
					</block_content>}</block></else></if_stmt>

				<case>case <expr><name>NUM_COMMA</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Np</name><operator>-&gt;</operator><name>num_in</name></name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if>
							<else>else<block type="pseudo"><block_content>
								<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
						</block_content>}</block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">','</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Np</name><operator>-&gt;</operator><name>num_in</name></name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>
						<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>!=</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if></if_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>NUM_G</name></expr>:</case>
					<expr_stmt><expr><name>pattern</name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>L_thousands_sep</name></name></expr>;</expr_stmt>
					<expr_stmt><expr><name>pattern_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Np</name><operator>-&gt;</operator><name>num_in</name></name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if>
							<else>else
							<block>{<block_content>
								<comment type="block">/* just in case there are MB chars */</comment>
								<expr_stmt><expr><name>pattern_len</name> <operator>=</operator> <call><name>pg_mbstrlen</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><literal type="char">' '</literal></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
								<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <name>pattern_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
							</block_content>}</block></else></if_stmt>
						</block_content>}</block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <name>pattern_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>!</operator><name><name>Np</name><operator>-&gt;</operator><name>num_in</name></name></expr>)</condition>
						<block>{<block_content>
							<if_stmt><if>if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
								<continue>continue;</continue></block_content></block></if></if_stmt>
						</block_content>}</block></if></if_stmt>

						<comment type="block">/*
						 * Because L_thousands_sep typically contains data
						 * characters (either '.' or ','), we can't use
						 * NUM_eat_non_data_chars here.  Instead skip only if
						 * the input matches L_thousands_sep.
						 */</comment>
						<if_stmt><if>if <condition>(<expr><call><name>AMOUNT_TEST</name><argument_list>(<argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
							<call><name>strncmp</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>, <argument><expr><name>pattern_len</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <name>pattern_len</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></else></if_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>NUM_L</name></expr>:</case>
					<expr_stmt><expr><name>pattern</name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>L_currency_symbol</name></name></expr>;</expr_stmt>
					<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>NUM_eat_non_data_chars</name><argument_list>(<argument><expr><name>Np</name></expr></argument>, <argument><expr><call><name>pg_mbstrlen</name><argument_list>(<argument><expr><name>pattern</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>NUM_RN</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><literal type="string">"%15s"</literal></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>NUM_rn</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><call><name>asc_tolower_z</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<expr_stmt><expr><call><name>sprintf</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><literal type="string">"%15s"</literal></expr></argument>, <argument><expr><call><name>asc_tolower_z</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>NUM_th</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>||</operator>
						<name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><call><name>get_th</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name>TH_LOWER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* All variants of 'th' occupy 2 characters */</comment>
						<expr_stmt><expr><call><name>NUM_eat_non_data_chars</name><argument_list>(<argument><expr><name>Np</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>NUM_TH</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call> <operator>||</operator> <operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>==</operator> <literal type="char">'#'</literal> <operator>||</operator>
						<name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal> <operator>||</operator> <call><name>IS_DECIMAL</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
						<continue>continue;</continue></block_content></block></if></if_stmt>

					<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
					<block>{<block_content>
						<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><call><name>get_th</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number</name></name></expr></argument>, <argument><expr><name>TH_UPPER</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <literal type="number">1</literal></expr>;</expr_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<comment type="block">/* All variants of 'TH' occupy 2 characters */</comment>
						<expr_stmt><expr><call><name>NUM_eat_non_data_chars</name><argument_list>(<argument><expr><name>Np</name></expr></argument>, <argument><expr><literal type="number">2</literal></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
						<continue>continue;</continue>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>NUM_MI</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if>
						<if type="elseif">else if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><call><name>NUM_eat_non_data_chars</name><argument_list>(<argument><expr><name>Np</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>NUM_PL</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>sign</name></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></if>
						<if type="elseif">else if <condition>(<expr><call><name>IS_FILLMODE</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
							<continue>continue;</continue></block_content></block></if>
						<else>else<block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
					</block_content>}</block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><call><name>NUM_eat_non_data_chars</name><argument_list>(<argument><expr><name>Np</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<case>case <expr><name>NUM_SG</name></expr>:</case>
					<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition><block type="pseudo"><block_content>
						<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>sign</name></name></expr>;</expr_stmt></block_content></block></if>
					<else>else
					<block>{<block_content>
						<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt></block_content></block></if>
						<if type="elseif">else if <condition>(<expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
							<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number</name></name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></if>
						<else>else
						<block>{<block_content>
							<expr_stmt><expr><call><name>NUM_eat_non_data_chars</name><argument_list>(<argument><expr><name>Np</name></expr></argument>, <argument><expr><literal type="number">1</literal></expr></argument>, <argument><expr><name>input_len</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
							<continue>continue;</continue>
						</block_content>}</block></else></if_stmt>
					</block_content>}</block></else></if_stmt>
					<break>break;</break>

				<default>default:</default>
					<continue>continue;</continue>
					<break>break;</break>
			</block_content>}</block></switch>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * In TO_CHAR, non-pattern characters in the format are copied to
			 * the output.  In TO_NUMBER, we skip one input character for each
			 * non-pattern format character, whether or not it matches the
			 * format character.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>, <argument><expr><name><name>n</name><operator>-&gt;</operator><name>character</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>+=</operator> <call><name>pg_mblen</name><argument_list>(<argument><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			</block_content>}</block></else></if_stmt>
			<continue>continue;</continue>
		</block_content>}</block></else></if_stmt>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name><name>Np</name><operator>-&gt;</operator><name>is_to_char</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>inout_p</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		<return>return <expr><name><name>Np</name><operator>-&gt;</operator><name>inout</name></name></expr>;</return>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>==</operator> <literal type="char">'.'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name> <operator>-</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name><name>Np</name><operator>-&gt;</operator><name>number_p</name></name> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Correction - precision of dec. number
		 */</comment>
		<expr_stmt><expr><name><name>Np</name><operator>-&gt;</operator><name>Num</name><operator>-&gt;</operator><name>post</name></name> <operator>=</operator> <name><name>Np</name><operator>-&gt;</operator><name>read_post</name></name></expr>;</expr_stmt>

<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>DEBUG_TO_FROM_CHAR</name></cpp:ifdef>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG_elog_output</name></expr></argument>, <argument><expr><literal type="string">"TO_NUMBER (number): '%s'"</literal></expr></argument>, <argument><expr><name><name>Np</name><operator>-&gt;</operator><name>number</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
		<return>return <expr><name><name>Np</name><operator>-&gt;</operator><name>number</name></name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/* ----------
 * MACRO: Start part of NUM - for all NUM's to_char variants
 *	(sorry, but I hate copy same code - macro is better..)
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_TOCHAR_prepare</name></cpp:macro> \
<cpp:value>do { \
	int len = VARSIZE_ANY_EXHDR(fmt); \
	if (len &lt;= 0 || len &gt;= (INT_MAX-VARHDRSZ)/NUM_MAX_ITEM_SIZ)		\
		PG_RETURN_TEXT_P(cstring_to_text("")); \
	result	= (text *) palloc0((len * NUM_MAX_ITEM_SIZ) + 1 + VARHDRSZ);	\
	format	= NUM_cache(len, &amp;Num, fmt, &amp;shouldFree);		\
} while (0)</cpp:value></cpp:define>

<comment type="block">/* ----------
 * MACRO: Finish part of NUM
 * ----------
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>NUM_TOCHAR_finish</name></cpp:macro> \
<cpp:value>do { \
	int		len; \
									\
	NUM_processor(format, &amp;Num, VARDATA(result), numstr, 0, out_pre_spaces, sign, true, PG_GET_COLLATION()); \
									\
	if (shouldFree)					\
		pfree(format);				\
									\
	<comment type="block">/*								\
	 * Convert null-terminated representation of result to standard text. \
	 * The result is usually much bigger than it needs to be, but there \
	 * seems little point in realloc'ing it smaller. \
	 */</comment>								\
	len = strlen(VARDATA(result));	\
	SET_VARSIZE(result, len + VARHDRSZ); \
} while (0)</cpp:value></cpp:define>

<comment type="block">/* -------------------
 * NUMERIC to_number() (convert string to numeric)
 * -------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_to_number</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>value</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NUMDesc</name></type>		<name>Num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>numstr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>len</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>scale</name></decl>,
				<decl><type ref="prev"/><name>precision</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>len</name> <operator>=</operator> <call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>fmt</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>len</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>len</name> <operator>&gt;=</operator> <name>INT_MAX</name> <operator>/</operator> <name>NUM_MAX_ITEM_SIZ</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>format</name> <operator>=</operator> <call><name>NUM_cache</name><argument_list>(<argument><expr><name>len</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>, <argument><expr><name>fmt</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>shouldFree</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><operator>(</operator><name>len</name> <operator>*</operator> <name>NUM_MAX_ITEM_SIZ</name><operator>)</operator> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>NUM_processor</name><argument_list>(<argument><expr><name>format</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>, <argument><expr><call><name>VARDATA_ANY</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><name>numstr</name></expr></argument>,
				  <argument><expr><call><name>VARSIZE_ANY_EXHDR</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><name>false</name></expr></argument>, <argument><expr><call><name>PG_GET_COLLATION</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>scale</name> <operator>=</operator> <name><name>Num</name><operator>.</operator><name>post</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>precision</name> <operator>=</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name> <operator>+</operator> <name>scale</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>shouldFree</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>format</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall3</name><argument_list>(<argument><expr><name>numeric_in</name></expr></argument>,
								 <argument><expr><call><name>CStringGetDatum</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>ObjectIdGetDatum</name><argument_list>(<argument><expr><name>InvalidOid</name></expr></argument>)</argument_list></call></expr></argument>,
								 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>(</operator><operator>(</operator><name>precision</name> <operator>&lt;&lt;</operator> <literal type="number">16</literal><operator>)</operator> <operator>|</operator> <name>scale</name><operator>)</operator> <operator>+</operator> <name>VARHDRSZ</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_MULTI</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>x</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>a</name> <init>= <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4_numeric</name></expr></argument>,
															<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>b</name> <init>= <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4_numeric</name></expr></argument>,
															<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><operator>-</operator><name><name>Num</name><operator>.</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_power</name></expr></argument>,
												<argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>result</name> <operator>=</operator> <call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_mul</name></expr></argument>,
									 <argument><expr><name>result</name></expr></argument>,
									 <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>result</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* ------------------
 * NUMERIC to_char()
 * ------------------
 */</comment>
<function><type><name>Datum</name></type>
<name>numeric_to_char</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_NUMERIC</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NUMDesc</name></type>		<name>Num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>out_pre_spaces</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>numstr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>orgnum</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Numeric</name></type>		<name>x</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_prepare</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * On DateType depend part (numeric)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_round</name></expr></argument>,
												<argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>=</operator>
			<call><name>int_to_roman</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_int4</name></expr></argument>,
														   <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_EEEE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <call><name>numeric_out_sci</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * numeric_out_sci() does not emit a sign for positive numbers.  We
		 * need to add a space in this case so that positive and negative
		 * numbers are aligned.  We also have to do the right thing for NaN.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><call><name>strcmp</name><argument_list>(<argument><expr><name>orgnum</name></expr></argument>, <argument><expr><literal type="string">"NaN"</literal></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Allow 6 characters for the leading sign, the decimal point,
			 * "e", the exponent's sign and two exponent digits.
			 */</comment>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fill_str</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>numstr</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>orgnum</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>numstr</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>numstr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>orgnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numstr_pre_len</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>val</name> <init>= <expr><name>value</name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_MULTI</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>Numeric</name></type>		<name>a</name> <init>= <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4_numeric</name></expr></argument>,
																<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><literal type="number">10</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
			<decl_stmt><decl><type><name>Numeric</name></type>		<name>b</name> <init>= <expr><call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4_numeric</name></expr></argument>,
																<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_power</name></expr></argument>,
													<argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>a</name></expr></argument>)</argument_list></call></expr></argument>,
													<argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>b</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_mul</name></expr></argument>,
													  <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+=</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>x</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>numeric_round</name></expr></argument>,
												<argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>,
												<argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>numeric_out</name></expr></argument>,
													 <argument><expr><call><name>NumericGetDatum</name><argument_list>(<argument><expr><name>x</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>numstr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* needs padding? */</comment>
		<if_stmt><if>if <condition>(<expr><name>numstr_pre_len</name> <operator>&lt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_pre_spaces</name> <operator>=</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>-</operator> <name>numstr_pre_len</name></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* overflowed prefix digit format? */</comment>
		<if type="elseif">else if <condition>(<expr><name>numstr_pre_len</name> <operator>&gt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fill_str</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_finish</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ---------------
 * INT4 to_char()
 * ---------------
 */</comment>
<function><type><name>Datum</name></type>
<name>int4_to_char</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int32</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NUMDesc</name></type>		<name>Num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>out_pre_spaces</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>numstr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>orgnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_prepare</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * On DateType depend part (int32)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>=</operator> <call><name>int_to_roman</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_EEEE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* we can do it easily because float8 won't lose any precision */</comment>
		<decl_stmt><decl><type><name>float8</name></type>		<name>val</name> <init>= <expr><operator>(</operator><name>float8</name><operator>)</operator> <name>value</name></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%+.*e"</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Swap a leading positive sign for a space.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><operator>*</operator><name>orgnum</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numstr_pre_len</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_MULTI</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4out</name></expr></argument>,
														 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>value</name> <operator>*</operator> <operator>(</operator><operator>(</operator><name>int32</name><operator>)</operator> <call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+=</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int4out</name></expr></argument>,
														 <argument><expr><call><name>Int32GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>orgnum</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>orgnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* post-decimal digits?  Pad out with zeros. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numstr_pre_len</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><name>orgnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name>numstr_pre_len</name><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>numstr</name> <operator>+</operator> <name>numstr_pre_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name>numstr_pre_len</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* needs padding? */</comment>
		<if_stmt><if>if <condition>(<expr><name>numstr_pre_len</name> <operator>&lt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_pre_spaces</name> <operator>=</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>-</operator> <name>numstr_pre_len</name></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* overflowed prefix digit format? */</comment>
		<if type="elseif">else if <condition>(<expr><name>numstr_pre_len</name> <operator>&gt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fill_str</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_finish</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* ---------------
 * INT8 to_char()
 * ---------------
 */</comment>
<function><type><name>Datum</name></type>
<name>int8_to_char</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int64</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NUMDesc</name></type>		<name>Num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>out_pre_spaces</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>numstr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>orgnum</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_prepare</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * On DateType depend part (int32)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Currently don't support int8 conversion to roman... */</comment>
		<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>=</operator> <call><name>int_to_roman</name><argument_list>(<argument><expr><call><name>DatumGetInt32</name><argument_list>(
													 <argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int84</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_EEEE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* to avoid loss of precision, must go via numeric not float8 */</comment>
		<decl_stmt><decl><type><name>Numeric</name></type>		<name>val</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>DatumGetNumeric</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8_numeric</name></expr></argument>,
												  <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <call><name>numeric_out_sci</name><argument_list>(<argument><expr><name>val</name></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * numeric_out_sci() does not emit a sign for positive numbers.  We
		 * need to add a space in this case so that positive and negative
		 * numbers are aligned.  We don't have to worry about NaN here.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>!=</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>strlen</name><argument_list>(<argument><expr><name>orgnum</name></expr></argument>)</argument_list></call> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>numstr</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>numstr</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><name>orgnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>numstr_pre_len</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_MULTI</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>multi</name> <init>= <expr><call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>value</name> <operator>=</operator> <call><name>DatumGetInt64</name><argument_list>(<argument><expr><call><name>DirectFunctionCall2</name><argument_list>(<argument><expr><name>int8mul</name></expr></argument>,
													  <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>,
													  <argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>dtoi8</name></expr></argument>,
																		  <argument><expr><call><name>Float8GetDatum</name><argument_list>(<argument><expr><name>multi</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+=</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <call><name>DatumGetCString</name><argument_list>(<argument><expr><call><name>DirectFunctionCall1</name><argument_list>(<argument><expr><name>int8out</name></expr></argument>,
													 <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>orgnum</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>orgnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* post-decimal digits?  Pad out with zeros. */</comment>
		<if_stmt><if>if <condition>(<expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name>numstr_pre_len</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>strcpy</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><name>orgnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name>numstr_pre_len</name><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name>numstr</name> <operator>+</operator> <name>numstr_pre_len</name> <operator>+</operator> <literal type="number">1</literal></expr></argument>, <argument><expr><literal type="char">'0'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name>numstr_pre_len</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'\0'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* needs padding? */</comment>
		<if_stmt><if>if <condition>(<expr><name>numstr_pre_len</name> <operator>&lt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_pre_spaces</name> <operator>=</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>-</operator> <name>numstr_pre_len</name></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* overflowed prefix digit format? */</comment>
		<if type="elseif">else if <condition>(<expr><name>numstr_pre_len</name> <operator>&gt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fill_str</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_finish</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------
 * FLOAT4 to_char()
 * -----------------
 */</comment>
<function><type><name>Datum</name></type>
<name>float4_to_char</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float4</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_FLOAT4</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NUMDesc</name></type>		<name>Num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>out_pre_spaces</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>numstr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>orgnum</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_prepare</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>=</operator> <call><name>int_to_roman</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_EEEE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Allow 6 characters for the leading sign, the decimal point,
			 * "e", the exponent's sign and two exponent digits.
			 */</comment>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fill_str</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>numstr</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%+.*e"</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Swap a leading positive sign for a space.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>orgnum</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>float4</name></type>		<name>val</name> <init>= <expr><name>value</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numstr_pre_len</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_MULTI</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>float</name></type>		<name>multi</name> <init>= <expr><call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <name>value</name> <operator>*</operator> <name>multi</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+=</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%.0f"</literal></expr></argument>, <argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>orgnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* adjust post digits to fit max float digits */</comment>
		<if_stmt><if>if <condition>(<expr><name>numstr_pre_len</name> <operator>&gt;=</operator> <name>FLT_DIG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Num</name><operator>.</operator><name>post</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>numstr_pre_len</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>&gt;</operator> <name>FLT_DIG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Num</name><operator>.</operator><name>post</name></name> <operator>=</operator> <name>FLT_DIG</name> <operator>-</operator> <name>numstr_pre_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%.*f"</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>						<comment type="block">/* &lt; 0 */</comment>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>numstr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* needs padding? */</comment>
		<if_stmt><if>if <condition>(<expr><name>numstr_pre_len</name> <operator>&lt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_pre_spaces</name> <operator>=</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>-</operator> <name>numstr_pre_len</name></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* overflowed prefix digit format? */</comment>
		<if type="elseif">else if <condition>(<expr><name>numstr_pre_len</name> <operator>&gt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fill_str</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_finish</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/* -----------------
 * FLOAT8 to_char()
 * -----------------
 */</comment>
<function><type><name>Datum</name></type>
<name>float8_to_char</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>float8</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>fmt</name> <init>= <expr><call><name>PG_GETARG_TEXT_PP</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>NUMDesc</name></type>		<name>Num</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FormatNode</name> <modifier>*</modifier></type><name>format</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>text</name>	   <modifier>*</modifier></type><name>result</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>shouldFree</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>out_pre_spaces</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sign</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>numstr</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>orgnum</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>p</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_prepare</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>IS_ROMAN</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>=</operator> <call><name>int_to_roman</name><argument_list>(<argument><expr><operator>(</operator><name>int</name><operator>)</operator> <call><name>rint</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><call><name>IS_EEEE</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>isnan</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call> <operator>||</operator> <call><name>isinf</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/*
			 * Allow 6 characters for the leading sign, the decimal point,
			 * "e", the exponent's sign and two exponent digits.
			 */</comment>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">7</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fill_str</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">6</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><name>numstr</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%+.*e"</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>, <argument><expr><name>value</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<comment type="block">/*
			 * Swap a leading positive sign for a space.
			 */</comment>
			<if_stmt><if>if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>==</operator> <literal type="char">'+'</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><operator>*</operator><name>orgnum</name> <operator>=</operator> <literal type="char">' '</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>float8</name></type>		<name>val</name> <init>= <expr><name>value</name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>numstr_pre_len</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>IS_MULTI</name><argument_list>(<argument><expr><operator>&amp;</operator><name>Num</name></expr></argument>)</argument_list></call></expr>)</condition>
		<block>{<block_content>
			<decl_stmt><decl><type><name>double</name></type>		<name>multi</name> <init>= <expr><call><name>pow</name><argument_list>(<argument><expr><operator>(</operator><name>double</name><operator>)</operator> <literal type="number">10</literal></expr></argument>, <argument><expr><operator>(</operator><name>double</name><operator>)</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name>val</name> <operator>=</operator> <name>value</name> <operator>*</operator> <name>multi</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+=</operator> <name><name>Num</name><operator>.</operator><name>multi</name></name></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
		<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%.0f"</literal></expr></argument>, <argument><expr><call><name>fabs</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>orgnum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* adjust post digits to fit max double digits */</comment>
		<if_stmt><if>if <condition>(<expr><name>numstr_pre_len</name> <operator>&gt;=</operator> <name>DBL_DIG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Num</name><operator>.</operator><name>post</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>numstr_pre_len</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>&gt;</operator> <name>DBL_DIG</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name><name>Num</name><operator>.</operator><name>post</name></name> <operator>=</operator> <name>DBL_DIG</name> <operator>-</operator> <name>numstr_pre_len</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>orgnum</name> <operator>=</operator> <call><name>psprintf</name><argument_list>(<argument><expr><literal type="string">"%.*f"</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>post</name></name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>orgnum</name> <operator>==</operator> <literal type="char">'-'</literal></expr>)</condition>
		<block>{<block_content>						<comment type="block">/* &lt; 0 */</comment>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'-'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><name>sign</name> <operator>=</operator> <literal type="char">'+'</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <name>orgnum</name></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>

		<if_stmt><if>if <condition>(<expr><operator>(</operator><name>p</name> <operator>=</operator> <call><name>strchr</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'.'</literal></expr></argument>)</argument_list></call><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <name>p</name> <operator>-</operator> <name>numstr</name></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>numstr_pre_len</name> <operator>=</operator> <call><name>strlen</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/* needs padding? */</comment>
		<if_stmt><if>if <condition>(<expr><name>numstr_pre_len</name> <operator>&lt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>out_pre_spaces</name> <operator>=</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>-</operator> <name>numstr_pre_len</name></expr>;</expr_stmt></block_content></block></if>
		<comment type="block">/* overflowed prefix digit format? */</comment>
		<if type="elseif">else if <condition>(<expr><name>numstr_pre_len</name> <operator>&gt;</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>numstr</name> <operator>=</operator> <operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <call><name>palloc</name><argument_list>(<argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">2</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>fill_str</name><argument_list>(<argument><expr><name>numstr</name></expr></argument>, <argument><expr><literal type="char">'#'</literal></expr></argument>, <argument><expr><name><name>Num</name><operator>.</operator><name>pre</name></name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>post</name></name> <operator>+</operator> <literal type="number">1</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><operator>*</operator><operator>(</operator><name>numstr</name> <operator>+</operator> <name><name>Num</name><operator>.</operator><name>pre</name></name><operator>)</operator> <operator>=</operator> <literal type="char">'.'</literal></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>NUM_TOCHAR_finish</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><name>result</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
