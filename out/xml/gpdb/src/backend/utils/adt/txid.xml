<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/txid.c"><comment type="block">/*-------------------------------------------------------------------------
 * txid.c
 *
 *	Export internal transaction IDs to user level.
 *
 * Note that only top-level transaction IDs are ever converted to TXID.
 * This is important because TXIDs frequently persist beyond the global
 * xmin horizon, or may even be shipped to other machines, so we cannot
 * rely on being able to correlate subtransaction IDs with their parents
 * via functions such as SubTransGetTopmostTransaction().
 *
 *
 *	Copyright (c) 2003-2019, PostgreSQL Global Development Group
 *	Author: Jan Wieck, Afilias USA INC.
 *	64-bit txids: Marko Kreen, Skype Technologies
 *
 *	src/backend/utils/adt/txid.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/clog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/transam.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"libpq/pqformat.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postmaster/postmaster.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/lwlock.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>


<comment type="block">/* txid will be signed int8 in database, so must limit to 63 bits */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_TXID</name></cpp:macro>   <cpp:value>((uint64) PG_INT64_MAX)</cpp:value></cpp:define>

<comment type="block">/* Use unsigned variant internally */</comment>
<typedef>typedef <type><name>uint64</name></type> <name>txid</name>;</typedef>

<comment type="block">/* sprintf format code for uint64 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TXID_FMT</name></cpp:macro> <cpp:value>UINT64_FORMAT</cpp:value></cpp:define>

<comment type="block">/*
 * If defined, use bsearch() function for searching for txids in snapshots
 * that have more than the specified number of values.
 */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>USE_BSEARCH_IF_NXIP_GREATER</name></cpp:macro> <cpp:value>30</cpp:value></cpp:define>


<comment type="block">/*
 * Snapshot containing 8byte txids.
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<comment type="block">/*
	 * 4-byte length hdr, should not be touched directly.
	 *
	 * Explicit embedding is ok as we want always correct alignment anyway.
	 */</comment>
	<decl_stmt><decl><type><name>int32</name></type>		<name>__varsz</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>uint32</name></type>		<name>nxip</name></decl>;</decl_stmt>			<comment type="block">/* number of txids in xip array */</comment>
	<decl_stmt><decl><type><name>txid</name></type>		<name>xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>txid</name></type>		<name>xmax</name></decl>;</decl_stmt>
	<comment type="block">/* in-progress txids, xmin &lt;= xip[i] &lt; xmax: */</comment>
	<decl_stmt><decl><type><name>txid</name></type>		<name><name>xip</name><index>[<expr><name>FLEXIBLE_ARRAY_MEMBER</name></expr>]</index></name></decl>;</decl_stmt>
}</block></struct></type> <name>TxidSnapshot</name>;</typedef>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TXID_SNAPSHOT_SIZE</name><parameter_list>(<parameter><type><name>nxip</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>(offsetof(TxidSnapshot, xip) + sizeof(txid) * (nxip))</cpp:value></cpp:define>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>TXID_SNAPSHOT_MAX_NXIP</name></cpp:macro> \
	<cpp:value>((MaxAllocSize - offsetof(TxidSnapshot, xip)) / sizeof(txid))</cpp:value></cpp:define>

<comment type="block">/*
 * Epoch values from xact.c
 */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>last_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>epoch</name></decl>;</decl_stmt>
}</block></struct></type> <name>TxidEpoch</name>;</typedef>


<comment type="block">/*
 * Fetch epoch data from xact.c.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>load_xid_epoch</name><parameter_list>(<parameter><decl><type><name>TxidEpoch</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>fullXid</name> <init>= <expr><call><name>ReadNextFullTransactionId</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>last_xid</name></name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name>fullXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>state</name><operator>-&gt;</operator><name>epoch</name></name> <operator>=</operator> <call><name>EpochFromFullTransactionId</name><argument_list>(<argument><expr><name>fullXid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Helper to get a TransactionId from a 64-bit xid with wraparound detection.
 *
 * It is an ERROR if the xid is in the future.  Otherwise, returns true if
 * the transaction is still new enough that we can determine whether it
 * committed and false otherwise.  If *extracted_xid is not NULL, it is set
 * to the low 32 bits of the transaction ID (i.e. the actual XID, without the
 * epoch).
 *
 * The caller must hold CLogTruncationLock since it's dealing with arbitrary
 * XIDs, and must continue to hold it until it's done with any clog lookups
 * relating to those XIDs.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>TransactionIdInRecentPast</name><parameter_list>(<parameter><decl><type><name>uint64</name></type> <name>xid_with_epoch</name></decl></parameter>, <parameter><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>extracted_xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>xid_epoch</name> <init>= <expr><operator>(</operator><name>uint32</name><operator>)</operator> <operator>(</operator><name>xid_with_epoch</name> <operator>&gt;&gt;</operator> <literal type="number">32</literal><operator>)</operator></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name> <init>= <expr><operator>(</operator><name>TransactionId</name><operator>)</operator> <name>xid_with_epoch</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>now_epoch</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>now_epoch_next_xid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>now_fullxid</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>now_fullxid</name> <operator>=</operator> <call><name>ReadNextFullTransactionId</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>now_epoch_next_xid</name> <operator>=</operator> <call><name>XidFromFullTransactionId</name><argument_list>(<argument><expr><name>now_fullxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>now_epoch</name> <operator>=</operator> <call><name>EpochFromFullTransactionId</name><argument_list>(<argument><expr><name>now_fullxid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>extracted_xid</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>extracted_xid</name> <operator>=</operator> <name>xid</name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* For non-normal transaction IDs, we can ignore the epoch. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* If the transaction ID is in the future, throw an error. */</comment>
	<if_stmt><if>if <condition>(<expr><name>xid_with_epoch</name> <operator>&gt;=</operator> <call><name>U64FromFullTransactionId</name><argument_list>(<argument><expr><name>now_fullxid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_PARAMETER_VALUE</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"transaction ID %s is in the future"</literal></expr></argument>,
						<argument><expr><call><name>psprintf</name><argument_list>(<argument><expr><name>UINT64_FORMAT</name></expr></argument>, <argument><expr><name>xid_with_epoch</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * ShmemVariableCache-&gt;oldestClogXid is protected by CLogTruncationLock,
	 * but we don't acquire that lock here.  Instead, we require the caller to
	 * acquire it, because the caller is presumably going to look up the
	 * returned XID.  If we took and released the lock within this function, a
	 * CLOG truncation could occur before the caller finished with the XID.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>CLogTruncationLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If the transaction ID has wrapped around, it's definitely too old to
	 * determine the commit status.  Otherwise, we can compare it to
	 * ShmemVariableCache-&gt;oldestClogXid to determine whether the relevant
	 * CLOG entry is guaranteed to still exist.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>xid_epoch</name> <operator>+</operator> <literal type="number">1</literal> <operator>&lt;</operator> <name>now_epoch</name>
		<operator>||</operator> <operator>(</operator><name>xid_epoch</name> <operator>+</operator> <literal type="number">1</literal> <operator>==</operator> <name>now_epoch</name> <operator>&amp;&amp;</operator> <name>xid</name> <operator>&lt;</operator> <name>now_epoch_next_xid</name><operator>)</operator>
		<operator>||</operator> <call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>ShmemVariableCache</name><operator>-&gt;</operator><name>oldestClogXid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>

	<return>return <expr><name>true</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * do a TransactionId -&gt; txid conversion for an XID near the given epoch
 */</comment>
<function><type><specifier>static</specifier> <name>txid</name></type>
<name>convert_xid</name><parameter_list>(<parameter><decl><type><name>TransactionId</name></type> <name>xid</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TxidEpoch</name> <modifier>*</modifier></type><name>state</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>epoch</name></decl>;</decl_stmt>

	<comment type="block">/* return special xid's as-is */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>TransactionIdIsNormal</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>(</operator><name>txid</name><operator>)</operator> <name>xid</name></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* xid can be on either side when near wrap-around */</comment>
	<expr_stmt><expr><name>epoch</name> <operator>=</operator> <operator>(</operator><name>uint64</name><operator>)</operator> <name><name>state</name><operator>-&gt;</operator><name>epoch</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xid</name> <operator>&gt;</operator> <name><name>state</name><operator>-&gt;</operator><name>last_xid</name></name> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>last_xid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>epoch</name><operator>--</operator></expr>;</expr_stmt></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>xid</name> <operator>&lt;</operator> <name><name>state</name><operator>-&gt;</operator><name>last_xid</name></name> <operator>&amp;&amp;</operator>
			 <call><name>TransactionIdFollows</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><name><name>state</name><operator>-&gt;</operator><name>last_xid</name></name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>epoch</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><operator>(</operator><name>epoch</name> <operator>&lt;&lt;</operator> <literal type="number">32</literal><operator>)</operator> <operator>|</operator> <name>xid</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * txid comparator for qsort/bsearch
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>cmp_txid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>aa</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>void</name> <modifier>*</modifier></type><name>bb</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>txid</name></type>		<name>a</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>txid</name> <operator>*</operator><operator>)</operator> <name>aa</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>txid</name></type>		<name>b</name> <init>= <expr><operator>*</operator><operator>(</operator><specifier>const</specifier> <name>txid</name> <operator>*</operator><operator>)</operator> <name>bb</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&lt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>a</name> <operator>&gt;</operator> <name>b</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">1</literal></expr>;</return></block_content></block></if></if_stmt>
	<return>return <expr><literal type="number">0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Sort a snapshot's txids, so we can use bsearch() later.  Also remove
 * any duplicates.
 *
 * For consistency of on-disk representation, we always sort even if bsearch
 * will not be used.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>sort_snapshot</name><parameter_list>(<parameter><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>txid</name></type>		<name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nxip</name></decl>,
				<decl><type ref="prev"/><name>idx1</name></decl>,
				<decl><type ref="prev"/><name>idx2</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name> <operator>&gt;</operator> <literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>qsort</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_txid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* remove duplicates */</comment>
		<expr_stmt><expr><name>nxip</name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr>;</expr_stmt>
		<expr_stmt><expr><name>idx1</name> <operator>=</operator> <name>idx2</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<while>while <condition>(<expr><name>idx1</name> <operator>&lt;</operator> <name>nxip</name></expr>)</condition>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>idx1</name></expr>]</index></name> <operator>!=</operator> <name>last</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>last</name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>idx2</name><operator>++</operator></expr>]</index></name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>idx1</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name><operator>--</operator></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<expr_stmt><expr><name>idx1</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></while>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * check txid visibility.
 */</comment>
<function><type><specifier>static</specifier> <name>bool</name></type>
<name>is_visible_txid</name><parameter_list>(<parameter><decl><type><name>txid</name></type> <name>value</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>value</name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>true</name></expr>;</return></block_content></block></if>
	<if type="elseif">else if <condition>(<expr><name>value</name> <operator>&gt;=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><name>false</name></expr>;</return></block_content></block></if>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>USE_BSEARCH_IF_NXIP_GREATER</name></cpp:ifdef>
	<if type="elseif">else if <condition>(<expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name> <operator>&gt;</operator> <name>USE_BSEARCH_IF_NXIP_GREATER</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>void</name>	   <modifier>*</modifier></type><name>res</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>res</name> <operator>=</operator> <call><name>bsearch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>value</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>txid</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>cmp_txid</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* if found, transaction is still in progress */</comment>
		<return>return <expr><ternary><condition><expr><operator>(</operator><name>res</name><operator>)</operator></expr> ?</condition><then> <expr><name>false</name></expr> </then><else>: <expr><name>true</name></expr></else></ternary></expr>;</return>
	</block_content>}</block></if>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<else>else
	<block>{<block_content>
		<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>value</name> <operator>==</operator> <name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><name>false</name></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
		<return>return <expr><name>true</name></expr>;</return>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * helper functions to use StringInfo for TxidSnapshot creation.
 */</comment>

<function><type><specifier>static</specifier> <name>StringInfo</name></type>
<name>buf_init</name><parameter_list>(<parameter><decl><type><name>txid</name></type> <name>xmin</name></decl></parameter>, <parameter><decl><type><name>txid</name></type> <name>xmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TxidSnapshot</name></type> <name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name><name>snap</name><operator>.</operator><name>xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>.</operator><name>xmax</name></name> <operator>=</operator> <name>xmax</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>.</operator><name>nxip</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>makeStringInfo</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>snap</name></expr></argument>, <argument><expr><call><name>TXID_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>buf</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>void</name></type>
<name>buf_add_txid</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>, <parameter><decl><type><name>txid</name></type> <name>xid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>TxidSnapshot</name> <operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* do this before possible realloc */</comment>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendBinaryStringInfo</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><operator>(</operator><name>char</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>xid</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>TxidSnapshot</name> <modifier>*</modifier></type>
<name>buf_finalize</name><parameter_list>(<parameter><decl><type><name>StringInfo</name></type> <name>buf</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>TxidSnapshot</name> <operator>*</operator><operator>)</operator> <name><name>buf</name><operator>-&gt;</operator><name>data</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><name><name>buf</name><operator>-&gt;</operator><name>len</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* buf is not needed anymore */</comment>
	<expr_stmt><expr><name><name>buf</name><operator>-&gt;</operator><name>data</name></name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>snap</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * simple number parser.
 *
 * We return 0 on error, which is invalid value for txid.
 */</comment>
<function><type><specifier>static</specifier> <name>txid</name></type>
<name>str2txid</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>s</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier><modifier>*</modifier></type><name>endp</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>txid</name></type>		<name>val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>txid</name></type>		<name>cutoff</name> <init>= <expr><name>MAX_TXID</name> <operator>/</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>txid</name></type>		<name>cutlim</name> <init>= <expr><name>MAX_TXID</name> <operator>%</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt>

	<for>for <control>(<init>;</init> <condition><expr><operator>*</operator><name>s</name></expr>;</condition> <incr><expr><name>s</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>unsigned</name></type>	<name>d</name></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name><name>s</name> <argument_list type="generic">&lt; <argument><expr><literal type="char">'0'</literal> <operator>||</operator> <operator>*</operator><name>s</name></expr></argument> &gt;</argument_list></name> <literal type="char">'9'</literal></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>d</name> <operator>=</operator> <operator>*</operator><name>s</name> <operator>-</operator> <literal type="char">'0'</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * check for overflow
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&gt;</operator> <name>cutoff</name> <operator>||</operator> <operator>(</operator><name>val</name> <operator>==</operator> <name>cutoff</name> <operator>&amp;&amp;</operator> <name>d</name> <operator>&gt;</operator> <name>cutlim</name><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>val</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name>val</name> <operator>=</operator> <name>val</name> <operator>*</operator> <literal type="number">10</literal> <operator>+</operator> <name>d</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<if_stmt><if>if <condition>(<expr><name>endp</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><operator>*</operator><name>endp</name> <operator>=</operator> <name>s</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name>val</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * parse snapshot from cstring
 */</comment>
<function><type><specifier>static</specifier> <name>TxidSnapshot</name> <modifier>*</modifier></type>
<name>parse_snapshot</name><parameter_list>(<parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>txid</name></type>		<name>xmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>txid</name></type>		<name>xmax</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>txid</name></type>		<name>last_val</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>str_start</name> <init>= <expr><name>str</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>endp</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>str2txid</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>xmax</name> <operator>=</operator> <call><name>str2txid</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><operator>*</operator><name>endp</name> <operator>!=</operator> <literal type="char">':'</literal></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>
	<expr_stmt><expr><name>str</name> <operator>=</operator> <name>endp</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<comment type="block">/* it should look sane */</comment>
	<if_stmt><if>if <condition>(<expr><name>xmin</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>xmax</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>xmin</name> <operator>&gt;</operator> <name>xmax</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

	<comment type="block">/* allocate buffer */</comment>
	<expr_stmt><expr><name>buf</name> <operator>=</operator> <call><name>buf_init</name><argument_list>(<argument><expr><name>xmin</name></expr></argument>, <argument><expr><name>xmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* loop over values */</comment>
	<while>while <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* read next value */</comment>
		<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>str2txid</name><argument_list>(<argument><expr><name>str</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>endp</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>str</name> <operator>=</operator> <name>endp</name></expr>;</expr_stmt>

		<comment type="block">/* require the input to be in order */</comment>
		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>&lt;</operator> <name>xmin</name> <operator>||</operator> <name>val</name> <operator>&gt;=</operator> <name>xmax</name> <operator>||</operator> <name>val</name> <operator>&lt;</operator> <name>last_val</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* skip duplicates */</comment>
		<if_stmt><if>if <condition>(<expr><name>val</name> <operator>!=</operator> <name>last_val</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>buf_add_txid</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>last_val</name> <operator>=</operator> <name>val</name></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><operator>*</operator><name>str</name> <operator>==</operator> <literal type="char">','</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>str</name><operator>++</operator></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><operator>*</operator><name>str</name> <operator>!=</operator> <literal type="char">'\0'</literal></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>
	</block_content>}</block></while>

	<return>return <expr><call><name>buf_finalize</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</return>

<label><name>bad_format</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_TEXT_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid input syntax for type %s: \"%s\""</literal></expr></argument>,
					<argument><expr><literal type="string">"txid_snapshot"</literal></expr></argument>, <argument><expr><name>str_start</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<return>return <expr><name>NULL</name></expr>;</return>				<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Public functions.
 *
 * txid_current() and txid_current_snapshot() are the only ones that
 * communicate with core xid machinery.  All the others work on data
 * returned by them.
 */</comment>

<comment type="block">/*
 * txid_current() returns int8
 *
 *	Return the current toplevel transaction ID as TXID
 *	If the current transaction does not have one, one is assigned.
 *
 *	This value has the epoch as the high 32 bits and the 32-bit xid
 *	as the low 32 bits.
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_current</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>txid</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TxidEpoch</name></type>	<name>state</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * Must prevent during recovery because if an xid is not assigned we try
	 * to assign one, which would fail. Programs already rely on this function
	 * to always return a valid current xid, so we should not change this to
	 * return NULL or similar invalid xid.
	 */</comment>
	<expr_stmt><expr><call><name>PreventCommandDuringRecovery</name><argument_list>(<argument><expr><literal type="string">"txid_current()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>load_xid_epoch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>convert_xid</name><argument_list>(<argument><expr><call><name>GetTopTransactionId</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Same as txid_current() but doesn't assign a new xid if there isn't one
 * yet.
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_current_if_assigned</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>txid</name></type>		<name>val</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TxidEpoch</name></type>	<name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>topxid</name> <init>= <expr><call><name>GetTopTransactionIdIfAny</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>topxid</name> <operator>==</operator> <name>InvalidTransactionId</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>load_xid_epoch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>val</name> <operator>=</operator> <call><name>convert_xid</name><argument_list>(<argument><expr><name>topxid</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name>val</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * txid_current_snapshot() returns txid_snapshot
 *
 *		Return current snapshot in TXID format
 *
 * Note that only top-transaction XIDs are included in the snapshot.
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_current_snapshot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>nxip</name></decl>,
				<decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TxidEpoch</name></type>	<name>state</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type>	<name>cur</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>cur</name> <operator>=</operator> <call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"no active snapshot set"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>load_xid_epoch</name><argument_list>(<argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Compile-time limits on the procarray (MAX_BACKENDS processes plus
	 * MAX_BACKENDS prepared transactions) guarantee nxip won't be too large.
	 */</comment>
	<expr_stmt><expr><call><name>StaticAssertStmt</name><argument_list>(<argument><expr><name>MAX_BACKENDS</name> <operator>*</operator> <literal type="number">2</literal> <operator>&lt;=</operator> <name>TXID_SNAPSHOT_MAX_NXIP</name></expr></argument>,
					 <argument><expr><literal type="string">"possible overflow in txid_current_snapshot()"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* allocate */</comment>
	<expr_stmt><expr><name>nxip</name> <operator>=</operator> <name><name>cur</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>TXID_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><name>nxip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* fill */</comment>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <call><name>convert_xid</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <call><name>convert_xid</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name> <operator>=</operator> <name>nxip</name></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nxip</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <call><name>convert_xid</name><argument_list>(<argument><expr><name><name>cur</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><operator>&amp;</operator><name>state</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * We want them guaranteed to be in ascending order.  This also removes
	 * any duplicate xids.  Normally, an XID can only be assigned to one
	 * backend, but when preparing a transaction for two-phase commit, there
	 * is a transient state when both the original backend and the dummy
	 * PGPROC entry reserved for the prepared transaction hold the same XID.
	 */</comment>
	<expr_stmt><expr><call><name>sort_snapshot</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* set size after sorting, because it may have removed duplicate xips */</comment>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><call><name>TXID_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * txid_snapshot_in(cstring) returns txid_snapshot
 *
 *		input function for type txid_snapshot
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_snapshot_in</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>str</name> <init>= <expr><call><name>PG_GETARG_CSTRING</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>parse_snapshot</name><argument_list>(<argument><expr><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * txid_snapshot_out(txid_snapshot) returns cstring
 *
 *		output function for type txid_snapshot
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_snapshot_out</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>TxidSnapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>TXID_FMT</name> <literal type="string">":"</literal></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>TXID_FMT</name> <literal type="string">":"</literal></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>i</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>appendStringInfoChar</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="char">','</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><name>TXID_FMT</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><call><name>PG_RETURN_CSTRING</name><argument_list>(<argument><expr><name><name>str</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * txid_snapshot_recv(internal) returns txid_snapshot
 *
 *		binary input function for type txid_snapshot
 *
 *		format: int4 nxip, int8 xmin, int8 xmax, int8 xip
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_snapshot_recv</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfo</name></type>	<name>buf</name> <init>= <expr><operator>(</operator><name>StringInfo</name><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>txid</name></type>		<name>last</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>nxip</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>txid</name></type>		<name>xmin</name></decl>,
				<decl><type ref="prev"/><name>xmax</name></decl>;</decl_stmt>

	<comment type="block">/* load and validate nxip */</comment>
	<expr_stmt><expr><name>nxip</name> <operator>=</operator> <call><name>pq_getmsgint</name><argument_list>(<argument><expr><name>buf</name></expr></argument>, <argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>nxip</name> <argument_list type="generic">&lt; <argument><expr><literal type="number">0</literal> <operator>||</operator> <name>nxip</name></expr></argument> &gt;</argument_list></name> <name>TXID_SNAPSHOT_MAX_NXIP</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>xmin</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>xmax</name> <operator>=</operator> <call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name>xmin</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>xmax</name> <operator>==</operator> <literal type="number">0</literal> <operator>||</operator> <name>xmin</name> <operator>&gt;</operator> <name>xmax</name> <operator>||</operator> <name>xmax</name> <operator>&gt;</operator> <name>MAX_TXID</name></expr>)</condition><block type="pseudo"><block_content>
		<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>palloc</name><argument_list>(<argument><expr><call><name>TXID_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><name>nxip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name>xmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name>xmax</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nxip</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>txid</name></type>		<name>cur</name> <init>= <expr><call><name>pq_getmsgint64</name><argument_list>(<argument><expr><name>buf</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>&lt;</operator> <name>last</name> <operator>||</operator> <name>cur</name> <operator>&lt;</operator> <name>xmin</name> <operator>||</operator> <name>cur</name> <operator>&gt;=</operator> <name>xmax</name></expr>)</condition><block type="pseudo"><block_content>
			<goto>goto <name>bad_format</name>;</goto></block_content></block></if></if_stmt>

		<comment type="block">/* skip duplicate xips */</comment>
		<if_stmt><if>if <condition>(<expr><name>cur</name> <operator>==</operator> <name>last</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>i</name><operator>--</operator></expr>;</expr_stmt>
			<expr_stmt><expr><name>nxip</name><operator>--</operator></expr>;</expr_stmt>
			<continue>continue;</continue>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>last</name> <operator>=</operator> <name>cur</name></expr>;</expr_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name> <operator>=</operator> <name>nxip</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>SET_VARSIZE</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><call><name>TXID_SNAPSHOT_SIZE</name><argument_list>(<argument><expr><name>nxip</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

<label><name>bad_format</name>:</label>
	<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
			<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_INVALID_BINARY_REPRESENTATION</name></expr></argument>)</argument_list></call><operator>,</operator>
			 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"invalid external txid_snapshot data"</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>PG_RETURN_POINTER</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>	<comment type="block">/* keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * txid_snapshot_send(txid_snapshot) returns bytea
 *
 *		binary output function for type txid_snapshot
 *
 *		format: int4 nxip, int8 xmin, int8 xmax, int8 xip
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_snapshot_send</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>TxidSnapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint32</name></type>		<name>i</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>pq_begintypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint32</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>pq_sendint64</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></for>
	<expr_stmt><expr><call><name>PG_RETURN_BYTEA_P</name><argument_list>(<argument><expr><call><name>pq_endtypsend</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * txid_visible_in_snapshot(int8, txid_snapshot) returns bool
 *
 *		is txid visible in snapshot ?
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_visible_in_snapshot</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>txid</name></type>		<name>value</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>TxidSnapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_BOOL</name><argument_list>(<argument><expr><call><name>is_visible_txid</name><argument_list>(<argument><expr><name>value</name></expr></argument>, <argument><expr><name>snap</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * txid_snapshot_xmin(txid_snapshot) returns int8
 *
 *		return snapshot's xmin
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_snapshot_xmin</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>TxidSnapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * txid_snapshot_xmax(txid_snapshot) returns int8
 *
 *		return snapshot's xmax
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_snapshot_xmax</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name> <init>= <expr><operator>(</operator><name>TxidSnapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_INT64</name><argument_list>(<argument><expr><name><name>snap</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * txid_snapshot_xip(txid_snapshot) returns setof int8
 *
 *		return in-progress TXIDs in snapshot.
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_snapshot_xip</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>FuncCallContext</name> <modifier>*</modifier></type><name>fctx</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>snap</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>txid</name></type>		<name>value</name></decl>;</decl_stmt>

	<comment type="block">/* on first call initialize snap_state and get copy of snapshot */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>SRF_IS_FIRSTCALL</name><argument_list>()</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>TxidSnapshot</name> <modifier>*</modifier></type><name>arg</name> <init>= <expr><operator>(</operator><name>TxidSnapshot</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_VARLENA_P</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>fctx</name> <operator>=</operator> <call><name>SRF_FIRSTCALL_INIT</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* make a copy of user snapshot */</comment>
		<expr_stmt><expr><name>snap</name> <operator>=</operator> <call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name><name>fctx</name><operator>-&gt;</operator><name>multi_call_memory_ctx</name></name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>snap</name></expr></argument>, <argument><expr><name>arg</name></expr></argument>, <argument><expr><call><name>VARSIZE</name><argument_list>(<argument><expr><name>arg</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name><name>fctx</name><operator>-&gt;</operator><name>user_fctx</name></name> <operator>=</operator> <name>snap</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* return values one-by-one */</comment>
	<expr_stmt><expr><name>fctx</name> <operator>=</operator> <call><name>SRF_PERCALL_SETUP</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>snap</name> <operator>=</operator> <name><name>fctx</name><operator>-&gt;</operator><name>user_fctx</name></name></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>fctx</name><operator>-&gt;</operator><name>call_cntr</name></name> <operator>&lt;</operator> <name><name>snap</name><operator>-&gt;</operator><name>nxip</name></name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>value</name> <operator>=</operator> <name><name>snap</name><operator>-&gt;</operator><name>xip</name><index>[<expr><name><name>fctx</name><operator>-&gt;</operator><name>call_cntr</name></name></expr>]</index></name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>SRF_RETURN_NEXT</name><argument_list>(<argument><expr><name>fctx</name></expr></argument>, <argument><expr><call><name>Int64GetDatum</name><argument_list>(<argument><expr><name>value</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>SRF_RETURN_DONE</name><argument_list>(<argument><expr><name>fctx</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Report the status of a recent transaction ID, or null for wrapped,
 * truncated away or otherwise too old XIDs.
 *
 * The passed epoch-qualified xid is treated as a normal xid, not a
 * multixact id.
 *
 * If it points to a committed subxact the result is the subxact status even
 * though the parent xact may still be in progress or may have aborted.
 */</comment>
<function><type><name>Datum</name></type>
<name>txid_status</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>status</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>uint64</name></type>		<name>xid_with_epoch</name> <init>= <expr><call><name>PG_GETARG_INT64</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name></type> <name>xid</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We must protect against concurrent truncation of clog entries to avoid
	 * an I/O error on SLRU lookup.
	 */</comment>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>CLogTruncationLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><call><name>TransactionIdInRecentPast</name><argument_list>(<argument><expr><name>xid_with_epoch</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsValid</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"in progress"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TransactionIdDidCommit</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"committed"</literal></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><call><name>TransactionIdDidAbort</name><argument_list>(<argument><expr><name>xid</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"aborted"</literal></expr>;</expr_stmt></block_content></block></if>
		<else>else
		<block>{<block_content>
			<comment type="block">/*
			 * The xact is not marked as either committed or aborted in clog.
			 *
			 * It could be a transaction that ended without updating clog or
			 * writing an abort record due to a crash. We can safely assume
			 * it's aborted if it isn't committed and is older than our
			 * snapshot xmin.
			 *
			 * Otherwise it must be in-progress (or have been at the time we
			 * checked commit/abort status).
			 */</comment>
			<if_stmt><if>if <condition>(<expr><call><name>TransactionIdPrecedes</name><argument_list>(<argument><expr><name>xid</name></expr></argument>, <argument><expr><call><name>GetActiveSnapshot</name><argument_list>()</argument_list></call><operator>-&gt;</operator><name>xmin</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"aborted"</literal></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>status</name> <operator>=</operator> <literal type="string">"in progress"</literal></expr>;</expr_stmt></block_content></block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><name>status</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>CLogTruncationLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>status</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_NULL</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_TEXT_P</name><argument_list>(<argument><expr><call><name>cstring_to_text</name><argument_list>(<argument><expr><name>status</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
</block_content>}</block></function>
</unit>
