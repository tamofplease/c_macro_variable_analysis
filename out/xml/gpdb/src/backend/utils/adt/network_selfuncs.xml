<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/adt/network_selfuncs.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * network_selfuncs.c
 *	  Functions for selectivity estimation of inet/cidr operators
 *
 * This module provides estimators for the subnet inclusion and overlap
 * operators.  Estimates are based on null fraction, most common values,
 * and histogram of inet/cidr columns.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 *
 * IDENTIFICATION
 *	  src/backend/utils/adt/network_selfuncs.c
 *
 *-------------------------------------------------------------------------
 */</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>&lt;math.h&gt;</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_operator.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"catalog/pg_statistic.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/inet.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/lsyscache.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/selfuncs.h"</cpp:file></cpp:include>


<comment type="block">/* Default selectivity for the inet overlap operator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_OVERLAP_SEL</name></cpp:macro> <cpp:value>0.01</cpp:value></cpp:define>

<comment type="block">/* Default selectivity for the various inclusion operators */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_INCLUSION_SEL</name></cpp:macro> <cpp:value>0.005</cpp:value></cpp:define>

<comment type="block">/* Default selectivity for specified operator */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DEFAULT_SEL</name><parameter_list>(<parameter><type><name>operator</name></type></parameter>)</parameter_list></cpp:macro> \
	<cpp:value>((operator) == OID_INET_OVERLAP_OP ? \
	 DEFAULT_OVERLAP_SEL : DEFAULT_INCLUSION_SEL)</cpp:value></cpp:define>

<comment type="block">/* Maximum number of items to consider in join selectivity calculations */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>MAX_CONSIDERED_ELEMS</name></cpp:macro> <cpp:value>1024</cpp:value></cpp:define>

<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>networkjoinsel_inner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>,
										<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata1</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>networkjoinsel_semi</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>,
									   <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata1</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata2</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>mcv_population</name><parameter_list>(<parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>mcv_numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcv_nvalues</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>inet_hist_value_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>,
									   <parameter><decl><type><name>Datum</name></type> <name>constvalue</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>inet_mcv_join_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcv1_values</name></decl></parameter>,
									 <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>mcv1_numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcv1_nvalues</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcv2_values</name></decl></parameter>,
									 <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>mcv2_numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcv2_nvalues</name></decl></parameter>, <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>inet_mcv_hist_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcv_values</name></decl></parameter>, <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>mcv_numbers</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>mcv_nvalues</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>,
									 <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>inet_hist_inclusion_join_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>hist1_values</name></decl></parameter>,
												<parameter><decl><type><name>int</name></type> <name>hist1_nvalues</name></decl></parameter>,
												<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>hist2_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist2_nvalues</name></decl></parameter>,
												<parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>Selectivity</name></type> <name>inet_semi_join_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lhs_value</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>mcv_exists</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcv_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcv_nvalues</name></decl></parameter>,
									  <parameter><decl><type><name>bool</name></type> <name>hist_exists</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>,
									  <parameter><decl><type><name>double</name></type> <name>hist_weight</name></decl></parameter>,
									  <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>inet_opr_codenum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>inet_inclusion_cmp</name><parameter_list>(<parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>inet_masklen_inclusion_cmp</name><parameter_list>(<parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>right</name></decl></parameter>,
									   <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>int</name></type>	<name>inet_hist_match_divider</name><parameter_list>(<parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>boundary</name></decl></parameter>, <parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>query</name></decl></parameter>,
									<parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Selectivity estimation for the subnet inclusion/overlap operators
 */</comment>
<function><type><name>Datum</name></type>
<name>networksel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>varRelid</name> <init>= <expr><call><name>PG_GETARG_INT32</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Node</name>	   <modifier>*</modifier></type><name>other</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>varonleft</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name></decl>,
				<decl><type ref="prev"/><name>mcv_selec</name></decl>,
				<decl><type ref="prev"/><name>non_mcv_selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Datum</name></type>		<name>constvalue</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>hslot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>sumcommon</name></decl>,
				<decl><type ref="prev"/><name>nullfrac</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>proc</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * If expression is not (variable op something) or (something op
	 * variable), then punt and return a default estimate.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>get_restriction_variable</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>varRelid</name></expr></argument>,
								  <argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>other</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>varonleft</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Can't do anything useful if the something is not a constant, either.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsA</name><argument_list>(<argument><expr><name>other</name></expr></argument>, <argument><expr><name>Const</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* All of the operators handled here are strict. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constisnull</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><literal type="number">0.0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
	<expr_stmt><expr><name>constvalue</name> <operator>=</operator> <operator>(</operator><operator>(</operator><name>Const</name> <operator>*</operator><operator>)</operator> <name>other</name><operator>)</operator><operator>-&gt;</operator><name>constvalue</name></expr>;</expr_stmt>

	<comment type="block">/* Otherwise, we need stats in order to produce a non-default estimate. */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>nullfrac</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have most-common-values info, add up the fractions of the MCV
	 * entries that satisfy MCV OP CONST.  These fractions contribute directly
	 * to the result selectivity.  Also add up the total fraction represented
	 * by MCV entries.
	 */</comment>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>mcv_selec</name> <operator>=</operator> <call><name>mcv_selectivity</name><argument_list>(<argument><expr><operator>&amp;</operator><name>vardata</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc</name></expr></argument>, <argument><expr><name>constvalue</name></expr></argument>, <argument><expr><name>varonleft</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>sumcommon</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we have a histogram, use it to estimate the proportion of the
	 * non-MCV population that satisfies the clause.  If we don't, apply the
	 * default selectivity to that population.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>, <argument><expr><name><name>vardata</name><operator>.</operator><name>statsTuple</name></name></expr></argument>,
						 <argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
						 <argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>opr_codenum</name> <init>= <expr><call><name>inet_opr_codenum</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<comment type="block">/* Commute if needed, so we can consider histogram to be on the left */</comment>
		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>varonleft</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>opr_codenum</name> <operator>=</operator> <operator>-</operator><name>opr_codenum</name></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<expr_stmt><expr><name>non_mcv_selec</name> <operator>=</operator> <call><name>inet_hist_value_sel</name><argument_list>(<argument><expr><name><name>hslot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>hslot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
											<argument><expr><name>constvalue</name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hslot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else<block type="pseudo"><block_content>
		<expr_stmt><expr><name>non_mcv_selec</name> <operator>=</operator> <call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>

	<comment type="block">/* Combine selectivities for MCV and non-MCV populations */</comment>
	<expr_stmt><expr><name>selec</name> <operator>=</operator> <name>mcv_selec</name> <operator>+</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac</name> <operator>-</operator> <name>sumcommon</name><operator>)</operator> <operator>*</operator> <name>non_mcv_selec</name></expr>;</expr_stmt>

	<comment type="block">/* Result should be in range, but make sure... */</comment>
	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Join selectivity estimation for the subnet inclusion/overlap operators
 *
 * This function has the same structure as eqjoinsel() in selfuncs.c.
 *
 * Throughout networkjoinsel and its subroutines, we have a performance issue
 * in that the amount of work to be done is O(N^2) in the length of the MCV
 * and histogram arrays.  To keep the runtime from getting out of hand when
 * large statistics targets have been set, we arbitrarily limit the number of
 * values considered to 1024 (MAX_CONSIDERED_ELEMS).  For the MCV arrays, this
 * is easy: just consider at most the first N elements.  (Since the MCVs are
 * sorted by decreasing frequency, this correctly gets us the first N MCVs.)
 * For the histogram arrays, we decimate; that is consider only every k'th
 * element, where k is chosen so that no more than MAX_CONSIDERED_ELEMS
 * elements are considered.  This should still give us a good random sample of
 * the non-MCV population.  Decimation is done on-the-fly in the loops that
 * iterate over the histogram arrays.
 */</comment>
<function><type><name>Datum</name></type>
<name>networkjoinsel</name><parameter_list>(<parameter><decl><type><name>PG_FUNCTION_ARGS</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>PlannerInfo</name> <modifier>*</modifier></type><name>root</name> <init>= <expr><operator>(</operator><name>PlannerInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Oid</name></type>			<name>operator</name> <init>= <expr><call><name>PG_GETARG_OID</name><argument_list>(<argument><expr><literal type="number">1</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>List</name>	   <modifier>*</modifier></type><name>args</name> <init>= <expr><operator>(</operator><name>List</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">2</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:ifdef>#<cpp:directive>ifdef</cpp:directive> <name>NOT_USED</name></cpp:ifdef>
	<decl_stmt><decl><type><name>JoinType</name></type>	<name>jointype</name> <init>= <expr><operator>(</operator><name>JoinType</name><operator>)</operator> <call><name>PG_GETARG_INT16</name><argument_list>(<argument><expr><literal type="number">3</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
<cpp:endif>#<cpp:directive>endif</cpp:directive></cpp:endif>
	<decl_stmt><decl><type><name>SpecialJoinInfo</name> <modifier>*</modifier></type><name>sjinfo</name> <init>= <expr><operator>(</operator><name>SpecialJoinInfo</name> <operator>*</operator><operator>)</operator> <call><name>PG_GETARG_POINTER</name><argument_list>(<argument><expr><literal type="number">4</literal></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>selec</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata1</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>VariableStatData</name></type> <name>vardata2</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>join_is_reversed</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>get_join_variables</name><argument_list>(<argument><expr><name>root</name></expr></argument>, <argument><expr><name>args</name></expr></argument>, <argument><expr><name>sjinfo</name></expr></argument>,
					   <argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>join_is_reversed</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<switch>switch <condition>(<expr><name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>JOIN_INNER</name></expr>:</case>
		<case>case <expr><name>JOIN_LEFT</name></expr>:</case>
		<case>case <expr><name>JOIN_FULL</name></expr>:</case>

			<comment type="block">/*
			 * Selectivity for left/full join is not exactly the same as inner
			 * join, but we neglect the difference, as eqjoinsel does.
			 */</comment>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>networkjoinsel_inner</name><argument_list>(<argument><expr><name>operator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<break>break;</break>
		<case>case <expr><name>JOIN_SEMI</name></expr>:</case>
		<case>case <expr><name>JOIN_ANTI</name></expr>:</case>
			<comment type="block">/* Here, it's important that we pass the outer var on the left. */</comment>
			<if_stmt><if>if <condition>(<expr><operator>!</operator><name>join_is_reversed</name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>networkjoinsel_semi</name><argument_list>(<argument><expr><name>operator</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
			<else>else<block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>=</operator> <call><name>networkjoinsel_semi</name><argument_list>(<argument><expr><call><name>get_commutator</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>,
											<argument><expr><operator>&amp;</operator><name>vardata2</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>vardata1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
			<break>break;</break>
		<default>default:</default>
			<comment type="block">/* other values not expected here */</comment>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized join type: %d"</literal></expr></argument>,
				 <argument><expr><operator>(</operator><name>int</name><operator>)</operator> <name><name>sjinfo</name><operator>-&gt;</operator><name>jointype</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>selec</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>			<comment type="block">/* keep compiler quiet */</comment>
			<break>break;</break>
	</block_content>}</block></switch>

	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata1</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>ReleaseVariableStats</name><argument_list>(<argument><expr><name>vardata2</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>CLAMP_PROBABILITY</name><argument_list>(<argument><expr><name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>PG_RETURN_FLOAT8</name><argument_list>(<argument><expr><operator>(</operator><name>float8</name><operator>)</operator> <name>selec</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Inner join selectivity estimation for subnet inclusion/overlap operators
 *
 * Calculates MCV vs MCV, MCV vs histogram and histogram vs histogram
 * selectivity for join using the subnet inclusion operators.  Unlike the
 * join selectivity function for the equality operator, eqjoinsel_inner(),
 * one to one matching of the values is not enough.  Network inclusion
 * operators are likely to match many to many, so we must check all pairs.
 * (Note: it might be possible to exploit understanding of the histogram's
 * btree ordering to reduce the work needed, but we don't currently try.)
 * Also, MCV vs histogram selectivity is not neglected as in eqjoinsel_inner().
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>networkjoinsel_inner</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>,
					 <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata1</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac1</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>nullfrac2</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sumcommon1</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sumcommon2</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mcv1_exists</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>mcv2_exists</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>hist1_exists</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>hist2_exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>opr_codenum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>mcv1_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>mcv2_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>mcv1_slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>mcv2_slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>hist1_slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>hist2_slot</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata1</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata1</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullfrac1</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>mcv1_exists</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv1_slot</name></expr></argument>, <argument><expr><name><name>vardata1</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
									   <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
									   <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hist1_exists</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist1_slot</name></expr></argument>, <argument><expr><name><name>vardata1</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
										<argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Arbitrarily limit number of MCVs considered */</comment>
		<expr_stmt><expr><name>mcv1_length</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>mcv1_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>, <argument><expr><name>MAX_CONSIDERED_ELEMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mcv1_exists</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sumcommon1</name> <operator>=</operator> <call><name>mcv_population</name><argument_list>(<argument><expr><name><name>mcv1_slot</name><operator>.</operator><name>numbers</name></name></expr></argument>, <argument><expr><name>mcv1_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv1_slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mcv1_slot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist1_slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hist1_slot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata2</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata2</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullfrac2</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>mcv2_exists</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv2_slot</name></expr></argument>, <argument><expr><name><name>vardata2</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
									   <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
									   <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hist2_exists</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist2_slot</name></expr></argument>, <argument><expr><name><name>vardata2</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
										<argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Arbitrarily limit number of MCVs considered */</comment>
		<expr_stmt><expr><name>mcv2_length</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>, <argument><expr><name>MAX_CONSIDERED_ELEMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mcv2_exists</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sumcommon2</name> <operator>=</operator> <call><name>mcv_population</name><argument_list>(<argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>numbers</name></name></expr></argument>, <argument><expr><name>mcv2_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv2_slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mcv2_slot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist2_slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hist2_slot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>opr_codenum</name> <operator>=</operator> <call><name>inet_opr_codenum</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Calculate selectivity for MCV vs MCV matches.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mcv1_exists</name> <operator>&amp;&amp;</operator> <name>mcv2_exists</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>+=</operator> <call><name>inet_mcv_join_sel</name><argument_list>(<argument><expr><name><name>mcv1_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>mcv1_slot</name><operator>.</operator><name>numbers</name></name></expr></argument>,
								   <argument><expr><name>mcv1_length</name></expr></argument>,
								   <argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>numbers</name></name></expr></argument>,
								   <argument><expr><name>mcv2_length</name></expr></argument>,
								   <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add in selectivities for MCV vs histogram matches, scaling according to
	 * the fractions of the populations represented by the histograms. Note
	 * that the second case needs to commute the operator.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mcv1_exists</name> <operator>&amp;&amp;</operator> <name>hist2_exists</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>+=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac2</name> <operator>-</operator> <name>sumcommon2</name><operator>)</operator> <operator>*</operator>
			<call><name>inet_mcv_hist_sel</name><argument_list>(<argument><expr><name><name>mcv1_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>mcv1_slot</name><operator>.</operator><name>numbers</name></name></expr></argument>, <argument><expr><name>mcv1_length</name></expr></argument>,
							  <argument><expr><name><name>hist2_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>hist2_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
							  <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<if_stmt><if>if <condition>(<expr><name>mcv2_exists</name> <operator>&amp;&amp;</operator> <name>hist1_exists</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>+=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name> <operator>-</operator> <name>sumcommon1</name><operator>)</operator> <operator>*</operator>
			<call><name>inet_mcv_hist_sel</name><argument_list>(<argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>numbers</name></name></expr></argument>, <argument><expr><name>mcv2_length</name></expr></argument>,
							  <argument><expr><name><name>hist1_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>hist1_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
							  <argument><expr><operator>-</operator><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Add in selectivity for histogram vs histogram matches, again scaling
	 * appropriately.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hist1_exists</name> <operator>&amp;&amp;</operator> <name>hist2_exists</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>+=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name> <operator>-</operator> <name>sumcommon1</name><operator>)</operator> <operator>*</operator>
			<operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac2</name> <operator>-</operator> <name>sumcommon2</name><operator>)</operator> <operator>*</operator>
			<call><name>inet_hist_inclusion_join_sel</name><argument_list>(<argument><expr><name><name>hist1_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>hist1_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
										 <argument><expr><name><name>hist2_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>hist2_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
										 <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * If useful statistics are not available then use the default estimate.
	 * We can apply null fractions if known, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>mcv1_exists</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hist1_exists</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>mcv2_exists</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hist2_exists</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac2</name><operator>)</operator> <operator>*</operator> <call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release stats. */</comment>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv1_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv2_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist1_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist2_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Semi join selectivity estimation for subnet inclusion/overlap operators
 *
 * Calculates MCV vs MCV, MCV vs histogram, histogram vs MCV, and histogram vs
 * histogram selectivity for semi/anti join cases.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>networkjoinsel_semi</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>,
					<parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata1</name></decl></parameter>, <parameter><decl><type><name>VariableStatData</name> <modifier>*</modifier></type><name>vardata2</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Form_pg_statistic</name></type> <name>stats</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sumcommon1</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>sumcommon2</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>double</name></type>		<name>nullfrac1</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>nullfrac2</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>hist2_weight</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>mcv1_exists</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>mcv2_exists</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>hist1_exists</name> <init>= <expr><name>false</name></expr></init></decl>,
				<decl><type ref="prev"/><name>hist2_exists</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>opr_codenum</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>mcv1_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>,
				<decl><type ref="prev"/><name>mcv2_length</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>mcv1_slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>mcv2_slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>hist1_slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>AttStatsSlot</name></type> <name>hist2_slot</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata1</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata1</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullfrac1</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>mcv1_exists</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv1_slot</name></expr></argument>, <argument><expr><name><name>vardata1</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
									   <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
									   <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hist1_exists</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist1_slot</name></expr></argument>, <argument><expr><name><name>vardata1</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
										<argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Arbitrarily limit number of MCVs considered */</comment>
		<expr_stmt><expr><name>mcv1_length</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>mcv1_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>, <argument><expr><name>MAX_CONSIDERED_ELEMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mcv1_exists</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sumcommon1</name> <operator>=</operator> <call><name>mcv_population</name><argument_list>(<argument><expr><name><name>mcv1_slot</name><operator>.</operator><name>numbers</name></name></expr></argument>, <argument><expr><name>mcv1_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv1_slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mcv1_slot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist1_slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hist1_slot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<if_stmt><if>if <condition>(<expr><call><name>HeapTupleIsValid</name><argument_list>(<argument><expr><name><name>vardata2</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>stats</name> <operator>=</operator> <operator>(</operator><name>Form_pg_statistic</name><operator>)</operator> <call><name>GETSTRUCT</name><argument_list>(<argument><expr><name><name>vardata2</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>nullfrac2</name> <operator>=</operator> <name><name>stats</name><operator>-&gt;</operator><name>stanullfrac</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>mcv2_exists</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv2_slot</name></expr></argument>, <argument><expr><name><name>vardata2</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
									   <argument><expr><name>STATISTIC_KIND_MCV</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
									   <argument><expr><name>ATTSTATSSLOT_VALUES</name> <operator>|</operator> <name>ATTSTATSSLOT_NUMBERS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>hist2_exists</name> <operator>=</operator> <call><name>get_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist2_slot</name></expr></argument>, <argument><expr><name><name>vardata2</name><operator>-&gt;</operator><name>statsTuple</name></name></expr></argument>,
										<argument><expr><name>STATISTIC_KIND_HISTOGRAM</name></expr></argument>, <argument><expr><name>InvalidOid</name></expr></argument>,
										<argument><expr><name>ATTSTATSSLOT_VALUES</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<comment type="block">/* Arbitrarily limit number of MCVs considered */</comment>
		<expr_stmt><expr><name>mcv2_length</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>, <argument><expr><name>MAX_CONSIDERED_ELEMS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>mcv2_exists</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>sumcommon2</name> <operator>=</operator> <call><name>mcv_population</name><argument_list>(<argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>numbers</name></name></expr></argument>, <argument><expr><name>mcv2_length</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv2_slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>mcv2_slot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist2_slot</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hist2_slot</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>

	<expr_stmt><expr><name>opr_codenum</name> <operator>=</operator> <call><name>inet_opr_codenum</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* Estimate number of input rows represented by RHS histogram. */</comment>
	<if_stmt><if>if <condition>(<expr><name>hist2_exists</name> <operator>&amp;&amp;</operator> <name><name>vardata2</name><operator>-&gt;</operator><name>rel</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>hist2_weight</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac2</name> <operator>-</operator> <name>sumcommon2</name><operator>)</operator> <operator>*</operator> <name><name>vardata2</name><operator>-&gt;</operator><name>rel</name><operator>-&gt;</operator><name>rows</name></name></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Consider each element of the LHS MCV list, matching it to whatever RHS
	 * stats we have.  Scale according to the known frequency of the MCV.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>mcv1_exists</name> <operator>&amp;&amp;</operator> <operator>(</operator><name>mcv2_exists</name> <operator>||</operator> <name>hist2_exists</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mcv1_length</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>selec</name> <operator>+=</operator> <name><name>mcv1_slot</name><operator>.</operator><name>numbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator>
				<call><name>inet_semi_join_sel</name><argument_list>(<argument><expr><name><name>mcv1_slot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name>mcv2_exists</name></expr></argument>, <argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name>mcv2_length</name></expr></argument>,
								   <argument><expr><name>hist2_exists</name></expr></argument>,
								   <argument><expr><name><name>hist2_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>hist2_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
								   <argument><expr><name>hist2_weight</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>proc</name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Consider each element of the LHS histogram, except for the first and
	 * last elements, which we exclude on the grounds that they're outliers
	 * and thus not very representative.  Scale on the assumption that each
	 * such histogram element represents an equal share of the LHS histogram
	 * population (which is a bit bogus, because the members of its bucket may
	 * not all act the same with respect to the join clause, but it's hard to
	 * do better).
	 *
	 * If there are too many histogram elements, decimate to limit runtime.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>hist1_exists</name> <operator>&amp;&amp;</operator> <name><name>hist1_slot</name><operator>.</operator><name>nvalues</name></name> <operator>&gt;</operator> <literal type="number">2</literal> <operator>&amp;&amp;</operator> <operator>(</operator><name>mcv2_exists</name> <operator>||</operator> <name>hist2_exists</name><operator>)</operator></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>double</name></type>		<name>hist_selec_sum</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type>			<name>k</name></decl>,
					<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name><name>hist1_slot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator> <operator>/</operator> <name>MAX_CONSIDERED_ELEMS</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>hist1_slot</name><operator>.</operator><name>nvalues</name></name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>k</name></expr></incr>)</control>
		<block>{<block_content>
			<expr_stmt><expr><name>hist_selec_sum</name> <operator>+=</operator>
				<call><name>inet_semi_join_sel</name><argument_list>(<argument><expr><name><name>hist1_slot</name><operator>.</operator><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								   <argument><expr><name>mcv2_exists</name></expr></argument>, <argument><expr><name><name>mcv2_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name>mcv2_length</name></expr></argument>,
								   <argument><expr><name>hist2_exists</name></expr></argument>,
								   <argument><expr><name><name>hist2_slot</name><operator>.</operator><name>values</name></name></expr></argument>, <argument><expr><name><name>hist2_slot</name><operator>.</operator><name>nvalues</name></name></expr></argument>,
								   <argument><expr><name>hist2_weight</name></expr></argument>,
								   <argument><expr><operator>&amp;</operator><name>proc</name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><name>selec</name> <operator>+=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name> <operator>-</operator> <name>sumcommon1</name><operator>)</operator> <operator>*</operator> <name>hist_selec_sum</name> <operator>/</operator> <name>n</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * If useful statistics are not available then use the default estimate.
	 * We can apply null fractions if known, though.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><operator>!</operator><name>mcv1_exists</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hist1_exists</name><operator>)</operator> <operator>||</operator> <operator>(</operator><operator>!</operator><name>mcv2_exists</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>hist2_exists</name><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>selec</name> <operator>=</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac1</name><operator>)</operator> <operator>*</operator> <operator>(</operator><literal type="number">1.0</literal> <operator>-</operator> <name>nullfrac2</name><operator>)</operator> <operator>*</operator> <call><name>DEFAULT_SEL</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Release stats. */</comment>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv1_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>mcv2_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist1_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>free_attstatsslot</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hist2_slot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Compute the fraction of a relation's population that is represented
 * by the MCV list.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>mcv_population</name><parameter_list>(<parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>mcv_numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcv_nvalues</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>sumcommon</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mcv_nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>sumcommon</name> <operator>+=</operator> <name><name>mcv_numbers</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>sumcommon</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Inet histogram vs single value selectivity estimation
 *
 * Estimate the fraction of the histogram population that satisfies
 * "value OPR CONST".  (The result needs to be scaled to reflect the
 * proportion of the total population represented by the histogram.)
 *
 * The histogram is originally for the inet btree comparison operators.
 * Only the common bits of the network part and the length of the network part
 * (masklen) are interesting for the subnet inclusion operators.  Fortunately,
 * btree comparison treats the network part as the major sort key.  Even so,
 * the length of the network part would not really be significant in the
 * histogram.  This would lead to big mistakes for data sets with uneven
 * masklen distribution.  To reduce this problem, comparisons with the left
 * and the right sides of the buckets are used together.
 *
 * Histogram bucket matches are calculated in two forms.  If the constant
 * matches both bucket endpoints the bucket is considered as fully matched.
 * The second form is to match the bucket partially; we recognize this when
 * the constant matches just one endpoint, or the two endpoints fall on
 * opposite sides of the constant.  (Note that when the constant matches an
 * interior histogram element, it gets credit for partial matches to the
 * buckets on both sides, while a match to a histogram endpoint gets credit
 * for only one partial match.  This is desirable.)
 *
 * The divider in the partial bucket match is imagined as the distance
 * between the decisive bits and the common bits of the addresses.  It will
 * be used as a power of two as it is the natural scale for the IP network
 * inclusion.  This partial bucket match divider calculation is an empirical
 * formula and subject to change with more experiment.
 *
 * For a partial match, we try to calculate dividers for both of the
 * boundaries.  If the address family of a boundary value does not match the
 * constant or comparison of the length of the network parts is not correct
 * for the operator, the divider for that boundary will not be taken into
 * account.  If both of the dividers are valid, the greater one will be used
 * to minimize the mistake in buckets that have disparate masklens.  This
 * calculation is unfair when dividers can be calculated for both of the
 * boundaries but they are far from each other; but it is not a common
 * situation as the boundaries are expected to share most of their significant
 * bits of their masklens.  The mistake would be greater, if we would use the
 * minimum instead of the maximum, and we don't know a sensible way to combine
 * them.
 *
 * For partial match in buckets that have different address families on the
 * left and right sides, only the boundary with the same address family is
 * taken into consideration.  This can cause more mistakes for these buckets
 * if the masklens of their boundaries are also disparate.  But this can only
 * happen in one bucket, since only two address families exist.  It seems a
 * better option than not considering these buckets at all.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>inet_hist_value_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>nvalues</name></decl></parameter>, <parameter><decl><type><name>Datum</name></type> <name>constvalue</name></decl></parameter>,
					<parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>match</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>inet</name>	   <modifier>*</modifier></type><name>query</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>left</name></decl>,
			   <decl><type ref="prev"><modifier>*</modifier></type><name>right</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>left_order</name></decl>,
				<decl><type ref="prev"/><name>right_order</name></decl>,
				<decl><type ref="prev"/><name>left_divider</name></decl>,
				<decl><type ref="prev"/><name>right_divider</name></decl>;</decl_stmt>

	<comment type="block">/* guard against zero-divide below */</comment>
	<if_stmt><if>if <condition>(<expr><name>nvalues</name> <operator>&lt;=</operator> <literal type="number">1</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/* if there are too many histogram elements, decimate to limit runtime */</comment>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>nvalues</name> <operator>-</operator> <literal type="number">2</literal><operator>)</operator> <operator>/</operator> <name>MAX_CONSIDERED_ELEMS</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>query</name> <operator>=</operator> <call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name>constvalue</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* "left" is the left boundary value of the current bucket ... */</comment>
	<expr_stmt><expr><name>left</name> <operator>=</operator> <call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>left_order</name> <operator>=</operator> <call><name>inet_inclusion_cmp</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <name>k</name></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>nvalues</name></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>k</name></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* ... and "right" is the right boundary value */</comment>
		<expr_stmt><expr><name>right</name> <operator>=</operator> <call><name>DatumGetInetPP</name><argument_list>(<argument><expr><name><name>values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>right_order</name> <operator>=</operator> <call><name>inet_inclusion_cmp</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>left_order</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>right_order</name> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* The whole bucket matches, since both endpoints do. */</comment>
			<expr_stmt><expr><name>match</name> <operator>+=</operator> <literal type="number">1.0</literal></expr>;</expr_stmt>
		</block_content>}</block></if>
		<if type="elseif">else if <condition>(<expr><operator>(</operator><name>left_order</name> <operator>&lt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>right_order</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
				 <operator>(</operator><name>left_order</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>right_order</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition>
		<block>{<block_content>
			<comment type="block">/* Partial bucket match. */</comment>
			<expr_stmt><expr><name>left_divider</name> <operator>=</operator> <call><name>inet_hist_match_divider</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>right_divider</name> <operator>=</operator> <call><name>inet_hist_match_divider</name><argument_list>(<argument><expr><name>right</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name>left_divider</name> <operator>&gt;=</operator> <literal type="number">0</literal> <operator>||</operator> <name>right_divider</name> <operator>&gt;=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>match</name> <operator>+=</operator> <literal type="number">1.0</literal> <operator>/</operator> <call><name>pow</name><argument_list>(<argument><expr><literal type="number">2.0</literal></expr></argument>, <argument><expr><call><name>Max</name><argument_list>(<argument><expr><name>left_divider</name></expr></argument>, <argument><expr><name>right_divider</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		</block_content>}</block></if></if_stmt>

		<comment type="block">/* Shift the variables. */</comment>
		<expr_stmt><expr><name>left</name> <operator>=</operator> <name>right</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>left_order</name> <operator>=</operator> <name>right_order</name></expr>;</expr_stmt>

		<comment type="block">/* Count the number of buckets considered. */</comment>
		<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>match</name> <operator>/</operator> <name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Inet MCV vs MCV join selectivity estimation
 *
 * We simply add up the fractions of the populations that satisfy the clause.
 * The result is exact and does not need to be scaled further.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>inet_mcv_join_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcv1_values</name></decl></parameter>, <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>mcv1_numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcv1_nvalues</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcv2_values</name></decl></parameter>, <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>mcv2_numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcv2_nvalues</name></decl></parameter>,
				  <parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FmgrInfo</name></type>	<name>proc</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>j</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>fmgr_info</name><argument_list>(<argument><expr><call><name>get_opcode</name><argument_list>(<argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>proc</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mcv1_nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<for>for <control>(<init><expr><name>j</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>j</name> <operator>&lt;</operator> <name>mcv2_nvalues</name></expr>;</condition> <incr><expr><name>j</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><operator>&amp;</operator><name>proc</name></expr></argument>,
										   <argument><expr><name><name>mcv1_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
										   <argument><expr><name><name>mcv2_values</name><index>[<expr><name>j</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>selec</name> <operator>+=</operator> <name><name>mcv1_numbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator> <name><name>mcv2_numbers</name><index>[<expr><name>j</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></if></if_stmt></block_content></block></for>
	</block_content>}</block></for>
	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Inet MCV vs histogram join selectivity estimation
 *
 * For each MCV on the lefthand side, estimate the fraction of the righthand's
 * histogram population that satisfies the join clause, and add those up,
 * scaling by the MCV's frequency.  The result still needs to be scaled
 * according to the fraction of the righthand's population represented by
 * the histogram.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>inet_mcv_hist_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcv_values</name></decl></parameter>, <parameter><decl><type><name>float4</name> <modifier>*</modifier></type><name>mcv_numbers</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcv_nvalues</name></decl></parameter>,
				  <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>,
				  <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Selectivity</name></type> <name>selec</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

	<comment type="block">/*
	 * We'll call inet_hist_value_selec with the histogram on the left, so we
	 * must commute the operator.
	 */</comment>
	<expr_stmt><expr><name>opr_codenum</name> <operator>=</operator> <operator>-</operator><name>opr_codenum</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mcv_nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>selec</name> <operator>+=</operator> <name><name>mcv_numbers</name><index>[<expr><name>i</name></expr>]</index></name> <operator>*</operator>
			<call><name>inet_hist_value_sel</name><argument_list>(<argument><expr><name>hist_values</name></expr></argument>, <argument><expr><name>hist_nvalues</name></expr></argument>, <argument><expr><name><name>mcv_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>,
								<argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></for>
	<return>return <expr><name>selec</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Inet histogram vs histogram join selectivity estimation
 *
 * Here, we take all values listed in the second histogram (except for the
 * first and last elements, which are excluded on the grounds of possibly
 * not being very representative) and treat them as a uniform sample of
 * the non-MCV population for that relation.  For each one, we apply
 * inet_hist_value_selec to see what fraction of the first histogram
 * it matches.
 *
 * We could alternatively do this the other way around using the operator's
 * commutator.  XXX would it be worthwhile to do it both ways and take the
 * average?  That would at least avoid non-commutative estimation results.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>inet_hist_inclusion_join_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>hist1_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist1_nvalues</name></decl></parameter>,
							 <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>hist2_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist2_nvalues</name></decl></parameter>,
							 <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>double</name></type>		<name>match</name> <init>= <expr><literal type="number">0.0</literal></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>,
				<decl><type ref="prev"/><name>k</name></decl>,
				<decl><type ref="prev"/><name>n</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>hist2_nvalues</name> <operator>&lt;=</operator> <literal type="number">2</literal></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0.0</literal></expr>;</return></block_content></block></if></if_stmt>				<comment type="block">/* no interior histogram elements */</comment>

	<comment type="block">/* if there are too many histogram elements, decimate to limit runtime */</comment>
	<expr_stmt><expr><name>k</name> <operator>=</operator> <operator>(</operator><name>hist2_nvalues</name> <operator>-</operator> <literal type="number">3</literal><operator>)</operator> <operator>/</operator> <name>MAX_CONSIDERED_ELEMS</name> <operator>+</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name>n</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>hist2_nvalues</name> <operator>-</operator> <literal type="number">1</literal></expr>;</condition> <incr><expr><name>i</name> <operator>+=</operator> <name>k</name></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>match</name> <operator>+=</operator> <call><name>inet_hist_value_sel</name><argument_list>(<argument><expr><name>hist1_values</name></expr></argument>, <argument><expr><name>hist1_nvalues</name></expr></argument>,
									 <argument><expr><name><name>hist2_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>n</name><operator>++</operator></expr>;</expr_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>match</name> <operator>/</operator> <name>n</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Inet semi join selectivity estimation for one value
 *
 * The function calculates the probability that there is at least one row
 * in the RHS table that satisfies the "lhs_value op column" condition.
 * It is used in semi join estimation to check a sample from the left hand
 * side table.
 *
 * The MCV and histogram from the right hand side table should be provided as
 * arguments with the lhs_value from the left hand side table for the join.
 * hist_weight is the total number of rows represented by the histogram.
 * For example, if the table has 1000 rows, and 10% of the rows are in the MCV
 * list, and another 10% are NULLs, hist_weight would be 800.
 *
 * First, the lhs_value will be matched to the most common values.  If it
 * matches any of them, 1.0 will be returned, because then there is surely
 * a match.
 *
 * Otherwise, the histogram will be used to estimate the number of rows in
 * the second table that match the condition.  If the estimate is greater
 * than 1.0, 1.0 will be returned, because it means there is a greater chance
 * that the lhs_value will match more than one row in the table.  If it is
 * between 0.0 and 1.0, it will be returned as the probability.
 */</comment>
<function><type><specifier>static</specifier> <name>Selectivity</name></type>
<name>inet_semi_join_sel</name><parameter_list>(<parameter><decl><type><name>Datum</name></type> <name>lhs_value</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>mcv_exists</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>mcv_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>mcv_nvalues</name></decl></parameter>,
				   <parameter><decl><type><name>bool</name></type> <name>hist_exists</name></decl></parameter>, <parameter><decl><type><name>Datum</name> <modifier>*</modifier></type><name>hist_values</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>hist_nvalues</name></decl></parameter>,
				   <parameter><decl><type><name>double</name></type> <name>hist_weight</name></decl></parameter>,
				   <parameter><decl><type><name>FmgrInfo</name> <modifier>*</modifier></type><name>proc</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>mcv_exists</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>

		<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>mcv_nvalues</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><call><name>DatumGetBool</name><argument_list>(<argument><expr><call><name>FunctionCall2</name><argument_list>(<argument><expr><name>proc</name></expr></argument>,
										   <argument><expr><name>lhs_value</name></expr></argument>,
										   <argument><expr><name><name>mcv_values</name><index>[<expr><name>i</name></expr>]</index></name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
				<return>return <expr><literal type="number">1.0</literal></expr>;</return></block_content></block></if></if_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>hist_exists</name> <operator>&amp;&amp;</operator> <name>hist_weight</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>Selectivity</name></type> <name>hist_selec</name></decl>;</decl_stmt>

		<comment type="block">/* Commute operator, since we're passing lhs_value on the right */</comment>
		<expr_stmt><expr><name>hist_selec</name> <operator>=</operator> <call><name>inet_hist_value_sel</name><argument_list>(<argument><expr><name>hist_values</name></expr></argument>, <argument><expr><name>hist_nvalues</name></expr></argument>,
										 <argument><expr><name>lhs_value</name></expr></argument>, <argument><expr><operator>-</operator><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>hist_selec</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><call><name>Min</name><argument_list>(<argument><expr><literal type="number">1.0</literal></expr></argument>, <argument><expr><name>hist_weight</name> <operator>*</operator> <name>hist_selec</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><literal type="number">0.0</literal></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Assign useful code numbers for the subnet inclusion/overlap operators
 *
 * Only inet_masklen_inclusion_cmp() and inet_hist_match_divider() depend
 * on the exact codes assigned here; but many other places in this file
 * know that they can negate a code to obtain the code for the commutator
 * operator.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>inet_opr_codenum</name><parameter_list>(<parameter><decl><type><name>Oid</name></type> <name>operator</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<switch>switch <condition>(<expr><name>operator</name></expr>)</condition>
	<block>{<block_content>
		<case>case <expr><name>OID_INET_SUP_OP</name></expr>:</case>
			<return>return <expr><operator>-</operator><literal type="number">2</literal></expr>;</return>
		<case>case <expr><name>OID_INET_SUPEQ_OP</name></expr>:</case>
			<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>OID_INET_OVERLAP_OP</name></expr>:</case>
			<return>return <expr><literal type="number">0</literal></expr>;</return>
		<case>case <expr><name>OID_INET_SUBEQ_OP</name></expr>:</case>
			<return>return <expr><literal type="number">1</literal></expr>;</return>
		<case>case <expr><name>OID_INET_SUB_OP</name></expr>:</case>
			<return>return <expr><literal type="number">2</literal></expr>;</return>
		<default>default:</default>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unrecognized operator %u for inet selectivity"</literal></expr></argument>,
				 <argument><expr><name>operator</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></switch>
	<return>return <expr><literal type="number">0</literal></expr>;</return>					<comment type="block">/* unreached, but keep compiler quiet */</comment>
</block_content>}</block></function>

<comment type="block">/*
 * Comparison function for the subnet inclusion/overlap operators
 *
 * If the comparison is okay for the specified inclusion operator, the return
 * value will be 0.  Otherwise the return value will be less than or greater
 * than 0 as appropriate for the operator.
 *
 * Comparison is compatible with the basic comparison function for the inet
 * type.  See network_cmp_internal() in network.c for the original.  Basic
 * comparison operators are implemented with the network_cmp_internal()
 * function.  It is possible to implement the subnet inclusion operators with
 * this function.
 *
 * Comparison is first on the common bits of the network part, then on the
 * length of the network part (masklen) as in the network_cmp_internal()
 * function.  Only the first part is in this function.  The second part is
 * separated to another function for reusability.  The difference between the
 * second part and the original network_cmp_internal() is that the inclusion
 * operator is considered while comparing the lengths of the network parts.
 * See the inet_masklen_inclusion_cmp() function below.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>inet_inclusion_cmp</name><parameter_list>(<parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>order</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>order</name> <operator>=</operator> <call><name>bitncmp</name><argument_list>(<argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>,
						<argument><expr><call><name>Min</name><argument_list>(<argument><expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>order</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>order</name></expr>;</return></block_content></block></if></if_stmt>

		<return>return <expr><call><name>inet_masklen_inclusion_cmp</name><argument_list>(<argument><expr><name>left</name></expr></argument>, <argument><expr><name>right</name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><call><name>ip_family</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>-</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Masklen comparison function for the subnet inclusion/overlap operators
 *
 * Compares the lengths of the network parts of the inputs.  If the comparison
 * is okay for the specified inclusion operator, the return value will be 0.
 * Otherwise the return value will be less than or greater than 0 as
 * appropriate for the operator.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>inet_masklen_inclusion_cmp</name><parameter_list>(<parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>left</name></decl></parameter>, <parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>right</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>order</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>order</name> <operator>=</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>left</name></expr></argument>)</argument_list></call> <operator>-</operator> <operator>(</operator><name>int</name><operator>)</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>right</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Return 0 if the operator would accept this combination of masklens.
	 * Note that opr_codenum zero (overlaps) will accept all cases.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>(</operator><name>order</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>opr_codenum</name> <operator>&gt;=</operator> <literal type="number">0</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>order</name> <operator>==</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>opr_codenum</name> <operator>&gt;=</operator> <operator>-</operator><literal type="number">1</literal> <operator>&amp;&amp;</operator> <name>opr_codenum</name> <operator>&lt;=</operator> <literal type="number">1</literal><operator>)</operator> <operator>||</operator>
		<operator>(</operator><name>order</name> <operator>&lt;</operator> <literal type="number">0</literal> <operator>&amp;&amp;</operator> <name>opr_codenum</name> <operator>&lt;=</operator> <literal type="number">0</literal><operator>)</operator></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><literal type="number">0</literal></expr>;</return></block_content></block></if></if_stmt>

	<comment type="block">/*
	 * Otherwise, return a negative value for sup/supeq (notionally, the RHS
	 * needs to have a larger masklen than it has, which would make it sort
	 * later), or a positive value for sub/subeq (vice versa).
	 */</comment>
	<return>return <expr><name>opr_codenum</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Inet histogram partial match divider calculation
 *
 * First the families and the lengths of the network parts are compared using
 * the subnet inclusion operator.  If those are acceptable for the operator,
 * the divider will be calculated using the masklens and the common bits of
 * the addresses.  -1 will be returned if it cannot be calculated.
 *
 * See commentary for inet_hist_value_sel() for some rationale for this.
 */</comment>
<function><type><specifier>static</specifier> <name>int</name></type>
<name>inet_hist_match_divider</name><parameter_list>(<parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>boundary</name></decl></parameter>, <parameter><decl><type><name>inet</name> <modifier>*</modifier></type><name>query</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>opr_codenum</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><call><name>ip_family</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>)</argument_list></call> <operator>==</operator> <call><name>ip_family</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>inet_masklen_inclusion_cmp</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>, <argument><expr><name>query</name></expr></argument>, <argument><expr><name>opr_codenum</name></expr></argument>)</argument_list></call> <operator>==</operator> <literal type="number">0</literal></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>min_bits</name></decl>,
					<decl><type ref="prev"/><name>decisive_bits</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>min_bits</name> <operator>=</operator> <call><name>Min</name><argument_list>(<argument><expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr></argument>, <argument><expr><call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set decisive_bits to the masklen of the one that should contain the
		 * other according to the operator.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>opr_codenum</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>decisive_bits</name> <operator>=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<if type="elseif">else if <condition>(<expr><name>opr_codenum</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><name>decisive_bits</name> <operator>=</operator> <call><name>ip_bits</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>decisive_bits</name> <operator>=</operator> <name>min_bits</name></expr>;</expr_stmt></block_content></block></else></if_stmt>

		<comment type="block">/*
		 * Now return the number of non-common decisive bits.  (This will be
		 * zero if the boundary and query in fact match, else positive.)
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>min_bits</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
			<return>return <expr><name>decisive_bits</name> <operator>-</operator> <call><name>bitncommon</name><argument_list>(<argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>boundary</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><call><name>ip_addr</name><argument_list>(<argument><expr><name>query</name></expr></argument>)</argument_list></call></expr></argument>,
											  <argument><expr><name>min_bits</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if></if_stmt>
		<return>return <expr><name>decisive_bits</name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<return>return <expr><operator>-</operator><literal type="number">1</literal></expr>;</return>
</block_content>}</block></function>
</unit>
