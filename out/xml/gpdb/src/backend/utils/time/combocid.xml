<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/time/combocid.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * combocid.c
 *	  Combo command ID support routines
 *
 * Before version 8.3, HeapTupleHeaderData had separate fields for cmin
 * and cmax.  To reduce the header size, cmin and cmax are now overlayed
 * in the same field in the header.  That usually works because you rarely
 * insert and delete a tuple in the same transaction, and we don't need
 * either field to remain valid after the originating transaction exits.
 * To make it work when the inserting transaction does delete the tuple,
 * we create a "combo" command ID and store that in the tuple header
 * instead of cmin and cmax. The combo command ID can be mapped to the
 * real cmin and cmax using a backend-private array, which is managed by
 * this module.
 *
 * To allow reusing existing combo cids, we also keep a hash table that
 * maps cmin,cmax pairs to combo cids.  This keeps the data structure size
 * reasonable in most cases, since the number of unique pairs used by any
 * one transaction is likely to be small.
 *
 * With a 32-bit combo command id we can represent 2^32 distinct cmin,cmax
 * combinations. In the most perverse case where each command deletes a tuple
 * generated by every previous command, the number of combo command ids
 * required for N commands is N*(N+1)/2.  That means that in the worst case,
 * that's enough for 92682 commands.  In practice, you'll run out of memory
 * and/or disk space way before you reach that limit.
 *
 * The array and hash table are kept in TopTransactionContext, and are
 * destroyed at the end of each transaction.
 *
 * GPDB: In addition to the local array and hash table, the QE writer process
 * also maintains a copy of the array in shared memory, in a DSM segment. QE
 * reader processes can access the writer's shared array to look up combo
 * CIDs.
 *
 * Portions Copyright (c) 1996-2019, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/time/combocid.c
 *
 *-------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/htup_details.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/shmem.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/combocid.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/hsearch.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/dsm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>

<comment type="block">/* Hash table to lookup combo cids by cmin and cmax */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>comboHash</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<comment type="block">/* Key and entry structures for the hash table */</comment>
<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cmin</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cmax</name></decl>;</decl_stmt>
}</block></struct></type> <name>ComboCidKeyData</name>;</typedef>

<typedef>typedef <type><name>ComboCidKeyData</name> <modifier>*</modifier></type><name>ComboCidKey</name>;</typedef>

<typedef>typedef <type><struct>struct
<block>{
	<decl_stmt><decl><type><name>ComboCidKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>combocid</name></decl>;</decl_stmt>
}</block></struct></type> <name>ComboCidEntryData</name>;</typedef>

<typedef>typedef <type><name>ComboCidEntryData</name> <modifier>*</modifier></type><name>ComboCidEntry</name>;</typedef>

<comment type="block">/* Initial size of the hash table */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCID_HASH_SIZE</name></cpp:macro>			<cpp:value>100</cpp:value></cpp:define>


<comment type="block">/*
 * An array of cmin,cmax pairs, indexed by combo command id.
 * To convert a combo cid to cmin and cmax, you do a simple array lookup.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>ComboCidKey</name></type> <name>comboCids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>usedComboCids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* number of elements in comboCids */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type>	<name>sizeComboCids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>	<comment type="block">/* allocated size of array */</comment>

<comment type="block">/* Initial size of the array */</comment>
<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>CCID_ARRAY_SIZE</name></cpp:macro>			<cpp:value>100</cpp:value></cpp:define>

<comment type="block">/* prototypes for internal functions */</comment>
<function_decl><type><specifier>static</specifier> <name>CommandId</name></type> <name>GetComboCommandId</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>cmin</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cmax</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CommandId</name></type> <name>GetRealCmin</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>CommandId</name></type> <name>GetRealCmax</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * To shared the combocids array from QE writer to QE readers, we keep a
 * copy of the 'comboCids' array in a DSM segment. The DSM segment has
 * the same serialized format as used by Serialize/RestoreComboCIDState
 * functions: the segment begins with the number of elements as an 'int',
 * followed by the array of ComboCidKeys.
 *
 * The dumpSharedComboCommandIds() function updates shared memory copy with
 * any new entries in local 'comboCids' array, and loadSharedComboCommandIds()
 * loads the local array from the shared copy.
 */</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>dsm_segment</name> <modifier>*</modifier></type><name>shared_comboCids</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>shared_usedComboCids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>int</name></type> <name>shared_sizeComboCids</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>dumpSharedComboCommandIds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>void</name></type> <name>loadSharedComboCommandIds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block" format="doxygen">/**** External API ****/</comment>

<comment type="block">/*
 * GetCmin and GetCmax assert that they are only called in situations where
 * they make sense, that is, can deliver a useful answer.  If you have
 * reason to examine a tuple's t_cid field from a transaction other than
 * the originating one, use HeapTupleHeaderGetRawCommandId() directly.
 */</comment>

<function><type><name>CommandId</name></type>
<name>HeapTupleHeaderGetCmin</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cid</name> <init>= <expr><call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_MOVED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetXmin</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_COMBOCID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>GetRealCmin</name><argument_list>(<argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>cid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<function><type><name>CommandId</name></type>
<name>HeapTupleHeaderGetCmax</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cid</name> <init>= <expr><call><name>HeapTupleHeaderGetRawCommandId</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><operator>(</operator><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_MOVED</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Because GetUpdateXid() performs memory allocations if xmax is a
	 * multixact we can't Assert() if we're inside a critical section. This
	 * weakens the check, but not using GetCmax() inside one would complicate
	 * things too much.
	 */</comment>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>CritSectionCount</name> <operator>&gt;</operator> <literal type="number">0</literal> <operator>||</operator>
	  <call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetUpdateXid</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>tup</name><operator>-&gt;</operator><name>t_infomask</name></name> <operator>&amp;</operator> <name>HEAP_COMBOCID</name></expr>)</condition><block type="pseudo"><block_content>
		<return>return <expr><call><name>GetRealCmax</name><argument_list>(<argument><expr><name>cid</name></expr></argument>)</argument_list></call></expr>;</return></block_content></block></if>
	<else>else<block type="pseudo"><block_content>
		<return>return <expr><name>cid</name></expr>;</return></block_content></block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Given a tuple we are about to delete, determine the correct value to store
 * into its t_cid field.
 *
 * If we don't need a combo CID, *cmax is unchanged and *iscombo is set to
 * false.  If we do need one, *cmax is replaced by a combo CID and *iscombo
 * is set to true.
 *
 * The reason this is separate from the actual HeapTupleHeaderSetCmax()
 * operation is that this could fail due to out-of-memory conditions.  Hence
 * we need to do this before entering the critical section that actually
 * changes the tuple in shared buffers.
 */</comment>
<function><type><name>void</name></type>
<name>HeapTupleHeaderAdjustCmax</name><parameter_list>(<parameter><decl><type><name>HeapTupleHeader</name></type> <name>tup</name></decl></parameter>,
						  <parameter><decl><type><name>CommandId</name> <modifier>*</modifier></type><name>cmax</name></decl></parameter>,
						  <parameter><decl><type><name>bool</name> <modifier>*</modifier></type><name>iscombo</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we're marking a tuple deleted that was inserted by (any
	 * subtransaction of) our transaction, we need to use a combo command id.
	 * Test for HeapTupleHeaderXminCommitted() first, because it's cheaper
	 * than a TransactionIdIsCurrentTransactionId call.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>HeapTupleHeaderXminCommitted</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call> <operator>&amp;&amp;</operator>
		<call><name>TransactionIdIsCurrentTransactionId</name><argument_list>(<argument><expr><call><name>HeapTupleHeaderGetRawXmin</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>CommandId</name></type>	<name>cmin</name> <init>= <expr><call><name>HeapTupleHeaderGetCmin</name><argument_list>(<argument><expr><name>tup</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><operator>*</operator><name>cmax</name> <operator>=</operator> <call><name>GetComboCommandId</name><argument_list>(<argument><expr><name>cmin</name></expr></argument>, <argument><expr><operator>*</operator><name>cmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>iscombo</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	</block_content>}</block></if>
	<else>else
	<block>{<block_content>
		<expr_stmt><expr><operator>*</operator><name>iscombo</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
	</block_content>}</block></else></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Combo command ids are only interesting to the inserting and deleting
 * transaction, so we can forget about them at the end of transaction.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_ComboCid</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * Don't bother to pfree. These are allocated in TopTransactionContext, so
	 * they're going to go away at the end of transaction anyway.
	 */</comment>
	<expr_stmt><expr><name>comboHash</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>comboCids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>usedComboCids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name>sizeComboCids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
</block_content>}</block></function>


<comment type="block" format="doxygen">/**** Internal routines ****/</comment>

<comment type="block">/*
 * Get a combo command id that maps to cmin and cmax.
 *
 * We try to reuse old combo command ids when possible.
 */</comment>
<function><type><specifier>static</specifier> <name>CommandId</name></type>
<name>GetComboCommandId</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>cmin</name></decl></parameter>, <parameter><decl><type><name>CommandId</name></type> <name>cmax</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>combocid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ComboCidKeyData</name></type> <name>key</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ComboCidEntry</name></type> <name>entry</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>bool</name></type>		<name>found</name></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Gp_is_writer</name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><call><name>IS_QUERY_DISPATCHER</name><argument_list>()</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"EntryReader qExec tried to allocate a Combo Command Id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Reader qExec tried to allocate a Combo Command Id"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We're either GP_ROLE_DISPATCH, GP_ROLE_UTILITY, or a QE-writer */</comment>

	<comment type="block">/*
	 * Create the hash table and array the first time we need to use combo
	 * cids in the transaction.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>comboHash</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>		<name>hash_ctl</name></decl>;</decl_stmt>

		<comment type="block">/* Make array first; existence of hash table asserts array exists */</comment>
		<expr_stmt><expr><name>comboCids</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator>
			<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
							   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>CCID_ARRAY_SIZE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sizeComboCids</name> <operator>=</operator> <name>CCID_ARRAY_SIZE</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>usedComboCids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidEntryData</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>TopTransactionContext</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>comboHash</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"Combo CIDs"</literal></expr></argument>,
								<argument><expr><name>CCID_HASH_SIZE</name></expr></argument>,
								<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
								<argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Grow the array if there's not at least one free slot.  We must do this
	 * before possibly entering a new hashtable entry, else failure to
	 * repalloc would leave a corrupt hashtable entry behind.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>usedComboCids</name> <operator>&gt;=</operator> <name>sizeComboCids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>newsize</name> <init>= <expr><name>sizeComboCids</name> <operator>*</operator> <literal type="number">2</literal></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name>comboCids</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator>
			<call><name>repalloc</name><argument_list>(<argument><expr><name>comboCids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>sizeComboCids</name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* Lookup or create a hash entry with the desired cmin/cmax */</comment>

	<comment type="block">/* We assume there is no struct padding in ComboCidKeyData! */</comment>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>cmin</name></name> <operator>=</operator> <name>cmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>key</name><operator>.</operator><name>cmax</name></name> <operator>=</operator> <name>cmax</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>entry</name> <operator>=</operator> <operator>(</operator><name>ComboCidEntry</name><operator>)</operator> <call><name>hash_search</name><argument_list>(<argument><expr><name>comboHash</name></expr></argument>,
										<argument><expr><operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator> <operator>&amp;</operator><name>key</name></expr></argument>,
										<argument><expr><name>HASH_ENTER</name></expr></argument>,
										<argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* Reuse an existing combo cid */</comment>
		<return>return <expr><name><name>entry</name><operator>-&gt;</operator><name>combocid</name></name></expr>;</return>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* We have to create a new combo cid; we already made room in the array */</comment>
	<expr_stmt><expr><name>combocid</name> <operator>=</operator> <name>usedComboCids</name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>comboCids</name><index>[<expr><name>combocid</name></expr>]</index></name><operator>.</operator><name>cmin</name> <operator>=</operator> <name>cmin</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>comboCids</name><index>[<expr><name>combocid</name></expr>]</index></name><operator>.</operator><name>cmax</name> <operator>=</operator> <name>cmax</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>usedComboCids</name><operator>++</operator></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>combocid</name></name> <operator>=</operator> <name>combocid</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we're the QE writer or the dispatcher, share the new combo CID with
	 * readers. (In utility mode, no need to share.)
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_UTILITY</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dumpSharedComboCommandIds</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<return>return <expr><name>combocid</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CommandId</name></type>
<name>GetRealCmin</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we are a reader process, check if we need to update our private copy
	 * of the shared comboCids first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>combocid</name> <operator>&gt;=</operator> <name>usedComboCids</name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Gp_is_writer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>loadSharedComboCommandIds</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>combocid</name> <operator>&gt;=</operator> <name>usedComboCids</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GetRealCmin: no combocid entry found for combo cid %u/%u"</literal></expr></argument>, <argument><expr><name>combocid</name></expr></argument>, <argument><expr><name>usedComboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name><name>comboCids</name><index>[<expr><name>combocid</name></expr>]</index></name><operator>.</operator><name>cmin</name></expr>;</return>
</block_content>}</block></function>

<function><type><specifier>static</specifier> <name>CommandId</name></type>
<name>GetRealCmax</name><parameter_list>(<parameter><decl><type><name>CommandId</name></type> <name>combocid</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<comment type="block">/*
	 * If we are a reader process, check if we need to update our private copy
	 * of the shared comboCids first.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>combocid</name> <operator>&gt;=</operator> <name>usedComboCids</name> <operator>&amp;&amp;</operator> <name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>Gp_is_writer</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>loadSharedComboCommandIds</name><argument_list>()</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name>combocid</name> <operator>&gt;=</operator> <name>usedComboCids</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"GetRealCmax: no combocid entry found for combo cid %u/%u"</literal></expr></argument>, <argument><expr><name>combocid</name></expr></argument>, <argument><expr><name>usedComboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	<return>return <expr><name><name>comboCids</name><index>[<expr><name>combocid</name></expr>]</index></name><operator>.</operator><name>cmax</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Estimate the amount of space required to serialize the current ComboCID
 * state.
 */</comment>
<function><type><name>Size</name></type>
<name>EstimateComboCIDStateSpace</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* Add space required for saving usedComboCids */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>

	<comment type="block">/* Add space required for saving the combocids key */</comment>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>usedComboCids</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>size</name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Serialize the ComboCID state into the memory, beginning at start_address.
 * maxsize should be at least as large as the value returned by
 * EstimateComboCIDStateSpace.
 */</comment>
<function><type><name>void</name></type>
<name>SerializeComboCIDState</name><parameter_list>(<parameter><decl><type><name>Size</name></type> <name>maxsize</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>start_address</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>endptr</name></decl>;</decl_stmt>

	<comment type="block">/* First, we store the number of currently-existing ComboCIDs. */</comment>
	<expr_stmt><expr><operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>start_address</name> <operator>=</operator> <name>usedComboCids</name></expr>;</expr_stmt>

	<comment type="block">/* If maxsize is too small, throw an error. */</comment>
	<expr_stmt><expr><name>endptr</name> <operator>=</operator> <name>start_address</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator>
		<operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>usedComboCids</name><operator>)</operator></expr>;</expr_stmt>
	<if_stmt><if>if <condition>(<expr><name><name>endptr</name> <argument_list type="generic">&lt; <argument><expr><name>start_address</name> <operator>||</operator> <name>endptr</name></expr></argument> &gt;</argument_list></name> <name>start_address</name> <operator>+</operator> <name>maxsize</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"not enough space to serialize ComboCID state"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<comment type="block">/* Now, copy the actual cmin/cmax pairs. */</comment>
	<if_stmt><if>if <condition>(<expr><name>usedComboCids</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>start_address</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><name>comboCids</name></expr></argument>,
			   <argument><expr><operator>(</operator><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>usedComboCids</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Read the ComboCID state at the specified address and initialize this
 * backend with the same ComboCIDs.  This is only valid in a backend that
 * currently has no ComboCIDs (and only makes sense if the transaction state
 * is serialized and restored as well).
 */</comment>
<function><type><name>void</name></type>
<name>RestoreComboCIDState</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>comboCIDstate</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ComboCidKeyData</name> <modifier>*</modifier></type><name>keydata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>CommandId</name></type>	<name>cid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>comboCids</name> <operator>&amp;&amp;</operator> <operator>!</operator><name>comboHash</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* First, we retrieve the number of ComboCIDs that were serialized. */</comment>
	<expr_stmt><expr><name>num_elements</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>comboCIDstate</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>keydata</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>comboCIDstate</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* Use GetComboCommandId to restore each ComboCID. */</comment>
	<for>for <control>(<init><expr><name>i</name> <operator>=</operator> <literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>num_elements</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>cid</name> <operator>=</operator> <call><name>GetComboCommandId</name><argument_list>(<argument><expr><name><name>keydata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cmin</name></expr></argument>, <argument><expr><name><name>keydata</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>cmax</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* Verify that we got the expected answer. */</comment>
		<if_stmt><if>if <condition>(<expr><name>cid</name> <operator>!=</operator> <name>i</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"unexpected command ID while restoring combo CIDs"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>
</block_content>}</block></function>

<comment type="block">/*
 * Copy the local comboCids array into shared memory, so that it can be
 * accessed by QE reader processes.
 *
 * In any given segment, there are many readers, but only one writer. The
 * writer process maintains an array of combo CIDs like in PostgreSQL,
 * but in addition to the local array, it maintains a copy of it in shared
 * memory, as a DSM segment. The handle of the DSM segment is made available
 * to reader processes in MyProc-&gt;comboCidsHandle.
 *
 * This function copies the local comboCids array to the DSM segment,
 * reallocating a larger DSM segment if needed. Since combo cid entries are
 * always appended to the end of a combo cid dsm segment, and because there is
 * only one writer, it is not necessary to lock the combo cid DSM segment
 * during reading or writing. A new combo cid will not become visible to the
 * reader until we have incremented the count stored in the beginning of the
 * DSM segment. We have to be careful with memory ordering, though, to make
 * sure the new entry becomes visible to readers before the counter is
 * incremented!
 *
 * The reader processes can find the current DSM segment via lockHolderProcPtr.
 */</comment>
<function><type><name>void</name></type>
<name>dumpSharedComboCommandIds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shared_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name>		   <modifier>*</modifier></type><name>num_elements_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ComboCidKey</name></type> <name>keydata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>oldsegment</name> <init>= <expr><name>shared_comboCids</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>!=</operator> <name>GP_ROLE_EXECUTE</name> <operator>||</operator> <name>Gp_is_writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * Allocate/extend the shared array, if the new elements don't fit in the
	 * old one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>usedComboCids</name> <operator>&gt;</operator> <name>shared_sizeComboCids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>newsegment</name></decl>;</decl_stmt>

		<expr_stmt><expr><name>oldowner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>TopTransactionResourceOwner</name></expr>;</expr_stmt>

		<comment type="block">/*
		 * DSM segments cannot be resized, so we have to allocate a whole new
		 * segment.
		 * Create a new DSM segment for the combocids array. If we had an
		 * old one, we'll copy it over to the new array. (DSM segments
		 * cannot be resized.)
		 */</comment>
		<expr_stmt><expr><name>newsegment</name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>sizeComboCids</name></expr></argument>,
								<argument><expr><name>DSM_CREATE_NULL_IF_MAXSEGMENTS</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>newsegment</name> <operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
					<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_OUT_OF_MEMORY</name></expr></argument>)</argument_list></call><operator>,</operator>
					 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not create DSM segment for %d combo CIDs"</literal></expr></argument>,
							<argument><expr><name>sizeComboCids</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
		<comment type="block">/*
		 * let current ResourceOwner forget this dsm
		 * and manage the lifecycle by ourselves
		 */</comment>
		<expr_stmt><expr><call><name>dsm_pin_mapping</name><argument_list>(<argument><expr><name>newsegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><name>shared_comboCids</name> <operator>=</operator> <name>newsegment</name></expr>;</expr_stmt>

		<comment type="block">/* update dsm size */</comment>
		<expr_stmt><expr><name>shared_sizeComboCids</name> <operator>=</operator> <name>sizeComboCids</name></expr>;</expr_stmt>

		<comment type="block">/* reset current usage amount */</comment>
		<expr_stmt><expr><name>shared_usedComboCids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>shared_ptr</name> <operator>=</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>shared_comboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>num_elements_ptr</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>shared_ptr</name></expr>;</expr_stmt>
		<expr_stmt><expr><operator>*</operator><name>num_elements_ptr</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Copy all new entries to the shared array. (This function is called
	 * after each combocid assignment, so in practice there should always
	 * be exactly one new one).
	 */</comment>
	<expr_stmt><expr><name>shared_ptr</name> <operator>=</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>shared_comboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_elements_ptr</name> <operator>=</operator> <operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>shared_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>*</operator><name>num_elements_ptr</name> <operator>==</operator> <name>shared_usedComboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>keydata</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>shared_ptr</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>i</name> <init>= <expr><name>shared_usedComboCids</name></expr></init></decl>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name>usedComboCids</name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control><block type="pseudo"><block_content>
		<expr_stmt><expr><name><name>keydata</name><index>[<expr><name>i</name></expr>]</index></name> <operator>=</operator> <name><name>comboCids</name><index>[<expr><name>i</name></expr>]</index></name></expr>;</expr_stmt></block_content></block></for>

	<comment type="block">/*
	 * Finally, advertise the new count. We need a memory barrier to make sure
	 * that the array contents become visible to other backends before the
	 * count!
	 */</comment>
	<expr_stmt><expr><call><name>pg_write_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>num_elements_ptr</name> <operator>=</operator> <name>usedComboCids</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>shared_usedComboCids</name> <operator>=</operator> <name>usedComboCids</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * If we had to allocate a new segment, we swap it in place and release the
	 * old one now.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name>oldsegment</name> <operator>!=</operator> <name>shared_comboCids</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>comboCidsHandle</name></name> <operator>=</operator> <call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name>shared_comboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>oldsegment</name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>oldsegment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Load the comboCids array from shared memory.
 */</comment>
<function><type><specifier>static</specifier> <name>void</name></type>
<name>loadSharedComboCommandIds</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>attached_comboCids</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>char</name>	   <modifier>*</modifier></type><name>shared_ptr</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>ComboCidKey</name></type> <name>keydata</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>num_elements</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>dsm_handle</name></type>	<name>handle</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>Gp_is_writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>lockHolderProcPtr</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/* get lockholder! */</comment>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"loadSharedComboCommandId: NO LOCK HOLDER POINTER."</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/*
	 * Attach to the DSM segment shared by the QE writer process.
	 *
	 * It's possible that the QE write process destroys and reallocates
	 * the array just when we're about to attach to it. Cope with that by
	 * retrying if dsm_attach() fails.
	 */</comment>
	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><name>handle</name> <operator>=</operator> <name><name>lockHolderProcPtr</name><operator>-&gt;</operator><name>comboCidsHandle</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>attached_comboCids</name> <operator>=</operator> <call><name>dsm_attach</name><argument_list>(<argument><expr><name>handle</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<if_stmt><if>if <condition>(<expr><name>attached_comboCids</name> <operator>!=</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
			<break>break;</break></block_content></block></if></if_stmt>		<comment type="block">/* attached successfully */</comment>

		<comment type="block">/*
		 * Could not attach. Did the QE writer just reallocate a new array?
		 * If so, retry with the new handle. Other errors are not expected.
		 */</comment>
		<if_stmt><if>if <condition>(<expr><name>handle</name> <operator>==</operator> <name><name>lockHolderProcPtr</name><operator>-&gt;</operator><name>comboCidsHandle</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"could not attach to shared combo CIDs array"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>
	</block_content>}</block></for>

	<comment type="block">/*
	 * Copy the array into local memory.
	 *
	 * Note: we don't use RestoreComboCIDState(), because we don't care about
	 * loading the hash table, just the array. Furthermore,
	 * RestoreComboCIDState assumes that we're starting from a clean slate,
	 * but we might already have old combocids loaded.
	 */</comment>
	<expr_stmt><expr><name>shared_ptr</name> <operator>=</operator> <call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>attached_comboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>num_elements</name> <operator>=</operator> <operator>*</operator><operator>(</operator><name>int</name> <operator>*</operator><operator>)</operator> <name>shared_ptr</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>keydata</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator> <operator>(</operator><name>shared_ptr</name> <operator>+</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>int</name></expr></argument>)</argument_list></sizeof><operator>)</operator></expr>;</expr_stmt>

	<comment type="block">/* make sure we read the 'num_elements' first */</comment>
	<expr_stmt><expr><call><name>pg_read_barrier</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>num_elements</name> <operator>&gt;</operator> <name>sizeComboCids</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>int</name></type>			<name>newsize</name> <init>= <expr><call><name>Max</name><argument_list>(<argument><expr><name>sizeComboCids</name> <operator>*</operator> <literal type="number">2</literal></expr></argument>, <argument><expr><name>num_elements</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name>comboCids</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>comboCids</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator>
				<call><name>MemoryContextAlloc</name><argument_list>(<argument><expr><name>TopTransactionContext</name></expr></argument>,
								   <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else<block type="pseudo"><block_content>
			<expr_stmt><expr><name>comboCids</name> <operator>=</operator> <operator>(</operator><name>ComboCidKeyData</name> <operator>*</operator><operator>)</operator>
				<call><name>repalloc</name><argument_list>(<argument><expr><name>comboCids</name></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>newsize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></else></if_stmt>
		<expr_stmt><expr><name>sizeComboCids</name> <operator>=</operator> <name>newsize</name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name>comboCids</name></expr></argument>, <argument><expr><name>keydata</name></expr></argument>, <argument><expr><name>num_elements</name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>ComboCidKeyData</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>usedComboCids</name> <operator>=</operator> <name>num_elements</name></expr>;</expr_stmt>

	<comment type="block">/*
	 * All done, detach from the array.
	 *
	 * XXX: Or would it be better to stay attached, in case we need to load it
	 * again soon?
	 */</comment>
	<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>attached_comboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>attached_comboCids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>AtEOXact_ComboCid_Dsm_Detach</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><name>shared_comboCids</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name><name>MyProc</name><operator>-&gt;</operator><name>comboCidsHandle</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>shared_comboCids</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>shared_comboCids</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

		<expr_stmt><expr><name>shared_usedComboCids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><name>shared_sizeComboCids</name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>
</unit>
