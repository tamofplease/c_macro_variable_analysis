<?xml version="1.0" encoding="UTF-8" standalone="yes"?>
<unit xmlns="http://www.srcML.org/srcML/src" xmlns:cpp="http://www.srcML.org/srcML/cpp" revision="1.0.0" language="C" filename="/cloned_projects/gpdb/src/backend/utils/time/sharedsnapshot.c"><comment type="block">/*-------------------------------------------------------------------------
 *
 * sharedsnapshot.c
 *	  GPDB shared snapshot management.
 *
 * Portions Copyright (c) 1996-2009, PostgreSQL Global Development Group
 * Portions Copyright (c) 1994, Regents of the University of California
 *
 * IDENTIFICATION
 *	  src/backend/utils/time/sharedsnapshot.c
 *
 * In Greenplum, as part of slice plans, many postgres processes (qExecs, QE)
 * running on a single segment database as part of the same user's SQL
 * statement. All of the qExecs that belong to a particular user on a
 * particular segment database need to have consistent visibility. Idea used
 * is called "Shared Local Snapshot". Shared-memory data structure
 * SharedSnapshotSlot shares session and transaction information among
 * session's gang processes on a particular database instance. The processes
 * are called a SegMate process group.
 *
 * A SegMate process group is a QE (Query Executor) Writer process and 0, 1 or
 * more QE Reader processes. Greenplum needed to invent a SegMate sharing
 * mechanism because in Postgres there is only 1 backend and most needed
 * information is simply available in private memory. With Greenplum session
 * parallelism on database instances, we need to have a way to share
 * not-yet-committed session information among the SegMates. This information
 * includes transaction snapshots, sub-transaction status, so-called combo-cid
 * mapping, etc.
 *
 * An example: the QE readers need to use the same snapshot and command number
 * information as the QE writer so they see the current data written by the QE
 * writer. During a transaction, the QE Writer writes new data into the
 * shared-memory buffered cache. Later in that same transaction, QE Readers
 * will need to recognize which tuples in the shared-memory buffered cache are
 * for its session's transaction to perform correctly.
 *
 * Another example: the QE readers need to know which sub-transactions are
 * active or committed for a session's transaction so they can properly read
 * sub-transaction data written by the QE writer for the transaction.
 *
 * So, the theme is to share private, not-yet-committed session transaction
 * information with the QE Readers so the SegMate process group can all work
 * on the transaction correctly. [We mostly think of QE Writers/Readers being
 * on the segments. However, masters have special purpose QE Reader called the
 * Entry DB Singleton. So, the SegMate module also works on the master.]
 *
 * Each shared snapshot is local only to the segment database. High level
 * Writer gang member establishes a local transaction, acquires the slot in
 * shared snapshot shmem space and copies the snapshot information into shared
 * memory where the other qExecs that are segmates can find it. Following
 * section convers details on how shared memory initialization happens, who
 * writes the snapshot, how its controlled how/when the readers can read the
 * snapshot, locking, etc..
 *
 * Shared Memory Initialization: Shared memory is setup by the postmaster. One
 * slot for every user connection on the QD is kind of needed to store a data
 * structure for a set of segmates to store their snapshot information. In
 * each slot QE writer stores information defined by SharedSnapshotSlot.
 *
 * PQsendMppStatement: Is the same as PQsendQuery except that it also sends a
 * serialized snapshot and xid. postgres.c has been modified to accept this
 * new protocol message. It does pretty much the same stuff as it would for a
 * 'Q' (normal query) except it unpacks the snapshot and xid from the QD and
 * stores it away. All QEs get sent in a QD snapshot during statement
 * dispatch.
 *
 * Global Session ID: The shared snapshot shared memory is split into slots. A
 * set of segmates for a given user requires a single slot. The snapshot
 * information and other information is stored within the snapshot. A unique
 * session id identifies all the components in the system that are working for
 * a single user session. Within a single segment database this essentially
 * defines what it means to be "segmates."  The shared snapshot slot is
 * identified by this unique session id. The unique session id is sent in from
 * the QD as a GUC called "mpp_session_id". So the slot's field "slotid" will
 * store the "mpp_session_id" that WRITER to the slot will use. Readers of the
 * slot will find the correct slot by finding the one that has the slotid
 * equal to their own mpp_session_id.
 *
 * Single Writer: Mechanism is simplified by introducing the restriction of
 * only having a single qExec in a set of segmates capable of writing. Single
 * WRITER qExec is the only qExec amongst all of its segmates that will ever
 * perform database write operations.  Benefits of the approach, Single WRITER
 * qExec is the only member of a set of segmates that need to participate in
 * global transactions. Also... only this WRITER qExec really has to do
 * anything during commit. Assumption seems since they are just reader qExecs
 * that this is not a problem. The single WRITER qExec is the only qExec that
 * is guaranteed to participate in every dispatched statement for a given user
 * (at least to that segdb). Also, it is this WRITER qExec that performs any
 * utility statement.
 *
 * Coordinating Readers and Writers: The coordination is on when the writer
 * has set the snapshot such that the readers can get it and use it. In
 * general, we cannot assume that the writer will get to setting it before the
 * reader needs it and so we need to build a mechanism for the reader to (1)
 * know that its reading the right snapshot and (2) know when it can read.
 * The Mpp_session_id stored in the SharedSnapshotSlot is the piece of
 * information that lets the reader know it has got the right slot. And it
 * knows can read it when the xid and cid in the slot match the transactionid
 * and curid sent in from the QD in the SnapshotInfo field.  Basically QE
 * READERS aren't allowed to read the shared local snapshot until the shared
 * local snapshot has the same QD statement id as the QE Reader. i.e. the QE
 * WRITER updates the local snapshot and then writes the QD statement id into
 * the slot which identifies the "freshness" of that information. Currently QE
 * readers check that value and if its not been set they sleep (gasp!) for a
 * while. Think this approach is definitely not elegant and robust would be
 * great maybe to replace it with latch based approach.
 *
 * Cursor handling through SharedSnapshot: Cursors are funny case because they
 * read through a snapshot taken when the create cursor command was executed,
 * not through the current snapshot. Originally, the SharedSnapshotSlot was
 * designed for just the current command. The default transaction isolation
 * mode is READ COMMITTED, which cause a new snapshot to be created each
 * command. Each command in an explicit transaction started with BEGIN and
 * completed with COMMIT, etc. So, cursors would read through the current
 * snapshot instead of the create cursor snapshot and see data they shouldn't
 * see. The problem turns out to be a little more subtle because of the
 * existence of QE Readers and the fact that QE Readers can be created later â
 * long after the create cursor command. So, the solution was to serialize the
 * current snapshot to a temporary file during create cursor so that
 * subsequently created QE Readers could get the right snapshot to use from
 * the temporary file and ignore the SharedSnapshotSlot.
 *
 * Sub-Transaction handling through SharedSnapshot: QE Readers need to know
 * which sub-transactions the QE Writer has committed and which are active so
 * QE Readers can see the right data. While a sub-transaction may be committed
 * in an active parent transaction, that data is not formally committed until
 * the parent commits. And, active sub-transactions are not even
 * sub-transaction committed yet. So, other transactions cannot see active or
 * committed sub-transaction work yet. Without adding special logic to a QE
 * Reader, it would be considered another transaction and not see the
 * committed or active sub-transaction work. This is because QE Readers do not
 * start their own transaction. We just set a few variables in the xact.c
 * module to fake making it look like there is a current transaction,
 * including which sub-transactions are active or committed. This is a
 * kludge. In order for the QE Reader to fake being part of the QE Writer
 * transaction, we put the current transaction id and the values of all active
 * and committed sub-transaction ids into the SharedSnapshotSlot shared-memory
 * structure. Since shared-memory is not dynamic, poses an arbitrary limit on
 * the number of sub-transaction ids we keep in the SharedSnapshotSlot
 * in-memory. Once this limit is exceeded the sub-transaction ids are written
 * to temp files on disk.  See how the TransactionIdIsCurrentTransactionId
 * procedure in xact.c checks to see if the backend executing is a QE Reader
 * (or Entry DB Singleton), and if it is, walk through the sub-transaction ids
 * in SharedSnapshotSlot.
 *
 * -------------------------------------------------------------------------
 */</comment>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"postgres.h"</cpp:file></cpp:include>

<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/distributedlog.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/twophase.h"</cpp:file></cpp:include>  <comment type="block">/*max_prepared_xacts*/</comment>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"access/xact.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbtm.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"cdb/cdbvars.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"funcapi.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"miscadmin.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"lib/stringinfo.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/proc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"storage/procarray.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/builtins.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/faultinjector.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/guc.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/memutils.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/resowner.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/sharedsnapshot.h"</cpp:file></cpp:include>
<cpp:include>#<cpp:directive>include</cpp:directive> <cpp:file>"utils/snapmgr.h"</cpp:file></cpp:include>

<comment type="block">/*
 * Distributed Snapshot that gets sent in from the QD to processes running
 * in EXECUTE mode.
 */</comment>
<decl_stmt><decl><type><name>DtxContext</name></type> <name>DistributedTransactionContext</name> <init>= <expr><name>DTX_CONTEXT_LOCAL_ONLY</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><name>DtxContextInfo</name></type> <name>QEDtxContextInfo</name> <init>= <expr><name>DtxContextInfo_StaticInit</name></expr></init></decl>;</decl_stmt>

<cpp:define>#<cpp:directive>define</cpp:directive> <cpp:macro><name>DUMP_HASH_SZ</name></cpp:macro>    <cpp:value>1024</cpp:value></cpp:define>
<typedef>typedef <type><struct>struct <name>DumpEntry</name>
<block>{
	<decl_stmt><decl><type><name>uint32</name></type>  <name>segmate</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>localXid</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl>;</decl_stmt>
}</block></struct></type> <name>DumpEntry</name>;</typedef>

<comment type="block">/* local hash table to store cursor snapshot dump*/</comment>
<decl_stmt><decl><type><specifier>static</specifier> <name>HTAB</name> <modifier>*</modifier></type><name>dumpHtab</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>bool</name></type> <name>created_dump</name> <init>= <expr><name>false</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>ResourceOwner</name></type> <name>DumpResOwner</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>	<comment type="block">/* shared snapshot dump resources */</comment>

<comment type="block">/* MPP Shared Snapshot. */</comment>
<typedef>typedef <type><struct>struct <name>SharedSnapshotStruct</name>
<block>{
	<decl_stmt><decl><type><name>int</name></type> 		<name>numSlots</name></decl>;</decl_stmt>		<comment type="block">/* number of valid Snapshot entries */</comment>
	<decl_stmt><decl><type><name>int</name></type>			<name>maxSlots</name></decl>;</decl_stmt>		<comment type="block">/* allocated size of sharedSnapshotArray */</comment>
	<decl_stmt><decl><type><name>int</name></type> 		<name>nextSlot</name></decl>;</decl_stmt>		<comment type="block">/* points to the next avail slot. */</comment>

	<comment type="block">/*
	 * We now allow direct indexing into this array.
	 *
	 * We allocate the XIPS below.
	 *
	 * Be very careful when accessing fields inside here.
	 */</comment>
	<decl_stmt><decl><type><name>SharedSnapshotSlot</name>	   <modifier>*</modifier></type><name>slots</name></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>TransactionId</name>	   <modifier>*</modifier></type><name>xips</name></decl>;</decl_stmt>		<comment type="block">/* VARIABLE LENGTH ARRAY */</comment>
}</block></struct></type> <name>SharedSnapshotStruct</name>;</typedef>

<decl_stmt><decl><type><specifier>static</specifier> <specifier>volatile</specifier> <name>SharedSnapshotStruct</name> <modifier>*</modifier></type><name>sharedSnapshotArray</name></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>volatile</specifier> <name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>SharedLocalSnapshotSlot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

<decl_stmt><decl><type><specifier>static</specifier> <name>Size</name></type> <name>slotSize</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Size</name></type> <name>slotCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>
<decl_stmt><decl><type><specifier>static</specifier> <name>Size</name></type> <name>xipEntryCount</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</decl_stmt>

<comment type="block">/* prototypes for internal functions */</comment>
<function_decl><type><specifier>static</specifier> <name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>SharedSnapshotAdd</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>slotId</name></decl></parameter>)</parameter_list>;</function_decl>
<function_decl><type><specifier>static</specifier> <name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>SharedSnapshotLookup</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>slotId</name></decl></parameter>)</parameter_list>;</function_decl>

<comment type="block">/*
 * Report shared-memory space needed by CreateSharedSnapshot.
 */</comment>
<function><type><name>Size</name></type>
<name>SharedSnapshotShmemSize</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>Size</name></type>		<name>size</name></decl>;</decl_stmt>

	<comment type="block">/* should be the same as PROCARRAY_MAXPROCS */</comment>
	<expr_stmt><expr><name>xipEntryCount</name> <operator>=</operator> <name>MaxBackends</name> <operator>+</operator> <name>max_prepared_xacts</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>slotSize</name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>SharedSnapshotSlot</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
	<expr_stmt><expr><name>slotSize</name> <operator>+=</operator> <call><name>mul_size</name><argument_list>(<argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>, <argument><expr><operator>(</operator><name>xipEntryCount</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>slotSize</name> <operator>=</operator> <call><name>MAXALIGN</name><argument_list>(<argument><expr><name>slotSize</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/*
	 * We only really need MaxBackends; but for safety we multiply that by two
	 * (to account for slow de-allocation on cleanup, for instance).
	 *
	 * MaxBackends is only somewhat right.  What we really want here is the
	 * MaxBackends value from the QD.  But this is at least safe since we know
	 * we dont need *MORE* than MaxBackends.  But in general MaxBackends on a
	 * QE is going to be bigger than on a QE by a good bit.  or at least it
	 * should be.
	 */</comment>

	<expr_stmt><expr><name>slotCount</name> <operator>=</operator> <name>NUM_SHARED_SNAPSHOT_SLOTS</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>offsetof</name><argument_list>(<argument><expr><name>SharedSnapshotStruct</name></expr></argument>, <argument><expr><name>xips</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>size</name> <operator>=</operator> <call><name>add_size</name><argument_list>(<argument><expr><name>size</name></expr></argument>, <argument><expr><call><name>mul_size</name><argument_list>(<argument><expr><name>slotSize</name></expr></argument>, <argument><expr><name>slotCount</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>RequestNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"SharedSnapshotLocks"</literal></expr></argument>, <argument><expr><name>slotCount</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><call><name>MAXALIGN</name><argument_list>(<argument><expr><name>size</name></expr></argument>)</argument_list></call></expr>;</return>
</block_content>}</block></function>

<comment type="block">/*
 * Initialize the sharedSnapshot array.  This array is used to communicate
 * snapshots between qExecs that are segmates.
 */</comment>
<function><type><name>void</name></type>
<name>CreateSharedSnapshotArray</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type>	<name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>		<name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>TransactionId</name> <modifier>*</modifier></type><name>xip_base</name><init>=<expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<comment type="block">/* Create or attach to the SharedSnapshot shared structure */</comment>
	<expr_stmt><expr><name>sharedSnapshotArray</name> <operator>=</operator> <operator>(</operator><name>SharedSnapshotStruct</name> <operator>*</operator><operator>)</operator>
		<call><name>ShmemInitStruct</name><argument_list>(<argument><expr><literal type="string">"Shared Snapshot"</literal></expr></argument>, <argument><expr><call><name>SharedSnapshotShmemSize</name><argument_list>()</argument_list></call></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>slotCount</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>xipEntryCount</name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * We're the first - initialize.
		 */</comment>
		<decl_stmt><decl><type><name>LWLockPadded</name> <modifier>*</modifier></type><name>lock_base</name></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>numSlots</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/* slotCount is initialized in SharedSnapshotShmemSize(). */</comment>
		<expr_stmt><expr><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>maxSlots</name></name> <operator>=</operator> <name>slotCount</name></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>nextSlot</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

		<comment type="block">/*
		 * Set slots to point to the next byte beyond what was allocated for
		 * SharedSnapshotStruct. xips is the last element in the struct but is
		 * not included in SharedSnapshotShmemSize allocation.
		 */</comment>
		<expr_stmt><expr><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>slots</name></name> <operator>=</operator> <operator>(</operator><name>SharedSnapshotSlot</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>xips</name></name></expr>;</expr_stmt>

		<comment type="block">/* xips start just after the last slot structure */</comment>
		<expr_stmt><expr><name>xip_base</name> <operator>=</operator> <operator>(</operator><name>TransactionId</name> <operator>*</operator><operator>)</operator><operator>&amp;</operator><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>]</index></name></expr>;</expr_stmt>

		<expr_stmt><expr><name>lock_base</name> <operator>=</operator> <call><name>GetNamedLWLockTranche</name><argument_list>(<argument><expr><literal type="string">"SharedSnapshotLocks"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>tmpSlot</name> <init>= <expr><operator>&amp;</operator><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

			<expr_stmt><expr><name><name>tmpSlot</name><operator>-&gt;</operator><name>slotid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmpSlot</name><operator>-&gt;</operator><name>slotindex</name></name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmpSlot</name><operator>-&gt;</operator><name>slotLock</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>lock_base</name><index>[<expr><name>i</name></expr>]</index></name><operator>.</operator><name>lock</name></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>tmpSlot</name><operator>-&gt;</operator><name>dump</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotDump</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>SNAPSHOTDUMPARRAYSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name><name>tmpSlot</name><operator>-&gt;</operator><name>cur_dump_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
			<comment type="block">/*
			 * Fixup xip array pointer reference space allocated after slot structs:
			 *
			 * Note: xipEntryCount is initialized in SharedSnapshotShmemSize().
			 * So each slot gets (MaxBackends + max_prepared_xacts) transaction-ids.
			 */</comment>
			<expr_stmt><expr><name><name>tmpSlot</name><operator>-&gt;</operator><name>snapshot</name><operator>.</operator><name>xip</name></name> <operator>=</operator> <operator>&amp;</operator><name><name>xip_base</name><index>[<expr><literal type="number">0</literal></expr>]</index></name></expr>;</expr_stmt>
			<expr_stmt><expr><name>xip_base</name> <operator>+=</operator> <name>xipEntryCount</name></expr>;</expr_stmt>
		</block_content>}</block></for>
	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Used to dump the internal state of the shared slots for debugging.
 */</comment>
<function><type><name>char</name> <modifier>*</modifier></type>
<name>SharedSnapshotDump</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>str</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>SharedSnapshotStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>sharedSnapshotArray</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type>			<name>index</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><call><name>LWLockHeldByMe</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>)</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"Local SharedSnapshot Slot Dump: currSlots: %d maxSlots: %d "</literal></expr></argument>,
					 <argument><expr><name><name>arrayP</name><operator>-&gt;</operator><name>numSlots</name></name></expr></argument>, <argument><expr><name><name>arrayP</name><operator>-&gt;</operator><name>maxSlots</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>index</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<comment type="block">/* need to do byte addressing to find the right slot */</comment>
		<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>testSlot</name> <init>= <expr><operator>&amp;</operator><name><name>arrayP</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>index</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>testSlot</name><operator>-&gt;</operator><name>slotid</name></name> <operator>!=</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>str</name></expr></argument>, <argument><expr><literal type="string">"(SLOT index: %d slotid: %d QDxid: "</literal><name>UINT64_FORMAT</name><literal type="string">" pid: %u)"</literal></expr></argument>,
							 <argument><expr><name><name>testSlot</name><operator>-&gt;</operator><name>slotindex</name></name></expr></argument>, <argument><expr><name><name>testSlot</name><operator>-&gt;</operator><name>slotid</name></name></expr></argument>, <argument><expr><name><name>testSlot</name><operator>-&gt;</operator><name>distributedXid</name></name></expr></argument>,
							 <argument><expr><ternary><condition><expr><name><name>testSlot</name><operator>-&gt;</operator><name>writer_proc</name></name></expr> ?</condition><then> <expr><name><name>testSlot</name><operator>-&gt;</operator><name>writer_proc</name><operator>-&gt;</operator><name>pid</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

	</block_content>}</block></for>

	<return>return <expr><name><name>str</name><operator>.</operator><name>data</name></name></expr>;</return>
</block_content>}</block></function>

<comment type="block">/* Acquires an available slot in the sharedSnapshotArray.  The slot is then
 * marked with the supplied slotId.  This slotId is what others will use to
 * find this slot.  This should only ever be called by the "writer" qExec.
 *
 * The slotId should be something that is unique amongst all the possible
 * "writer" qExecs active on a segment database at a given moment.  It also
 * will need to be communicated to the "reader" qExecs so that they can find
 * this slot.
 */</comment>
<function><type><specifier>static</specifier> <name>SharedSnapshotSlot</name> <modifier>*</modifier></type>
<name>SharedSnapshotAdd</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>slotId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>SharedSnapshotStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>sharedSnapshotArray</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>nextSlot</name></decl>, <decl><type ref="prev"/><name>i</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>retryCount</name> <init>= <expr><name>gp_snapshotadd_timeout</name> <operator>*</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* .1 s per wait */</comment>

<label><name>retry</name>:</label>
	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<for>for <control>(<init><expr><name>i</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>testSlot</name> <init>= <expr><operator>&amp;</operator><name><name>arrayP</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>testSlot</name><operator>-&gt;</operator><name>slotindex</name></name> <operator>&gt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Shared Local Snapshots Array appears corrupted: %s"</literal></expr></argument>, <argument><expr><call><name>SharedSnapshotDump</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>testSlot</name><operator>-&gt;</operator><name>slotid</name></name> <operator>==</operator> <name>slotId</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>slot</name> <operator>=</operator> <name>testSlot</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>DEBUG1</name></expr></argument>, <argument><expr><literal type="string">"SharedSnapshotAdd: found existing entry for our session-id. id %d retry %d pid %u"</literal></expr></argument>, <argument><expr><name>slotId</name></expr></argument>, <argument><expr><name>retryCount</name></expr></argument>,
				<argument><expr><ternary><condition><expr><name><name>slot</name><operator>-&gt;</operator><name>writer_proc</name></name></expr> ?</condition><then> <expr><name><name>slot</name><operator>-&gt;</operator><name>writer_proc</name><operator>-&gt;</operator><name>pid</name></name></expr> </then><else>: <expr><literal type="number">0</literal></expr></else></ternary></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>retryCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><name>retryCount</name><operator>--</operator></expr>;</expr_stmt>

			<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 100ms, wait gp_snapshotadd_timeout seconds max. */</comment>
			<goto>goto <name>retry</name>;</goto>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>slot_dump</name> <init>= <expr><call><name>SharedSnapshotDump</name><argument_list>()</argument_list></call></expr></init></decl>;</decl_stmt>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"writer segworker group shared snapshot collision on id %d. Slot array dump: %s"</literal></expr></argument>,
				 <argument><expr><name>slotId</name></expr></argument>, <argument><expr><name>slot_dump</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></if></if_stmt>

	<if_stmt><if>if <condition>(<expr><name><name>arrayP</name><operator>-&gt;</operator><name>numSlots</name></name> <operator>&gt;=</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxSlots</name></name> <operator>||</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>nextSlot</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
	<block>{<block_content>
		<comment type="block">/*
		 * Ooops, no room.  this shouldn't happen as something else should have
		 * complained if we go over MaxBackends.
		 */</comment>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>FATAL</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errcode</name><argument_list>(<argument><expr><name>ERRCODE_TOO_MANY_CONNECTIONS</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"sorry, too many clients already."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"There are no more available slots in the sharedSnapshotArray."</literal></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Another piece of code should have detected that we have too many clients."</literal>
						 <literal type="string">" this probably means that someone isn't releasing their slot properly."</literal></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <operator>&amp;</operator><name><name>arrayP</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name><name>arrayP</name><operator>-&gt;</operator><name>nextSlot</name></name></expr>]</index></name></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>slotindex</name></name> <operator>=</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>nextSlot</name></name></expr>;</expr_stmt>

	<comment type="block">/*
	 * find the next available slot
	 */</comment>
	<expr_stmt><expr><name>nextSlot</name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<for>for <control>(<init><expr><name>i</name><operator>=</operator><name><name>arrayP</name><operator>-&gt;</operator><name>nextSlot</name></name><operator>+</operator><literal type="number">1</literal></expr>;</init> <condition><expr><name>i</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>;</condition> <incr><expr><name>i</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>tmpSlot</name> <init>= <expr><operator>&amp;</operator><name><name>arrayP</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>i</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

		<if_stmt><if>if <condition>(<expr><name><name>tmpSlot</name><operator>-&gt;</operator><name>slotid</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><name>nextSlot</name> <operator>=</operator> <name>i</name></expr>;</expr_stmt>
			<break>break;</break>
		</block_content>}</block></if></if_stmt>
	</block_content>}</block></for>

	<expr_stmt><expr><name><name>arrayP</name><operator>-&gt;</operator><name>nextSlot</name></name> <operator>=</operator> <name>nextSlot</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>arrayP</name><operator>-&gt;</operator><name>numSlots</name></name><operator>++</operator></expr>;</expr_stmt>

	<comment type="block">/* initialize some things */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>slotid</name></name> <operator>=</operator> <name>slotId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>fullXid</name></name> <operator>=</operator> <name>InvalidFullTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>startTimestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>distributedXid</name></name> <operator>=</operator> <name>InvalidDistributedTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>segmateSync</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<comment type="block">/* Remember the writer proc for IsCurrentTransactionIdForReader */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>writer_proc</name></name> <operator>=</operator> <name>MyProc</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>writer_xact</name></name> <operator>=</operator> <name>MyPgXact</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>GetSlotTableDebugInfo</name><parameter_list>(<parameter><decl><type><name>void</name> <modifier>*</modifier><modifier>*</modifier></type><name>snapshotArray</name></decl></parameter>, <parameter><decl><type><name>int</name> <modifier>*</modifier></type><name>maxSlots</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><operator>*</operator><name>snapshotArray</name> <operator>=</operator> <operator>(</operator><name>void</name> <operator>*</operator><operator>)</operator><name>sharedSnapshotArray</name></expr>;</expr_stmt>
	<expr_stmt><expr><operator>*</operator><name>maxSlots</name> <operator>=</operator> <name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Used by "reader" qExecs to find the slot in the sharedsnapshotArray with the
 * specified slotId.  In general, we should always be able to find the specified
 * slot unless something unexpected.  If the slot is not found, then NULL is
 * returned.
 *
 * MPP-4599: retry in the same pattern as the writer.
 */</comment>
<function><type><specifier>static</specifier> <name>SharedSnapshotSlot</name> <modifier>*</modifier></type>
<name>SharedSnapshotLookup</name><parameter_list>(<parameter><decl><type><name>int32</name></type> <name>slotId</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>slot</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>SharedSnapshotStruct</name> <modifier>*</modifier></type><name>arrayP</name> <init>= <expr><name>sharedSnapshotArray</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>retryCount</name> <init>= <expr><name>gp_snapshotadd_timeout</name> <operator>*</operator> <literal type="number">10</literal></expr></init></decl>;</decl_stmt> <comment type="block">/* .1 s per wait */</comment>
	<decl_stmt><decl><type><name>int</name></type> <name>index</name></decl>;</decl_stmt>

	<for>for <control>(<init>;</init><condition>;</condition><incr/>)</control>
	<block>{<block_content>
		<expr_stmt><expr><call><name>CHECK_FOR_INTERRUPTS</name><argument_list>()</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<for>for <control>(<init><expr><name>index</name><operator>=</operator><literal type="number">0</literal></expr>;</init> <condition><expr><name>index</name> <operator>&lt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>;</condition> <incr><expr><name>index</name><operator>++</operator></expr></incr>)</control>
		<block>{<block_content>
			<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>testSlot</name></decl>;</decl_stmt>

			<expr_stmt><expr><name>testSlot</name> <operator>=</operator> <operator>&amp;</operator><name><name>arrayP</name><operator>-&gt;</operator><name>slots</name><index>[<expr><name>index</name></expr>]</index></name></expr>;</expr_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>testSlot</name><operator>-&gt;</operator><name>slotindex</name></name> <operator>&gt;</operator> <name><name>arrayP</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Shared Local Snapshots Array appears corrupted: %s"</literal></expr></argument>, <argument><expr><call><name>SharedSnapshotDump</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>testSlot</name><operator>-&gt;</operator><name>slotid</name></name> <operator>==</operator> <name>slotId</name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>slot</name> <operator>=</operator> <name>testSlot</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>
		</block_content>}</block></for>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>!=</operator> <name>NULL</name></expr>)</condition>
		<block>{<block_content>
			<break>break;</break>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>retryCount</name> <operator>&gt;</operator> <literal type="number">0</literal></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>retryCount</name><operator>--</operator></expr>;</expr_stmt>

				<expr_stmt><expr><call><name>pg_usleep</name><argument_list>(<argument><expr><literal type="number">100000</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* 100ms, wait gp_snapshotadd_timeout seconds max. */</comment>
			</block_content>}</block></if>
			<else>else
			<block>{<block_content>
				<break>break;</break>
			</block_content>}</block></else></if_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>

	<return>return <expr><name>slot</name></expr>;</return>
</block_content>}</block></function>


<comment type="block">/*
 * Used by the "writer" qExec to "release" the slot it had been using.
 *
 */</comment>
<function><type><name>void</name></type>
<name>SharedSnapshotRemove</name><parameter_list>(<parameter><decl><type><specifier>volatile</specifier> <name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>slot</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>creatorDescription</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>int</name></type> <name>slotId</name> <init>= <expr><name><name>slot</name><operator>-&gt;</operator><name>slotid</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* determine if we need to modify the next available slot to use.  we
	 * only do this is our slotindex is lower then the existing one.
	 */</comment>
	<if_stmt><if>if <condition>(<expr><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>nextSlot</name></name> <operator>==</operator> <operator>-</operator><literal type="number">1</literal> <operator>||</operator> <name><name>slot</name><operator>-&gt;</operator><name>slotindex</name></name> <operator>&lt;</operator> <name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>nextSlot</name></name></expr>)</condition>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name><name>slot</name><operator>-&gt;</operator><name>slotindex</name></name> <operator>&gt;</operator> <name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>maxSlots</name></name></expr>)</condition><block type="pseudo"><block_content>
			<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><literal type="string">"Shared Local Snapshots slot has a bogus slotindex: %d. slot array dump: %s"</literal></expr></argument>,
				 <argument><expr><name><name>slot</name><operator>-&gt;</operator><name>slotindex</name></name></expr></argument>, <argument><expr><call><name>SharedSnapshotDump</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

		<expr_stmt><expr><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>nextSlot</name></name> <operator>=</operator> <name><name>slot</name><operator>-&gt;</operator><name>slotindex</name></name></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* reset the slotid which marks it as being unused. */</comment>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>slotid</name></name> <operator>=</operator> <operator>-</operator><literal type="number">1</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>fullXid</name></name> <operator>=</operator> <name>InvalidFullTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>startTimestamp</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>distributedXid</name></name> <operator>=</operator> <name>InvalidDistributedTransactionId</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>slot</name><operator>-&gt;</operator><name>segmateSync</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>sharedSnapshotArray</name><operator>-&gt;</operator><name>numSlots</name></name> <operator>-=</operator> <literal type="number">1</literal></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"SharedSnapshotRemove removed slot for slotId = %d, creator = %s (address %p)"</literal></expr></argument>,
		 <argument><expr><name>slotId</name></expr></argument>, <argument><expr><name>creatorDescription</name></expr></argument>, <argument><expr><name>SharedLocalSnapshotSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>addSharedSnapshot</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>creatorDescription</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>SharedLocalSnapshotSlot</name> <operator>=</operator> <call><name>SharedSnapshotAdd</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"%s added Shared Local Snapshot slot for gp_session_id = %d (address %p)"</literal></expr></argument>,
		 <argument><expr><name>creatorDescription</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>SharedLocalSnapshotSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>lookupSharedSnapshot</name><parameter_list>(<parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>lookerDescription</name></decl></parameter>, <parameter><decl><type><name>char</name> <modifier>*</modifier></type><name>creatorDescription</name></decl></parameter>, <parameter><decl><type><name>int</name></type> <name>id</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>slot</name></decl>;</decl_stmt>

	<expr_stmt><expr><name>slot</name> <operator>=</operator> <call><name>SharedSnapshotLookup</name><argument_list>(<argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>slot</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>,
				<argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"%s could not find Shared Local Snapshot!"</literal></expr></argument>,
						<argument><expr><name>lookerDescription</name></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Tried to find a shared snapshot slot with id: %d "</literal>
						   <literal type="string">"and found none. Shared Local Snapshots dump: %s"</literal></expr></argument>, <argument><expr><name>id</name></expr></argument>,
						   <argument><expr><call><name>SharedSnapshotDump</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>,</operator>
				 <call><name>errhint</name><argument_list>(<argument><expr><literal type="string">"Either this %s was created before the %s or the %s died."</literal></expr></argument>,
						 <argument><expr><name>lookerDescription</name></expr></argument>, <argument><expr><name>creatorDescription</name></expr></argument>, <argument><expr><name>creatorDescription</name></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<expr_stmt><expr><name>SharedLocalSnapshotSlot</name> <operator>=</operator> <name>slot</name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><operator>(</operator><ternary><condition><expr><name>Debug_print_full_dtm</name></expr> ?</condition><then> <expr><name>LOG</name></expr> </then><else>: <expr><name>DEBUG5</name></expr></else></ternary><operator>)</operator></expr></argument>,<argument><expr><literal type="string">"%s found Shared Local Snapshot slot for gp_session_id = %d created by %s (address %p)"</literal></expr></argument>,
		 <argument><expr><name>lookerDescription</name></expr></argument>, <argument><expr><name>id</name></expr></argument>, <argument><expr><name>creatorDescription</name></expr></argument>, <argument><expr><name>SharedLocalSnapshotSlot</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * Dump the shared local snapshot, so that the readers can pick it up.
 */</comment>
<function><type><name>void</name></type>
<name>dumpSharedLocalSnapshot_forCursor</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>ResourceOwner</name></type> <name>oldowner</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_DISPATCH</name> <operator>||</operator> <operator>(</operator><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name> <operator>&amp;&amp;</operator> <name>Gp_is_writer</name><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SharedLocalSnapshotSlot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>DumpResOwner</name><operator>==</operator> <name>NULL</name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><name>DumpResOwner</name> <operator>=</operator> <call><name>ResourceOwnerCreate</name><argument_list>(<argument><expr><name>NULL</name></expr></argument>, <argument><expr><literal type="string">"SharedSnapshotDumpResOwner"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name>created_dump</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>oldowner</name> <operator>=</operator> <name>CurrentResourceOwner</name></expr>;</expr_stmt>
	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>DumpResOwner</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>SharedSnapshotSlot</name> <operator>*</operator><operator>)</operator><name>SharedLocalSnapshotSlot</name></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>Size</name></type> <name>sz</name></decl> ;</decl_stmt>
	<decl_stmt><decl><type><name>dsm_segment</name> <modifier>*</modifier></type><name>segment</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>int</name></type> <name>id</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>cur_dump_id</name></name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>SnapshotDump</name> <modifier>*</modifier></type><name>pDump</name> <init>= <expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>dump</name><index>[<expr><name>id</name></expr>]</index></name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if<condition>(<expr><name><name>pDump</name><operator>-&gt;</operator><name>segment</name></name></expr>)</condition><block type="pseudo"><block_content>
		<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name><name>pDump</name><operator>-&gt;</operator><name>segment</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt></block_content></block></if></if_stmt>

	<expr_stmt><expr><name>sz</name> <operator>=</operator> <call><name>EstimateSnapshotSpace</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name>segment</name> <operator>=</operator> <call><name>dsm_create</name><argument_list>(<argument><expr><name>sz</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>SerializeSnapshot</name><argument_list>(<argument><expr><operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>snapshot</name></name></expr></argument>, <argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>pDump</name><operator>-&gt;</operator><name>segment</name></name> <operator>=</operator> <name>segment</name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pDump</name><operator>-&gt;</operator><name>handle</name></name> <operator>=</operator> <call><name>dsm_segment_handle</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pDump</name><operator>-&gt;</operator><name>segmateSync</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>segmateSync</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pDump</name><operator>-&gt;</operator><name>distributedXid</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>distributedXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>pDump</name><operator>-&gt;</operator><name>localXid</name></name> <operator>=</operator> <name><name>src</name><operator>-&gt;</operator><name>fullXid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"Dump syncmate : %u snapshot to slot %d"</literal></expr></argument>, <argument><expr><name><name>src</name><operator>-&gt;</operator><name>segmateSync</name></name></expr></argument>, <argument><expr><name>id</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>src</name><operator>-&gt;</operator><name>cur_dump_id</name></name> <operator>=</operator>
		<operator>(</operator><name><name>src</name><operator>-&gt;</operator><name>cur_dump_id</name></name> <operator>+</operator> <literal type="number">1</literal><operator>)</operator> <operator>%</operator> <name>SNAPSHOTDUMPARRAYSZ</name></expr>;</expr_stmt>

	<expr_stmt><expr><name>CurrentResourceOwner</name> <operator>=</operator> <name>oldowner</name></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>

<function><type><name>void</name></type>
<name>readSharedLocalSnapshot_forCursor</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><name>DtxContext</name></type> <name>distributedTransactionContext</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<decl_stmt><decl><type><name>bool</name></type> <name>found</name></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>SharedSnapshotSlot</name> <modifier>*</modifier></type><name>src</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><name>FullTransactionId</name></type> <name>localXid</name></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>Gp_role</name> <operator>==</operator> <name>GP_ROLE_EXECUTE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><operator>!</operator><name>Gp_is_writer</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name>SharedLocalSnapshotSlot</name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name> <operator>!=</operator> <name>NULL</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SIMPLE_FAULT_INJECTOR</name><argument_list>(<argument><expr><literal type="string">"before_read_shared_snapshot_for_cursor"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>dumpHtab</name> <operator>==</operator> <name>NULL</name></expr>)</condition>
	<block>{<block_content>
		<decl_stmt><decl><type><name>HASHCTL</name></type>     <name>hash_ctl</name></decl>;</decl_stmt>
		<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>hash_ctl</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>keysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>uint32</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>entrysize</name></name> <operator>=</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>DumpEntry</name></expr></argument>)</argument_list></sizeof></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>hash_ctl</name><operator>.</operator><name>hcxt</name></name> <operator>=</operator> <name>TopTransactionContext</name></expr>;</expr_stmt>
		<expr_stmt><expr><name>dumpHtab</name> <operator>=</operator> <call><name>hash_create</name><argument_list>(<argument><expr><literal type="string">"snapshot dump"</literal></expr></argument>,
		                       <argument><expr><name>DUMP_HASH_SZ</name></expr></argument>  ,
		                       <argument><expr><operator>&amp;</operator><name>hash_ctl</name></expr></argument>,
		                       <argument><expr><name>HASH_ELEM</name> <operator>|</operator> <name>HASH_BLOBS</name> <operator>|</operator> <name>HASH_CONTEXT</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<comment type="block">/* check segmate in local memory, only sync from shared memory once */</comment>
	<decl_stmt><decl><type><name>DumpEntry</name> <modifier>*</modifier></type><name>entry</name> <init>= <expr><call><name>hash_search</name><argument_list>(<argument><expr><name>dumpHtab</name></expr></argument>, <argument><expr><operator>&amp;</operator><name><name>QEDtxContextInfo</name><operator>.</operator><name>segmateSync</name></name></expr></argument>, <argument><expr><name>HASH_ENTER</name></expr></argument>, <argument><expr><operator>&amp;</operator><name>found</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
	<decl_stmt><decl><type><specifier>volatile</specifier> <name>SnapshotDump</name> <modifier>*</modifier></type><name>pDump</name> <init>= <expr><name>NULL</name></expr></init></decl>;</decl_stmt>

	<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><name>src</name> <operator>=</operator> <operator>(</operator><name>SharedSnapshotSlot</name> <operator>*</operator><operator>)</operator><name>SharedLocalSnapshotSlot</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>src</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>search_finish_id</name> <init>= <expr><name><name>src</name><operator>-&gt;</operator><name>cur_dump_id</name></name></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>int</name></type> <name>search_iter</name> <init>= <expr><name>search_finish_id</name></expr></init></decl>;</decl_stmt>

		<do>do<block>{<block_content>
			<if_stmt><if>if <condition>(<expr><name>search_iter</name> <operator>&lt;</operator> <literal type="number">0</literal></expr>)</condition><block type="pseudo"><block_content>
				<expr_stmt><expr><name>search_iter</name> <operator>=</operator> <name>SNAPSHOTDUMPARRAYSZ</name> <operator>-</operator> <literal type="number">1</literal></expr>;</expr_stmt></block_content></block></if></if_stmt>

			<if_stmt><if>if <condition>(<expr><name><name>src</name><operator>-&gt;</operator><name>dump</name><index>[<expr><name>search_iter</name></expr>]</index></name><operator>.</operator><name>segmateSync</name> <operator>==</operator> <name><name>QEDtxContextInfo</name><operator>.</operator><name>segmateSync</name></name> <operator>&amp;&amp;</operator>
				<name><name>src</name><operator>-&gt;</operator><name>dump</name><index>[<expr><name>search_iter</name></expr>]</index></name><operator>.</operator><name>distributedXid</name> <operator>==</operator> <name><name>QEDtxContextInfo</name><operator>.</operator><name>distributedXid</name></name></expr>)</condition>
			<block>{<block_content>
				<expr_stmt><expr><name>pDump</name> <operator>=</operator> <operator>&amp;</operator><name><name>src</name><operator>-&gt;</operator><name>dump</name><index>[<expr><name>search_iter</name></expr>]</index></name></expr>;</expr_stmt>
				<expr_stmt><expr><name>found</name> <operator>=</operator> <name>true</name></expr>;</expr_stmt>
				<break>break;</break>
			</block_content>}</block></if></if_stmt>

			<expr_stmt><expr><name>search_iter</name> <operator>--</operator></expr>;</expr_stmt>

		</block_content>}</block> while <condition>(<expr><name>search_iter</name> <operator>!=</operator> <name>search_finish_id</name></expr>)</condition>;</do>

		<if_stmt><if>if <condition>(<expr><operator>!</operator><name>found</name></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
			<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name>SharedSnapshotLock</name></expr></argument>, <argument><expr><name>LW_SHARED</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* For SharedSnapshotDump() */</comment>
			<expr_stmt><expr><call><name>ereport</name><argument_list>(<argument><expr><name>ERROR</name></expr></argument>, <argument><expr><operator>(</operator><call><name>errmsg</name><argument_list>(<argument><expr><literal type="string">"could not find Shared Local Snapshot!"</literal></expr></argument>)</argument_list></call><operator>,</operator>
				<call><name>errdetail</name><argument_list>(<argument><expr><literal type="string">"Tried to set the shared local snapshot slot with segmate: %u "</literal>
				          <literal type="string">"and failed. Shared Local Snapshots dump: %s"</literal></expr></argument>, <argument><expr><name><name>QEDtxContextInfo</name><operator>.</operator><name>segmateSync</name></name></expr></argument>,
				          <argument><expr><call><name>SharedSnapshotDump</name><argument_list>()</argument_list></call></expr></argument>)</argument_list></call><operator>)</operator></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if></if_stmt>

		<expr_stmt><expr><call><name>Assert</name><argument_list>(<argument><expr><name><name>pDump</name><operator>-&gt;</operator><name>handle</name></name> <operator>!=</operator> <literal type="number">0</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<decl_stmt><decl><type><name>dsm_segment</name><modifier>*</modifier></type> <name>segment</name> <init>= <expr><call><name>dsm_attach</name><argument_list>(<argument><expr><name><name>pDump</name><operator>-&gt;</operator><name>handle</name></name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>
		<decl_stmt><decl><type><name>char</name> <modifier>*</modifier></type><name>ptr</name> <init>= <expr><call><name>dsm_segment_address</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr></init></decl>;</decl_stmt>

		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>snapshot</name></name> <operator>=</operator> <call><name>RestoreSnapshot</name><argument_list>(<argument><expr><name>ptr</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name><name>entry</name><operator>-&gt;</operator><name>localXid</name></name> <operator>=</operator> <name><name>pDump</name><operator>-&gt;</operator><name>localXid</name></name></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>dsm_detach</name><argument_list>(<argument><expr><name>segment</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	</block_content>}</block></if></if_stmt>

	<decl_stmt><decl><type><name>Snapshot</name></type> <name>dumpsnapshot</name> <init>= <expr><name><name>entry</name><operator>-&gt;</operator><name>snapshot</name></name></expr></init></decl>;</decl_stmt>
	<expr_stmt><expr><name>localXid</name> <operator>=</operator> <name><name>entry</name><operator>-&gt;</operator><name>localXid</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmin</name></name> <operator>=</operator> <name><name>dumpsnapshot</name><operator>-&gt;</operator><name>xmin</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xmax</name></name> <operator>=</operator> <name><name>dumpsnapshot</name><operator>-&gt;</operator><name>xmax</name></name></expr>;</expr_stmt>
	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>=</operator> <name><name>dumpsnapshot</name><operator>-&gt;</operator><name>xcnt</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>memcpy</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>dumpsnapshot</name><operator>-&gt;</operator><name>xip</name></name></expr></argument>, <argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name> <operator>*</operator> <sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<comment type="block">/* zero out the slack in the xip-array */</comment>
	<expr_stmt><expr><call><name>memset</name><argument_list>(<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>xip</name></name> <operator>+</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><operator>(</operator><name>xipEntryCount</name> <operator>-</operator> <name><name>snapshot</name><operator>-&gt;</operator><name>xcnt</name></name><operator>)</operator><operator>*</operator><sizeof>sizeof<argument_list>(<argument><expr><name>TransactionId</name></expr></argument>)</argument_list></sizeof></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><name><name>snapshot</name><operator>-&gt;</operator><name>curcid</name></name> <operator>=</operator> <name><name>dumpsnapshot</name><operator>-&gt;</operator><name>curcid</name></name></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>SetSharedTransactionId_reader</name><argument_list>(
		<argument><expr><name>localXid</name></expr></argument>,
		<argument><expr><name><name>snapshot</name><operator>-&gt;</operator><name>curcid</name></name></expr></argument>,
		<argument><expr><name>distributedTransactionContext</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

</block_content>}</block></function>

<comment type="block">/*
 * Free any shared snapshot files.
 */</comment>
<function><type><name>void</name></type>
<name>AtEOXact_SharedSnapshot</name><parameter_list>(<parameter><decl><type><name>void</name></type></decl></parameter>)</parameter_list>
<block>{<block_content>
	<expr_stmt><expr><name>dumpHtab</name> <operator>=</operator> <name>NULL</name></expr>;</expr_stmt>

	<if_stmt><if>if <condition>(<expr><name>created_dump</name></expr>)</condition>
	<block>{<block_content>
		<expr_stmt><expr><call><name>LWLockAcquire</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>, <argument><expr><name>LW_EXCLUSIVE</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

		<comment type="block">/* release dump dsm */</comment>
		<expr_stmt><expr><call><name>ResourceOwnerRelease</name><argument_list>(<argument><expr><name>DumpResOwner</name></expr></argument>,
		                     <argument><expr><name>RESOURCE_RELEASE_BEFORE_LOCKS</name></expr></argument>,
		                     <argument><expr><name>false</name></expr></argument>, <comment type="block">/* isCommit */</comment>
		                     <argument><expr><name>true</name></expr></argument>)</argument_list></call></expr>;</expr_stmt> <comment type="block">/* isTopLevel */</comment>

		<expr_stmt><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>cur_dump_id</name></name> <operator>=</operator> <literal type="number">0</literal></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>MemSet</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>dump</name></name></expr></argument>, <argument><expr><literal type="number">0</literal></expr></argument>, <argument><expr><sizeof>sizeof<argument_list>(<argument><expr><name>SnapshotDump</name></expr></argument>)</argument_list></sizeof> <operator>*</operator> <name>SNAPSHOTDUMPARRAYSZ</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		<expr_stmt><expr><name>created_dump</name> <operator>=</operator> <name>false</name></expr>;</expr_stmt>
		<expr_stmt><expr><call><name>LWLockRelease</name><argument_list>(<argument><expr><name><name>SharedLocalSnapshotSlot</name><operator>-&gt;</operator><name>slotLock</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	</block_content>}</block></if></if_stmt>
</block_content>}</block></function>

<comment type="block">/*
 * LogDistributedSnapshotInfo
 *   Log the distributed snapshot info in a given snapshot.
 *
 * The 'prefix' is used to prefix the log message.
 */</comment>
<function><type><name>void</name></type>
<name>LogDistributedSnapshotInfo</name><parameter_list>(<parameter><decl><type><name>Snapshot</name></type> <name>snapshot</name></decl></parameter>, <parameter><decl><type><specifier>const</specifier> <name>char</name> <modifier>*</modifier></type><name>prefix</name></decl></parameter>)</parameter_list>
<block>{<block_content>
	<if_stmt><if>if <condition>(<expr><operator>!</operator><call><name>IsMVCCSnapshot</name><argument_list>(<argument><expr><name>snapshot</name></expr></argument>)</argument_list></call></expr>)</condition><block type="pseudo"><block_content>
		<return>return;</return></block_content></block></if></if_stmt>

	<decl_stmt><decl><type><name>StringInfoData</name></type> <name>buf</name></decl>;</decl_stmt>
	<expr_stmt><expr><call><name>initStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<decl_stmt><decl><type><name>DistributedSnapshotWithLocalMapping</name> <modifier>*</modifier></type><name>mapping</name> <init>=
		<expr><operator>&amp;</operator><operator>(</operator><name><name>snapshot</name><operator>-&gt;</operator><name>distribSnapshotWithLocalMapping</name></name><operator>)</operator></expr></init></decl>;</decl_stmt>

	<decl_stmt><decl><type><name>DistributedSnapshot</name> <modifier>*</modifier></type><name>ds</name> <init>= <expr><operator>&amp;</operator><name><name>mapping</name><operator>-&gt;</operator><name>ds</name></name></expr></init></decl>;</decl_stmt>

	<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"%s Distributed snapshot info: "</literal>
			 <literal type="string">"xminAllDistributedSnapshots="</literal><name>UINT64_FORMAT</name><literal type="string">", distribSnapshotId=%d"</literal>
			 <literal type="string">", xmin="</literal><name>UINT64_FORMAT</name><literal type="string">", xmax="</literal><name>UINT64_FORMAT</name><literal type="string">", count=%d"</literal></expr></argument>,
			 <argument><expr><name>prefix</name></expr></argument>,
			 <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>xminAllDistributedSnapshots</name></name></expr></argument>,
			 <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>distribSnapshotId</name></name></expr></argument>,
			 <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>xmin</name></name></expr></argument>,
			 <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>xmax</name></name></expr></argument>,
			 <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", In progress array: {"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<for>for <control>(<init><decl><type><name>int</name></type> <name>no</name> <init>= <expr><literal type="number">0</literal></expr></init></decl>;</init> <condition><expr><name>no</name> <operator>&lt;</operator> <name><name>ds</name><operator>-&gt;</operator><name>count</name></name></expr>;</condition> <incr><expr><name>no</name><operator>++</operator></expr></incr>)</control>
	<block>{<block_content>
		<if_stmt><if>if <condition>(<expr><name>no</name> <operator>!=</operator> <literal type="number">0</literal></expr>)</condition>
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">", (dx"</literal><name>UINT64_FORMAT</name><literal type="string">")"</literal></expr></argument>,
					 <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>inProgressXidArray</name><index>[<expr><name>no</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></if>
		<else>else
		<block>{<block_content>
			<expr_stmt><expr><call><name>appendStringInfo</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">" (dx"</literal><name>UINT64_FORMAT</name><literal type="string">")"</literal></expr></argument>,
					 <argument><expr><name><name>ds</name><operator>-&gt;</operator><name>inProgressXidArray</name><index>[<expr><name>no</name></expr>]</index></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
		</block_content>}</block></else></if_stmt>
	</block_content>}</block></for>
	<expr_stmt><expr><call><name>appendStringInfoString</name><argument_list>(<argument><expr><operator>&amp;</operator><name>buf</name></expr></argument>, <argument><expr><literal type="string">"}"</literal></expr></argument>)</argument_list></call></expr>;</expr_stmt>

	<expr_stmt><expr><call><name>elog</name><argument_list>(<argument><expr><name>LOG</name></expr></argument>, <argument><expr><literal type="string">"%s"</literal></expr></argument>, <argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
	<expr_stmt><expr><call><name>pfree</name><argument_list>(<argument><expr><name><name>buf</name><operator>.</operator><name>data</name></name></expr></argument>)</argument_list></call></expr>;</expr_stmt>
</block_content>}</block></function>
</unit>
